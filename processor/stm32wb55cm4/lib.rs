# ! [doc = "Peripheral access API for STM32WB55_CM4 microcontrollers (generated using svd2rust v0.37.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next] svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.37.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"] # ! [allow (non_camel_case_types)] # ! [allow (non_snake_case)] # ! [no_std] # ! [cfg_attr (docsrs , feature (doc_auto_cfg))]
#[doc = r"Number available in the NVIC for configuring priority"] pub const NVIC_PRIO_BITS : u8 = 4 ;
#[allow (unused_imports)] use generic :: * ;
#[doc = r"Common register and bit access and modify traits"] pub mod generic { use core :: marker ;
#[doc = " Generic peripheral accessor"] pub struct Periph < RB , const A : usize > { _marker : marker :: PhantomData < RB > , } unsafe impl < RB , const A : usize > Send for Periph < RB , A > { } impl < RB , const A : usize > Periph < RB , A > {
#[doc = "Pointer to the register block"] pub const PTR : * const RB = A as * const _ ;
#[doc = "Return the pointer to the register block"]
#[inline (always)] pub const fn ptr () -> * const RB { Self :: PTR }
#[doc = " Steal an instance of this peripheral"]
#[doc = ""]
#[doc = " # Safety"]
#[doc = ""]
#[doc = " Ensure that the new instance of the peripheral cannot be used in a way"]
#[doc = " that may race with any existing instances, for example by only"]
#[doc = " accessing read-only or write-only registers, or by consuming the"]
#[doc = " original peripheral and using critical sections to coordinate"]
#[doc = " access between multiple new instances."]
#[doc = ""]
#[doc = " Additionally, other software such as HALs may rely on only one"]
#[doc = " peripheral instance existing to ensure memory safety; ensure"]
#[doc = " no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : marker :: PhantomData , } } } impl < RB , const A : usize > core :: ops :: Deref for Periph < RB , A > { type Target = RB ;
#[inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } }
#[doc = " Raw register type (`u8`, `u16`, `u32`, ...)"] pub trait RawReg : Copy + From < bool > + core :: ops :: BitOr < Output = Self > + core :: ops :: BitAnd < Output = Self > + core :: ops :: BitOrAssign + core :: ops :: BitAndAssign + core :: ops :: Not < Output = Self > + core :: ops :: Shl < u8 , Output = Self > {
#[doc = " Mask for bits of width `WI`"] fn mask < const WI : u8 > () -> Self ;
#[doc = " `0`"] const ZERO : Self ;
#[doc = " `1`"] const ONE : Self ; } macro_rules ! raw_reg { ($ U : ty , $ size : literal , $ mask : ident) => { impl RawReg for $ U {
#[inline (always)] fn mask < const WI : u8 > () -> Self { $ mask ::< WI > () } const ZERO : Self = 0 ; const ONE : Self = 1 ; } const fn $ mask < const WI : u8 > () -> $ U { <$ U >:: MAX >> ($ size - WI) } impl FieldSpec for $ U { type Ux = $ U ; } } ; } raw_reg ! (u8 , 8 , mask_u8) ; raw_reg ! (u16 , 16 , mask_u16) ; raw_reg ! (u32 , 32 , mask_u32) ; raw_reg ! (u64 , 64 , mask_u64) ;
#[doc = " Raw register type"] pub trait RegisterSpec {
#[doc = " Raw register type (`u8`, `u16`, `u32`, ...)."] type Ux : RawReg ; }
#[doc = " Raw field type"] pub trait FieldSpec : Sized {
#[doc = " Raw field type (`u8`, `u16`, `u32`, ...)."] type Ux : Copy + core :: fmt :: Debug + PartialEq + From < Self > ; }
#[doc = " Marker for fields with fixed values"] pub trait IsEnum : FieldSpec { }
#[doc = " Trait implemented by readable registers to enable the `read` method."]
#[doc = ""]
#[doc = " Registers marked with `Writable` can be also be `modify`'ed."] pub trait Readable : RegisterSpec { }
#[doc = " Trait implemented by writeable registers."]
#[doc = ""]
#[doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
#[doc = ""]
#[doc = " Registers marked with `Readable` can be also be `modify`'ed."] pub trait Writable : RegisterSpec {
#[doc = " Is it safe to write any bits to register"] type Safety ;
#[doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"] const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = Self :: Ux :: ZERO ;
#[doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"] const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = Self :: Ux :: ZERO ; }
#[doc = " Reset value of the register."]
#[doc = ""]
#[doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
#[doc = " register by using the `reset` method."] pub trait Resettable : RegisterSpec {
#[doc = " Reset value of the register."] const RESET_VALUE : Self :: Ux = Self :: Ux :: ZERO ;
#[doc = " Reset value of the register."]
#[inline (always)] fn reset_value () -> Self :: Ux { Self :: RESET_VALUE } }
#[doc (hidden)] pub mod raw { use super :: { marker , BitM , FieldSpec , RegisterSpec , Unsafe , Writable } ; pub struct R < REG : RegisterSpec > { pub (crate) bits : REG :: Ux , pub (super) _reg : marker :: PhantomData < REG > , } pub struct W < REG : RegisterSpec > {
#[doc = "Writable bits"] pub (crate) bits : REG :: Ux , pub (super) _reg : marker :: PhantomData < REG > , } pub struct FieldReader < FI = u8 > where FI : FieldSpec , { pub (crate) bits : FI :: Ux , _reg : marker :: PhantomData < FI > , } impl < FI : FieldSpec > FieldReader < FI > {
#[doc = " Creates a new instance of the reader."]
#[allow (unused)]
#[inline (always)] pub (crate) const fn new (bits : FI :: Ux) -> Self { Self { bits , _reg : marker :: PhantomData , } } } pub struct BitReader < FI = bool > { pub (crate) bits : bool , _reg : marker :: PhantomData < FI > , } impl < FI > BitReader < FI > {
#[doc = " Creates a new instance of the reader."]
#[allow (unused)]
#[inline (always)] pub (crate) const fn new (bits : bool) -> Self { Self { bits , _reg : marker :: PhantomData , } } }
#[must_use = "after creating `FieldWriter` you need to call field value setting method"] pub struct FieldWriter < 'a , REG , const WI : u8 , FI = u8 , Safety = Unsafe > where REG : Writable + RegisterSpec , FI : FieldSpec , { pub (crate) w : & 'a mut W < REG > , pub (crate) o : u8 , _field : marker :: PhantomData < (FI , Safety) > , } impl < 'a , REG , const WI : u8 , FI , Safety > FieldWriter < 'a , REG , WI , FI , Safety > where REG : Writable + RegisterSpec , FI : FieldSpec , {
#[doc = " Creates a new instance of the writer"]
#[allow (unused)]
#[inline (always)] pub (crate) fn new (w : & 'a mut W < REG > , o : u8) -> Self { Self { w , o , _field : marker :: PhantomData , } } }
#[must_use = "after creating `BitWriter` you need to call bit setting method"] pub struct BitWriter < 'a , REG , FI = bool , M = BitM > where REG : Writable + RegisterSpec , bool : From < FI > , { pub (crate) w : & 'a mut W < REG > , pub (crate) o : u8 , _field : marker :: PhantomData < (FI , M) > , } impl < 'a , REG , FI , M > BitWriter < 'a , REG , FI , M > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = " Creates a new instance of the writer"]
#[allow (unused)]
#[inline (always)] pub (crate) fn new (w : & 'a mut W < REG > , o : u8) -> Self { Self { w , o , _field : marker :: PhantomData , } } } }
#[doc = " Register reader."]
#[doc = ""]
#[doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
#[doc = " method."] pub type R < REG > = raw :: R < REG > ; impl < REG : RegisterSpec > R < REG > {
#[doc = " Reads raw bits from register."]
#[inline (always)] pub const fn bits (& self) -> REG :: Ux { self . bits } } impl < REG : RegisterSpec , FI > PartialEq < FI > for R < REG > where REG :: Ux : PartialEq , FI : Copy , REG :: Ux : From < FI > , {
#[inline (always)] fn eq (& self , other : & FI) -> bool { self . bits . eq (& REG :: Ux :: from (* other)) } }
#[doc = " Register writer."]
#[doc = ""]
#[doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."] pub type W < REG > = raw :: W < REG > ; impl < REG : Writable > W < REG > {
#[doc = " Writes raw bits to the register."]
#[doc = ""]
#[doc = " # Safety"]
#[doc = ""]
#[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
#[inline (always)] pub unsafe fn bits (& mut self , bits : REG :: Ux) -> & mut Self { self . bits = bits ; self } } impl < REG > W < REG > where REG : Writable < Safety = Safe > , {
#[doc = " Writes raw bits to the register."]
#[inline (always)] pub fn set (& mut self , bits : REG :: Ux) -> & mut Self { self . bits = bits ; self } }
#[doc = " Field reader."]
#[doc = ""]
#[doc = " Result of the `read` methods of fields."] pub type FieldReader < FI = u8 > = raw :: FieldReader < FI > ;
#[doc = " Bit-wise field reader"] pub type BitReader < FI = bool > = raw :: BitReader < FI > ; impl < FI : FieldSpec > FieldReader < FI > {
#[doc = " Reads raw bits from field."]
#[inline (always)] pub const fn bits (& self) -> FI :: Ux { self . bits } } impl < FI : FieldSpec > core :: fmt :: Debug for FieldReader < FI > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { core :: fmt :: Debug :: fmt (& self . bits , f) } } impl < FI > PartialEq < FI > for FieldReader < FI > where FI : FieldSpec + Copy , {
#[inline (always)] fn eq (& self , other : & FI) -> bool { self . bits . eq (& FI :: Ux :: from (* other)) } } impl < FI > PartialEq < FI > for BitReader < FI > where FI : Copy , bool : From < FI > , {
#[inline (always)] fn eq (& self , other : & FI) -> bool { self . bits . eq (& bool :: from (* other)) } } impl < FI > BitReader < FI > {
#[doc = " Value of the field as raw bits."]
#[inline (always)] pub const fn bit (& self) -> bool { self . bits }
#[doc = " Returns `true` if the bit is clear (0)."]
#[inline (always)] pub const fn bit_is_clear (& self) -> bool { ! self . bit () }
#[doc = " Returns `true` if the bit is set (1)."]
#[inline (always)] pub const fn bit_is_set (& self) -> bool { self . bit () } } impl < FI > core :: fmt :: Debug for BitReader < FI > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { core :: fmt :: Debug :: fmt (& self . bits , f) } }
#[doc = " Marker for register/field writers which can take any value of specified width"] pub struct Safe ;
#[doc = " You should check that value is allowed to pass to register/field writer marked with this"] pub struct Unsafe ;
#[doc = " Marker for field writers are safe to write in specified inclusive range"] pub struct Range < const MIN : u64 , const MAX : u64 > ;
#[doc = " Marker for field writers are safe to write in specified inclusive range"] pub struct RangeFrom < const MIN : u64 > ;
#[doc = " Marker for field writers are safe to write in specified inclusive range"] pub struct RangeTo < const MAX : u64 > ;
#[doc = " Write field Proxy"] pub type FieldWriter < 'a , REG , const WI : u8 , FI = u8 , Safety = Unsafe > = raw :: FieldWriter < 'a , REG , WI , FI , Safety > ; impl < REG , const WI : u8 , FI , Safety > FieldWriter < '_ , REG , WI , FI , Safety > where REG : Writable + RegisterSpec , FI : FieldSpec , {
#[doc = " Field width"] pub const WIDTH : u8 = WI ;
#[doc = " Field width"]
#[inline (always)] pub const fn width (& self) -> u8 { WI }
#[doc = " Field offset"]
#[inline (always)] pub const fn offset (& self) -> u8 { self . o } } impl < 'a , REG , const WI : u8 , FI , Safety > FieldWriter < 'a , REG , WI , FI , Safety > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , {
#[doc = " Writes raw bits to the field"]
#[doc = ""]
#[doc = " # Safety"]
#[doc = ""]
#[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
#[inline (always)] pub unsafe fn bits (self , value : FI :: Ux) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: mask :: < WI > () << self . o) ; self . w . bits |= (REG :: Ux :: from (value) & REG :: Ux :: mask :: < WI > ()) << self . o ; self . w } } impl < 'a , REG , const WI : u8 , FI > FieldWriter < 'a , REG , WI , FI , Safe > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , {
#[doc = " Writes raw bits to the field"]
#[inline (always)] pub fn set (self , value : FI :: Ux) -> & 'a mut W < REG > { unsafe { self . bits (value) } } } impl < 'a , REG , const WI : u8 , FI , const MIN : u64 , const MAX : u64 > FieldWriter < 'a , REG , WI , FI , Range < MIN , MAX > > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , u64 : From < FI :: Ux > , {
#[doc = " Writes raw bits to the field"]
#[inline (always)] pub fn set (self , value : FI :: Ux) -> & 'a mut W < REG > { { let value = u64 :: from (value) ; assert ! (value >= MIN && value <= MAX) ; } unsafe { self . bits (value) } } } impl < 'a , REG , const WI : u8 , FI , const MIN : u64 > FieldWriter < 'a , REG , WI , FI , RangeFrom < MIN > > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , u64 : From < FI :: Ux > , {
#[doc = " Writes raw bits to the field"]
#[inline (always)] pub fn set (self , value : FI :: Ux) -> & 'a mut W < REG > { { let value = u64 :: from (value) ; assert ! (value >= MIN) ; } unsafe { self . bits (value) } } } impl < 'a , REG , const WI : u8 , FI , const MAX : u64 > FieldWriter < 'a , REG , WI , FI , RangeTo < MAX > > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , u64 : From < FI :: Ux > , {
#[doc = " Writes raw bits to the field"]
#[inline (always)] pub fn set (self , value : FI :: Ux) -> & 'a mut W < REG > { { let value = u64 :: from (value) ; assert ! (value <= MAX) ; } unsafe { self . bits (value) } } } impl < 'a , REG , const WI : u8 , FI , Safety > FieldWriter < 'a , REG , WI , FI , Safety > where REG : Writable + RegisterSpec , FI : IsEnum , REG :: Ux : From < FI :: Ux > , {
#[doc = " Writes `variant` to the field"]
#[inline (always)] pub fn variant (self , variant : FI) -> & 'a mut W < REG > { unsafe { self . bits (FI :: Ux :: from (variant)) } } } macro_rules ! bit_proxy { ($ writer : ident , $ mwv : ident) => {
#[doc (hidden)] pub struct $ mwv ;
#[doc = " Bit-wise write field proxy"] pub type $ writer <'a , REG , FI = bool > = raw :: BitWriter <'a , REG , FI , $ mwv >; impl <'a , REG , FI > $ writer <'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI >, {
#[doc = " Field width"] pub const WIDTH : u8 = 1 ;
#[doc = " Field width"]
#[inline (always)] pub const fn width (& self) -> u8 { Self :: WIDTH }
#[doc = " Field offset"]
#[inline (always)] pub const fn offset (& self) -> u8 { self . o }
#[doc = " Writes bit to the field"]
#[inline (always)] pub fn bit (self , value : bool) -> &'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: ONE << self . o) ; self . w . bits |= (REG :: Ux :: from (value) & REG :: Ux :: ONE) << self . o ; self . w }
#[doc = " Writes `variant` to the field"]
#[inline (always)] pub fn variant (self , variant : FI) -> &'a mut W < REG > { self . bit (bool :: from (variant)) } } } ; } bit_proxy ! (BitWriter , BitM) ; bit_proxy ! (BitWriter1S , Bit1S) ; bit_proxy ! (BitWriter0C , Bit0C) ; bit_proxy ! (BitWriter1C , Bit1C) ; bit_proxy ! (BitWriter0S , Bit0S) ; bit_proxy ! (BitWriter1T , Bit1T) ; bit_proxy ! (BitWriter0T , Bit0T) ; impl < 'a , REG , FI > BitWriter < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = " Sets the field bit"]
#[inline (always)] pub fn set_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: ONE << self . o ; self . w }
#[doc = " Clears the field bit"]
#[inline (always)] pub fn clear_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: ONE << self . o) ; self . w } } impl < 'a , REG , FI > BitWriter1S < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = " Sets the field bit"]
#[inline (always)] pub fn set_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: ONE << self . o ; self . w } } impl < 'a , REG , FI > BitWriter0C < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = " Clears the field bit"]
#[inline (always)] pub fn clear_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: ONE << self . o) ; self . w } } impl < 'a , REG , FI > BitWriter1C < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = "Clears the field bit by passing one"]
#[inline (always)] pub fn clear_bit_by_one (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: ONE << self . o ; self . w } } impl < 'a , REG , FI > BitWriter0S < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = "Sets the field bit by passing zero"]
#[inline (always)] pub fn set_bit_by_zero (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: ONE << self . o) ; self . w } } impl < 'a , REG , FI > BitWriter1T < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = "Toggle the field bit by passing one"]
#[inline (always)] pub fn toggle_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: ONE << self . o ; self . w } } impl < 'a , REG , FI > BitWriter0T < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = "Toggle the field bit by passing zero"]
#[inline (always)] pub fn toggle_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: ONE << self . o) ; self . w } }
#[doc = " This structure provides volatile access to registers."]
#[repr (transparent)] pub struct Reg < REG : RegisterSpec > { register : vcell :: VolatileCell < REG :: Ux > , _marker : marker :: PhantomData < REG > , } unsafe impl < REG : RegisterSpec > Send for Reg < REG > where REG :: Ux : Send { } impl < REG : RegisterSpec > Reg < REG > {
#[doc = " Returns the underlying memory address of register."]
#[doc = ""]
#[doc = " ```ignore"]
#[doc = " let reg_ptr = periph.reg.as_ptr();"]
#[doc = " ```"]
#[inline (always)] pub fn as_ptr (& self) -> * mut REG :: Ux { self . register . as_ptr () } } impl < REG : Readable > Reg < REG > {
#[doc = " Reads the contents of a `Readable` register."]
#[doc = ""]
#[doc = " You can read the raw contents of a register by using `bits`:"]
#[doc = " ```ignore"]
#[doc = " let bits = periph.reg.read().bits();"]
#[doc = " ```"]
#[doc = " or get the content of a particular field of a register:"]
#[doc = " ```ignore"]
#[doc = " let reader = periph.reg.read();"]
#[doc = " let bits = reader.field1().bits();"]
#[doc = " let flag = reader.field2().bit_is_set();"]
#[doc = " ```"]
#[inline (always)] pub fn read (& self) -> R < REG > { R { bits : self . register . get () , _reg : marker :: PhantomData , } } } impl < REG : Resettable + Writable > Reg < REG > {
#[doc = " Writes the reset value to `Writable` register."]
#[doc = ""]
#[doc = " Resets the register to its initial state."]
#[inline (always)] pub fn reset (& self) { self . register . set (REG :: RESET_VALUE) }
#[doc = " Writes bits to a `Writable` register."]
#[doc = ""]
#[doc = " You can write raw bits into a register:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
#[doc = " ```"]
#[doc = " or write only the fields you need:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.write(|w| w"]
#[doc = "     .field1().bits(newfield1bits)"]
#[doc = "     .field2().set_bit()"]
#[doc = "     .field3().variant(VARIANT)"]
#[doc = " );"]
#[doc = " ```"]
#[doc = " or an alternative way of saying the same:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.write(|w| {"]
#[doc = "     w.field1().bits(newfield1bits);"]
#[doc = "     w.field2().set_bit();"]
#[doc = "     w.field3().variant(VARIANT)"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " In the latter case, other fields will be set to their reset value."]
#[inline (always)] pub fn write < F > (& self , f : F) -> REG :: Ux where F : FnOnce (& mut W < REG >) -> & mut W < REG > , { let value = f (& mut W { bits : REG :: RESET_VALUE & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , }) . bits ; self . register . set (value) ; value }
#[doc = " Writes bits to a `Writable` register and produce a value."]
#[doc = ""]
#[doc = " You can write raw bits into a register:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.write_and(|w| unsafe { w.bits(rawbits); });"]
#[doc = " ```"]
#[doc = " or write only the fields you need:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.write_and(|w| {"]
#[doc = "     w.field1().bits(newfield1bits)"]
#[doc = "         .field2().set_bit()"]
#[doc = "         .field3().variant(VARIANT);"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " or an alternative way of saying the same:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.write_and(|w| {"]
#[doc = "     w.field1().bits(newfield1bits);"]
#[doc = "     w.field2().set_bit();"]
#[doc = "     w.field3().variant(VARIANT);"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " In the latter case, other fields will be set to their reset value."]
#[doc = ""]
#[doc = " Values can be returned from the closure:"]
#[doc = " ```ignore"]
#[doc = " let state = periph.reg.write_and(|w| State::set(w.field1()));"]
#[doc = " ```"]
#[inline (always)] pub fn from_write < F , T > (& self , f : F) -> T where F : FnOnce (& mut W < REG >) -> T , { let mut writer = W { bits : REG :: RESET_VALUE & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , } ; let result = f (& mut writer) ; self . register . set (writer . bits) ; result } } impl < REG : Writable > Reg < REG > {
#[doc = " Writes 0 to a `Writable` register."]
#[doc = ""]
#[doc = " Similar to `write`, but unused bits will contain 0."]
#[doc = ""]
#[doc = " # Safety"]
#[doc = ""]
#[doc = " Unsafe to use with registers which don't allow to write 0."]
#[inline (always)] pub unsafe fn write_with_zero < F > (& self , f : F) -> REG :: Ux where F : FnOnce (& mut W < REG >) -> & mut W < REG > , { let value = f (& mut W { bits : REG :: Ux :: ZERO , _reg : marker :: PhantomData , }) . bits ; self . register . set (value) ; value }
#[doc = " Writes 0 to a `Writable` register and produces a value."]
#[doc = ""]
#[doc = " Similar to `write`, but unused bits will contain 0."]
#[doc = ""]
#[doc = " # Safety"]
#[doc = ""]
#[doc = " Unsafe to use with registers which don't allow to write 0."]
#[inline (always)] pub unsafe fn from_write_with_zero < F , T > (& self , f : F) -> T where F : FnOnce (& mut W < REG >) -> T , { let mut writer = W { bits : REG :: Ux :: ZERO , _reg : marker :: PhantomData , } ; let result = f (& mut writer) ; self . register . set (writer . bits) ; result } } impl < REG : Readable + Writable > Reg < REG > {
#[doc = " Modifies the contents of the register by reading and then writing it."]
#[doc = ""]
#[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
#[doc = "    r.bits() | 3"]
#[doc = " ) });"]
#[doc = " ```"]
#[doc = " or"]
#[doc = " ```ignore"]
#[doc = " periph.reg.modify(|_, w| w"]
#[doc = "     .field1().bits(newfield1bits)"]
#[doc = "     .field2().set_bit()"]
#[doc = "     .field3().variant(VARIANT)"]
#[doc = " );"]
#[doc = " ```"]
#[doc = " or an alternative way of saying the same:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.modify(|_, w| {"]
#[doc = "     w.field1().bits(newfield1bits);"]
#[doc = "     w.field2().set_bit();"]
#[doc = "     w.field3().variant(VARIANT)"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " Other fields will have the value they had before the call to `modify`."]
#[inline (always)] pub fn modify < F > (& self , f : F) -> REG :: Ux where for < 'w > F : FnOnce (& R < REG > , & 'w mut W < REG >) -> & 'w mut W < REG > , { let bits = self . register . get () ; let value = f (& R { bits , _reg : marker :: PhantomData , } , & mut W { bits : bits & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , } ,) . bits ; self . register . set (value) ; value }
#[doc = " Modifies the contents of the register by reading and then writing it"]
#[doc = " and produces a value."]
#[doc = ""]
#[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
#[doc = " ```ignore"]
#[doc = " let bits = periph.reg.modify(|r, w| {"]
#[doc = "     let new_bits = r.bits() | 3;"]
#[doc = "     unsafe {"]
#[doc = "         w.bits(new_bits);"]
#[doc = "     }"]
#[doc = ""]
#[doc = "     new_bits"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " or"]
#[doc = " ```ignore"]
#[doc = " periph.reg.modify(|_, w| {"]
#[doc = "     w.field1().bits(newfield1bits)"]
#[doc = "         .field2().set_bit()"]
#[doc = "         .field3().variant(VARIANT);"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " or an alternative way of saying the same:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.modify(|_, w| {"]
#[doc = "     w.field1().bits(newfield1bits);"]
#[doc = "     w.field2().set_bit();"]
#[doc = "     w.field3().variant(VARIANT);"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " Other fields will have the value they had before the call to `modify`."]
#[inline (always)] pub fn from_modify < F , T > (& self , f : F) -> T where for < 'w > F : FnOnce (& R < REG > , & 'w mut W < REG >) -> T , { let bits = self . register . get () ; let mut writer = W { bits : bits & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , } ; let result = f (& R { bits , _reg : marker :: PhantomData , } , & mut writer ,) ; self . register . set (writer . bits) ; result } } impl < REG : Readable > core :: fmt :: Debug for crate :: generic :: Reg < REG > where R < REG > : core :: fmt :: Debug , { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { core :: fmt :: Debug :: fmt (& self . read () , f) } } }
#[cfg (feature = "rt")] extern "C" { fn WWDG () ; fn PVD () ; fn RTC_TAMP () ; fn RTC_WKUP () ; fn FLASH () ; fn RCC () ; fn EXTI0 () ; fn EXTI1 () ; fn EXTI2 () ; fn EXTI3 () ; fn EXTI4 () ; fn DMA1_Channel1 () ; fn DMA1_Channel2 () ; fn DMA1_Channel3 () ; fn DMA1_Channel4 () ; fn DMA1_Channel5 () ; fn DMA1_Channel6 () ; fn DMA1_Channel7 () ; fn ADC1 () ; fn USB_HP () ; fn USB_LP () ; fn C2SEV () ; fn COMP () ; fn EXTI5_9 () ; fn TIM1_BRK () ; fn TIM1_UP () ; fn TIM1_TRG_COM_TIM17 () ; fn TIM1_CC () ; fn TIM2 () ; fn PKA () ; fn I2C1_EV () ; fn I2C1_ER () ; fn I2C3_EV () ; fn I2C3_ER () ; fn SPI1 () ; fn SPI2 () ; fn USART1 () ; fn LPUART1 () ; fn SAI1 () ; fn TSC () ; fn EXTI10_15 () ; fn RTC_ALARM () ; fn CRS_IT () ; fn PWR_SOTF () ; fn IPCC_C1_RX_IT () ; fn IPCC_C1_TX_IT () ; fn HSEM () ; fn LPTIM1 () ; fn LPTIM2 () ; fn LCD () ; fn QUADSPI () ; fn AES1 () ; fn AES2 () ; fn True_RNG () ; fn DMA2_CH1 () ; fn DMA2_CH2 () ; fn DMA2_CH3 () ; fn DMA2_CH4 () ; fn DMA2_CH5 () ; fn DMA2_CH6 () ; fn DMA2_CH7 () ; fn DMAMUX_OVR () ; }
#[doc (hidden)]
#[repr (C)] pub union Vector { _handler : unsafe extern "C" fn () , _reserved : u32 , }
#[cfg (feature = "rt")]
#[doc (hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle] pub static __INTERRUPTS : [Vector ; 63] = [Vector { _handler : WWDG } , Vector { _handler : PVD } , Vector { _handler : RTC_TAMP } , Vector { _handler : RTC_WKUP } , Vector { _handler : FLASH } , Vector { _handler : RCC } , Vector { _handler : EXTI0 } , Vector { _handler : EXTI1 } , Vector { _handler : EXTI2 } , Vector { _handler : EXTI3 } , Vector { _handler : EXTI4 } , Vector { _handler : DMA1_Channel1 } , Vector { _handler : DMA1_Channel2 } , Vector { _handler : DMA1_Channel3 } , Vector { _handler : DMA1_Channel4 } , Vector { _handler : DMA1_Channel5 } , Vector { _handler : DMA1_Channel6 } , Vector { _handler : DMA1_Channel7 } , Vector { _handler : ADC1 } , Vector { _handler : USB_HP } , Vector { _handler : USB_LP } , Vector { _handler : C2SEV } , Vector { _handler : COMP } , Vector { _handler : EXTI5_9 } , Vector { _handler : TIM1_BRK } , Vector { _handler : TIM1_UP } , Vector { _handler : TIM1_TRG_COM_TIM17 } , Vector { _handler : TIM1_CC } , Vector { _handler : TIM2 } , Vector { _handler : PKA } , Vector { _handler : I2C1_EV } , Vector { _handler : I2C1_ER } , Vector { _handler : I2C3_EV } , Vector { _handler : I2C3_ER } , Vector { _handler : SPI1 } , Vector { _handler : SPI2 } , Vector { _handler : USART1 } , Vector { _handler : LPUART1 } , Vector { _handler : SAI1 } , Vector { _handler : TSC } , Vector { _handler : EXTI10_15 } , Vector { _handler : RTC_ALARM } , Vector { _handler : CRS_IT } , Vector { _handler : PWR_SOTF } , Vector { _handler : IPCC_C1_RX_IT } , Vector { _handler : IPCC_C1_TX_IT } , Vector { _handler : HSEM } , Vector { _handler : LPTIM1 } , Vector { _handler : LPTIM2 } , Vector { _handler : LCD } , Vector { _handler : QUADSPI } , Vector { _handler : AES1 } , Vector { _handler : AES2 } , Vector { _handler : True_RNG } , Vector { _reserved : 0 } , Vector { _handler : DMA2_CH1 } , Vector { _handler : DMA2_CH2 } , Vector { _handler : DMA2_CH3 } , Vector { _handler : DMA2_CH4 } , Vector { _handler : DMA2_CH5 } , Vector { _handler : DMA2_CH6 } , Vector { _handler : DMA2_CH7 } , Vector { _handler : DMAMUX_OVR } ,] ;
#[doc = r"Enumeration of all the interrupts."]
#[derive (Copy , Clone , Debug , PartialEq , Eq)]
#[repr (u16)] pub enum Interrupt {
#[doc = "0 - Window Watchdog interrupt"] WWDG = 0 ,
#[doc = "1 - PVD through EXTI\\[16\\] (C1IMR2\\[20\\])"] PVD = 1 ,
#[doc = "2 - RTC/TAMP/CSS on LSE through EXTI line 19 interrupt"] RTC_TAMP = 2 ,
#[doc = "3 - RTC wakeup interrupt through EXTI\\[19\\]"] RTC_WKUP = 3 ,
#[doc = "4 - Flash global interrupt"] FLASH = 4 ,
#[doc = "5 - RCC global interrupt"] RCC = 5 ,
#[doc = "6 - EXTI line 0 interrupt through EXTI\\[0\\]"] EXTI0 = 6 ,
#[doc = "7 - EXTI line 0 interrupt through EXTI\\[1\\]"] EXTI1 = 7 ,
#[doc = "8 - EXTI line 0 interrupt through EXTI\\[2\\]"] EXTI2 = 8 ,
#[doc = "9 - EXTI line 0 interrupt through EXTI\\[3\\]"] EXTI3 = 9 ,
#[doc = "10 - EXTI line 0 interrupt through EXTI\\[4\\]"] EXTI4 = 10 ,
#[doc = "11 - DMA1 Channel1 global interrupt"] DMA1_Channel1 = 11 ,
#[doc = "12 - DMA1 Channel2 global interrupt"] DMA1_Channel2 = 12 ,
#[doc = "13 - DMA1 Channel3 interrupt"] DMA1_Channel3 = 13 ,
#[doc = "14 - DMA1 Channel4 interrupt"] DMA1_Channel4 = 14 ,
#[doc = "15 - DMA1 Channel5 interrupt"] DMA1_Channel5 = 15 ,
#[doc = "16 - DMA1 Channel6 interrupt"] DMA1_Channel6 = 16 ,
#[doc = "17 - DMA1 Channel 7 interrupt"] DMA1_Channel7 = 17 ,
#[doc = "18 - ADC1 global interrupt"] ADC1 = 18 ,
#[doc = "19 - USB high priority interrupt"] USB_HP = 19 ,
#[doc = "20 - USB low priority interrupt (including USB wakeup)"] USB_LP = 20 ,
#[doc = "21 - CPU2 SEV through EXTI\\[40\\]"] C2SEV = 21 ,
#[doc = "22 - COMP2 & COMP1 interrupt through AIEC\\[21:20\\]"] COMP = 22 ,
#[doc = "23 - EXTI line \\[9:5\\] interrupt through EXTI\\[9:5\\]"] EXTI5_9 = 23 ,
#[doc = "24 - Timer 1 break interrupt"] TIM1_BRK = 24 ,
#[doc = "25 - Timer 1 Update"] TIM1_UP = 25 ,
#[doc = "26 - TIM1 Trigger and Commutation interrupts and TIM17 global interrupt"] TIM1_TRG_COM_TIM17 = 26 ,
#[doc = "27 - TIM1 Capture Compare interrupt"] TIM1_CC = 27 ,
#[doc = "28 - TIM2 global interrupt"] TIM2 = 28 ,
#[doc = "29 - Private key accelerator interrupt"] PKA = 29 ,
#[doc = "30 - I2C1 event interrupt"] I2C1_EV = 30 ,
#[doc = "31 - I2C1 error interrupt"] I2C1_ER = 31 ,
#[doc = "32 - I2C3 event interrupt"] I2C3_EV = 32 ,
#[doc = "33 - I2C3 error interrupt"] I2C3_ER = 33 ,
#[doc = "34 - SPI 1 global interrupt"] SPI1 = 34 ,
#[doc = "35 - SPI1 global interrupt"] SPI2 = 35 ,
#[doc = "36 - USART1 global interrupt"] USART1 = 36 ,
#[doc = "37 - LPUART1 global interrupt"] LPUART1 = 37 ,
#[doc = "38 - SAI1 global interrupt"] SAI1 = 38 ,
#[doc = "39 - TSC global interrupt"] TSC = 39 ,
#[doc = "40 - EXTI line \\[15:10\\] interrupt through EXTI\\[15:10\\]"] EXTI10_15 = 40 ,
#[doc = "41 - RTC Alarms (A and B) interrupt through AIEC"] RTC_ALARM = 41 ,
#[doc = "42 - CRS interrupt"] CRS_IT = 42 ,
#[doc = "43 - PWR switching on the fly interrupt"] PWR_SOTF = 43 ,
#[doc = "44 - IPCC CPU1 RX occupied interrupt"] IPCC_C1_RX_IT = 44 ,
#[doc = "45 - IPCC CPU1 TX free interrupt"] IPCC_C1_TX_IT = 45 ,
#[doc = "46 - Semaphore interrupt 0 to CPU1"] HSEM = 46 ,
#[doc = "47 - LPtimer 1 global interrupt"] LPTIM1 = 47 ,
#[doc = "48 - LPtimer 2 global interrupt"] LPTIM2 = 48 ,
#[doc = "49 - LCD global interrupt"] LCD = 49 ,
#[doc = "50 - QSPI global interrupt"] QUADSPI = 50 ,
#[doc = "51 - AES1 global interrupt"] AES1 = 51 ,
#[doc = "52 - AES2 global interrupt"] AES2 = 52 ,
#[doc = "53 - True random number generator interrupt"] True_RNG = 53 ,
#[doc = "55 - DMA2 channel 1 interrupt"] DMA2_CH1 = 55 ,
#[doc = "56 - DMA2 channel 2 interrupt"] DMA2_CH2 = 56 ,
#[doc = "57 - DMA2 channel 3 interrupt"] DMA2_CH3 = 57 ,
#[doc = "58 - DMA2 channel 4 interrupt"] DMA2_CH4 = 58 ,
#[doc = "59 - DMA2 channel 5 interrupt"] DMA2_CH5 = 59 ,
#[doc = "60 - DMA2 channel 6 interrupt"] DMA2_CH6 = 60 ,
#[doc = "61 - DMA2 channel 7 interrupt"] DMA2_CH7 = 61 ,
#[doc = "62 - DMAMUX overrun interrupt"] DMAMUX_OVR = 62 , } unsafe impl cortex_m :: interrupt :: InterruptNumber for Interrupt {
#[inline (always)] fn number (self) -> u16 { self as u16 } }
#[doc = "Direct memory access controller"] pub type Dma1 = crate :: Periph < dma1 :: RegisterBlock , 0x4002_0000 > ; impl core :: fmt :: Debug for Dma1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dma1") . finish () } }
#[doc = "Direct memory access controller"] pub mod dma1 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { isr : Isr , ifcr : Ifcr , ccr1 : Ccr1 , cndtr1 : Cndtr1 , cpar1 : Cpar1 , cmar1 : Cmar1 , _reserved6 : [u8 ; 0x04] , ccr2 : Ccr2 , cndtr2 : Cndtr2 , cpar2 : Cpar2 , cmar2 : Cmar2 , _reserved10 : [u8 ; 0x04] , ccr3 : Ccr3 , cndtr3 : Cndtr3 , cpar3 : Cpar3 , cmar3 : Cmar3 , _reserved14 : [u8 ; 0x04] , ccr4 : Ccr4 , cndtr4 : Cndtr4 , cpar4 : Cpar4 , cmar4 : Cmar4 , _reserved18 : [u8 ; 0x04] , ccr5 : Ccr5 , cndtr5 : Cndtr5 , cpar5 : Cpar5 , cmar5 : Cmar5 , _reserved22 : [u8 ; 0x04] , ccr6 : Ccr6 , cndtr6 : Cndtr6 , cpar6 : Cpar6 , cmar6 : Cmar6 , _reserved26 : [u8 ; 0x04] , ccr7 : Ccr7 , cndtr7 : Cndtr7 , cpar7 : Cpar7 , cmar7 : Cmar7 , } impl RegisterBlock {
#[doc = "0x00 - interrupt status register"]
#[inline (always)] pub const fn isr (& self) -> & Isr { & self . isr }
#[doc = "0x04 - interrupt flag clear register"]
#[inline (always)] pub const fn ifcr (& self) -> & Ifcr { & self . ifcr }
#[doc = "0x08 - channel x configuration register"]
#[inline (always)] pub const fn ccr1 (& self) -> & Ccr1 { & self . ccr1 }
#[doc = "0x0c - channel x number of data register"]
#[inline (always)] pub const fn cndtr1 (& self) -> & Cndtr1 { & self . cndtr1 }
#[doc = "0x10 - channel x peripheral address register"]
#[inline (always)] pub const fn cpar1 (& self) -> & Cpar1 { & self . cpar1 }
#[doc = "0x14 - channel x memory address register"]
#[inline (always)] pub const fn cmar1 (& self) -> & Cmar1 { & self . cmar1 }
#[doc = "0x1c - channel x configuration register"]
#[inline (always)] pub const fn ccr2 (& self) -> & Ccr2 { & self . ccr2 }
#[doc = "0x20 - channel x number of data register"]
#[inline (always)] pub const fn cndtr2 (& self) -> & Cndtr2 { & self . cndtr2 }
#[doc = "0x24 - channel x peripheral address register"]
#[inline (always)] pub const fn cpar2 (& self) -> & Cpar2 { & self . cpar2 }
#[doc = "0x28 - channel x memory address register"]
#[inline (always)] pub const fn cmar2 (& self) -> & Cmar2 { & self . cmar2 }
#[doc = "0x30 - channel x configuration register"]
#[inline (always)] pub const fn ccr3 (& self) -> & Ccr3 { & self . ccr3 }
#[doc = "0x34 - channel x number of data register"]
#[inline (always)] pub const fn cndtr3 (& self) -> & Cndtr3 { & self . cndtr3 }
#[doc = "0x38 - channel x peripheral address register"]
#[inline (always)] pub const fn cpar3 (& self) -> & Cpar3 { & self . cpar3 }
#[doc = "0x3c - channel x memory address register"]
#[inline (always)] pub const fn cmar3 (& self) -> & Cmar3 { & self . cmar3 }
#[doc = "0x44 - channel x configuration register"]
#[inline (always)] pub const fn ccr4 (& self) -> & Ccr4 { & self . ccr4 }
#[doc = "0x48 - channel x number of data register"]
#[inline (always)] pub const fn cndtr4 (& self) -> & Cndtr4 { & self . cndtr4 }
#[doc = "0x4c - channel x peripheral address register"]
#[inline (always)] pub const fn cpar4 (& self) -> & Cpar4 { & self . cpar4 }
#[doc = "0x50 - channel x memory address register"]
#[inline (always)] pub const fn cmar4 (& self) -> & Cmar4 { & self . cmar4 }
#[doc = "0x58 - channel x configuration register"]
#[inline (always)] pub const fn ccr5 (& self) -> & Ccr5 { & self . ccr5 }
#[doc = "0x5c - channel x number of data register"]
#[inline (always)] pub const fn cndtr5 (& self) -> & Cndtr5 { & self . cndtr5 }
#[doc = "0x60 - channel x peripheral address register"]
#[inline (always)] pub const fn cpar5 (& self) -> & Cpar5 { & self . cpar5 }
#[doc = "0x64 - channel x memory address register"]
#[inline (always)] pub const fn cmar5 (& self) -> & Cmar5 { & self . cmar5 }
#[doc = "0x6c - channel x configuration register"]
#[inline (always)] pub const fn ccr6 (& self) -> & Ccr6 { & self . ccr6 }
#[doc = "0x70 - channel x number of data register"]
#[inline (always)] pub const fn cndtr6 (& self) -> & Cndtr6 { & self . cndtr6 }
#[doc = "0x74 - channel x peripheral address register"]
#[inline (always)] pub const fn cpar6 (& self) -> & Cpar6 { & self . cpar6 }
#[doc = "0x78 - channel x memory address register"]
#[inline (always)] pub const fn cmar6 (& self) -> & Cmar6 { & self . cmar6 }
#[doc = "0x80 - channel x configuration register"]
#[inline (always)] pub const fn ccr7 (& self) -> & Ccr7 { & self . ccr7 }
#[doc = "0x84 - channel x number of data register"]
#[inline (always)] pub const fn cndtr7 (& self) -> & Cndtr7 { & self . cndtr7 }
#[doc = "0x88 - channel x peripheral address register"]
#[inline (always)] pub const fn cpar7 (& self) -> & Cpar7 { & self . cpar7 }
#[doc = "0x8c - channel x memory address register"]
#[inline (always)] pub const fn cmar7 (& self) -> & Cmar7 { & self . cmar7 } }
#[doc = "ISR (r) register accessor: interrupt status register\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@isr`] module"]
#[doc (alias = "ISR")] pub type Isr = crate :: Reg < isr :: IsrSpec > ;
#[doc = "interrupt status register"] pub mod isr {
#[doc = "Register `ISR` reader"] pub type R = crate :: R < IsrSpec > ;
#[doc = "Field `GIF1` reader - Channel x global interrupt flag (x = 1 ..7)"] pub type Gif1R = crate :: BitReader ;
#[doc = "Field `TCIF1` reader - Channel x transfer complete flag (x = 1 ..7)"] pub type Tcif1R = crate :: BitReader ;
#[doc = "Field `HTIF1` reader - Channel x half transfer flag (x = 1 ..7)"] pub type Htif1R = crate :: BitReader ;
#[doc = "Field `TEIF1` reader - Channel x transfer error flag (x = 1 ..7)"] pub type Teif1R = crate :: BitReader ;
#[doc = "Field `GIF2` reader - Channel x global interrupt flag (x = 1 ..7)"] pub type Gif2R = crate :: BitReader ;
#[doc = "Field `TCIF2` reader - Channel x transfer complete flag (x = 1 ..7)"] pub type Tcif2R = crate :: BitReader ;
#[doc = "Field `HTIF2` reader - Channel x half transfer flag (x = 1 ..7)"] pub type Htif2R = crate :: BitReader ;
#[doc = "Field `TEIF2` reader - Channel x transfer error flag (x = 1 ..7)"] pub type Teif2R = crate :: BitReader ;
#[doc = "Field `GIF3` reader - Channel x global interrupt flag (x = 1 ..7)"] pub type Gif3R = crate :: BitReader ;
#[doc = "Field `TCIF3` reader - Channel x transfer complete flag (x = 1 ..7)"] pub type Tcif3R = crate :: BitReader ;
#[doc = "Field `HTIF3` reader - Channel x half transfer flag (x = 1 ..7)"] pub type Htif3R = crate :: BitReader ;
#[doc = "Field `TEIF3` reader - Channel x transfer error flag (x = 1 ..7)"] pub type Teif3R = crate :: BitReader ;
#[doc = "Field `GIF4` reader - Channel x global interrupt flag (x = 1 ..7)"] pub type Gif4R = crate :: BitReader ;
#[doc = "Field `TCIF4` reader - Channel x transfer complete flag (x = 1 ..7)"] pub type Tcif4R = crate :: BitReader ;
#[doc = "Field `HTIF4` reader - Channel x half transfer flag (x = 1 ..7)"] pub type Htif4R = crate :: BitReader ;
#[doc = "Field `TEIF4` reader - Channel x transfer error flag (x = 1 ..7)"] pub type Teif4R = crate :: BitReader ;
#[doc = "Field `GIF5` reader - Channel x global interrupt flag (x = 1 ..7)"] pub type Gif5R = crate :: BitReader ;
#[doc = "Field `TCIF5` reader - Channel x transfer complete flag (x = 1 ..7)"] pub type Tcif5R = crate :: BitReader ;
#[doc = "Field `HTIF5` reader - Channel x half transfer flag (x = 1 ..7)"] pub type Htif5R = crate :: BitReader ;
#[doc = "Field `TEIF5` reader - Channel x transfer error flag (x = 1 ..7)"] pub type Teif5R = crate :: BitReader ;
#[doc = "Field `GIF6` reader - Channel x global interrupt flag (x = 1 ..7)"] pub type Gif6R = crate :: BitReader ;
#[doc = "Field `TCIF6` reader - Channel x transfer complete flag (x = 1 ..7)"] pub type Tcif6R = crate :: BitReader ;
#[doc = "Field `HTIF6` reader - Channel x half transfer flag (x = 1 ..7)"] pub type Htif6R = crate :: BitReader ;
#[doc = "Field `TEIF6` reader - Channel x transfer error flag (x = 1 ..7)"] pub type Teif6R = crate :: BitReader ;
#[doc = "Field `GIF7` reader - Channel x global interrupt flag (x = 1 ..7)"] pub type Gif7R = crate :: BitReader ;
#[doc = "Field `TCIF7` reader - Channel x transfer complete flag (x = 1 ..7)"] pub type Tcif7R = crate :: BitReader ;
#[doc = "Field `HTIF7` reader - Channel x half transfer flag (x = 1 ..7)"] pub type Htif7R = crate :: BitReader ;
#[doc = "Field `TEIF7` reader - Channel x transfer error flag (x = 1 ..7)"] pub type Teif7R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Channel x global interrupt flag (x = 1 ..7)"]
#[inline (always)] pub fn gif1 (& self) -> Gif1R { Gif1R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Channel x transfer complete flag (x = 1 ..7)"]
#[inline (always)] pub fn tcif1 (& self) -> Tcif1R { Tcif1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Channel x half transfer flag (x = 1 ..7)"]
#[inline (always)] pub fn htif1 (& self) -> Htif1R { Htif1R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Channel x transfer error flag (x = 1 ..7)"]
#[inline (always)] pub fn teif1 (& self) -> Teif1R { Teif1R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Channel x global interrupt flag (x = 1 ..7)"]
#[inline (always)] pub fn gif2 (& self) -> Gif2R { Gif2R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Channel x transfer complete flag (x = 1 ..7)"]
#[inline (always)] pub fn tcif2 (& self) -> Tcif2R { Tcif2R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Channel x half transfer flag (x = 1 ..7)"]
#[inline (always)] pub fn htif2 (& self) -> Htif2R { Htif2R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Channel x transfer error flag (x = 1 ..7)"]
#[inline (always)] pub fn teif2 (& self) -> Teif2R { Teif2R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Channel x global interrupt flag (x = 1 ..7)"]
#[inline (always)] pub fn gif3 (& self) -> Gif3R { Gif3R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Channel x transfer complete flag (x = 1 ..7)"]
#[inline (always)] pub fn tcif3 (& self) -> Tcif3R { Tcif3R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Channel x half transfer flag (x = 1 ..7)"]
#[inline (always)] pub fn htif3 (& self) -> Htif3R { Htif3R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Channel x transfer error flag (x = 1 ..7)"]
#[inline (always)] pub fn teif3 (& self) -> Teif3R { Teif3R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Channel x global interrupt flag (x = 1 ..7)"]
#[inline (always)] pub fn gif4 (& self) -> Gif4R { Gif4R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Channel x transfer complete flag (x = 1 ..7)"]
#[inline (always)] pub fn tcif4 (& self) -> Tcif4R { Tcif4R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Channel x half transfer flag (x = 1 ..7)"]
#[inline (always)] pub fn htif4 (& self) -> Htif4R { Htif4R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Channel x transfer error flag (x = 1 ..7)"]
#[inline (always)] pub fn teif4 (& self) -> Teif4R { Teif4R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Channel x global interrupt flag (x = 1 ..7)"]
#[inline (always)] pub fn gif5 (& self) -> Gif5R { Gif5R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Channel x transfer complete flag (x = 1 ..7)"]
#[inline (always)] pub fn tcif5 (& self) -> Tcif5R { Tcif5R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Channel x half transfer flag (x = 1 ..7)"]
#[inline (always)] pub fn htif5 (& self) -> Htif5R { Htif5R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Channel x transfer error flag (x = 1 ..7)"]
#[inline (always)] pub fn teif5 (& self) -> Teif5R { Teif5R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Channel x global interrupt flag (x = 1 ..7)"]
#[inline (always)] pub fn gif6 (& self) -> Gif6R { Gif6R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Channel x transfer complete flag (x = 1 ..7)"]
#[inline (always)] pub fn tcif6 (& self) -> Tcif6R { Tcif6R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Channel x half transfer flag (x = 1 ..7)"]
#[inline (always)] pub fn htif6 (& self) -> Htif6R { Htif6R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Channel x transfer error flag (x = 1 ..7)"]
#[inline (always)] pub fn teif6 (& self) -> Teif6R { Teif6R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Channel x global interrupt flag (x = 1 ..7)"]
#[inline (always)] pub fn gif7 (& self) -> Gif7R { Gif7R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Channel x transfer complete flag (x = 1 ..7)"]
#[inline (always)] pub fn tcif7 (& self) -> Tcif7R { Tcif7R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Channel x half transfer flag (x = 1 ..7)"]
#[inline (always)] pub fn htif7 (& self) -> Htif7R { Htif7R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Channel x transfer error flag (x = 1 ..7)"]
#[inline (always)] pub fn teif7 (& self) -> Teif7R { Teif7R :: new (((self . bits >> 27) & 1) != 0) } }
#[doc = "interrupt status register\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IsrSpec ; impl crate :: RegisterSpec for IsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`isr::R`](R) reader structure"] impl crate :: Readable for IsrSpec { }
#[doc = "`reset()` method sets ISR to value 0"] impl crate :: Resettable for IsrSpec { } }
#[doc = "IFCR (w) register accessor: interrupt flag clear register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ifcr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ifcr`] module"]
#[doc (alias = "IFCR")] pub type Ifcr = crate :: Reg < ifcr :: IfcrSpec > ;
#[doc = "interrupt flag clear register"] pub mod ifcr {
#[doc = "Register `IFCR` writer"] pub type W = crate :: W < IfcrSpec > ;
#[doc = "Field `CGIF1` writer - Channel x global interrupt clear (x = 1 ..7)"] pub type Cgif1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCIF1` writer - Channel x transfer complete clear (x = 1 ..7)"] pub type Ctcif1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTIF1` writer - Channel x half transfer clear (x = 1 ..7)"] pub type Chtif1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTEIF1` writer - Channel x transfer error clear (x = 1 ..7)"] pub type Cteif1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CGIF2` writer - Channel x global interrupt clear (x = 1 ..7)"] pub type Cgif2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCIF2` writer - Channel x transfer complete clear (x = 1 ..7)"] pub type Ctcif2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTIF2` writer - Channel x half transfer clear (x = 1 ..7)"] pub type Chtif2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTEIF2` writer - Channel x transfer error clear (x = 1 ..7)"] pub type Cteif2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CGIF3` writer - Channel x global interrupt clear (x = 1 ..7)"] pub type Cgif3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCIF3` writer - Channel x transfer complete clear (x = 1 ..7)"] pub type Ctcif3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTIF3` writer - Channel x half transfer clear (x = 1 ..7)"] pub type Chtif3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTEIF3` writer - Channel x transfer error clear (x = 1 ..7)"] pub type Cteif3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CGIF4` writer - Channel x global interrupt clear (x = 1 ..7)"] pub type Cgif4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCIF4` writer - Channel x transfer complete clear (x = 1 ..7)"] pub type Ctcif4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTIF4` writer - Channel x half transfer clear (x = 1 ..7)"] pub type Chtif4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTEIF4` writer - Channel x transfer error clear (x = 1 ..7)"] pub type Cteif4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CGIF5` writer - Channel x global interrupt clear (x = 1 ..7)"] pub type Cgif5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCIF5` writer - Channel x transfer complete clear (x = 1 ..7)"] pub type Ctcif5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTIF5` writer - Channel x half transfer clear (x = 1 ..7)"] pub type Chtif5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTEIF5` writer - Channel x transfer error clear (x = 1 ..7)"] pub type Cteif5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CGIF6` writer - Channel x global interrupt clear (x = 1 ..7)"] pub type Cgif6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCIF6` writer - Channel x transfer complete clear (x = 1 ..7)"] pub type Ctcif6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTIF6` writer - Channel x half transfer clear (x = 1 ..7)"] pub type Chtif6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTEIF6` writer - Channel x transfer error clear (x = 1 ..7)"] pub type Cteif6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CGIF7` writer - Channel x global interrupt clear (x = 1 ..7)"] pub type Cgif7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCIF7` writer - Channel x transfer complete clear (x = 1 ..7)"] pub type Ctcif7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTIF7` writer - Channel x half transfer clear (x = 1 ..7)"] pub type Chtif7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTEIF7` writer - Channel x transfer error clear (x = 1 ..7)"] pub type Cteif7W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Channel x global interrupt clear (x = 1 ..7)"]
#[inline (always)] pub fn cgif1 (& mut self) -> Cgif1W < '_ , IfcrSpec > { Cgif1W :: new (self , 0) }
#[doc = "Bit 1 - Channel x transfer complete clear (x = 1 ..7)"]
#[inline (always)] pub fn ctcif1 (& mut self) -> Ctcif1W < '_ , IfcrSpec > { Ctcif1W :: new (self , 1) }
#[doc = "Bit 2 - Channel x half transfer clear (x = 1 ..7)"]
#[inline (always)] pub fn chtif1 (& mut self) -> Chtif1W < '_ , IfcrSpec > { Chtif1W :: new (self , 2) }
#[doc = "Bit 3 - Channel x transfer error clear (x = 1 ..7)"]
#[inline (always)] pub fn cteif1 (& mut self) -> Cteif1W < '_ , IfcrSpec > { Cteif1W :: new (self , 3) }
#[doc = "Bit 4 - Channel x global interrupt clear (x = 1 ..7)"]
#[inline (always)] pub fn cgif2 (& mut self) -> Cgif2W < '_ , IfcrSpec > { Cgif2W :: new (self , 4) }
#[doc = "Bit 5 - Channel x transfer complete clear (x = 1 ..7)"]
#[inline (always)] pub fn ctcif2 (& mut self) -> Ctcif2W < '_ , IfcrSpec > { Ctcif2W :: new (self , 5) }
#[doc = "Bit 6 - Channel x half transfer clear (x = 1 ..7)"]
#[inline (always)] pub fn chtif2 (& mut self) -> Chtif2W < '_ , IfcrSpec > { Chtif2W :: new (self , 6) }
#[doc = "Bit 7 - Channel x transfer error clear (x = 1 ..7)"]
#[inline (always)] pub fn cteif2 (& mut self) -> Cteif2W < '_ , IfcrSpec > { Cteif2W :: new (self , 7) }
#[doc = "Bit 8 - Channel x global interrupt clear (x = 1 ..7)"]
#[inline (always)] pub fn cgif3 (& mut self) -> Cgif3W < '_ , IfcrSpec > { Cgif3W :: new (self , 8) }
#[doc = "Bit 9 - Channel x transfer complete clear (x = 1 ..7)"]
#[inline (always)] pub fn ctcif3 (& mut self) -> Ctcif3W < '_ , IfcrSpec > { Ctcif3W :: new (self , 9) }
#[doc = "Bit 10 - Channel x half transfer clear (x = 1 ..7)"]
#[inline (always)] pub fn chtif3 (& mut self) -> Chtif3W < '_ , IfcrSpec > { Chtif3W :: new (self , 10) }
#[doc = "Bit 11 - Channel x transfer error clear (x = 1 ..7)"]
#[inline (always)] pub fn cteif3 (& mut self) -> Cteif3W < '_ , IfcrSpec > { Cteif3W :: new (self , 11) }
#[doc = "Bit 12 - Channel x global interrupt clear (x = 1 ..7)"]
#[inline (always)] pub fn cgif4 (& mut self) -> Cgif4W < '_ , IfcrSpec > { Cgif4W :: new (self , 12) }
#[doc = "Bit 13 - Channel x transfer complete clear (x = 1 ..7)"]
#[inline (always)] pub fn ctcif4 (& mut self) -> Ctcif4W < '_ , IfcrSpec > { Ctcif4W :: new (self , 13) }
#[doc = "Bit 14 - Channel x half transfer clear (x = 1 ..7)"]
#[inline (always)] pub fn chtif4 (& mut self) -> Chtif4W < '_ , IfcrSpec > { Chtif4W :: new (self , 14) }
#[doc = "Bit 15 - Channel x transfer error clear (x = 1 ..7)"]
#[inline (always)] pub fn cteif4 (& mut self) -> Cteif4W < '_ , IfcrSpec > { Cteif4W :: new (self , 15) }
#[doc = "Bit 16 - Channel x global interrupt clear (x = 1 ..7)"]
#[inline (always)] pub fn cgif5 (& mut self) -> Cgif5W < '_ , IfcrSpec > { Cgif5W :: new (self , 16) }
#[doc = "Bit 17 - Channel x transfer complete clear (x = 1 ..7)"]
#[inline (always)] pub fn ctcif5 (& mut self) -> Ctcif5W < '_ , IfcrSpec > { Ctcif5W :: new (self , 17) }
#[doc = "Bit 18 - Channel x half transfer clear (x = 1 ..7)"]
#[inline (always)] pub fn chtif5 (& mut self) -> Chtif5W < '_ , IfcrSpec > { Chtif5W :: new (self , 18) }
#[doc = "Bit 19 - Channel x transfer error clear (x = 1 ..7)"]
#[inline (always)] pub fn cteif5 (& mut self) -> Cteif5W < '_ , IfcrSpec > { Cteif5W :: new (self , 19) }
#[doc = "Bit 20 - Channel x global interrupt clear (x = 1 ..7)"]
#[inline (always)] pub fn cgif6 (& mut self) -> Cgif6W < '_ , IfcrSpec > { Cgif6W :: new (self , 20) }
#[doc = "Bit 21 - Channel x transfer complete clear (x = 1 ..7)"]
#[inline (always)] pub fn ctcif6 (& mut self) -> Ctcif6W < '_ , IfcrSpec > { Ctcif6W :: new (self , 21) }
#[doc = "Bit 22 - Channel x half transfer clear (x = 1 ..7)"]
#[inline (always)] pub fn chtif6 (& mut self) -> Chtif6W < '_ , IfcrSpec > { Chtif6W :: new (self , 22) }
#[doc = "Bit 23 - Channel x transfer error clear (x = 1 ..7)"]
#[inline (always)] pub fn cteif6 (& mut self) -> Cteif6W < '_ , IfcrSpec > { Cteif6W :: new (self , 23) }
#[doc = "Bit 24 - Channel x global interrupt clear (x = 1 ..7)"]
#[inline (always)] pub fn cgif7 (& mut self) -> Cgif7W < '_ , IfcrSpec > { Cgif7W :: new (self , 24) }
#[doc = "Bit 25 - Channel x transfer complete clear (x = 1 ..7)"]
#[inline (always)] pub fn ctcif7 (& mut self) -> Ctcif7W < '_ , IfcrSpec > { Ctcif7W :: new (self , 25) }
#[doc = "Bit 26 - Channel x half transfer clear (x = 1 ..7)"]
#[inline (always)] pub fn chtif7 (& mut self) -> Chtif7W < '_ , IfcrSpec > { Chtif7W :: new (self , 26) }
#[doc = "Bit 27 - Channel x transfer error clear (x = 1 ..7)"]
#[inline (always)] pub fn cteif7 (& mut self) -> Cteif7W < '_ , IfcrSpec > { Cteif7W :: new (self , 27) } }
#[doc = "interrupt flag clear register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ifcr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IfcrSpec ; impl crate :: RegisterSpec for IfcrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`ifcr::W`](W) writer structure"] impl crate :: Writable for IfcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IFCR to value 0"] impl crate :: Resettable for IfcrSpec { } }
#[doc = "CCR1 (rw) register accessor: channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr1`] module"]
#[doc (alias = "CCR1")] pub type Ccr1 = crate :: Reg < ccr1 :: Ccr1Spec > ;
#[doc = "channel x configuration register"] pub mod ccr1 {
#[doc = "Register `CCR1` reader"] pub type R = crate :: R < Ccr1Spec > ;
#[doc = "Register `CCR1` writer"] pub type W = crate :: W < Ccr1Spec > ;
#[doc = "Field `EN` reader - Channel enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Channel enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HTIE` reader - Half transfer interrupt enable"] pub type HtieR = crate :: BitReader ;
#[doc = "Field `HTIE` writer - Half transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader ;
#[doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader ;
#[doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MINC` reader - Memory increment mode"] pub type MincR = crate :: BitReader ;
#[doc = "Field `MINC` writer - Memory increment mode"] pub type MincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSIZE` reader - Peripheral size"] pub type PsizeR = crate :: FieldReader ;
#[doc = "Field `PSIZE` writer - Peripheral size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MSIZE` reader - Memory size"] pub type MsizeR = crate :: FieldReader ;
#[doc = "Field `MSIZE` writer - Memory size"] pub type MsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PL` reader - Channel priority level"] pub type PlR = crate :: FieldReader ;
#[doc = "Field `PL` writer - Channel priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MEM2MEM` reader - Memory to memory mode"] pub type Mem2memR = crate :: BitReader ;
#[doc = "Field `MEM2MEM` writer - Memory to memory mode"] pub type Mem2memW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& self) -> Mem2memR { Mem2memR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Ccr1Spec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Ccr1Spec > { TcieW :: new (self , 1) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& mut self) -> HtieW < '_ , Ccr1Spec > { HtieW :: new (self , 2) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , Ccr1Spec > { TeieW :: new (self , 3) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Ccr1Spec > { DirW :: new (self , 4) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& mut self) -> CircW < '_ , Ccr1Spec > { CircW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& mut self) -> PincW < '_ , Ccr1Spec > { PincW :: new (self , 6) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& mut self) -> MincW < '_ , Ccr1Spec > { MincW :: new (self , 7) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& mut self) -> PsizeW < '_ , Ccr1Spec > { PsizeW :: new (self , 8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& mut self) -> MsizeW < '_ , Ccr1Spec > { MsizeW :: new (self , 10) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& mut self) -> PlW < '_ , Ccr1Spec > { PlW :: new (self , 12) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& mut self) -> Mem2memW < '_ , Ccr1Spec > { Mem2memW :: new (self , 14) } }
#[doc = "channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr1Spec ; impl crate :: RegisterSpec for Ccr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr1::R`](R) reader structure"] impl crate :: Readable for Ccr1Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr1::W`](W) writer structure"] impl crate :: Writable for Ccr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR1 to value 0"] impl crate :: Resettable for Ccr1Spec { } }
#[doc = "CNDTR1 (rw) register accessor: channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cndtr1`] module"]
#[doc (alias = "CNDTR1")] pub type Cndtr1 = crate :: Reg < cndtr1 :: Cndtr1Spec > ;
#[doc = "channel x number of data register"] pub mod cndtr1 {
#[doc = "Register `CNDTR1` reader"] pub type R = crate :: R < Cndtr1Spec > ;
#[doc = "Register `CNDTR1` writer"] pub type W = crate :: W < Cndtr1Spec > ;
#[doc = "Field `NDT` reader - Number of data to transfer"] pub type NdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `NDT` writer - Number of data to transfer"] pub type NdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& self) -> NdtR { NdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& mut self) -> NdtW < '_ , Cndtr1Spec > { NdtW :: new (self , 0) } }
#[doc = "channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cndtr1Spec ; impl crate :: RegisterSpec for Cndtr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cndtr1::R`](R) reader structure"] impl crate :: Readable for Cndtr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cndtr1::W`](W) writer structure"] impl crate :: Writable for Cndtr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNDTR1 to value 0"] impl crate :: Resettable for Cndtr1Spec { } }
#[doc = "CPAR1 (rw) register accessor: channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpar1`] module"]
#[doc (alias = "CPAR1")] pub type Cpar1 = crate :: Reg < cpar1 :: Cpar1Spec > ;
#[doc = "channel x peripheral address register"] pub mod cpar1 {
#[doc = "Register `CPAR1` reader"] pub type R = crate :: R < Cpar1Spec > ;
#[doc = "Register `CPAR1` writer"] pub type W = crate :: W < Cpar1Spec > ;
#[doc = "Field `PA` reader - Peripheral address"] pub type PaR = crate :: FieldReader < u32 > ;
#[doc = "Field `PA` writer - Peripheral address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , Cpar1Spec > { PaW :: new (self , 0) } }
#[doc = "channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cpar1Spec ; impl crate :: RegisterSpec for Cpar1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cpar1::R`](R) reader structure"] impl crate :: Readable for Cpar1Spec { }
#[doc = "`write(|w| ..)` method takes [`cpar1::W`](W) writer structure"] impl crate :: Writable for Cpar1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CPAR1 to value 0"] impl crate :: Resettable for Cpar1Spec { } }
#[doc = "CMAR1 (rw) register accessor: channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmar1`] module"]
#[doc (alias = "CMAR1")] pub type Cmar1 = crate :: Reg < cmar1 :: Cmar1Spec > ;
#[doc = "channel x memory address register"] pub mod cmar1 {
#[doc = "Register `CMAR1` reader"] pub type R = crate :: R < Cmar1Spec > ;
#[doc = "Register `CMAR1` writer"] pub type W = crate :: W < Cmar1Spec > ;
#[doc = "Field `MA` reader - Memory address"] pub type MaR = crate :: FieldReader < u32 > ;
#[doc = "Field `MA` writer - Memory address"] pub type MaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& self) -> MaR { MaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& mut self) -> MaW < '_ , Cmar1Spec > { MaW :: new (self , 0) } }
#[doc = "channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cmar1Spec ; impl crate :: RegisterSpec for Cmar1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmar1::R`](R) reader structure"] impl crate :: Readable for Cmar1Spec { }
#[doc = "`write(|w| ..)` method takes [`cmar1::W`](W) writer structure"] impl crate :: Writable for Cmar1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMAR1 to value 0"] impl crate :: Resettable for Cmar1Spec { } }
#[doc = "CCR2 (rw) register accessor: channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr2`] module"]
#[doc (alias = "CCR2")] pub type Ccr2 = crate :: Reg < ccr2 :: Ccr2Spec > ;
#[doc = "channel x configuration register"] pub mod ccr2 {
#[doc = "Register `CCR2` reader"] pub type R = crate :: R < Ccr2Spec > ;
#[doc = "Register `CCR2` writer"] pub type W = crate :: W < Ccr2Spec > ;
#[doc = "Field `EN` reader - Channel enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Channel enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HTIE` reader - Half transfer interrupt enable"] pub type HtieR = crate :: BitReader ;
#[doc = "Field `HTIE` writer - Half transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader ;
#[doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader ;
#[doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MINC` reader - Memory increment mode"] pub type MincR = crate :: BitReader ;
#[doc = "Field `MINC` writer - Memory increment mode"] pub type MincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSIZE` reader - Peripheral size"] pub type PsizeR = crate :: FieldReader ;
#[doc = "Field `PSIZE` writer - Peripheral size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MSIZE` reader - Memory size"] pub type MsizeR = crate :: FieldReader ;
#[doc = "Field `MSIZE` writer - Memory size"] pub type MsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PL` reader - Channel priority level"] pub type PlR = crate :: FieldReader ;
#[doc = "Field `PL` writer - Channel priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MEM2MEM` reader - Memory to memory mode"] pub type Mem2memR = crate :: BitReader ;
#[doc = "Field `MEM2MEM` writer - Memory to memory mode"] pub type Mem2memW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& self) -> Mem2memR { Mem2memR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Ccr2Spec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Ccr2Spec > { TcieW :: new (self , 1) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& mut self) -> HtieW < '_ , Ccr2Spec > { HtieW :: new (self , 2) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , Ccr2Spec > { TeieW :: new (self , 3) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Ccr2Spec > { DirW :: new (self , 4) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& mut self) -> CircW < '_ , Ccr2Spec > { CircW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& mut self) -> PincW < '_ , Ccr2Spec > { PincW :: new (self , 6) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& mut self) -> MincW < '_ , Ccr2Spec > { MincW :: new (self , 7) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& mut self) -> PsizeW < '_ , Ccr2Spec > { PsizeW :: new (self , 8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& mut self) -> MsizeW < '_ , Ccr2Spec > { MsizeW :: new (self , 10) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& mut self) -> PlW < '_ , Ccr2Spec > { PlW :: new (self , 12) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& mut self) -> Mem2memW < '_ , Ccr2Spec > { Mem2memW :: new (self , 14) } }
#[doc = "channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr2Spec ; impl crate :: RegisterSpec for Ccr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr2::R`](R) reader structure"] impl crate :: Readable for Ccr2Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr2::W`](W) writer structure"] impl crate :: Writable for Ccr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR2 to value 0"] impl crate :: Resettable for Ccr2Spec { } }
#[doc = "CNDTR2 (rw) register accessor: channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cndtr2`] module"]
#[doc (alias = "CNDTR2")] pub type Cndtr2 = crate :: Reg < cndtr2 :: Cndtr2Spec > ;
#[doc = "channel x number of data register"] pub mod cndtr2 {
#[doc = "Register `CNDTR2` reader"] pub type R = crate :: R < Cndtr2Spec > ;
#[doc = "Register `CNDTR2` writer"] pub type W = crate :: W < Cndtr2Spec > ;
#[doc = "Field `NDT` reader - Number of data to transfer"] pub type NdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `NDT` writer - Number of data to transfer"] pub type NdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& self) -> NdtR { NdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& mut self) -> NdtW < '_ , Cndtr2Spec > { NdtW :: new (self , 0) } }
#[doc = "channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cndtr2Spec ; impl crate :: RegisterSpec for Cndtr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cndtr2::R`](R) reader structure"] impl crate :: Readable for Cndtr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cndtr2::W`](W) writer structure"] impl crate :: Writable for Cndtr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNDTR2 to value 0"] impl crate :: Resettable for Cndtr2Spec { } }
#[doc = "CPAR2 (rw) register accessor: channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpar2`] module"]
#[doc (alias = "CPAR2")] pub type Cpar2 = crate :: Reg < cpar2 :: Cpar2Spec > ;
#[doc = "channel x peripheral address register"] pub mod cpar2 {
#[doc = "Register `CPAR2` reader"] pub type R = crate :: R < Cpar2Spec > ;
#[doc = "Register `CPAR2` writer"] pub type W = crate :: W < Cpar2Spec > ;
#[doc = "Field `PA` reader - Peripheral address"] pub type PaR = crate :: FieldReader < u32 > ;
#[doc = "Field `PA` writer - Peripheral address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , Cpar2Spec > { PaW :: new (self , 0) } }
#[doc = "channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cpar2Spec ; impl crate :: RegisterSpec for Cpar2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cpar2::R`](R) reader structure"] impl crate :: Readable for Cpar2Spec { }
#[doc = "`write(|w| ..)` method takes [`cpar2::W`](W) writer structure"] impl crate :: Writable for Cpar2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CPAR2 to value 0"] impl crate :: Resettable for Cpar2Spec { } }
#[doc = "CMAR2 (rw) register accessor: channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmar2`] module"]
#[doc (alias = "CMAR2")] pub type Cmar2 = crate :: Reg < cmar2 :: Cmar2Spec > ;
#[doc = "channel x memory address register"] pub mod cmar2 {
#[doc = "Register `CMAR2` reader"] pub type R = crate :: R < Cmar2Spec > ;
#[doc = "Register `CMAR2` writer"] pub type W = crate :: W < Cmar2Spec > ;
#[doc = "Field `MA` reader - Memory address"] pub type MaR = crate :: FieldReader < u32 > ;
#[doc = "Field `MA` writer - Memory address"] pub type MaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& self) -> MaR { MaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& mut self) -> MaW < '_ , Cmar2Spec > { MaW :: new (self , 0) } }
#[doc = "channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cmar2Spec ; impl crate :: RegisterSpec for Cmar2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmar2::R`](R) reader structure"] impl crate :: Readable for Cmar2Spec { }
#[doc = "`write(|w| ..)` method takes [`cmar2::W`](W) writer structure"] impl crate :: Writable for Cmar2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMAR2 to value 0"] impl crate :: Resettable for Cmar2Spec { } }
#[doc = "CCR3 (rw) register accessor: channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr3`] module"]
#[doc (alias = "CCR3")] pub type Ccr3 = crate :: Reg < ccr3 :: Ccr3Spec > ;
#[doc = "channel x configuration register"] pub mod ccr3 {
#[doc = "Register `CCR3` reader"] pub type R = crate :: R < Ccr3Spec > ;
#[doc = "Register `CCR3` writer"] pub type W = crate :: W < Ccr3Spec > ;
#[doc = "Field `EN` reader - Channel enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Channel enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HTIE` reader - Half transfer interrupt enable"] pub type HtieR = crate :: BitReader ;
#[doc = "Field `HTIE` writer - Half transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader ;
#[doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader ;
#[doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MINC` reader - Memory increment mode"] pub type MincR = crate :: BitReader ;
#[doc = "Field `MINC` writer - Memory increment mode"] pub type MincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSIZE` reader - Peripheral size"] pub type PsizeR = crate :: FieldReader ;
#[doc = "Field `PSIZE` writer - Peripheral size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MSIZE` reader - Memory size"] pub type MsizeR = crate :: FieldReader ;
#[doc = "Field `MSIZE` writer - Memory size"] pub type MsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PL` reader - Channel priority level"] pub type PlR = crate :: FieldReader ;
#[doc = "Field `PL` writer - Channel priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MEM2MEM` reader - Memory to memory mode"] pub type Mem2memR = crate :: BitReader ;
#[doc = "Field `MEM2MEM` writer - Memory to memory mode"] pub type Mem2memW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& self) -> Mem2memR { Mem2memR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Ccr3Spec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Ccr3Spec > { TcieW :: new (self , 1) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& mut self) -> HtieW < '_ , Ccr3Spec > { HtieW :: new (self , 2) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , Ccr3Spec > { TeieW :: new (self , 3) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Ccr3Spec > { DirW :: new (self , 4) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& mut self) -> CircW < '_ , Ccr3Spec > { CircW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& mut self) -> PincW < '_ , Ccr3Spec > { PincW :: new (self , 6) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& mut self) -> MincW < '_ , Ccr3Spec > { MincW :: new (self , 7) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& mut self) -> PsizeW < '_ , Ccr3Spec > { PsizeW :: new (self , 8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& mut self) -> MsizeW < '_ , Ccr3Spec > { MsizeW :: new (self , 10) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& mut self) -> PlW < '_ , Ccr3Spec > { PlW :: new (self , 12) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& mut self) -> Mem2memW < '_ , Ccr3Spec > { Mem2memW :: new (self , 14) } }
#[doc = "channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr3Spec ; impl crate :: RegisterSpec for Ccr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr3::R`](R) reader structure"] impl crate :: Readable for Ccr3Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr3::W`](W) writer structure"] impl crate :: Writable for Ccr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR3 to value 0"] impl crate :: Resettable for Ccr3Spec { } }
#[doc = "CNDTR3 (rw) register accessor: channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cndtr3`] module"]
#[doc (alias = "CNDTR3")] pub type Cndtr3 = crate :: Reg < cndtr3 :: Cndtr3Spec > ;
#[doc = "channel x number of data register"] pub mod cndtr3 {
#[doc = "Register `CNDTR3` reader"] pub type R = crate :: R < Cndtr3Spec > ;
#[doc = "Register `CNDTR3` writer"] pub type W = crate :: W < Cndtr3Spec > ;
#[doc = "Field `NDT` reader - Number of data to transfer"] pub type NdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `NDT` writer - Number of data to transfer"] pub type NdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& self) -> NdtR { NdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& mut self) -> NdtW < '_ , Cndtr3Spec > { NdtW :: new (self , 0) } }
#[doc = "channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cndtr3Spec ; impl crate :: RegisterSpec for Cndtr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cndtr3::R`](R) reader structure"] impl crate :: Readable for Cndtr3Spec { }
#[doc = "`write(|w| ..)` method takes [`cndtr3::W`](W) writer structure"] impl crate :: Writable for Cndtr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNDTR3 to value 0"] impl crate :: Resettable for Cndtr3Spec { } }
#[doc = "CPAR3 (rw) register accessor: channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpar3`] module"]
#[doc (alias = "CPAR3")] pub type Cpar3 = crate :: Reg < cpar3 :: Cpar3Spec > ;
#[doc = "channel x peripheral address register"] pub mod cpar3 {
#[doc = "Register `CPAR3` reader"] pub type R = crate :: R < Cpar3Spec > ;
#[doc = "Register `CPAR3` writer"] pub type W = crate :: W < Cpar3Spec > ;
#[doc = "Field `PA` reader - Peripheral address"] pub type PaR = crate :: FieldReader < u32 > ;
#[doc = "Field `PA` writer - Peripheral address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , Cpar3Spec > { PaW :: new (self , 0) } }
#[doc = "channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cpar3Spec ; impl crate :: RegisterSpec for Cpar3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cpar3::R`](R) reader structure"] impl crate :: Readable for Cpar3Spec { }
#[doc = "`write(|w| ..)` method takes [`cpar3::W`](W) writer structure"] impl crate :: Writable for Cpar3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CPAR3 to value 0"] impl crate :: Resettable for Cpar3Spec { } }
#[doc = "CMAR3 (rw) register accessor: channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmar3`] module"]
#[doc (alias = "CMAR3")] pub type Cmar3 = crate :: Reg < cmar3 :: Cmar3Spec > ;
#[doc = "channel x memory address register"] pub mod cmar3 {
#[doc = "Register `CMAR3` reader"] pub type R = crate :: R < Cmar3Spec > ;
#[doc = "Register `CMAR3` writer"] pub type W = crate :: W < Cmar3Spec > ;
#[doc = "Field `MA` reader - Memory address"] pub type MaR = crate :: FieldReader < u32 > ;
#[doc = "Field `MA` writer - Memory address"] pub type MaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& self) -> MaR { MaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& mut self) -> MaW < '_ , Cmar3Spec > { MaW :: new (self , 0) } }
#[doc = "channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cmar3Spec ; impl crate :: RegisterSpec for Cmar3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmar3::R`](R) reader structure"] impl crate :: Readable for Cmar3Spec { }
#[doc = "`write(|w| ..)` method takes [`cmar3::W`](W) writer structure"] impl crate :: Writable for Cmar3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMAR3 to value 0"] impl crate :: Resettable for Cmar3Spec { } }
#[doc = "CCR4 (rw) register accessor: channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr4`] module"]
#[doc (alias = "CCR4")] pub type Ccr4 = crate :: Reg < ccr4 :: Ccr4Spec > ;
#[doc = "channel x configuration register"] pub mod ccr4 {
#[doc = "Register `CCR4` reader"] pub type R = crate :: R < Ccr4Spec > ;
#[doc = "Register `CCR4` writer"] pub type W = crate :: W < Ccr4Spec > ;
#[doc = "Field `EN` reader - Channel enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Channel enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HTIE` reader - Half transfer interrupt enable"] pub type HtieR = crate :: BitReader ;
#[doc = "Field `HTIE` writer - Half transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader ;
#[doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader ;
#[doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MINC` reader - Memory increment mode"] pub type MincR = crate :: BitReader ;
#[doc = "Field `MINC` writer - Memory increment mode"] pub type MincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSIZE` reader - Peripheral size"] pub type PsizeR = crate :: FieldReader ;
#[doc = "Field `PSIZE` writer - Peripheral size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MSIZE` reader - Memory size"] pub type MsizeR = crate :: FieldReader ;
#[doc = "Field `MSIZE` writer - Memory size"] pub type MsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PL` reader - Channel priority level"] pub type PlR = crate :: FieldReader ;
#[doc = "Field `PL` writer - Channel priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MEM2MEM` reader - Memory to memory mode"] pub type Mem2memR = crate :: BitReader ;
#[doc = "Field `MEM2MEM` writer - Memory to memory mode"] pub type Mem2memW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& self) -> Mem2memR { Mem2memR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Ccr4Spec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Ccr4Spec > { TcieW :: new (self , 1) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& mut self) -> HtieW < '_ , Ccr4Spec > { HtieW :: new (self , 2) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , Ccr4Spec > { TeieW :: new (self , 3) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Ccr4Spec > { DirW :: new (self , 4) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& mut self) -> CircW < '_ , Ccr4Spec > { CircW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& mut self) -> PincW < '_ , Ccr4Spec > { PincW :: new (self , 6) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& mut self) -> MincW < '_ , Ccr4Spec > { MincW :: new (self , 7) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& mut self) -> PsizeW < '_ , Ccr4Spec > { PsizeW :: new (self , 8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& mut self) -> MsizeW < '_ , Ccr4Spec > { MsizeW :: new (self , 10) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& mut self) -> PlW < '_ , Ccr4Spec > { PlW :: new (self , 12) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& mut self) -> Mem2memW < '_ , Ccr4Spec > { Mem2memW :: new (self , 14) } }
#[doc = "channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr4Spec ; impl crate :: RegisterSpec for Ccr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr4::R`](R) reader structure"] impl crate :: Readable for Ccr4Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr4::W`](W) writer structure"] impl crate :: Writable for Ccr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR4 to value 0"] impl crate :: Resettable for Ccr4Spec { } }
#[doc = "CNDTR4 (rw) register accessor: channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cndtr4`] module"]
#[doc (alias = "CNDTR4")] pub type Cndtr4 = crate :: Reg < cndtr4 :: Cndtr4Spec > ;
#[doc = "channel x number of data register"] pub mod cndtr4 {
#[doc = "Register `CNDTR4` reader"] pub type R = crate :: R < Cndtr4Spec > ;
#[doc = "Register `CNDTR4` writer"] pub type W = crate :: W < Cndtr4Spec > ;
#[doc = "Field `NDT` reader - Number of data to transfer"] pub type NdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `NDT` writer - Number of data to transfer"] pub type NdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& self) -> NdtR { NdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& mut self) -> NdtW < '_ , Cndtr4Spec > { NdtW :: new (self , 0) } }
#[doc = "channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cndtr4Spec ; impl crate :: RegisterSpec for Cndtr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cndtr4::R`](R) reader structure"] impl crate :: Readable for Cndtr4Spec { }
#[doc = "`write(|w| ..)` method takes [`cndtr4::W`](W) writer structure"] impl crate :: Writable for Cndtr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNDTR4 to value 0"] impl crate :: Resettable for Cndtr4Spec { } }
#[doc = "CPAR4 (rw) register accessor: channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpar4`] module"]
#[doc (alias = "CPAR4")] pub type Cpar4 = crate :: Reg < cpar4 :: Cpar4Spec > ;
#[doc = "channel x peripheral address register"] pub mod cpar4 {
#[doc = "Register `CPAR4` reader"] pub type R = crate :: R < Cpar4Spec > ;
#[doc = "Register `CPAR4` writer"] pub type W = crate :: W < Cpar4Spec > ;
#[doc = "Field `PA` reader - Peripheral address"] pub type PaR = crate :: FieldReader < u32 > ;
#[doc = "Field `PA` writer - Peripheral address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , Cpar4Spec > { PaW :: new (self , 0) } }
#[doc = "channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cpar4Spec ; impl crate :: RegisterSpec for Cpar4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cpar4::R`](R) reader structure"] impl crate :: Readable for Cpar4Spec { }
#[doc = "`write(|w| ..)` method takes [`cpar4::W`](W) writer structure"] impl crate :: Writable for Cpar4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CPAR4 to value 0"] impl crate :: Resettable for Cpar4Spec { } }
#[doc = "CMAR4 (rw) register accessor: channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmar4`] module"]
#[doc (alias = "CMAR4")] pub type Cmar4 = crate :: Reg < cmar4 :: Cmar4Spec > ;
#[doc = "channel x memory address register"] pub mod cmar4 {
#[doc = "Register `CMAR4` reader"] pub type R = crate :: R < Cmar4Spec > ;
#[doc = "Register `CMAR4` writer"] pub type W = crate :: W < Cmar4Spec > ;
#[doc = "Field `MA` reader - Memory address"] pub type MaR = crate :: FieldReader < u32 > ;
#[doc = "Field `MA` writer - Memory address"] pub type MaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& self) -> MaR { MaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& mut self) -> MaW < '_ , Cmar4Spec > { MaW :: new (self , 0) } }
#[doc = "channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cmar4Spec ; impl crate :: RegisterSpec for Cmar4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmar4::R`](R) reader structure"] impl crate :: Readable for Cmar4Spec { }
#[doc = "`write(|w| ..)` method takes [`cmar4::W`](W) writer structure"] impl crate :: Writable for Cmar4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMAR4 to value 0"] impl crate :: Resettable for Cmar4Spec { } }
#[doc = "CCR5 (rw) register accessor: channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr5`] module"]
#[doc (alias = "CCR5")] pub type Ccr5 = crate :: Reg < ccr5 :: Ccr5Spec > ;
#[doc = "channel x configuration register"] pub mod ccr5 {
#[doc = "Register `CCR5` reader"] pub type R = crate :: R < Ccr5Spec > ;
#[doc = "Register `CCR5` writer"] pub type W = crate :: W < Ccr5Spec > ;
#[doc = "Field `EN` reader - Channel enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Channel enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HTIE` reader - Half transfer interrupt enable"] pub type HtieR = crate :: BitReader ;
#[doc = "Field `HTIE` writer - Half transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader ;
#[doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader ;
#[doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MINC` reader - Memory increment mode"] pub type MincR = crate :: BitReader ;
#[doc = "Field `MINC` writer - Memory increment mode"] pub type MincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSIZE` reader - Peripheral size"] pub type PsizeR = crate :: FieldReader ;
#[doc = "Field `PSIZE` writer - Peripheral size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MSIZE` reader - Memory size"] pub type MsizeR = crate :: FieldReader ;
#[doc = "Field `MSIZE` writer - Memory size"] pub type MsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PL` reader - Channel priority level"] pub type PlR = crate :: FieldReader ;
#[doc = "Field `PL` writer - Channel priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MEM2MEM` reader - Memory to memory mode"] pub type Mem2memR = crate :: BitReader ;
#[doc = "Field `MEM2MEM` writer - Memory to memory mode"] pub type Mem2memW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& self) -> Mem2memR { Mem2memR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Ccr5Spec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Ccr5Spec > { TcieW :: new (self , 1) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& mut self) -> HtieW < '_ , Ccr5Spec > { HtieW :: new (self , 2) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , Ccr5Spec > { TeieW :: new (self , 3) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Ccr5Spec > { DirW :: new (self , 4) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& mut self) -> CircW < '_ , Ccr5Spec > { CircW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& mut self) -> PincW < '_ , Ccr5Spec > { PincW :: new (self , 6) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& mut self) -> MincW < '_ , Ccr5Spec > { MincW :: new (self , 7) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& mut self) -> PsizeW < '_ , Ccr5Spec > { PsizeW :: new (self , 8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& mut self) -> MsizeW < '_ , Ccr5Spec > { MsizeW :: new (self , 10) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& mut self) -> PlW < '_ , Ccr5Spec > { PlW :: new (self , 12) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& mut self) -> Mem2memW < '_ , Ccr5Spec > { Mem2memW :: new (self , 14) } }
#[doc = "channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr5Spec ; impl crate :: RegisterSpec for Ccr5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr5::R`](R) reader structure"] impl crate :: Readable for Ccr5Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr5::W`](W) writer structure"] impl crate :: Writable for Ccr5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR5 to value 0"] impl crate :: Resettable for Ccr5Spec { } }
#[doc = "CNDTR5 (rw) register accessor: channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cndtr5`] module"]
#[doc (alias = "CNDTR5")] pub type Cndtr5 = crate :: Reg < cndtr5 :: Cndtr5Spec > ;
#[doc = "channel x number of data register"] pub mod cndtr5 {
#[doc = "Register `CNDTR5` reader"] pub type R = crate :: R < Cndtr5Spec > ;
#[doc = "Register `CNDTR5` writer"] pub type W = crate :: W < Cndtr5Spec > ;
#[doc = "Field `NDT` reader - Number of data to transfer"] pub type NdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `NDT` writer - Number of data to transfer"] pub type NdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& self) -> NdtR { NdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& mut self) -> NdtW < '_ , Cndtr5Spec > { NdtW :: new (self , 0) } }
#[doc = "channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cndtr5Spec ; impl crate :: RegisterSpec for Cndtr5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cndtr5::R`](R) reader structure"] impl crate :: Readable for Cndtr5Spec { }
#[doc = "`write(|w| ..)` method takes [`cndtr5::W`](W) writer structure"] impl crate :: Writable for Cndtr5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNDTR5 to value 0"] impl crate :: Resettable for Cndtr5Spec { } }
#[doc = "CPAR5 (rw) register accessor: channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpar5`] module"]
#[doc (alias = "CPAR5")] pub type Cpar5 = crate :: Reg < cpar5 :: Cpar5Spec > ;
#[doc = "channel x peripheral address register"] pub mod cpar5 {
#[doc = "Register `CPAR5` reader"] pub type R = crate :: R < Cpar5Spec > ;
#[doc = "Register `CPAR5` writer"] pub type W = crate :: W < Cpar5Spec > ;
#[doc = "Field `PA` reader - Peripheral address"] pub type PaR = crate :: FieldReader < u32 > ;
#[doc = "Field `PA` writer - Peripheral address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , Cpar5Spec > { PaW :: new (self , 0) } }
#[doc = "channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cpar5Spec ; impl crate :: RegisterSpec for Cpar5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cpar5::R`](R) reader structure"] impl crate :: Readable for Cpar5Spec { }
#[doc = "`write(|w| ..)` method takes [`cpar5::W`](W) writer structure"] impl crate :: Writable for Cpar5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CPAR5 to value 0"] impl crate :: Resettable for Cpar5Spec { } }
#[doc = "CMAR5 (rw) register accessor: channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmar5`] module"]
#[doc (alias = "CMAR5")] pub type Cmar5 = crate :: Reg < cmar5 :: Cmar5Spec > ;
#[doc = "channel x memory address register"] pub mod cmar5 {
#[doc = "Register `CMAR5` reader"] pub type R = crate :: R < Cmar5Spec > ;
#[doc = "Register `CMAR5` writer"] pub type W = crate :: W < Cmar5Spec > ;
#[doc = "Field `MA` reader - Memory address"] pub type MaR = crate :: FieldReader < u32 > ;
#[doc = "Field `MA` writer - Memory address"] pub type MaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& self) -> MaR { MaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& mut self) -> MaW < '_ , Cmar5Spec > { MaW :: new (self , 0) } }
#[doc = "channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cmar5Spec ; impl crate :: RegisterSpec for Cmar5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmar5::R`](R) reader structure"] impl crate :: Readable for Cmar5Spec { }
#[doc = "`write(|w| ..)` method takes [`cmar5::W`](W) writer structure"] impl crate :: Writable for Cmar5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMAR5 to value 0"] impl crate :: Resettable for Cmar5Spec { } }
#[doc = "CCR6 (rw) register accessor: channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr6`] module"]
#[doc (alias = "CCR6")] pub type Ccr6 = crate :: Reg < ccr6 :: Ccr6Spec > ;
#[doc = "channel x configuration register"] pub mod ccr6 {
#[doc = "Register `CCR6` reader"] pub type R = crate :: R < Ccr6Spec > ;
#[doc = "Register `CCR6` writer"] pub type W = crate :: W < Ccr6Spec > ;
#[doc = "Field `EN` reader - Channel enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Channel enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HTIE` reader - Half transfer interrupt enable"] pub type HtieR = crate :: BitReader ;
#[doc = "Field `HTIE` writer - Half transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader ;
#[doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader ;
#[doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MINC` reader - Memory increment mode"] pub type MincR = crate :: BitReader ;
#[doc = "Field `MINC` writer - Memory increment mode"] pub type MincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSIZE` reader - Peripheral size"] pub type PsizeR = crate :: FieldReader ;
#[doc = "Field `PSIZE` writer - Peripheral size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MSIZE` reader - Memory size"] pub type MsizeR = crate :: FieldReader ;
#[doc = "Field `MSIZE` writer - Memory size"] pub type MsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PL` reader - Channel priority level"] pub type PlR = crate :: FieldReader ;
#[doc = "Field `PL` writer - Channel priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MEM2MEM` reader - Memory to memory mode"] pub type Mem2memR = crate :: BitReader ;
#[doc = "Field `MEM2MEM` writer - Memory to memory mode"] pub type Mem2memW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& self) -> Mem2memR { Mem2memR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Ccr6Spec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Ccr6Spec > { TcieW :: new (self , 1) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& mut self) -> HtieW < '_ , Ccr6Spec > { HtieW :: new (self , 2) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , Ccr6Spec > { TeieW :: new (self , 3) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Ccr6Spec > { DirW :: new (self , 4) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& mut self) -> CircW < '_ , Ccr6Spec > { CircW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& mut self) -> PincW < '_ , Ccr6Spec > { PincW :: new (self , 6) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& mut self) -> MincW < '_ , Ccr6Spec > { MincW :: new (self , 7) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& mut self) -> PsizeW < '_ , Ccr6Spec > { PsizeW :: new (self , 8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& mut self) -> MsizeW < '_ , Ccr6Spec > { MsizeW :: new (self , 10) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& mut self) -> PlW < '_ , Ccr6Spec > { PlW :: new (self , 12) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& mut self) -> Mem2memW < '_ , Ccr6Spec > { Mem2memW :: new (self , 14) } }
#[doc = "channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr6Spec ; impl crate :: RegisterSpec for Ccr6Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr6::R`](R) reader structure"] impl crate :: Readable for Ccr6Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr6::W`](W) writer structure"] impl crate :: Writable for Ccr6Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR6 to value 0"] impl crate :: Resettable for Ccr6Spec { } }
#[doc = "CNDTR6 (rw) register accessor: channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cndtr6`] module"]
#[doc (alias = "CNDTR6")] pub type Cndtr6 = crate :: Reg < cndtr6 :: Cndtr6Spec > ;
#[doc = "channel x number of data register"] pub mod cndtr6 {
#[doc = "Register `CNDTR6` reader"] pub type R = crate :: R < Cndtr6Spec > ;
#[doc = "Register `CNDTR6` writer"] pub type W = crate :: W < Cndtr6Spec > ;
#[doc = "Field `NDT` reader - Number of data to transfer"] pub type NdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `NDT` writer - Number of data to transfer"] pub type NdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& self) -> NdtR { NdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& mut self) -> NdtW < '_ , Cndtr6Spec > { NdtW :: new (self , 0) } }
#[doc = "channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cndtr6Spec ; impl crate :: RegisterSpec for Cndtr6Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cndtr6::R`](R) reader structure"] impl crate :: Readable for Cndtr6Spec { }
#[doc = "`write(|w| ..)` method takes [`cndtr6::W`](W) writer structure"] impl crate :: Writable for Cndtr6Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNDTR6 to value 0"] impl crate :: Resettable for Cndtr6Spec { } }
#[doc = "CPAR6 (rw) register accessor: channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpar6`] module"]
#[doc (alias = "CPAR6")] pub type Cpar6 = crate :: Reg < cpar6 :: Cpar6Spec > ;
#[doc = "channel x peripheral address register"] pub mod cpar6 {
#[doc = "Register `CPAR6` reader"] pub type R = crate :: R < Cpar6Spec > ;
#[doc = "Register `CPAR6` writer"] pub type W = crate :: W < Cpar6Spec > ;
#[doc = "Field `PA` reader - Peripheral address"] pub type PaR = crate :: FieldReader < u32 > ;
#[doc = "Field `PA` writer - Peripheral address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , Cpar6Spec > { PaW :: new (self , 0) } }
#[doc = "channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cpar6Spec ; impl crate :: RegisterSpec for Cpar6Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cpar6::R`](R) reader structure"] impl crate :: Readable for Cpar6Spec { }
#[doc = "`write(|w| ..)` method takes [`cpar6::W`](W) writer structure"] impl crate :: Writable for Cpar6Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CPAR6 to value 0"] impl crate :: Resettable for Cpar6Spec { } }
#[doc = "CMAR6 (rw) register accessor: channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmar6`] module"]
#[doc (alias = "CMAR6")] pub type Cmar6 = crate :: Reg < cmar6 :: Cmar6Spec > ;
#[doc = "channel x memory address register"] pub mod cmar6 {
#[doc = "Register `CMAR6` reader"] pub type R = crate :: R < Cmar6Spec > ;
#[doc = "Register `CMAR6` writer"] pub type W = crate :: W < Cmar6Spec > ;
#[doc = "Field `MA` reader - Memory address"] pub type MaR = crate :: FieldReader < u32 > ;
#[doc = "Field `MA` writer - Memory address"] pub type MaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& self) -> MaR { MaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& mut self) -> MaW < '_ , Cmar6Spec > { MaW :: new (self , 0) } }
#[doc = "channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cmar6Spec ; impl crate :: RegisterSpec for Cmar6Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmar6::R`](R) reader structure"] impl crate :: Readable for Cmar6Spec { }
#[doc = "`write(|w| ..)` method takes [`cmar6::W`](W) writer structure"] impl crate :: Writable for Cmar6Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMAR6 to value 0"] impl crate :: Resettable for Cmar6Spec { } }
#[doc = "CCR7 (rw) register accessor: channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr7::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr7::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr7`] module"]
#[doc (alias = "CCR7")] pub type Ccr7 = crate :: Reg < ccr7 :: Ccr7Spec > ;
#[doc = "channel x configuration register"] pub mod ccr7 {
#[doc = "Register `CCR7` reader"] pub type R = crate :: R < Ccr7Spec > ;
#[doc = "Register `CCR7` writer"] pub type W = crate :: W < Ccr7Spec > ;
#[doc = "Field `EN` reader - Channel enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Channel enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HTIE` reader - Half transfer interrupt enable"] pub type HtieR = crate :: BitReader ;
#[doc = "Field `HTIE` writer - Half transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader ;
#[doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader ;
#[doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MINC` reader - Memory increment mode"] pub type MincR = crate :: BitReader ;
#[doc = "Field `MINC` writer - Memory increment mode"] pub type MincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSIZE` reader - Peripheral size"] pub type PsizeR = crate :: FieldReader ;
#[doc = "Field `PSIZE` writer - Peripheral size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MSIZE` reader - Memory size"] pub type MsizeR = crate :: FieldReader ;
#[doc = "Field `MSIZE` writer - Memory size"] pub type MsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PL` reader - Channel priority level"] pub type PlR = crate :: FieldReader ;
#[doc = "Field `PL` writer - Channel priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MEM2MEM` reader - Memory to memory mode"] pub type Mem2memR = crate :: BitReader ;
#[doc = "Field `MEM2MEM` writer - Memory to memory mode"] pub type Mem2memW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& self) -> Mem2memR { Mem2memR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Ccr7Spec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Ccr7Spec > { TcieW :: new (self , 1) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& mut self) -> HtieW < '_ , Ccr7Spec > { HtieW :: new (self , 2) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , Ccr7Spec > { TeieW :: new (self , 3) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Ccr7Spec > { DirW :: new (self , 4) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& mut self) -> CircW < '_ , Ccr7Spec > { CircW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& mut self) -> PincW < '_ , Ccr7Spec > { PincW :: new (self , 6) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& mut self) -> MincW < '_ , Ccr7Spec > { MincW :: new (self , 7) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& mut self) -> PsizeW < '_ , Ccr7Spec > { PsizeW :: new (self , 8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& mut self) -> MsizeW < '_ , Ccr7Spec > { MsizeW :: new (self , 10) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& mut self) -> PlW < '_ , Ccr7Spec > { PlW :: new (self , 12) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& mut self) -> Mem2memW < '_ , Ccr7Spec > { Mem2memW :: new (self , 14) } }
#[doc = "channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr7::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr7::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr7Spec ; impl crate :: RegisterSpec for Ccr7Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr7::R`](R) reader structure"] impl crate :: Readable for Ccr7Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr7::W`](W) writer structure"] impl crate :: Writable for Ccr7Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR7 to value 0"] impl crate :: Resettable for Ccr7Spec { } }
#[doc = "CNDTR7 (rw) register accessor: channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr7::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr7::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cndtr7`] module"]
#[doc (alias = "CNDTR7")] pub type Cndtr7 = crate :: Reg < cndtr7 :: Cndtr7Spec > ;
#[doc = "channel x number of data register"] pub mod cndtr7 {
#[doc = "Register `CNDTR7` reader"] pub type R = crate :: R < Cndtr7Spec > ;
#[doc = "Register `CNDTR7` writer"] pub type W = crate :: W < Cndtr7Spec > ;
#[doc = "Field `NDT` reader - Number of data to transfer"] pub type NdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `NDT` writer - Number of data to transfer"] pub type NdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& self) -> NdtR { NdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& mut self) -> NdtW < '_ , Cndtr7Spec > { NdtW :: new (self , 0) } }
#[doc = "channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr7::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr7::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cndtr7Spec ; impl crate :: RegisterSpec for Cndtr7Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cndtr7::R`](R) reader structure"] impl crate :: Readable for Cndtr7Spec { }
#[doc = "`write(|w| ..)` method takes [`cndtr7::W`](W) writer structure"] impl crate :: Writable for Cndtr7Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNDTR7 to value 0"] impl crate :: Resettable for Cndtr7Spec { } }
#[doc = "CPAR7 (rw) register accessor: channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar7::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar7::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpar7`] module"]
#[doc (alias = "CPAR7")] pub type Cpar7 = crate :: Reg < cpar7 :: Cpar7Spec > ;
#[doc = "channel x peripheral address register"] pub mod cpar7 {
#[doc = "Register `CPAR7` reader"] pub type R = crate :: R < Cpar7Spec > ;
#[doc = "Register `CPAR7` writer"] pub type W = crate :: W < Cpar7Spec > ;
#[doc = "Field `PA` reader - Peripheral address"] pub type PaR = crate :: FieldReader < u32 > ;
#[doc = "Field `PA` writer - Peripheral address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , Cpar7Spec > { PaW :: new (self , 0) } }
#[doc = "channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar7::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar7::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cpar7Spec ; impl crate :: RegisterSpec for Cpar7Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cpar7::R`](R) reader structure"] impl crate :: Readable for Cpar7Spec { }
#[doc = "`write(|w| ..)` method takes [`cpar7::W`](W) writer structure"] impl crate :: Writable for Cpar7Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CPAR7 to value 0"] impl crate :: Resettable for Cpar7Spec { } }
#[doc = "CMAR7 (rw) register accessor: channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar7::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar7::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmar7`] module"]
#[doc (alias = "CMAR7")] pub type Cmar7 = crate :: Reg < cmar7 :: Cmar7Spec > ;
#[doc = "channel x memory address register"] pub mod cmar7 {
#[doc = "Register `CMAR7` reader"] pub type R = crate :: R < Cmar7Spec > ;
#[doc = "Register `CMAR7` writer"] pub type W = crate :: W < Cmar7Spec > ;
#[doc = "Field `MA` reader - Memory address"] pub type MaR = crate :: FieldReader < u32 > ;
#[doc = "Field `MA` writer - Memory address"] pub type MaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& self) -> MaR { MaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& mut self) -> MaW < '_ , Cmar7Spec > { MaW :: new (self , 0) } }
#[doc = "channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar7::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar7::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cmar7Spec ; impl crate :: RegisterSpec for Cmar7Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmar7::R`](R) reader structure"] impl crate :: Readable for Cmar7Spec { }
#[doc = "`write(|w| ..)` method takes [`cmar7::W`](W) writer structure"] impl crate :: Writable for Cmar7Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMAR7 to value 0"] impl crate :: Resettable for Cmar7Spec { } } }
#[doc = "Direct memory access controller"] pub type Dma2 = crate :: Periph < dma2 :: RegisterBlock , 0x4002_0400 > ; impl core :: fmt :: Debug for Dma2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dma2") . finish () } }
#[doc = "Direct memory access controller"] pub mod dma2 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { isr : Isr , ifcr : Ifcr , ccr1 : Ccr1 , cndtr1 : Cndtr1 , cpar1 : Cpar1 , cmar1 : Cmar1 , _reserved6 : [u8 ; 0x04] , ccr2 : Ccr2 , cndtr2 : Cndtr2 , cpar2 : Cpar2 , cmar2 : Cmar2 , _reserved10 : [u8 ; 0x04] , ccr3 : Ccr3 , cndtr3 : Cndtr3 , cpar3 : Cpar3 , cmar3 : Cmar3 , _reserved14 : [u8 ; 0x04] , ccr4 : Ccr4 , cndtr4 : Cndtr4 , cpar4 : Cpar4 , cmar4 : Cmar4 , _reserved18 : [u8 ; 0x04] , ccr5 : Ccr5 , cndtr5 : Cndtr5 , cpar5 : Cpar5 , cmar5 : Cmar5 , _reserved22 : [u8 ; 0x04] , ccr6 : Ccr6 , cndtr6 : Cndtr6 , cpar6 : Cpar6 , cmar6 : Cmar6 , _reserved26 : [u8 ; 0x04] , ccr7 : Ccr7 , cndtr7 : Cndtr7 , cpar7 : Cpar7 , cmar7 : Cmar7 , _reserved30 : [u8 ; 0x18] , cselr : Cselr , } impl RegisterBlock {
#[doc = "0x00 - interrupt status register"]
#[inline (always)] pub const fn isr (& self) -> & Isr { & self . isr }
#[doc = "0x04 - interrupt flag clear register"]
#[inline (always)] pub const fn ifcr (& self) -> & Ifcr { & self . ifcr }
#[doc = "0x08 - channel x configuration register"]
#[inline (always)] pub const fn ccr1 (& self) -> & Ccr1 { & self . ccr1 }
#[doc = "0x0c - channel x number of data register"]
#[inline (always)] pub const fn cndtr1 (& self) -> & Cndtr1 { & self . cndtr1 }
#[doc = "0x10 - channel x peripheral address register"]
#[inline (always)] pub const fn cpar1 (& self) -> & Cpar1 { & self . cpar1 }
#[doc = "0x14 - channel x memory address register"]
#[inline (always)] pub const fn cmar1 (& self) -> & Cmar1 { & self . cmar1 }
#[doc = "0x1c - channel x configuration register"]
#[inline (always)] pub const fn ccr2 (& self) -> & Ccr2 { & self . ccr2 }
#[doc = "0x20 - channel x number of data register"]
#[inline (always)] pub const fn cndtr2 (& self) -> & Cndtr2 { & self . cndtr2 }
#[doc = "0x24 - channel x peripheral address register"]
#[inline (always)] pub const fn cpar2 (& self) -> & Cpar2 { & self . cpar2 }
#[doc = "0x28 - channel x memory address register"]
#[inline (always)] pub const fn cmar2 (& self) -> & Cmar2 { & self . cmar2 }
#[doc = "0x30 - channel x configuration register"]
#[inline (always)] pub const fn ccr3 (& self) -> & Ccr3 { & self . ccr3 }
#[doc = "0x34 - channel x number of data register"]
#[inline (always)] pub const fn cndtr3 (& self) -> & Cndtr3 { & self . cndtr3 }
#[doc = "0x38 - channel x peripheral address register"]
#[inline (always)] pub const fn cpar3 (& self) -> & Cpar3 { & self . cpar3 }
#[doc = "0x3c - channel x memory address register"]
#[inline (always)] pub const fn cmar3 (& self) -> & Cmar3 { & self . cmar3 }
#[doc = "0x44 - channel x configuration register"]
#[inline (always)] pub const fn ccr4 (& self) -> & Ccr4 { & self . ccr4 }
#[doc = "0x48 - channel x number of data register"]
#[inline (always)] pub const fn cndtr4 (& self) -> & Cndtr4 { & self . cndtr4 }
#[doc = "0x4c - channel x peripheral address register"]
#[inline (always)] pub const fn cpar4 (& self) -> & Cpar4 { & self . cpar4 }
#[doc = "0x50 - channel x memory address register"]
#[inline (always)] pub const fn cmar4 (& self) -> & Cmar4 { & self . cmar4 }
#[doc = "0x58 - channel x configuration register"]
#[inline (always)] pub const fn ccr5 (& self) -> & Ccr5 { & self . ccr5 }
#[doc = "0x5c - channel x number of data register"]
#[inline (always)] pub const fn cndtr5 (& self) -> & Cndtr5 { & self . cndtr5 }
#[doc = "0x60 - channel x peripheral address register"]
#[inline (always)] pub const fn cpar5 (& self) -> & Cpar5 { & self . cpar5 }
#[doc = "0x64 - channel x memory address register"]
#[inline (always)] pub const fn cmar5 (& self) -> & Cmar5 { & self . cmar5 }
#[doc = "0x6c - channel x configuration register"]
#[inline (always)] pub const fn ccr6 (& self) -> & Ccr6 { & self . ccr6 }
#[doc = "0x70 - channel x number of data register"]
#[inline (always)] pub const fn cndtr6 (& self) -> & Cndtr6 { & self . cndtr6 }
#[doc = "0x74 - channel x peripheral address register"]
#[inline (always)] pub const fn cpar6 (& self) -> & Cpar6 { & self . cpar6 }
#[doc = "0x78 - channel x memory address register"]
#[inline (always)] pub const fn cmar6 (& self) -> & Cmar6 { & self . cmar6 }
#[doc = "0x80 - channel x configuration register"]
#[inline (always)] pub const fn ccr7 (& self) -> & Ccr7 { & self . ccr7 }
#[doc = "0x84 - channel x number of data register"]
#[inline (always)] pub const fn cndtr7 (& self) -> & Cndtr7 { & self . cndtr7 }
#[doc = "0x88 - channel x peripheral address register"]
#[inline (always)] pub const fn cpar7 (& self) -> & Cpar7 { & self . cpar7 }
#[doc = "0x8c - channel x memory address register"]
#[inline (always)] pub const fn cmar7 (& self) -> & Cmar7 { & self . cmar7 }
#[doc = "0xa8 - channel selection register"]
#[inline (always)] pub const fn cselr (& self) -> & Cselr { & self . cselr } }
#[doc = "ISR (r) register accessor: interrupt status register\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@isr`] module"]
#[doc (alias = "ISR")] pub type Isr = crate :: Reg < isr :: IsrSpec > ;
#[doc = "interrupt status register"] pub mod isr {
#[doc = "Register `ISR` reader"] pub type R = crate :: R < IsrSpec > ;
#[doc = "Field `GIF1` reader - Channel x global interrupt flag (x = 1 ..7)"] pub type Gif1R = crate :: BitReader ;
#[doc = "Field `TCIF1` reader - Channel x transfer complete flag (x = 1 ..7)"] pub type Tcif1R = crate :: BitReader ;
#[doc = "Field `HTIF1` reader - Channel x half transfer flag (x = 1 ..7)"] pub type Htif1R = crate :: BitReader ;
#[doc = "Field `TEIF1` reader - Channel x transfer error flag (x = 1 ..7)"] pub type Teif1R = crate :: BitReader ;
#[doc = "Field `GIF2` reader - Channel x global interrupt flag (x = 1 ..7)"] pub type Gif2R = crate :: BitReader ;
#[doc = "Field `TCIF2` reader - Channel x transfer complete flag (x = 1 ..7)"] pub type Tcif2R = crate :: BitReader ;
#[doc = "Field `HTIF2` reader - Channel x half transfer flag (x = 1 ..7)"] pub type Htif2R = crate :: BitReader ;
#[doc = "Field `TEIF2` reader - Channel x transfer error flag (x = 1 ..7)"] pub type Teif2R = crate :: BitReader ;
#[doc = "Field `GIF3` reader - Channel x global interrupt flag (x = 1 ..7)"] pub type Gif3R = crate :: BitReader ;
#[doc = "Field `TCIF3` reader - Channel x transfer complete flag (x = 1 ..7)"] pub type Tcif3R = crate :: BitReader ;
#[doc = "Field `HTIF3` reader - Channel x half transfer flag (x = 1 ..7)"] pub type Htif3R = crate :: BitReader ;
#[doc = "Field `TEIF3` reader - Channel x transfer error flag (x = 1 ..7)"] pub type Teif3R = crate :: BitReader ;
#[doc = "Field `GIF4` reader - Channel x global interrupt flag (x = 1 ..7)"] pub type Gif4R = crate :: BitReader ;
#[doc = "Field `TCIF4` reader - Channel x transfer complete flag (x = 1 ..7)"] pub type Tcif4R = crate :: BitReader ;
#[doc = "Field `HTIF4` reader - Channel x half transfer flag (x = 1 ..7)"] pub type Htif4R = crate :: BitReader ;
#[doc = "Field `TEIF4` reader - Channel x transfer error flag (x = 1 ..7)"] pub type Teif4R = crate :: BitReader ;
#[doc = "Field `GIF5` reader - Channel x global interrupt flag (x = 1 ..7)"] pub type Gif5R = crate :: BitReader ;
#[doc = "Field `TCIF5` reader - Channel x transfer complete flag (x = 1 ..7)"] pub type Tcif5R = crate :: BitReader ;
#[doc = "Field `HTIF5` reader - Channel x half transfer flag (x = 1 ..7)"] pub type Htif5R = crate :: BitReader ;
#[doc = "Field `TEIF5` reader - Channel x transfer error flag (x = 1 ..7)"] pub type Teif5R = crate :: BitReader ;
#[doc = "Field `GIF6` reader - Channel x global interrupt flag (x = 1 ..7)"] pub type Gif6R = crate :: BitReader ;
#[doc = "Field `TCIF6` reader - Channel x transfer complete flag (x = 1 ..7)"] pub type Tcif6R = crate :: BitReader ;
#[doc = "Field `HTIF6` reader - Channel x half transfer flag (x = 1 ..7)"] pub type Htif6R = crate :: BitReader ;
#[doc = "Field `TEIF6` reader - Channel x transfer error flag (x = 1 ..7)"] pub type Teif6R = crate :: BitReader ;
#[doc = "Field `GIF7` reader - Channel x global interrupt flag (x = 1 ..7)"] pub type Gif7R = crate :: BitReader ;
#[doc = "Field `TCIF7` reader - Channel x transfer complete flag (x = 1 ..7)"] pub type Tcif7R = crate :: BitReader ;
#[doc = "Field `HTIF7` reader - Channel x half transfer flag (x = 1 ..7)"] pub type Htif7R = crate :: BitReader ;
#[doc = "Field `TEIF7` reader - Channel x transfer error flag (x = 1 ..7)"] pub type Teif7R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Channel x global interrupt flag (x = 1 ..7)"]
#[inline (always)] pub fn gif1 (& self) -> Gif1R { Gif1R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Channel x transfer complete flag (x = 1 ..7)"]
#[inline (always)] pub fn tcif1 (& self) -> Tcif1R { Tcif1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Channel x half transfer flag (x = 1 ..7)"]
#[inline (always)] pub fn htif1 (& self) -> Htif1R { Htif1R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Channel x transfer error flag (x = 1 ..7)"]
#[inline (always)] pub fn teif1 (& self) -> Teif1R { Teif1R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Channel x global interrupt flag (x = 1 ..7)"]
#[inline (always)] pub fn gif2 (& self) -> Gif2R { Gif2R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Channel x transfer complete flag (x = 1 ..7)"]
#[inline (always)] pub fn tcif2 (& self) -> Tcif2R { Tcif2R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Channel x half transfer flag (x = 1 ..7)"]
#[inline (always)] pub fn htif2 (& self) -> Htif2R { Htif2R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Channel x transfer error flag (x = 1 ..7)"]
#[inline (always)] pub fn teif2 (& self) -> Teif2R { Teif2R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Channel x global interrupt flag (x = 1 ..7)"]
#[inline (always)] pub fn gif3 (& self) -> Gif3R { Gif3R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Channel x transfer complete flag (x = 1 ..7)"]
#[inline (always)] pub fn tcif3 (& self) -> Tcif3R { Tcif3R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Channel x half transfer flag (x = 1 ..7)"]
#[inline (always)] pub fn htif3 (& self) -> Htif3R { Htif3R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Channel x transfer error flag (x = 1 ..7)"]
#[inline (always)] pub fn teif3 (& self) -> Teif3R { Teif3R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Channel x global interrupt flag (x = 1 ..7)"]
#[inline (always)] pub fn gif4 (& self) -> Gif4R { Gif4R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Channel x transfer complete flag (x = 1 ..7)"]
#[inline (always)] pub fn tcif4 (& self) -> Tcif4R { Tcif4R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Channel x half transfer flag (x = 1 ..7)"]
#[inline (always)] pub fn htif4 (& self) -> Htif4R { Htif4R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Channel x transfer error flag (x = 1 ..7)"]
#[inline (always)] pub fn teif4 (& self) -> Teif4R { Teif4R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Channel x global interrupt flag (x = 1 ..7)"]
#[inline (always)] pub fn gif5 (& self) -> Gif5R { Gif5R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Channel x transfer complete flag (x = 1 ..7)"]
#[inline (always)] pub fn tcif5 (& self) -> Tcif5R { Tcif5R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Channel x half transfer flag (x = 1 ..7)"]
#[inline (always)] pub fn htif5 (& self) -> Htif5R { Htif5R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Channel x transfer error flag (x = 1 ..7)"]
#[inline (always)] pub fn teif5 (& self) -> Teif5R { Teif5R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Channel x global interrupt flag (x = 1 ..7)"]
#[inline (always)] pub fn gif6 (& self) -> Gif6R { Gif6R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Channel x transfer complete flag (x = 1 ..7)"]
#[inline (always)] pub fn tcif6 (& self) -> Tcif6R { Tcif6R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Channel x half transfer flag (x = 1 ..7)"]
#[inline (always)] pub fn htif6 (& self) -> Htif6R { Htif6R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Channel x transfer error flag (x = 1 ..7)"]
#[inline (always)] pub fn teif6 (& self) -> Teif6R { Teif6R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Channel x global interrupt flag (x = 1 ..7)"]
#[inline (always)] pub fn gif7 (& self) -> Gif7R { Gif7R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Channel x transfer complete flag (x = 1 ..7)"]
#[inline (always)] pub fn tcif7 (& self) -> Tcif7R { Tcif7R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Channel x half transfer flag (x = 1 ..7)"]
#[inline (always)] pub fn htif7 (& self) -> Htif7R { Htif7R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Channel x transfer error flag (x = 1 ..7)"]
#[inline (always)] pub fn teif7 (& self) -> Teif7R { Teif7R :: new (((self . bits >> 27) & 1) != 0) } }
#[doc = "interrupt status register\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IsrSpec ; impl crate :: RegisterSpec for IsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`isr::R`](R) reader structure"] impl crate :: Readable for IsrSpec { }
#[doc = "`reset()` method sets ISR to value 0"] impl crate :: Resettable for IsrSpec { } }
#[doc = "IFCR (w) register accessor: interrupt flag clear register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ifcr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ifcr`] module"]
#[doc (alias = "IFCR")] pub type Ifcr = crate :: Reg < ifcr :: IfcrSpec > ;
#[doc = "interrupt flag clear register"] pub mod ifcr {
#[doc = "Register `IFCR` writer"] pub type W = crate :: W < IfcrSpec > ;
#[doc = "Field `CGIF1` writer - Channel x global interrupt clear (x = 1 ..7)"] pub type Cgif1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCIF1` writer - Channel x transfer complete clear (x = 1 ..7)"] pub type Ctcif1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTIF1` writer - Channel x half transfer clear (x = 1 ..7)"] pub type Chtif1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTEIF1` writer - Channel x transfer error clear (x = 1 ..7)"] pub type Cteif1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CGIF2` writer - Channel x global interrupt clear (x = 1 ..7)"] pub type Cgif2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCIF2` writer - Channel x transfer complete clear (x = 1 ..7)"] pub type Ctcif2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTIF2` writer - Channel x half transfer clear (x = 1 ..7)"] pub type Chtif2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTEIF2` writer - Channel x transfer error clear (x = 1 ..7)"] pub type Cteif2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CGIF3` writer - Channel x global interrupt clear (x = 1 ..7)"] pub type Cgif3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCIF3` writer - Channel x transfer complete clear (x = 1 ..7)"] pub type Ctcif3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTIF3` writer - Channel x half transfer clear (x = 1 ..7)"] pub type Chtif3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTEIF3` writer - Channel x transfer error clear (x = 1 ..7)"] pub type Cteif3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CGIF4` writer - Channel x global interrupt clear (x = 1 ..7)"] pub type Cgif4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCIF4` writer - Channel x transfer complete clear (x = 1 ..7)"] pub type Ctcif4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTIF4` writer - Channel x half transfer clear (x = 1 ..7)"] pub type Chtif4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTEIF4` writer - Channel x transfer error clear (x = 1 ..7)"] pub type Cteif4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CGIF5` writer - Channel x global interrupt clear (x = 1 ..7)"] pub type Cgif5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCIF5` writer - Channel x transfer complete clear (x = 1 ..7)"] pub type Ctcif5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTIF5` writer - Channel x half transfer clear (x = 1 ..7)"] pub type Chtif5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTEIF5` writer - Channel x transfer error clear (x = 1 ..7)"] pub type Cteif5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CGIF6` writer - Channel x global interrupt clear (x = 1 ..7)"] pub type Cgif6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCIF6` writer - Channel x transfer complete clear (x = 1 ..7)"] pub type Ctcif6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTIF6` writer - Channel x half transfer clear (x = 1 ..7)"] pub type Chtif6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTEIF6` writer - Channel x transfer error clear (x = 1 ..7)"] pub type Cteif6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CGIF7` writer - Channel x global interrupt clear (x = 1 ..7)"] pub type Cgif7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCIF7` writer - Channel x transfer complete clear (x = 1 ..7)"] pub type Ctcif7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTIF7` writer - Channel x half transfer clear (x = 1 ..7)"] pub type Chtif7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTEIF7` writer - Channel x transfer error clear (x = 1 ..7)"] pub type Cteif7W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Channel x global interrupt clear (x = 1 ..7)"]
#[inline (always)] pub fn cgif1 (& mut self) -> Cgif1W < '_ , IfcrSpec > { Cgif1W :: new (self , 0) }
#[doc = "Bit 1 - Channel x transfer complete clear (x = 1 ..7)"]
#[inline (always)] pub fn ctcif1 (& mut self) -> Ctcif1W < '_ , IfcrSpec > { Ctcif1W :: new (self , 1) }
#[doc = "Bit 2 - Channel x half transfer clear (x = 1 ..7)"]
#[inline (always)] pub fn chtif1 (& mut self) -> Chtif1W < '_ , IfcrSpec > { Chtif1W :: new (self , 2) }
#[doc = "Bit 3 - Channel x transfer error clear (x = 1 ..7)"]
#[inline (always)] pub fn cteif1 (& mut self) -> Cteif1W < '_ , IfcrSpec > { Cteif1W :: new (self , 3) }
#[doc = "Bit 4 - Channel x global interrupt clear (x = 1 ..7)"]
#[inline (always)] pub fn cgif2 (& mut self) -> Cgif2W < '_ , IfcrSpec > { Cgif2W :: new (self , 4) }
#[doc = "Bit 5 - Channel x transfer complete clear (x = 1 ..7)"]
#[inline (always)] pub fn ctcif2 (& mut self) -> Ctcif2W < '_ , IfcrSpec > { Ctcif2W :: new (self , 5) }
#[doc = "Bit 6 - Channel x half transfer clear (x = 1 ..7)"]
#[inline (always)] pub fn chtif2 (& mut self) -> Chtif2W < '_ , IfcrSpec > { Chtif2W :: new (self , 6) }
#[doc = "Bit 7 - Channel x transfer error clear (x = 1 ..7)"]
#[inline (always)] pub fn cteif2 (& mut self) -> Cteif2W < '_ , IfcrSpec > { Cteif2W :: new (self , 7) }
#[doc = "Bit 8 - Channel x global interrupt clear (x = 1 ..7)"]
#[inline (always)] pub fn cgif3 (& mut self) -> Cgif3W < '_ , IfcrSpec > { Cgif3W :: new (self , 8) }
#[doc = "Bit 9 - Channel x transfer complete clear (x = 1 ..7)"]
#[inline (always)] pub fn ctcif3 (& mut self) -> Ctcif3W < '_ , IfcrSpec > { Ctcif3W :: new (self , 9) }
#[doc = "Bit 10 - Channel x half transfer clear (x = 1 ..7)"]
#[inline (always)] pub fn chtif3 (& mut self) -> Chtif3W < '_ , IfcrSpec > { Chtif3W :: new (self , 10) }
#[doc = "Bit 11 - Channel x transfer error clear (x = 1 ..7)"]
#[inline (always)] pub fn cteif3 (& mut self) -> Cteif3W < '_ , IfcrSpec > { Cteif3W :: new (self , 11) }
#[doc = "Bit 12 - Channel x global interrupt clear (x = 1 ..7)"]
#[inline (always)] pub fn cgif4 (& mut self) -> Cgif4W < '_ , IfcrSpec > { Cgif4W :: new (self , 12) }
#[doc = "Bit 13 - Channel x transfer complete clear (x = 1 ..7)"]
#[inline (always)] pub fn ctcif4 (& mut self) -> Ctcif4W < '_ , IfcrSpec > { Ctcif4W :: new (self , 13) }
#[doc = "Bit 14 - Channel x half transfer clear (x = 1 ..7)"]
#[inline (always)] pub fn chtif4 (& mut self) -> Chtif4W < '_ , IfcrSpec > { Chtif4W :: new (self , 14) }
#[doc = "Bit 15 - Channel x transfer error clear (x = 1 ..7)"]
#[inline (always)] pub fn cteif4 (& mut self) -> Cteif4W < '_ , IfcrSpec > { Cteif4W :: new (self , 15) }
#[doc = "Bit 16 - Channel x global interrupt clear (x = 1 ..7)"]
#[inline (always)] pub fn cgif5 (& mut self) -> Cgif5W < '_ , IfcrSpec > { Cgif5W :: new (self , 16) }
#[doc = "Bit 17 - Channel x transfer complete clear (x = 1 ..7)"]
#[inline (always)] pub fn ctcif5 (& mut self) -> Ctcif5W < '_ , IfcrSpec > { Ctcif5W :: new (self , 17) }
#[doc = "Bit 18 - Channel x half transfer clear (x = 1 ..7)"]
#[inline (always)] pub fn chtif5 (& mut self) -> Chtif5W < '_ , IfcrSpec > { Chtif5W :: new (self , 18) }
#[doc = "Bit 19 - Channel x transfer error clear (x = 1 ..7)"]
#[inline (always)] pub fn cteif5 (& mut self) -> Cteif5W < '_ , IfcrSpec > { Cteif5W :: new (self , 19) }
#[doc = "Bit 20 - Channel x global interrupt clear (x = 1 ..7)"]
#[inline (always)] pub fn cgif6 (& mut self) -> Cgif6W < '_ , IfcrSpec > { Cgif6W :: new (self , 20) }
#[doc = "Bit 21 - Channel x transfer complete clear (x = 1 ..7)"]
#[inline (always)] pub fn ctcif6 (& mut self) -> Ctcif6W < '_ , IfcrSpec > { Ctcif6W :: new (self , 21) }
#[doc = "Bit 22 - Channel x half transfer clear (x = 1 ..7)"]
#[inline (always)] pub fn chtif6 (& mut self) -> Chtif6W < '_ , IfcrSpec > { Chtif6W :: new (self , 22) }
#[doc = "Bit 23 - Channel x transfer error clear (x = 1 ..7)"]
#[inline (always)] pub fn cteif6 (& mut self) -> Cteif6W < '_ , IfcrSpec > { Cteif6W :: new (self , 23) }
#[doc = "Bit 24 - Channel x global interrupt clear (x = 1 ..7)"]
#[inline (always)] pub fn cgif7 (& mut self) -> Cgif7W < '_ , IfcrSpec > { Cgif7W :: new (self , 24) }
#[doc = "Bit 25 - Channel x transfer complete clear (x = 1 ..7)"]
#[inline (always)] pub fn ctcif7 (& mut self) -> Ctcif7W < '_ , IfcrSpec > { Ctcif7W :: new (self , 25) }
#[doc = "Bit 26 - Channel x half transfer clear (x = 1 ..7)"]
#[inline (always)] pub fn chtif7 (& mut self) -> Chtif7W < '_ , IfcrSpec > { Chtif7W :: new (self , 26) }
#[doc = "Bit 27 - Channel x transfer error clear (x = 1 ..7)"]
#[inline (always)] pub fn cteif7 (& mut self) -> Cteif7W < '_ , IfcrSpec > { Cteif7W :: new (self , 27) } }
#[doc = "interrupt flag clear register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ifcr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IfcrSpec ; impl crate :: RegisterSpec for IfcrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`ifcr::W`](W) writer structure"] impl crate :: Writable for IfcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IFCR to value 0"] impl crate :: Resettable for IfcrSpec { } }
#[doc = "CCR1 (rw) register accessor: channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr1`] module"]
#[doc (alias = "CCR1")] pub type Ccr1 = crate :: Reg < ccr1 :: Ccr1Spec > ;
#[doc = "channel x configuration register"] pub mod ccr1 {
#[doc = "Register `CCR1` reader"] pub type R = crate :: R < Ccr1Spec > ;
#[doc = "Register `CCR1` writer"] pub type W = crate :: W < Ccr1Spec > ;
#[doc = "Field `EN` reader - Channel enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Channel enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HTIE` reader - Half transfer interrupt enable"] pub type HtieR = crate :: BitReader ;
#[doc = "Field `HTIE` writer - Half transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader ;
#[doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader ;
#[doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MINC` reader - Memory increment mode"] pub type MincR = crate :: BitReader ;
#[doc = "Field `MINC` writer - Memory increment mode"] pub type MincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSIZE` reader - Peripheral size"] pub type PsizeR = crate :: FieldReader ;
#[doc = "Field `PSIZE` writer - Peripheral size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MSIZE` reader - Memory size"] pub type MsizeR = crate :: FieldReader ;
#[doc = "Field `MSIZE` writer - Memory size"] pub type MsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PL` reader - Channel priority level"] pub type PlR = crate :: FieldReader ;
#[doc = "Field `PL` writer - Channel priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MEM2MEM` reader - Memory to memory mode"] pub type Mem2memR = crate :: BitReader ;
#[doc = "Field `MEM2MEM` writer - Memory to memory mode"] pub type Mem2memW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& self) -> Mem2memR { Mem2memR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Ccr1Spec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Ccr1Spec > { TcieW :: new (self , 1) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& mut self) -> HtieW < '_ , Ccr1Spec > { HtieW :: new (self , 2) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , Ccr1Spec > { TeieW :: new (self , 3) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Ccr1Spec > { DirW :: new (self , 4) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& mut self) -> CircW < '_ , Ccr1Spec > { CircW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& mut self) -> PincW < '_ , Ccr1Spec > { PincW :: new (self , 6) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& mut self) -> MincW < '_ , Ccr1Spec > { MincW :: new (self , 7) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& mut self) -> PsizeW < '_ , Ccr1Spec > { PsizeW :: new (self , 8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& mut self) -> MsizeW < '_ , Ccr1Spec > { MsizeW :: new (self , 10) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& mut self) -> PlW < '_ , Ccr1Spec > { PlW :: new (self , 12) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& mut self) -> Mem2memW < '_ , Ccr1Spec > { Mem2memW :: new (self , 14) } }
#[doc = "channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr1Spec ; impl crate :: RegisterSpec for Ccr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr1::R`](R) reader structure"] impl crate :: Readable for Ccr1Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr1::W`](W) writer structure"] impl crate :: Writable for Ccr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR1 to value 0"] impl crate :: Resettable for Ccr1Spec { } }
#[doc = "CNDTR1 (rw) register accessor: channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cndtr1`] module"]
#[doc (alias = "CNDTR1")] pub type Cndtr1 = crate :: Reg < cndtr1 :: Cndtr1Spec > ;
#[doc = "channel x number of data register"] pub mod cndtr1 {
#[doc = "Register `CNDTR1` reader"] pub type R = crate :: R < Cndtr1Spec > ;
#[doc = "Register `CNDTR1` writer"] pub type W = crate :: W < Cndtr1Spec > ;
#[doc = "Field `NDT` reader - Number of data to transfer"] pub type NdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `NDT` writer - Number of data to transfer"] pub type NdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& self) -> NdtR { NdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& mut self) -> NdtW < '_ , Cndtr1Spec > { NdtW :: new (self , 0) } }
#[doc = "channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cndtr1Spec ; impl crate :: RegisterSpec for Cndtr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cndtr1::R`](R) reader structure"] impl crate :: Readable for Cndtr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cndtr1::W`](W) writer structure"] impl crate :: Writable for Cndtr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNDTR1 to value 0"] impl crate :: Resettable for Cndtr1Spec { } }
#[doc = "CPAR1 (rw) register accessor: channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpar1`] module"]
#[doc (alias = "CPAR1")] pub type Cpar1 = crate :: Reg < cpar1 :: Cpar1Spec > ;
#[doc = "channel x peripheral address register"] pub mod cpar1 {
#[doc = "Register `CPAR1` reader"] pub type R = crate :: R < Cpar1Spec > ;
#[doc = "Register `CPAR1` writer"] pub type W = crate :: W < Cpar1Spec > ;
#[doc = "Field `PA` reader - Peripheral address"] pub type PaR = crate :: FieldReader < u32 > ;
#[doc = "Field `PA` writer - Peripheral address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , Cpar1Spec > { PaW :: new (self , 0) } }
#[doc = "channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cpar1Spec ; impl crate :: RegisterSpec for Cpar1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cpar1::R`](R) reader structure"] impl crate :: Readable for Cpar1Spec { }
#[doc = "`write(|w| ..)` method takes [`cpar1::W`](W) writer structure"] impl crate :: Writable for Cpar1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CPAR1 to value 0"] impl crate :: Resettable for Cpar1Spec { } }
#[doc = "CMAR1 (rw) register accessor: channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmar1`] module"]
#[doc (alias = "CMAR1")] pub type Cmar1 = crate :: Reg < cmar1 :: Cmar1Spec > ;
#[doc = "channel x memory address register"] pub mod cmar1 {
#[doc = "Register `CMAR1` reader"] pub type R = crate :: R < Cmar1Spec > ;
#[doc = "Register `CMAR1` writer"] pub type W = crate :: W < Cmar1Spec > ;
#[doc = "Field `MA` reader - Memory address"] pub type MaR = crate :: FieldReader < u32 > ;
#[doc = "Field `MA` writer - Memory address"] pub type MaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& self) -> MaR { MaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& mut self) -> MaW < '_ , Cmar1Spec > { MaW :: new (self , 0) } }
#[doc = "channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cmar1Spec ; impl crate :: RegisterSpec for Cmar1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmar1::R`](R) reader structure"] impl crate :: Readable for Cmar1Spec { }
#[doc = "`write(|w| ..)` method takes [`cmar1::W`](W) writer structure"] impl crate :: Writable for Cmar1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMAR1 to value 0"] impl crate :: Resettable for Cmar1Spec { } }
#[doc = "CCR2 (rw) register accessor: channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr2`] module"]
#[doc (alias = "CCR2")] pub type Ccr2 = crate :: Reg < ccr2 :: Ccr2Spec > ;
#[doc = "channel x configuration register"] pub mod ccr2 {
#[doc = "Register `CCR2` reader"] pub type R = crate :: R < Ccr2Spec > ;
#[doc = "Register `CCR2` writer"] pub type W = crate :: W < Ccr2Spec > ;
#[doc = "Field `EN` reader - Channel enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Channel enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HTIE` reader - Half transfer interrupt enable"] pub type HtieR = crate :: BitReader ;
#[doc = "Field `HTIE` writer - Half transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader ;
#[doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader ;
#[doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MINC` reader - Memory increment mode"] pub type MincR = crate :: BitReader ;
#[doc = "Field `MINC` writer - Memory increment mode"] pub type MincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSIZE` reader - Peripheral size"] pub type PsizeR = crate :: FieldReader ;
#[doc = "Field `PSIZE` writer - Peripheral size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MSIZE` reader - Memory size"] pub type MsizeR = crate :: FieldReader ;
#[doc = "Field `MSIZE` writer - Memory size"] pub type MsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PL` reader - Channel priority level"] pub type PlR = crate :: FieldReader ;
#[doc = "Field `PL` writer - Channel priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MEM2MEM` reader - Memory to memory mode"] pub type Mem2memR = crate :: BitReader ;
#[doc = "Field `MEM2MEM` writer - Memory to memory mode"] pub type Mem2memW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& self) -> Mem2memR { Mem2memR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Ccr2Spec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Ccr2Spec > { TcieW :: new (self , 1) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& mut self) -> HtieW < '_ , Ccr2Spec > { HtieW :: new (self , 2) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , Ccr2Spec > { TeieW :: new (self , 3) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Ccr2Spec > { DirW :: new (self , 4) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& mut self) -> CircW < '_ , Ccr2Spec > { CircW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& mut self) -> PincW < '_ , Ccr2Spec > { PincW :: new (self , 6) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& mut self) -> MincW < '_ , Ccr2Spec > { MincW :: new (self , 7) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& mut self) -> PsizeW < '_ , Ccr2Spec > { PsizeW :: new (self , 8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& mut self) -> MsizeW < '_ , Ccr2Spec > { MsizeW :: new (self , 10) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& mut self) -> PlW < '_ , Ccr2Spec > { PlW :: new (self , 12) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& mut self) -> Mem2memW < '_ , Ccr2Spec > { Mem2memW :: new (self , 14) } }
#[doc = "channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr2Spec ; impl crate :: RegisterSpec for Ccr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr2::R`](R) reader structure"] impl crate :: Readable for Ccr2Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr2::W`](W) writer structure"] impl crate :: Writable for Ccr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR2 to value 0"] impl crate :: Resettable for Ccr2Spec { } }
#[doc = "CNDTR2 (rw) register accessor: channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cndtr2`] module"]
#[doc (alias = "CNDTR2")] pub type Cndtr2 = crate :: Reg < cndtr2 :: Cndtr2Spec > ;
#[doc = "channel x number of data register"] pub mod cndtr2 {
#[doc = "Register `CNDTR2` reader"] pub type R = crate :: R < Cndtr2Spec > ;
#[doc = "Register `CNDTR2` writer"] pub type W = crate :: W < Cndtr2Spec > ;
#[doc = "Field `NDT` reader - Number of data to transfer"] pub type NdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `NDT` writer - Number of data to transfer"] pub type NdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& self) -> NdtR { NdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& mut self) -> NdtW < '_ , Cndtr2Spec > { NdtW :: new (self , 0) } }
#[doc = "channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cndtr2Spec ; impl crate :: RegisterSpec for Cndtr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cndtr2::R`](R) reader structure"] impl crate :: Readable for Cndtr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cndtr2::W`](W) writer structure"] impl crate :: Writable for Cndtr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNDTR2 to value 0"] impl crate :: Resettable for Cndtr2Spec { } }
#[doc = "CPAR2 (rw) register accessor: channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpar2`] module"]
#[doc (alias = "CPAR2")] pub type Cpar2 = crate :: Reg < cpar2 :: Cpar2Spec > ;
#[doc = "channel x peripheral address register"] pub mod cpar2 {
#[doc = "Register `CPAR2` reader"] pub type R = crate :: R < Cpar2Spec > ;
#[doc = "Register `CPAR2` writer"] pub type W = crate :: W < Cpar2Spec > ;
#[doc = "Field `PA` reader - Peripheral address"] pub type PaR = crate :: FieldReader < u32 > ;
#[doc = "Field `PA` writer - Peripheral address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , Cpar2Spec > { PaW :: new (self , 0) } }
#[doc = "channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cpar2Spec ; impl crate :: RegisterSpec for Cpar2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cpar2::R`](R) reader structure"] impl crate :: Readable for Cpar2Spec { }
#[doc = "`write(|w| ..)` method takes [`cpar2::W`](W) writer structure"] impl crate :: Writable for Cpar2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CPAR2 to value 0"] impl crate :: Resettable for Cpar2Spec { } }
#[doc = "CMAR2 (rw) register accessor: channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmar2`] module"]
#[doc (alias = "CMAR2")] pub type Cmar2 = crate :: Reg < cmar2 :: Cmar2Spec > ;
#[doc = "channel x memory address register"] pub mod cmar2 {
#[doc = "Register `CMAR2` reader"] pub type R = crate :: R < Cmar2Spec > ;
#[doc = "Register `CMAR2` writer"] pub type W = crate :: W < Cmar2Spec > ;
#[doc = "Field `MA` reader - Memory address"] pub type MaR = crate :: FieldReader < u32 > ;
#[doc = "Field `MA` writer - Memory address"] pub type MaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& self) -> MaR { MaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& mut self) -> MaW < '_ , Cmar2Spec > { MaW :: new (self , 0) } }
#[doc = "channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cmar2Spec ; impl crate :: RegisterSpec for Cmar2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmar2::R`](R) reader structure"] impl crate :: Readable for Cmar2Spec { }
#[doc = "`write(|w| ..)` method takes [`cmar2::W`](W) writer structure"] impl crate :: Writable for Cmar2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMAR2 to value 0"] impl crate :: Resettable for Cmar2Spec { } }
#[doc = "CCR3 (rw) register accessor: channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr3`] module"]
#[doc (alias = "CCR3")] pub type Ccr3 = crate :: Reg < ccr3 :: Ccr3Spec > ;
#[doc = "channel x configuration register"] pub mod ccr3 {
#[doc = "Register `CCR3` reader"] pub type R = crate :: R < Ccr3Spec > ;
#[doc = "Register `CCR3` writer"] pub type W = crate :: W < Ccr3Spec > ;
#[doc = "Field `EN` reader - Channel enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Channel enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HTIE` reader - Half transfer interrupt enable"] pub type HtieR = crate :: BitReader ;
#[doc = "Field `HTIE` writer - Half transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader ;
#[doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader ;
#[doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MINC` reader - Memory increment mode"] pub type MincR = crate :: BitReader ;
#[doc = "Field `MINC` writer - Memory increment mode"] pub type MincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSIZE` reader - Peripheral size"] pub type PsizeR = crate :: FieldReader ;
#[doc = "Field `PSIZE` writer - Peripheral size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MSIZE` reader - Memory size"] pub type MsizeR = crate :: FieldReader ;
#[doc = "Field `MSIZE` writer - Memory size"] pub type MsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PL` reader - Channel priority level"] pub type PlR = crate :: FieldReader ;
#[doc = "Field `PL` writer - Channel priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MEM2MEM` reader - Memory to memory mode"] pub type Mem2memR = crate :: BitReader ;
#[doc = "Field `MEM2MEM` writer - Memory to memory mode"] pub type Mem2memW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& self) -> Mem2memR { Mem2memR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Ccr3Spec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Ccr3Spec > { TcieW :: new (self , 1) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& mut self) -> HtieW < '_ , Ccr3Spec > { HtieW :: new (self , 2) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , Ccr3Spec > { TeieW :: new (self , 3) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Ccr3Spec > { DirW :: new (self , 4) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& mut self) -> CircW < '_ , Ccr3Spec > { CircW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& mut self) -> PincW < '_ , Ccr3Spec > { PincW :: new (self , 6) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& mut self) -> MincW < '_ , Ccr3Spec > { MincW :: new (self , 7) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& mut self) -> PsizeW < '_ , Ccr3Spec > { PsizeW :: new (self , 8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& mut self) -> MsizeW < '_ , Ccr3Spec > { MsizeW :: new (self , 10) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& mut self) -> PlW < '_ , Ccr3Spec > { PlW :: new (self , 12) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& mut self) -> Mem2memW < '_ , Ccr3Spec > { Mem2memW :: new (self , 14) } }
#[doc = "channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr3Spec ; impl crate :: RegisterSpec for Ccr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr3::R`](R) reader structure"] impl crate :: Readable for Ccr3Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr3::W`](W) writer structure"] impl crate :: Writable for Ccr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR3 to value 0"] impl crate :: Resettable for Ccr3Spec { } }
#[doc = "CNDTR3 (rw) register accessor: channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cndtr3`] module"]
#[doc (alias = "CNDTR3")] pub type Cndtr3 = crate :: Reg < cndtr3 :: Cndtr3Spec > ;
#[doc = "channel x number of data register"] pub mod cndtr3 {
#[doc = "Register `CNDTR3` reader"] pub type R = crate :: R < Cndtr3Spec > ;
#[doc = "Register `CNDTR3` writer"] pub type W = crate :: W < Cndtr3Spec > ;
#[doc = "Field `NDT` reader - Number of data to transfer"] pub type NdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `NDT` writer - Number of data to transfer"] pub type NdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& self) -> NdtR { NdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& mut self) -> NdtW < '_ , Cndtr3Spec > { NdtW :: new (self , 0) } }
#[doc = "channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cndtr3Spec ; impl crate :: RegisterSpec for Cndtr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cndtr3::R`](R) reader structure"] impl crate :: Readable for Cndtr3Spec { }
#[doc = "`write(|w| ..)` method takes [`cndtr3::W`](W) writer structure"] impl crate :: Writable for Cndtr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNDTR3 to value 0"] impl crate :: Resettable for Cndtr3Spec { } }
#[doc = "CPAR3 (rw) register accessor: channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpar3`] module"]
#[doc (alias = "CPAR3")] pub type Cpar3 = crate :: Reg < cpar3 :: Cpar3Spec > ;
#[doc = "channel x peripheral address register"] pub mod cpar3 {
#[doc = "Register `CPAR3` reader"] pub type R = crate :: R < Cpar3Spec > ;
#[doc = "Register `CPAR3` writer"] pub type W = crate :: W < Cpar3Spec > ;
#[doc = "Field `PA` reader - Peripheral address"] pub type PaR = crate :: FieldReader < u32 > ;
#[doc = "Field `PA` writer - Peripheral address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , Cpar3Spec > { PaW :: new (self , 0) } }
#[doc = "channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cpar3Spec ; impl crate :: RegisterSpec for Cpar3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cpar3::R`](R) reader structure"] impl crate :: Readable for Cpar3Spec { }
#[doc = "`write(|w| ..)` method takes [`cpar3::W`](W) writer structure"] impl crate :: Writable for Cpar3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CPAR3 to value 0"] impl crate :: Resettable for Cpar3Spec { } }
#[doc = "CMAR3 (rw) register accessor: channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmar3`] module"]
#[doc (alias = "CMAR3")] pub type Cmar3 = crate :: Reg < cmar3 :: Cmar3Spec > ;
#[doc = "channel x memory address register"] pub mod cmar3 {
#[doc = "Register `CMAR3` reader"] pub type R = crate :: R < Cmar3Spec > ;
#[doc = "Register `CMAR3` writer"] pub type W = crate :: W < Cmar3Spec > ;
#[doc = "Field `MA` reader - Memory address"] pub type MaR = crate :: FieldReader < u32 > ;
#[doc = "Field `MA` writer - Memory address"] pub type MaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& self) -> MaR { MaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& mut self) -> MaW < '_ , Cmar3Spec > { MaW :: new (self , 0) } }
#[doc = "channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cmar3Spec ; impl crate :: RegisterSpec for Cmar3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmar3::R`](R) reader structure"] impl crate :: Readable for Cmar3Spec { }
#[doc = "`write(|w| ..)` method takes [`cmar3::W`](W) writer structure"] impl crate :: Writable for Cmar3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMAR3 to value 0"] impl crate :: Resettable for Cmar3Spec { } }
#[doc = "CCR4 (rw) register accessor: channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr4`] module"]
#[doc (alias = "CCR4")] pub type Ccr4 = crate :: Reg < ccr4 :: Ccr4Spec > ;
#[doc = "channel x configuration register"] pub mod ccr4 {
#[doc = "Register `CCR4` reader"] pub type R = crate :: R < Ccr4Spec > ;
#[doc = "Register `CCR4` writer"] pub type W = crate :: W < Ccr4Spec > ;
#[doc = "Field `EN` reader - Channel enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Channel enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HTIE` reader - Half transfer interrupt enable"] pub type HtieR = crate :: BitReader ;
#[doc = "Field `HTIE` writer - Half transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader ;
#[doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader ;
#[doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MINC` reader - Memory increment mode"] pub type MincR = crate :: BitReader ;
#[doc = "Field `MINC` writer - Memory increment mode"] pub type MincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSIZE` reader - Peripheral size"] pub type PsizeR = crate :: FieldReader ;
#[doc = "Field `PSIZE` writer - Peripheral size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MSIZE` reader - Memory size"] pub type MsizeR = crate :: FieldReader ;
#[doc = "Field `MSIZE` writer - Memory size"] pub type MsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PL` reader - Channel priority level"] pub type PlR = crate :: FieldReader ;
#[doc = "Field `PL` writer - Channel priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MEM2MEM` reader - Memory to memory mode"] pub type Mem2memR = crate :: BitReader ;
#[doc = "Field `MEM2MEM` writer - Memory to memory mode"] pub type Mem2memW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& self) -> Mem2memR { Mem2memR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Ccr4Spec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Ccr4Spec > { TcieW :: new (self , 1) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& mut self) -> HtieW < '_ , Ccr4Spec > { HtieW :: new (self , 2) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , Ccr4Spec > { TeieW :: new (self , 3) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Ccr4Spec > { DirW :: new (self , 4) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& mut self) -> CircW < '_ , Ccr4Spec > { CircW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& mut self) -> PincW < '_ , Ccr4Spec > { PincW :: new (self , 6) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& mut self) -> MincW < '_ , Ccr4Spec > { MincW :: new (self , 7) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& mut self) -> PsizeW < '_ , Ccr4Spec > { PsizeW :: new (self , 8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& mut self) -> MsizeW < '_ , Ccr4Spec > { MsizeW :: new (self , 10) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& mut self) -> PlW < '_ , Ccr4Spec > { PlW :: new (self , 12) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& mut self) -> Mem2memW < '_ , Ccr4Spec > { Mem2memW :: new (self , 14) } }
#[doc = "channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr4Spec ; impl crate :: RegisterSpec for Ccr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr4::R`](R) reader structure"] impl crate :: Readable for Ccr4Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr4::W`](W) writer structure"] impl crate :: Writable for Ccr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR4 to value 0"] impl crate :: Resettable for Ccr4Spec { } }
#[doc = "CNDTR4 (rw) register accessor: channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cndtr4`] module"]
#[doc (alias = "CNDTR4")] pub type Cndtr4 = crate :: Reg < cndtr4 :: Cndtr4Spec > ;
#[doc = "channel x number of data register"] pub mod cndtr4 {
#[doc = "Register `CNDTR4` reader"] pub type R = crate :: R < Cndtr4Spec > ;
#[doc = "Register `CNDTR4` writer"] pub type W = crate :: W < Cndtr4Spec > ;
#[doc = "Field `NDT` reader - Number of data to transfer"] pub type NdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `NDT` writer - Number of data to transfer"] pub type NdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& self) -> NdtR { NdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& mut self) -> NdtW < '_ , Cndtr4Spec > { NdtW :: new (self , 0) } }
#[doc = "channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cndtr4Spec ; impl crate :: RegisterSpec for Cndtr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cndtr4::R`](R) reader structure"] impl crate :: Readable for Cndtr4Spec { }
#[doc = "`write(|w| ..)` method takes [`cndtr4::W`](W) writer structure"] impl crate :: Writable for Cndtr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNDTR4 to value 0"] impl crate :: Resettable for Cndtr4Spec { } }
#[doc = "CPAR4 (rw) register accessor: channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpar4`] module"]
#[doc (alias = "CPAR4")] pub type Cpar4 = crate :: Reg < cpar4 :: Cpar4Spec > ;
#[doc = "channel x peripheral address register"] pub mod cpar4 {
#[doc = "Register `CPAR4` reader"] pub type R = crate :: R < Cpar4Spec > ;
#[doc = "Register `CPAR4` writer"] pub type W = crate :: W < Cpar4Spec > ;
#[doc = "Field `PA` reader - Peripheral address"] pub type PaR = crate :: FieldReader < u32 > ;
#[doc = "Field `PA` writer - Peripheral address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , Cpar4Spec > { PaW :: new (self , 0) } }
#[doc = "channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cpar4Spec ; impl crate :: RegisterSpec for Cpar4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cpar4::R`](R) reader structure"] impl crate :: Readable for Cpar4Spec { }
#[doc = "`write(|w| ..)` method takes [`cpar4::W`](W) writer structure"] impl crate :: Writable for Cpar4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CPAR4 to value 0"] impl crate :: Resettable for Cpar4Spec { } }
#[doc = "CMAR4 (rw) register accessor: channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmar4`] module"]
#[doc (alias = "CMAR4")] pub type Cmar4 = crate :: Reg < cmar4 :: Cmar4Spec > ;
#[doc = "channel x memory address register"] pub mod cmar4 {
#[doc = "Register `CMAR4` reader"] pub type R = crate :: R < Cmar4Spec > ;
#[doc = "Register `CMAR4` writer"] pub type W = crate :: W < Cmar4Spec > ;
#[doc = "Field `MA` reader - Memory address"] pub type MaR = crate :: FieldReader < u32 > ;
#[doc = "Field `MA` writer - Memory address"] pub type MaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& self) -> MaR { MaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& mut self) -> MaW < '_ , Cmar4Spec > { MaW :: new (self , 0) } }
#[doc = "channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cmar4Spec ; impl crate :: RegisterSpec for Cmar4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmar4::R`](R) reader structure"] impl crate :: Readable for Cmar4Spec { }
#[doc = "`write(|w| ..)` method takes [`cmar4::W`](W) writer structure"] impl crate :: Writable for Cmar4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMAR4 to value 0"] impl crate :: Resettable for Cmar4Spec { } }
#[doc = "CCR5 (rw) register accessor: channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr5`] module"]
#[doc (alias = "CCR5")] pub type Ccr5 = crate :: Reg < ccr5 :: Ccr5Spec > ;
#[doc = "channel x configuration register"] pub mod ccr5 {
#[doc = "Register `CCR5` reader"] pub type R = crate :: R < Ccr5Spec > ;
#[doc = "Register `CCR5` writer"] pub type W = crate :: W < Ccr5Spec > ;
#[doc = "Field `EN` reader - Channel enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Channel enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HTIE` reader - Half transfer interrupt enable"] pub type HtieR = crate :: BitReader ;
#[doc = "Field `HTIE` writer - Half transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader ;
#[doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader ;
#[doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MINC` reader - Memory increment mode"] pub type MincR = crate :: BitReader ;
#[doc = "Field `MINC` writer - Memory increment mode"] pub type MincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSIZE` reader - Peripheral size"] pub type PsizeR = crate :: FieldReader ;
#[doc = "Field `PSIZE` writer - Peripheral size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MSIZE` reader - Memory size"] pub type MsizeR = crate :: FieldReader ;
#[doc = "Field `MSIZE` writer - Memory size"] pub type MsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PL` reader - Channel priority level"] pub type PlR = crate :: FieldReader ;
#[doc = "Field `PL` writer - Channel priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MEM2MEM` reader - Memory to memory mode"] pub type Mem2memR = crate :: BitReader ;
#[doc = "Field `MEM2MEM` writer - Memory to memory mode"] pub type Mem2memW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& self) -> Mem2memR { Mem2memR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Ccr5Spec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Ccr5Spec > { TcieW :: new (self , 1) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& mut self) -> HtieW < '_ , Ccr5Spec > { HtieW :: new (self , 2) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , Ccr5Spec > { TeieW :: new (self , 3) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Ccr5Spec > { DirW :: new (self , 4) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& mut self) -> CircW < '_ , Ccr5Spec > { CircW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& mut self) -> PincW < '_ , Ccr5Spec > { PincW :: new (self , 6) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& mut self) -> MincW < '_ , Ccr5Spec > { MincW :: new (self , 7) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& mut self) -> PsizeW < '_ , Ccr5Spec > { PsizeW :: new (self , 8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& mut self) -> MsizeW < '_ , Ccr5Spec > { MsizeW :: new (self , 10) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& mut self) -> PlW < '_ , Ccr5Spec > { PlW :: new (self , 12) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& mut self) -> Mem2memW < '_ , Ccr5Spec > { Mem2memW :: new (self , 14) } }
#[doc = "channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr5Spec ; impl crate :: RegisterSpec for Ccr5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr5::R`](R) reader structure"] impl crate :: Readable for Ccr5Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr5::W`](W) writer structure"] impl crate :: Writable for Ccr5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR5 to value 0"] impl crate :: Resettable for Ccr5Spec { } }
#[doc = "CNDTR5 (rw) register accessor: channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cndtr5`] module"]
#[doc (alias = "CNDTR5")] pub type Cndtr5 = crate :: Reg < cndtr5 :: Cndtr5Spec > ;
#[doc = "channel x number of data register"] pub mod cndtr5 {
#[doc = "Register `CNDTR5` reader"] pub type R = crate :: R < Cndtr5Spec > ;
#[doc = "Register `CNDTR5` writer"] pub type W = crate :: W < Cndtr5Spec > ;
#[doc = "Field `NDT` reader - Number of data to transfer"] pub type NdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `NDT` writer - Number of data to transfer"] pub type NdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& self) -> NdtR { NdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& mut self) -> NdtW < '_ , Cndtr5Spec > { NdtW :: new (self , 0) } }
#[doc = "channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cndtr5Spec ; impl crate :: RegisterSpec for Cndtr5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cndtr5::R`](R) reader structure"] impl crate :: Readable for Cndtr5Spec { }
#[doc = "`write(|w| ..)` method takes [`cndtr5::W`](W) writer structure"] impl crate :: Writable for Cndtr5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNDTR5 to value 0"] impl crate :: Resettable for Cndtr5Spec { } }
#[doc = "CPAR5 (rw) register accessor: channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpar5`] module"]
#[doc (alias = "CPAR5")] pub type Cpar5 = crate :: Reg < cpar5 :: Cpar5Spec > ;
#[doc = "channel x peripheral address register"] pub mod cpar5 {
#[doc = "Register `CPAR5` reader"] pub type R = crate :: R < Cpar5Spec > ;
#[doc = "Register `CPAR5` writer"] pub type W = crate :: W < Cpar5Spec > ;
#[doc = "Field `PA` reader - Peripheral address"] pub type PaR = crate :: FieldReader < u32 > ;
#[doc = "Field `PA` writer - Peripheral address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , Cpar5Spec > { PaW :: new (self , 0) } }
#[doc = "channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cpar5Spec ; impl crate :: RegisterSpec for Cpar5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cpar5::R`](R) reader structure"] impl crate :: Readable for Cpar5Spec { }
#[doc = "`write(|w| ..)` method takes [`cpar5::W`](W) writer structure"] impl crate :: Writable for Cpar5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CPAR5 to value 0"] impl crate :: Resettable for Cpar5Spec { } }
#[doc = "CMAR5 (rw) register accessor: channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmar5`] module"]
#[doc (alias = "CMAR5")] pub type Cmar5 = crate :: Reg < cmar5 :: Cmar5Spec > ;
#[doc = "channel x memory address register"] pub mod cmar5 {
#[doc = "Register `CMAR5` reader"] pub type R = crate :: R < Cmar5Spec > ;
#[doc = "Register `CMAR5` writer"] pub type W = crate :: W < Cmar5Spec > ;
#[doc = "Field `MA` reader - Memory address"] pub type MaR = crate :: FieldReader < u32 > ;
#[doc = "Field `MA` writer - Memory address"] pub type MaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& self) -> MaR { MaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& mut self) -> MaW < '_ , Cmar5Spec > { MaW :: new (self , 0) } }
#[doc = "channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cmar5Spec ; impl crate :: RegisterSpec for Cmar5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmar5::R`](R) reader structure"] impl crate :: Readable for Cmar5Spec { }
#[doc = "`write(|w| ..)` method takes [`cmar5::W`](W) writer structure"] impl crate :: Writable for Cmar5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMAR5 to value 0"] impl crate :: Resettable for Cmar5Spec { } }
#[doc = "CCR6 (rw) register accessor: channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr6`] module"]
#[doc (alias = "CCR6")] pub type Ccr6 = crate :: Reg < ccr6 :: Ccr6Spec > ;
#[doc = "channel x configuration register"] pub mod ccr6 {
#[doc = "Register `CCR6` reader"] pub type R = crate :: R < Ccr6Spec > ;
#[doc = "Register `CCR6` writer"] pub type W = crate :: W < Ccr6Spec > ;
#[doc = "Field `EN` reader - Channel enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Channel enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HTIE` reader - Half transfer interrupt enable"] pub type HtieR = crate :: BitReader ;
#[doc = "Field `HTIE` writer - Half transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader ;
#[doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader ;
#[doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MINC` reader - Memory increment mode"] pub type MincR = crate :: BitReader ;
#[doc = "Field `MINC` writer - Memory increment mode"] pub type MincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSIZE` reader - Peripheral size"] pub type PsizeR = crate :: FieldReader ;
#[doc = "Field `PSIZE` writer - Peripheral size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MSIZE` reader - Memory size"] pub type MsizeR = crate :: FieldReader ;
#[doc = "Field `MSIZE` writer - Memory size"] pub type MsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PL` reader - Channel priority level"] pub type PlR = crate :: FieldReader ;
#[doc = "Field `PL` writer - Channel priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MEM2MEM` reader - Memory to memory mode"] pub type Mem2memR = crate :: BitReader ;
#[doc = "Field `MEM2MEM` writer - Memory to memory mode"] pub type Mem2memW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& self) -> Mem2memR { Mem2memR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Ccr6Spec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Ccr6Spec > { TcieW :: new (self , 1) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& mut self) -> HtieW < '_ , Ccr6Spec > { HtieW :: new (self , 2) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , Ccr6Spec > { TeieW :: new (self , 3) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Ccr6Spec > { DirW :: new (self , 4) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& mut self) -> CircW < '_ , Ccr6Spec > { CircW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& mut self) -> PincW < '_ , Ccr6Spec > { PincW :: new (self , 6) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& mut self) -> MincW < '_ , Ccr6Spec > { MincW :: new (self , 7) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& mut self) -> PsizeW < '_ , Ccr6Spec > { PsizeW :: new (self , 8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& mut self) -> MsizeW < '_ , Ccr6Spec > { MsizeW :: new (self , 10) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& mut self) -> PlW < '_ , Ccr6Spec > { PlW :: new (self , 12) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& mut self) -> Mem2memW < '_ , Ccr6Spec > { Mem2memW :: new (self , 14) } }
#[doc = "channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr6Spec ; impl crate :: RegisterSpec for Ccr6Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr6::R`](R) reader structure"] impl crate :: Readable for Ccr6Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr6::W`](W) writer structure"] impl crate :: Writable for Ccr6Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR6 to value 0"] impl crate :: Resettable for Ccr6Spec { } }
#[doc = "CNDTR6 (rw) register accessor: channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cndtr6`] module"]
#[doc (alias = "CNDTR6")] pub type Cndtr6 = crate :: Reg < cndtr6 :: Cndtr6Spec > ;
#[doc = "channel x number of data register"] pub mod cndtr6 {
#[doc = "Register `CNDTR6` reader"] pub type R = crate :: R < Cndtr6Spec > ;
#[doc = "Register `CNDTR6` writer"] pub type W = crate :: W < Cndtr6Spec > ;
#[doc = "Field `NDT` reader - Number of data to transfer"] pub type NdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `NDT` writer - Number of data to transfer"] pub type NdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& self) -> NdtR { NdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& mut self) -> NdtW < '_ , Cndtr6Spec > { NdtW :: new (self , 0) } }
#[doc = "channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cndtr6Spec ; impl crate :: RegisterSpec for Cndtr6Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cndtr6::R`](R) reader structure"] impl crate :: Readable for Cndtr6Spec { }
#[doc = "`write(|w| ..)` method takes [`cndtr6::W`](W) writer structure"] impl crate :: Writable for Cndtr6Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNDTR6 to value 0"] impl crate :: Resettable for Cndtr6Spec { } }
#[doc = "CPAR6 (rw) register accessor: channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpar6`] module"]
#[doc (alias = "CPAR6")] pub type Cpar6 = crate :: Reg < cpar6 :: Cpar6Spec > ;
#[doc = "channel x peripheral address register"] pub mod cpar6 {
#[doc = "Register `CPAR6` reader"] pub type R = crate :: R < Cpar6Spec > ;
#[doc = "Register `CPAR6` writer"] pub type W = crate :: W < Cpar6Spec > ;
#[doc = "Field `PA` reader - Peripheral address"] pub type PaR = crate :: FieldReader < u32 > ;
#[doc = "Field `PA` writer - Peripheral address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , Cpar6Spec > { PaW :: new (self , 0) } }
#[doc = "channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cpar6Spec ; impl crate :: RegisterSpec for Cpar6Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cpar6::R`](R) reader structure"] impl crate :: Readable for Cpar6Spec { }
#[doc = "`write(|w| ..)` method takes [`cpar6::W`](W) writer structure"] impl crate :: Writable for Cpar6Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CPAR6 to value 0"] impl crate :: Resettable for Cpar6Spec { } }
#[doc = "CMAR6 (rw) register accessor: channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmar6`] module"]
#[doc (alias = "CMAR6")] pub type Cmar6 = crate :: Reg < cmar6 :: Cmar6Spec > ;
#[doc = "channel x memory address register"] pub mod cmar6 {
#[doc = "Register `CMAR6` reader"] pub type R = crate :: R < Cmar6Spec > ;
#[doc = "Register `CMAR6` writer"] pub type W = crate :: W < Cmar6Spec > ;
#[doc = "Field `MA` reader - Memory address"] pub type MaR = crate :: FieldReader < u32 > ;
#[doc = "Field `MA` writer - Memory address"] pub type MaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& self) -> MaR { MaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& mut self) -> MaW < '_ , Cmar6Spec > { MaW :: new (self , 0) } }
#[doc = "channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cmar6Spec ; impl crate :: RegisterSpec for Cmar6Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmar6::R`](R) reader structure"] impl crate :: Readable for Cmar6Spec { }
#[doc = "`write(|w| ..)` method takes [`cmar6::W`](W) writer structure"] impl crate :: Writable for Cmar6Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMAR6 to value 0"] impl crate :: Resettable for Cmar6Spec { } }
#[doc = "CCR7 (rw) register accessor: channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr7::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr7::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr7`] module"]
#[doc (alias = "CCR7")] pub type Ccr7 = crate :: Reg < ccr7 :: Ccr7Spec > ;
#[doc = "channel x configuration register"] pub mod ccr7 {
#[doc = "Register `CCR7` reader"] pub type R = crate :: R < Ccr7Spec > ;
#[doc = "Register `CCR7` writer"] pub type W = crate :: W < Ccr7Spec > ;
#[doc = "Field `EN` reader - Channel enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Channel enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HTIE` reader - Half transfer interrupt enable"] pub type HtieR = crate :: BitReader ;
#[doc = "Field `HTIE` writer - Half transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader ;
#[doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader ;
#[doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MINC` reader - Memory increment mode"] pub type MincR = crate :: BitReader ;
#[doc = "Field `MINC` writer - Memory increment mode"] pub type MincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSIZE` reader - Peripheral size"] pub type PsizeR = crate :: FieldReader ;
#[doc = "Field `PSIZE` writer - Peripheral size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MSIZE` reader - Memory size"] pub type MsizeR = crate :: FieldReader ;
#[doc = "Field `MSIZE` writer - Memory size"] pub type MsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PL` reader - Channel priority level"] pub type PlR = crate :: FieldReader ;
#[doc = "Field `PL` writer - Channel priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MEM2MEM` reader - Memory to memory mode"] pub type Mem2memR = crate :: BitReader ;
#[doc = "Field `MEM2MEM` writer - Memory to memory mode"] pub type Mem2memW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& self) -> Mem2memR { Mem2memR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Ccr7Spec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Ccr7Spec > { TcieW :: new (self , 1) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& mut self) -> HtieW < '_ , Ccr7Spec > { HtieW :: new (self , 2) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , Ccr7Spec > { TeieW :: new (self , 3) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Ccr7Spec > { DirW :: new (self , 4) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& mut self) -> CircW < '_ , Ccr7Spec > { CircW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& mut self) -> PincW < '_ , Ccr7Spec > { PincW :: new (self , 6) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& mut self) -> MincW < '_ , Ccr7Spec > { MincW :: new (self , 7) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& mut self) -> PsizeW < '_ , Ccr7Spec > { PsizeW :: new (self , 8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& mut self) -> MsizeW < '_ , Ccr7Spec > { MsizeW :: new (self , 10) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& mut self) -> PlW < '_ , Ccr7Spec > { PlW :: new (self , 12) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& mut self) -> Mem2memW < '_ , Ccr7Spec > { Mem2memW :: new (self , 14) } }
#[doc = "channel x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr7::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr7::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr7Spec ; impl crate :: RegisterSpec for Ccr7Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr7::R`](R) reader structure"] impl crate :: Readable for Ccr7Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr7::W`](W) writer structure"] impl crate :: Writable for Ccr7Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR7 to value 0"] impl crate :: Resettable for Ccr7Spec { } }
#[doc = "CNDTR7 (rw) register accessor: channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr7::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr7::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cndtr7`] module"]
#[doc (alias = "CNDTR7")] pub type Cndtr7 = crate :: Reg < cndtr7 :: Cndtr7Spec > ;
#[doc = "channel x number of data register"] pub mod cndtr7 {
#[doc = "Register `CNDTR7` reader"] pub type R = crate :: R < Cndtr7Spec > ;
#[doc = "Register `CNDTR7` writer"] pub type W = crate :: W < Cndtr7Spec > ;
#[doc = "Field `NDT` reader - Number of data to transfer"] pub type NdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `NDT` writer - Number of data to transfer"] pub type NdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& self) -> NdtR { NdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& mut self) -> NdtW < '_ , Cndtr7Spec > { NdtW :: new (self , 0) } }
#[doc = "channel x number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr7::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr7::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cndtr7Spec ; impl crate :: RegisterSpec for Cndtr7Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cndtr7::R`](R) reader structure"] impl crate :: Readable for Cndtr7Spec { }
#[doc = "`write(|w| ..)` method takes [`cndtr7::W`](W) writer structure"] impl crate :: Writable for Cndtr7Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNDTR7 to value 0"] impl crate :: Resettable for Cndtr7Spec { } }
#[doc = "CPAR7 (rw) register accessor: channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar7::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar7::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpar7`] module"]
#[doc (alias = "CPAR7")] pub type Cpar7 = crate :: Reg < cpar7 :: Cpar7Spec > ;
#[doc = "channel x peripheral address register"] pub mod cpar7 {
#[doc = "Register `CPAR7` reader"] pub type R = crate :: R < Cpar7Spec > ;
#[doc = "Register `CPAR7` writer"] pub type W = crate :: W < Cpar7Spec > ;
#[doc = "Field `PA` reader - Peripheral address"] pub type PaR = crate :: FieldReader < u32 > ;
#[doc = "Field `PA` writer - Peripheral address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , Cpar7Spec > { PaW :: new (self , 0) } }
#[doc = "channel x peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar7::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar7::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cpar7Spec ; impl crate :: RegisterSpec for Cpar7Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cpar7::R`](R) reader structure"] impl crate :: Readable for Cpar7Spec { }
#[doc = "`write(|w| ..)` method takes [`cpar7::W`](W) writer structure"] impl crate :: Writable for Cpar7Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CPAR7 to value 0"] impl crate :: Resettable for Cpar7Spec { } }
#[doc = "CMAR7 (rw) register accessor: channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar7::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar7::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmar7`] module"]
#[doc (alias = "CMAR7")] pub type Cmar7 = crate :: Reg < cmar7 :: Cmar7Spec > ;
#[doc = "channel x memory address register"] pub mod cmar7 {
#[doc = "Register `CMAR7` reader"] pub type R = crate :: R < Cmar7Spec > ;
#[doc = "Register `CMAR7` writer"] pub type W = crate :: W < Cmar7Spec > ;
#[doc = "Field `MA` reader - Memory address"] pub type MaR = crate :: FieldReader < u32 > ;
#[doc = "Field `MA` writer - Memory address"] pub type MaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& self) -> MaR { MaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& mut self) -> MaW < '_ , Cmar7Spec > { MaW :: new (self , 0) } }
#[doc = "channel x memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar7::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar7::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cmar7Spec ; impl crate :: RegisterSpec for Cmar7Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmar7::R`](R) reader structure"] impl crate :: Readable for Cmar7Spec { }
#[doc = "`write(|w| ..)` method takes [`cmar7::W`](W) writer structure"] impl crate :: Writable for Cmar7Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMAR7 to value 0"] impl crate :: Resettable for Cmar7Spec { } }
#[doc = "CSELR (rw) register accessor: channel selection register\n\nYou can [`read`](crate::Reg::read) this register and get [`cselr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cselr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cselr`] module"]
#[doc (alias = "CSELR")] pub type Cselr = crate :: Reg < cselr :: CselrSpec > ;
#[doc = "channel selection register"] pub mod cselr {
#[doc = "Register `CSELR` reader"] pub type R = crate :: R < CselrSpec > ;
#[doc = "Register `CSELR` writer"] pub type W = crate :: W < CselrSpec > ;
#[doc = "Field `C1S` reader - DMA channel 1 selection"] pub type C1sR = crate :: FieldReader ;
#[doc = "Field `C1S` writer - DMA channel 1 selection"] pub type C1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `C2S` reader - DMA channel 2 selection"] pub type C2sR = crate :: FieldReader ;
#[doc = "Field `C2S` writer - DMA channel 2 selection"] pub type C2sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `C3S` reader - DMA channel 3 selection"] pub type C3sR = crate :: FieldReader ;
#[doc = "Field `C3S` writer - DMA channel 3 selection"] pub type C3sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `C4S` reader - DMA channel 4 selection"] pub type C4sR = crate :: FieldReader ;
#[doc = "Field `C4S` writer - DMA channel 4 selection"] pub type C4sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `C5S` reader - DMA channel 5 selection"] pub type C5sR = crate :: FieldReader ;
#[doc = "Field `C5S` writer - DMA channel 5 selection"] pub type C5sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `C6S` reader - DMA channel 6 selection"] pub type C6sR = crate :: FieldReader ;
#[doc = "Field `C6S` writer - DMA channel 6 selection"] pub type C6sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `C7S` reader - DMA channel 7 selection"] pub type C7sR = crate :: FieldReader ;
#[doc = "Field `C7S` writer - DMA channel 7 selection"] pub type C7sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - DMA channel 1 selection"]
#[inline (always)] pub fn c1s (& self) -> C1sR { C1sR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - DMA channel 2 selection"]
#[inline (always)] pub fn c2s (& self) -> C2sR { C2sR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:11 - DMA channel 3 selection"]
#[inline (always)] pub fn c3s (& self) -> C3sR { C3sR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:15 - DMA channel 4 selection"]
#[inline (always)] pub fn c4s (& self) -> C4sR { C4sR :: new (((self . bits >> 12) & 0x0f) as u8) }
#[doc = "Bits 16:19 - DMA channel 5 selection"]
#[inline (always)] pub fn c5s (& self) -> C5sR { C5sR :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bits 20:23 - DMA channel 6 selection"]
#[inline (always)] pub fn c6s (& self) -> C6sR { C6sR :: new (((self . bits >> 20) & 0x0f) as u8) }
#[doc = "Bits 24:27 - DMA channel 7 selection"]
#[inline (always)] pub fn c7s (& self) -> C7sR { C7sR :: new (((self . bits >> 24) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - DMA channel 1 selection"]
#[inline (always)] pub fn c1s (& mut self) -> C1sW < '_ , CselrSpec > { C1sW :: new (self , 0) }
#[doc = "Bits 4:7 - DMA channel 2 selection"]
#[inline (always)] pub fn c2s (& mut self) -> C2sW < '_ , CselrSpec > { C2sW :: new (self , 4) }
#[doc = "Bits 8:11 - DMA channel 3 selection"]
#[inline (always)] pub fn c3s (& mut self) -> C3sW < '_ , CselrSpec > { C3sW :: new (self , 8) }
#[doc = "Bits 12:15 - DMA channel 4 selection"]
#[inline (always)] pub fn c4s (& mut self) -> C4sW < '_ , CselrSpec > { C4sW :: new (self , 12) }
#[doc = "Bits 16:19 - DMA channel 5 selection"]
#[inline (always)] pub fn c5s (& mut self) -> C5sW < '_ , CselrSpec > { C5sW :: new (self , 16) }
#[doc = "Bits 20:23 - DMA channel 6 selection"]
#[inline (always)] pub fn c6s (& mut self) -> C6sW < '_ , CselrSpec > { C6sW :: new (self , 20) }
#[doc = "Bits 24:27 - DMA channel 7 selection"]
#[inline (always)] pub fn c7s (& mut self) -> C7sW < '_ , CselrSpec > { C7sW :: new (self , 24) } }
#[doc = "channel selection register\n\nYou can [`read`](crate::Reg::read) this register and get [`cselr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cselr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CselrSpec ; impl crate :: RegisterSpec for CselrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cselr::R`](R) reader structure"] impl crate :: Readable for CselrSpec { }
#[doc = "`write(|w| ..)` method takes [`cselr::W`](W) writer structure"] impl crate :: Writable for CselrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CSELR to value 0"] impl crate :: Resettable for CselrSpec { } } }
#[doc = "Direct memory access Multiplexer"] pub type Dmamux1 = crate :: Periph < dmamux1 :: RegisterBlock , 0x4002_0800 > ; impl core :: fmt :: Debug for Dmamux1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dmamux1") . finish () } }
#[doc = "Direct memory access Multiplexer"] pub mod dmamux1 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { c0cr : C0cr , c1cr : C1cr , c2cr : C2cr , c3cr : C3cr , c4cr : C4cr , c5cr : C5cr , c6cr : C6cr , c7cr : C7cr , c8cr : C8cr , c9cr : C9cr , c10cr : C10cr , c11cr : C11cr , c12cr : C12cr , c13cr : C13cr , _reserved14 : [u8 ; 0x48] , csr : Csr , cfr : Cfr , _reserved16 : [u8 ; 0x78] , rg0cr : Rg0cr , rg1cr : Rg1cr , rg2cr : Rg2cr , rg3cr : Rg3cr , _reserved20 : [u8 ; 0x30] , rgsr : Rgsr , rgcfr : Rgcfr , } impl RegisterBlock {
#[doc = "0x00 - DMA Multiplexer Channel 0 Control register"]
#[inline (always)] pub const fn c0cr (& self) -> & C0cr { & self . c0cr }
#[doc = "0x04 - DMA Multiplexer Channel 1 Control register"]
#[inline (always)] pub const fn c1cr (& self) -> & C1cr { & self . c1cr }
#[doc = "0x08 - DMA Multiplexer Channel 2 Control register"]
#[inline (always)] pub const fn c2cr (& self) -> & C2cr { & self . c2cr }
#[doc = "0x0c - DMA Multiplexer Channel 3 Control register"]
#[inline (always)] pub const fn c3cr (& self) -> & C3cr { & self . c3cr }
#[doc = "0x10 - DMA Multiplexer Channel 4 Control register"]
#[inline (always)] pub const fn c4cr (& self) -> & C4cr { & self . c4cr }
#[doc = "0x14 - DMA Multiplexer Channel 5 Control register"]
#[inline (always)] pub const fn c5cr (& self) -> & C5cr { & self . c5cr }
#[doc = "0x18 - DMA Multiplexer Channel 6 Control register"]
#[inline (always)] pub const fn c6cr (& self) -> & C6cr { & self . c6cr }
#[doc = "0x1c - DMA Multiplexer Channel 7 Control register"]
#[inline (always)] pub const fn c7cr (& self) -> & C7cr { & self . c7cr }
#[doc = "0x20 - DMA Multiplexer Channel 8 Control register"]
#[inline (always)] pub const fn c8cr (& self) -> & C8cr { & self . c8cr }
#[doc = "0x24 - DMA Multiplexer Channel 9 Control register"]
#[inline (always)] pub const fn c9cr (& self) -> & C9cr { & self . c9cr }
#[doc = "0x28 - DMA Multiplexer Channel 10 Control register"]
#[inline (always)] pub const fn c10cr (& self) -> & C10cr { & self . c10cr }
#[doc = "0x2c - DMA Multiplexer Channel 11 Control register"]
#[inline (always)] pub const fn c11cr (& self) -> & C11cr { & self . c11cr }
#[doc = "0x30 - DMA Multiplexer Channel 12 Control register"]
#[inline (always)] pub const fn c12cr (& self) -> & C12cr { & self . c12cr }
#[doc = "0x34 - DMA Multiplexer Channel 13 Control register"]
#[inline (always)] pub const fn c13cr (& self) -> & C13cr { & self . c13cr }
#[doc = "0x80 - DMA Multiplexer Channel Status register"]
#[inline (always)] pub const fn csr (& self) -> & Csr { & self . csr }
#[doc = "0x84 - DMA Channel Clear Flag Register"]
#[inline (always)] pub const fn cfr (& self) -> & Cfr { & self . cfr }
#[doc = "0x100 - DMA Request Generator 0 Control Register"]
#[inline (always)] pub const fn rg0cr (& self) -> & Rg0cr { & self . rg0cr }
#[doc = "0x104 - DMA Request Generator 1 Control Register"]
#[inline (always)] pub const fn rg1cr (& self) -> & Rg1cr { & self . rg1cr }
#[doc = "0x108 - DMA Request Generator 2 Control Register"]
#[inline (always)] pub const fn rg2cr (& self) -> & Rg2cr { & self . rg2cr }
#[doc = "0x10c - DMA Request Generator 3 Control Register"]
#[inline (always)] pub const fn rg3cr (& self) -> & Rg3cr { & self . rg3cr }
#[doc = "0x140 - DMA Request Generator Status Register"]
#[inline (always)] pub const fn rgsr (& self) -> & Rgsr { & self . rgsr }
#[doc = "0x144 - DMA Request Generator Clear Flag Register"]
#[inline (always)] pub const fn rgcfr (& self) -> & Rgcfr { & self . rgcfr } }
#[doc = "C0CR (rw) register accessor: DMA Multiplexer Channel 0 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c0cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c0cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c0cr`] module"]
#[doc (alias = "C0CR")] pub type C0cr = crate :: Reg < c0cr :: C0crSpec > ;
#[doc = "DMA Multiplexer Channel 0 Control register"] pub mod c0cr {
#[doc = "Register `C0CR` reader"] pub type R = crate :: R < C0crSpec > ;
#[doc = "Register `C0CR` writer"] pub type W = crate :: W < C0crSpec > ;
#[doc = "Field `DMAREQ_ID` reader - DMA Request ID"] pub type DmareqIdR = crate :: FieldReader ;
#[doc = "Field `DMAREQ_ID` writer - DMA Request ID"] pub type DmareqIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `SOIE` reader - Synchronization Overrun Interrupt Enable"] pub type SoieR = crate :: BitReader ;
#[doc = "Field `SOIE` writer - Synchronization Overrun Interrupt Enable"] pub type SoieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EGE` reader - Event Generation Enable"] pub type EgeR = crate :: BitReader ;
#[doc = "Field `EGE` writer - Event Generation Enable"] pub type EgeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SE` reader - Synchronization enable"] pub type SeR = crate :: BitReader ;
#[doc = "Field `SE` writer - Synchronization enable"] pub type SeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPOL` reader - Sync polarity"] pub type SpolR = crate :: FieldReader ;
#[doc = "Field `SPOL` writer - Sync polarity"] pub type SpolW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `NBREQ` reader - Nb request"] pub type NbreqR = crate :: FieldReader ;
#[doc = "Field `NBREQ` writer - Nb request"] pub type NbreqW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SYNC_ID` reader - SYNC_ID"] pub type SyncIdR = crate :: FieldReader ;
#[doc = "Field `SYNC_ID` writer - SYNC_ID"] pub type SyncIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& self) -> DmareqIdR { DmareqIdR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& self) -> SoieR { SoieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& self) -> EgeR { EgeR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& self) -> SeR { SeR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& self) -> SpolR { SpolR :: new (((self . bits >> 17) & 3) as u8) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& self) -> NbreqR { NbreqR :: new (((self . bits >> 19) & 0x1f) as u8) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& self) -> SyncIdR { SyncIdR :: new (((self . bits >> 24) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& mut self) -> DmareqIdW < '_ , C0crSpec > { DmareqIdW :: new (self , 0) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& mut self) -> SoieW < '_ , C0crSpec > { SoieW :: new (self , 8) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& mut self) -> EgeW < '_ , C0crSpec > { EgeW :: new (self , 9) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& mut self) -> SeW < '_ , C0crSpec > { SeW :: new (self , 16) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& mut self) -> SpolW < '_ , C0crSpec > { SpolW :: new (self , 17) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& mut self) -> NbreqW < '_ , C0crSpec > { NbreqW :: new (self , 19) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& mut self) -> SyncIdW < '_ , C0crSpec > { SyncIdW :: new (self , 24) } }
#[doc = "DMA Multiplexer Channel 0 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c0cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c0cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C0crSpec ; impl crate :: RegisterSpec for C0crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c0cr::R`](R) reader structure"] impl crate :: Readable for C0crSpec { }
#[doc = "`write(|w| ..)` method takes [`c0cr::W`](W) writer structure"] impl crate :: Writable for C0crSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C0CR to value 0"] impl crate :: Resettable for C0crSpec { } }
#[doc = "C1CR (rw) register accessor: DMA Multiplexer Channel 1 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c1cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c1cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c1cr`] module"]
#[doc (alias = "C1CR")] pub type C1cr = crate :: Reg < c1cr :: C1crSpec > ;
#[doc = "DMA Multiplexer Channel 1 Control register"] pub mod c1cr {
#[doc = "Register `C1CR` reader"] pub type R = crate :: R < C1crSpec > ;
#[doc = "Register `C1CR` writer"] pub type W = crate :: W < C1crSpec > ;
#[doc = "Field `DMAREQ_ID` reader - DMA Request ID"] pub type DmareqIdR = crate :: FieldReader ;
#[doc = "Field `DMAREQ_ID` writer - DMA Request ID"] pub type DmareqIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `SOIE` reader - Synchronization Overrun Interrupt Enable"] pub type SoieR = crate :: BitReader ;
#[doc = "Field `SOIE` writer - Synchronization Overrun Interrupt Enable"] pub type SoieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EGE` reader - Event Generation Enable"] pub type EgeR = crate :: BitReader ;
#[doc = "Field `EGE` writer - Event Generation Enable"] pub type EgeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SE` reader - Synchronization enable"] pub type SeR = crate :: BitReader ;
#[doc = "Field `SE` writer - Synchronization enable"] pub type SeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPOL` reader - Sync polarity"] pub type SpolR = crate :: FieldReader ;
#[doc = "Field `SPOL` writer - Sync polarity"] pub type SpolW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `NBREQ` reader - Nb request"] pub type NbreqR = crate :: FieldReader ;
#[doc = "Field `NBREQ` writer - Nb request"] pub type NbreqW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SYNC_ID` reader - SYNC_ID"] pub type SyncIdR = crate :: FieldReader ;
#[doc = "Field `SYNC_ID` writer - SYNC_ID"] pub type SyncIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& self) -> DmareqIdR { DmareqIdR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& self) -> SoieR { SoieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& self) -> EgeR { EgeR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& self) -> SeR { SeR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& self) -> SpolR { SpolR :: new (((self . bits >> 17) & 3) as u8) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& self) -> NbreqR { NbreqR :: new (((self . bits >> 19) & 0x1f) as u8) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& self) -> SyncIdR { SyncIdR :: new (((self . bits >> 24) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& mut self) -> DmareqIdW < '_ , C1crSpec > { DmareqIdW :: new (self , 0) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& mut self) -> SoieW < '_ , C1crSpec > { SoieW :: new (self , 8) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& mut self) -> EgeW < '_ , C1crSpec > { EgeW :: new (self , 9) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& mut self) -> SeW < '_ , C1crSpec > { SeW :: new (self , 16) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& mut self) -> SpolW < '_ , C1crSpec > { SpolW :: new (self , 17) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& mut self) -> NbreqW < '_ , C1crSpec > { NbreqW :: new (self , 19) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& mut self) -> SyncIdW < '_ , C1crSpec > { SyncIdW :: new (self , 24) } }
#[doc = "DMA Multiplexer Channel 1 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c1cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c1cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C1crSpec ; impl crate :: RegisterSpec for C1crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c1cr::R`](R) reader structure"] impl crate :: Readable for C1crSpec { }
#[doc = "`write(|w| ..)` method takes [`c1cr::W`](W) writer structure"] impl crate :: Writable for C1crSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C1CR to value 0"] impl crate :: Resettable for C1crSpec { } }
#[doc = "C2CR (rw) register accessor: DMA Multiplexer Channel 2 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2cr`] module"]
#[doc (alias = "C2CR")] pub type C2cr = crate :: Reg < c2cr :: C2crSpec > ;
#[doc = "DMA Multiplexer Channel 2 Control register"] pub mod c2cr {
#[doc = "Register `C2CR` reader"] pub type R = crate :: R < C2crSpec > ;
#[doc = "Register `C2CR` writer"] pub type W = crate :: W < C2crSpec > ;
#[doc = "Field `DMAREQ_ID` reader - DMA Request ID"] pub type DmareqIdR = crate :: FieldReader ;
#[doc = "Field `DMAREQ_ID` writer - DMA Request ID"] pub type DmareqIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `SOIE` reader - Synchronization Overrun Interrupt Enable"] pub type SoieR = crate :: BitReader ;
#[doc = "Field `SOIE` writer - Synchronization Overrun Interrupt Enable"] pub type SoieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EGE` reader - Event Generation Enable"] pub type EgeR = crate :: BitReader ;
#[doc = "Field `EGE` writer - Event Generation Enable"] pub type EgeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SE` reader - Synchronization enable"] pub type SeR = crate :: BitReader ;
#[doc = "Field `SE` writer - Synchronization enable"] pub type SeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPOL` reader - Sync polarity"] pub type SpolR = crate :: FieldReader ;
#[doc = "Field `SPOL` writer - Sync polarity"] pub type SpolW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `NBREQ` reader - Nb request"] pub type NbreqR = crate :: FieldReader ;
#[doc = "Field `NBREQ` writer - Nb request"] pub type NbreqW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SYNC_ID` reader - SYNC_ID"] pub type SyncIdR = crate :: FieldReader ;
#[doc = "Field `SYNC_ID` writer - SYNC_ID"] pub type SyncIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& self) -> DmareqIdR { DmareqIdR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& self) -> SoieR { SoieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& self) -> EgeR { EgeR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& self) -> SeR { SeR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& self) -> SpolR { SpolR :: new (((self . bits >> 17) & 3) as u8) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& self) -> NbreqR { NbreqR :: new (((self . bits >> 19) & 0x1f) as u8) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& self) -> SyncIdR { SyncIdR :: new (((self . bits >> 24) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& mut self) -> DmareqIdW < '_ , C2crSpec > { DmareqIdW :: new (self , 0) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& mut self) -> SoieW < '_ , C2crSpec > { SoieW :: new (self , 8) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& mut self) -> EgeW < '_ , C2crSpec > { EgeW :: new (self , 9) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& mut self) -> SeW < '_ , C2crSpec > { SeW :: new (self , 16) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& mut self) -> SpolW < '_ , C2crSpec > { SpolW :: new (self , 17) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& mut self) -> NbreqW < '_ , C2crSpec > { NbreqW :: new (self , 19) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& mut self) -> SyncIdW < '_ , C2crSpec > { SyncIdW :: new (self , 24) } }
#[doc = "DMA Multiplexer Channel 2 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2crSpec ; impl crate :: RegisterSpec for C2crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2cr::R`](R) reader structure"] impl crate :: Readable for C2crSpec { }
#[doc = "`write(|w| ..)` method takes [`c2cr::W`](W) writer structure"] impl crate :: Writable for C2crSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2CR to value 0"] impl crate :: Resettable for C2crSpec { } }
#[doc = "C3CR (rw) register accessor: DMA Multiplexer Channel 3 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c3cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c3cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c3cr`] module"]
#[doc (alias = "C3CR")] pub type C3cr = crate :: Reg < c3cr :: C3crSpec > ;
#[doc = "DMA Multiplexer Channel 3 Control register"] pub mod c3cr {
#[doc = "Register `C3CR` reader"] pub type R = crate :: R < C3crSpec > ;
#[doc = "Register `C3CR` writer"] pub type W = crate :: W < C3crSpec > ;
#[doc = "Field `DMAREQ_ID` reader - DMA Request ID"] pub type DmareqIdR = crate :: FieldReader ;
#[doc = "Field `DMAREQ_ID` writer - DMA Request ID"] pub type DmareqIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `SOIE` reader - Synchronization Overrun Interrupt Enable"] pub type SoieR = crate :: BitReader ;
#[doc = "Field `SOIE` writer - Synchronization Overrun Interrupt Enable"] pub type SoieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EGE` reader - Event Generation Enable"] pub type EgeR = crate :: BitReader ;
#[doc = "Field `EGE` writer - Event Generation Enable"] pub type EgeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SE` reader - Synchronization enable"] pub type SeR = crate :: BitReader ;
#[doc = "Field `SE` writer - Synchronization enable"] pub type SeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPOL` reader - Sync polarity"] pub type SpolR = crate :: FieldReader ;
#[doc = "Field `SPOL` writer - Sync polarity"] pub type SpolW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `NBREQ` reader - Nb request"] pub type NbreqR = crate :: FieldReader ;
#[doc = "Field `NBREQ` writer - Nb request"] pub type NbreqW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SYNC_ID` reader - SYNC_ID"] pub type SyncIdR = crate :: FieldReader ;
#[doc = "Field `SYNC_ID` writer - SYNC_ID"] pub type SyncIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& self) -> DmareqIdR { DmareqIdR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& self) -> SoieR { SoieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& self) -> EgeR { EgeR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& self) -> SeR { SeR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& self) -> SpolR { SpolR :: new (((self . bits >> 17) & 3) as u8) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& self) -> NbreqR { NbreqR :: new (((self . bits >> 19) & 0x1f) as u8) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& self) -> SyncIdR { SyncIdR :: new (((self . bits >> 24) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& mut self) -> DmareqIdW < '_ , C3crSpec > { DmareqIdW :: new (self , 0) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& mut self) -> SoieW < '_ , C3crSpec > { SoieW :: new (self , 8) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& mut self) -> EgeW < '_ , C3crSpec > { EgeW :: new (self , 9) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& mut self) -> SeW < '_ , C3crSpec > { SeW :: new (self , 16) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& mut self) -> SpolW < '_ , C3crSpec > { SpolW :: new (self , 17) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& mut self) -> NbreqW < '_ , C3crSpec > { NbreqW :: new (self , 19) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& mut self) -> SyncIdW < '_ , C3crSpec > { SyncIdW :: new (self , 24) } }
#[doc = "DMA Multiplexer Channel 3 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c3cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c3cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C3crSpec ; impl crate :: RegisterSpec for C3crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c3cr::R`](R) reader structure"] impl crate :: Readable for C3crSpec { }
#[doc = "`write(|w| ..)` method takes [`c3cr::W`](W) writer structure"] impl crate :: Writable for C3crSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C3CR to value 0"] impl crate :: Resettable for C3crSpec { } }
#[doc = "C4CR (rw) register accessor: DMA Multiplexer Channel 4 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c4cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c4cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c4cr`] module"]
#[doc (alias = "C4CR")] pub type C4cr = crate :: Reg < c4cr :: C4crSpec > ;
#[doc = "DMA Multiplexer Channel 4 Control register"] pub mod c4cr {
#[doc = "Register `C4CR` reader"] pub type R = crate :: R < C4crSpec > ;
#[doc = "Register `C4CR` writer"] pub type W = crate :: W < C4crSpec > ;
#[doc = "Field `DMAREQ_ID` reader - DMA Request ID"] pub type DmareqIdR = crate :: FieldReader ;
#[doc = "Field `DMAREQ_ID` writer - DMA Request ID"] pub type DmareqIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `SOIE` reader - Synchronization Overrun Interrupt Enable"] pub type SoieR = crate :: BitReader ;
#[doc = "Field `SOIE` writer - Synchronization Overrun Interrupt Enable"] pub type SoieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EGE` reader - Event Generation Enable"] pub type EgeR = crate :: BitReader ;
#[doc = "Field `EGE` writer - Event Generation Enable"] pub type EgeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SE` reader - Synchronization enable"] pub type SeR = crate :: BitReader ;
#[doc = "Field `SE` writer - Synchronization enable"] pub type SeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPOL` reader - Sync polarity"] pub type SpolR = crate :: FieldReader ;
#[doc = "Field `SPOL` writer - Sync polarity"] pub type SpolW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `NBREQ` reader - Nb request"] pub type NbreqR = crate :: FieldReader ;
#[doc = "Field `NBREQ` writer - Nb request"] pub type NbreqW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SYNC_ID` reader - SYNC_ID"] pub type SyncIdR = crate :: FieldReader ;
#[doc = "Field `SYNC_ID` writer - SYNC_ID"] pub type SyncIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& self) -> DmareqIdR { DmareqIdR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& self) -> SoieR { SoieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& self) -> EgeR { EgeR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& self) -> SeR { SeR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& self) -> SpolR { SpolR :: new (((self . bits >> 17) & 3) as u8) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& self) -> NbreqR { NbreqR :: new (((self . bits >> 19) & 0x1f) as u8) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& self) -> SyncIdR { SyncIdR :: new (((self . bits >> 24) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& mut self) -> DmareqIdW < '_ , C4crSpec > { DmareqIdW :: new (self , 0) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& mut self) -> SoieW < '_ , C4crSpec > { SoieW :: new (self , 8) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& mut self) -> EgeW < '_ , C4crSpec > { EgeW :: new (self , 9) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& mut self) -> SeW < '_ , C4crSpec > { SeW :: new (self , 16) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& mut self) -> SpolW < '_ , C4crSpec > { SpolW :: new (self , 17) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& mut self) -> NbreqW < '_ , C4crSpec > { NbreqW :: new (self , 19) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& mut self) -> SyncIdW < '_ , C4crSpec > { SyncIdW :: new (self , 24) } }
#[doc = "DMA Multiplexer Channel 4 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c4cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c4cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C4crSpec ; impl crate :: RegisterSpec for C4crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c4cr::R`](R) reader structure"] impl crate :: Readable for C4crSpec { }
#[doc = "`write(|w| ..)` method takes [`c4cr::W`](W) writer structure"] impl crate :: Writable for C4crSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C4CR to value 0"] impl crate :: Resettable for C4crSpec { } }
#[doc = "C5CR (rw) register accessor: DMA Multiplexer Channel 5 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c5cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c5cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c5cr`] module"]
#[doc (alias = "C5CR")] pub type C5cr = crate :: Reg < c5cr :: C5crSpec > ;
#[doc = "DMA Multiplexer Channel 5 Control register"] pub mod c5cr {
#[doc = "Register `C5CR` reader"] pub type R = crate :: R < C5crSpec > ;
#[doc = "Register `C5CR` writer"] pub type W = crate :: W < C5crSpec > ;
#[doc = "Field `DMAREQ_ID` reader - DMA Request ID"] pub type DmareqIdR = crate :: FieldReader ;
#[doc = "Field `DMAREQ_ID` writer - DMA Request ID"] pub type DmareqIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `SOIE` reader - Synchronization Overrun Interrupt Enable"] pub type SoieR = crate :: BitReader ;
#[doc = "Field `SOIE` writer - Synchronization Overrun Interrupt Enable"] pub type SoieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EGE` reader - Event Generation Enable"] pub type EgeR = crate :: BitReader ;
#[doc = "Field `EGE` writer - Event Generation Enable"] pub type EgeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SE` reader - Synchronization enable"] pub type SeR = crate :: BitReader ;
#[doc = "Field `SE` writer - Synchronization enable"] pub type SeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPOL` reader - Sync polarity"] pub type SpolR = crate :: FieldReader ;
#[doc = "Field `SPOL` writer - Sync polarity"] pub type SpolW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `NBREQ` reader - Nb request"] pub type NbreqR = crate :: FieldReader ;
#[doc = "Field `NBREQ` writer - Nb request"] pub type NbreqW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SYNC_ID` reader - SYNC_ID"] pub type SyncIdR = crate :: FieldReader ;
#[doc = "Field `SYNC_ID` writer - SYNC_ID"] pub type SyncIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& self) -> DmareqIdR { DmareqIdR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& self) -> SoieR { SoieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& self) -> EgeR { EgeR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& self) -> SeR { SeR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& self) -> SpolR { SpolR :: new (((self . bits >> 17) & 3) as u8) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& self) -> NbreqR { NbreqR :: new (((self . bits >> 19) & 0x1f) as u8) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& self) -> SyncIdR { SyncIdR :: new (((self . bits >> 24) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& mut self) -> DmareqIdW < '_ , C5crSpec > { DmareqIdW :: new (self , 0) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& mut self) -> SoieW < '_ , C5crSpec > { SoieW :: new (self , 8) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& mut self) -> EgeW < '_ , C5crSpec > { EgeW :: new (self , 9) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& mut self) -> SeW < '_ , C5crSpec > { SeW :: new (self , 16) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& mut self) -> SpolW < '_ , C5crSpec > { SpolW :: new (self , 17) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& mut self) -> NbreqW < '_ , C5crSpec > { NbreqW :: new (self , 19) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& mut self) -> SyncIdW < '_ , C5crSpec > { SyncIdW :: new (self , 24) } }
#[doc = "DMA Multiplexer Channel 5 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c5cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c5cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C5crSpec ; impl crate :: RegisterSpec for C5crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c5cr::R`](R) reader structure"] impl crate :: Readable for C5crSpec { }
#[doc = "`write(|w| ..)` method takes [`c5cr::W`](W) writer structure"] impl crate :: Writable for C5crSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C5CR to value 0"] impl crate :: Resettable for C5crSpec { } }
#[doc = "C6CR (rw) register accessor: DMA Multiplexer Channel 6 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c6cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c6cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c6cr`] module"]
#[doc (alias = "C6CR")] pub type C6cr = crate :: Reg < c6cr :: C6crSpec > ;
#[doc = "DMA Multiplexer Channel 6 Control register"] pub mod c6cr {
#[doc = "Register `C6CR` reader"] pub type R = crate :: R < C6crSpec > ;
#[doc = "Register `C6CR` writer"] pub type W = crate :: W < C6crSpec > ;
#[doc = "Field `DMAREQ_ID` reader - DMA Request ID"] pub type DmareqIdR = crate :: FieldReader ;
#[doc = "Field `DMAREQ_ID` writer - DMA Request ID"] pub type DmareqIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `SOIE` reader - Synchronization Overrun Interrupt Enable"] pub type SoieR = crate :: BitReader ;
#[doc = "Field `SOIE` writer - Synchronization Overrun Interrupt Enable"] pub type SoieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EGE` reader - Event Generation Enable"] pub type EgeR = crate :: BitReader ;
#[doc = "Field `EGE` writer - Event Generation Enable"] pub type EgeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SE` reader - Synchronization enable"] pub type SeR = crate :: BitReader ;
#[doc = "Field `SE` writer - Synchronization enable"] pub type SeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPOL` reader - Sync polarity"] pub type SpolR = crate :: FieldReader ;
#[doc = "Field `SPOL` writer - Sync polarity"] pub type SpolW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `NBREQ` reader - Nb request"] pub type NbreqR = crate :: FieldReader ;
#[doc = "Field `NBREQ` writer - Nb request"] pub type NbreqW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SYNC_ID` reader - SYNC_ID"] pub type SyncIdR = crate :: FieldReader ;
#[doc = "Field `SYNC_ID` writer - SYNC_ID"] pub type SyncIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& self) -> DmareqIdR { DmareqIdR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& self) -> SoieR { SoieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& self) -> EgeR { EgeR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& self) -> SeR { SeR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& self) -> SpolR { SpolR :: new (((self . bits >> 17) & 3) as u8) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& self) -> NbreqR { NbreqR :: new (((self . bits >> 19) & 0x1f) as u8) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& self) -> SyncIdR { SyncIdR :: new (((self . bits >> 24) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& mut self) -> DmareqIdW < '_ , C6crSpec > { DmareqIdW :: new (self , 0) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& mut self) -> SoieW < '_ , C6crSpec > { SoieW :: new (self , 8) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& mut self) -> EgeW < '_ , C6crSpec > { EgeW :: new (self , 9) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& mut self) -> SeW < '_ , C6crSpec > { SeW :: new (self , 16) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& mut self) -> SpolW < '_ , C6crSpec > { SpolW :: new (self , 17) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& mut self) -> NbreqW < '_ , C6crSpec > { NbreqW :: new (self , 19) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& mut self) -> SyncIdW < '_ , C6crSpec > { SyncIdW :: new (self , 24) } }
#[doc = "DMA Multiplexer Channel 6 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c6cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c6cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C6crSpec ; impl crate :: RegisterSpec for C6crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c6cr::R`](R) reader structure"] impl crate :: Readable for C6crSpec { }
#[doc = "`write(|w| ..)` method takes [`c6cr::W`](W) writer structure"] impl crate :: Writable for C6crSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C6CR to value 0"] impl crate :: Resettable for C6crSpec { } }
#[doc = "C7CR (rw) register accessor: DMA Multiplexer Channel 7 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c7cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c7cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c7cr`] module"]
#[doc (alias = "C7CR")] pub type C7cr = crate :: Reg < c7cr :: C7crSpec > ;
#[doc = "DMA Multiplexer Channel 7 Control register"] pub mod c7cr {
#[doc = "Register `C7CR` reader"] pub type R = crate :: R < C7crSpec > ;
#[doc = "Register `C7CR` writer"] pub type W = crate :: W < C7crSpec > ;
#[doc = "Field `DMAREQ_ID` reader - DMA Request ID"] pub type DmareqIdR = crate :: FieldReader ;
#[doc = "Field `DMAREQ_ID` writer - DMA Request ID"] pub type DmareqIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `SOIE` reader - Synchronization Overrun Interrupt Enable"] pub type SoieR = crate :: BitReader ;
#[doc = "Field `SOIE` writer - Synchronization Overrun Interrupt Enable"] pub type SoieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EGE` reader - Event Generation Enable"] pub type EgeR = crate :: BitReader ;
#[doc = "Field `EGE` writer - Event Generation Enable"] pub type EgeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SE` reader - Synchronization enable"] pub type SeR = crate :: BitReader ;
#[doc = "Field `SE` writer - Synchronization enable"] pub type SeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPOL` reader - Sync polarity"] pub type SpolR = crate :: FieldReader ;
#[doc = "Field `SPOL` writer - Sync polarity"] pub type SpolW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `NBREQ` reader - Nb request"] pub type NbreqR = crate :: FieldReader ;
#[doc = "Field `NBREQ` writer - Nb request"] pub type NbreqW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SYNC_ID` reader - SYNC_ID"] pub type SyncIdR = crate :: FieldReader ;
#[doc = "Field `SYNC_ID` writer - SYNC_ID"] pub type SyncIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& self) -> DmareqIdR { DmareqIdR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& self) -> SoieR { SoieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& self) -> EgeR { EgeR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& self) -> SeR { SeR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& self) -> SpolR { SpolR :: new (((self . bits >> 17) & 3) as u8) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& self) -> NbreqR { NbreqR :: new (((self . bits >> 19) & 0x1f) as u8) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& self) -> SyncIdR { SyncIdR :: new (((self . bits >> 24) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& mut self) -> DmareqIdW < '_ , C7crSpec > { DmareqIdW :: new (self , 0) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& mut self) -> SoieW < '_ , C7crSpec > { SoieW :: new (self , 8) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& mut self) -> EgeW < '_ , C7crSpec > { EgeW :: new (self , 9) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& mut self) -> SeW < '_ , C7crSpec > { SeW :: new (self , 16) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& mut self) -> SpolW < '_ , C7crSpec > { SpolW :: new (self , 17) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& mut self) -> NbreqW < '_ , C7crSpec > { NbreqW :: new (self , 19) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& mut self) -> SyncIdW < '_ , C7crSpec > { SyncIdW :: new (self , 24) } }
#[doc = "DMA Multiplexer Channel 7 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c7cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c7cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C7crSpec ; impl crate :: RegisterSpec for C7crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c7cr::R`](R) reader structure"] impl crate :: Readable for C7crSpec { }
#[doc = "`write(|w| ..)` method takes [`c7cr::W`](W) writer structure"] impl crate :: Writable for C7crSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C7CR to value 0"] impl crate :: Resettable for C7crSpec { } }
#[doc = "C8CR (rw) register accessor: DMA Multiplexer Channel 8 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c8cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c8cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c8cr`] module"]
#[doc (alias = "C8CR")] pub type C8cr = crate :: Reg < c8cr :: C8crSpec > ;
#[doc = "DMA Multiplexer Channel 8 Control register"] pub mod c8cr {
#[doc = "Register `C8CR` reader"] pub type R = crate :: R < C8crSpec > ;
#[doc = "Register `C8CR` writer"] pub type W = crate :: W < C8crSpec > ;
#[doc = "Field `DMAREQ_ID` reader - DMA Request ID"] pub type DmareqIdR = crate :: FieldReader ;
#[doc = "Field `DMAREQ_ID` writer - DMA Request ID"] pub type DmareqIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `SOIE` reader - Synchronization Overrun Interrupt Enable"] pub type SoieR = crate :: BitReader ;
#[doc = "Field `SOIE` writer - Synchronization Overrun Interrupt Enable"] pub type SoieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EGE` reader - Event Generation Enable"] pub type EgeR = crate :: BitReader ;
#[doc = "Field `EGE` writer - Event Generation Enable"] pub type EgeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SE` reader - Synchronization enable"] pub type SeR = crate :: BitReader ;
#[doc = "Field `SE` writer - Synchronization enable"] pub type SeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPOL` reader - Sync polarity"] pub type SpolR = crate :: FieldReader ;
#[doc = "Field `SPOL` writer - Sync polarity"] pub type SpolW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `NBREQ` reader - Nb request"] pub type NbreqR = crate :: FieldReader ;
#[doc = "Field `NBREQ` writer - Nb request"] pub type NbreqW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SYNC_ID` reader - SYNC_ID"] pub type SyncIdR = crate :: FieldReader ;
#[doc = "Field `SYNC_ID` writer - SYNC_ID"] pub type SyncIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& self) -> DmareqIdR { DmareqIdR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& self) -> SoieR { SoieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& self) -> EgeR { EgeR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& self) -> SeR { SeR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& self) -> SpolR { SpolR :: new (((self . bits >> 17) & 3) as u8) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& self) -> NbreqR { NbreqR :: new (((self . bits >> 19) & 0x1f) as u8) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& self) -> SyncIdR { SyncIdR :: new (((self . bits >> 24) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& mut self) -> DmareqIdW < '_ , C8crSpec > { DmareqIdW :: new (self , 0) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& mut self) -> SoieW < '_ , C8crSpec > { SoieW :: new (self , 8) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& mut self) -> EgeW < '_ , C8crSpec > { EgeW :: new (self , 9) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& mut self) -> SeW < '_ , C8crSpec > { SeW :: new (self , 16) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& mut self) -> SpolW < '_ , C8crSpec > { SpolW :: new (self , 17) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& mut self) -> NbreqW < '_ , C8crSpec > { NbreqW :: new (self , 19) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& mut self) -> SyncIdW < '_ , C8crSpec > { SyncIdW :: new (self , 24) } }
#[doc = "DMA Multiplexer Channel 8 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c8cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c8cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C8crSpec ; impl crate :: RegisterSpec for C8crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c8cr::R`](R) reader structure"] impl crate :: Readable for C8crSpec { }
#[doc = "`write(|w| ..)` method takes [`c8cr::W`](W) writer structure"] impl crate :: Writable for C8crSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C8CR to value 0"] impl crate :: Resettable for C8crSpec { } }
#[doc = "C9CR (rw) register accessor: DMA Multiplexer Channel 9 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c9cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c9cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c9cr`] module"]
#[doc (alias = "C9CR")] pub type C9cr = crate :: Reg < c9cr :: C9crSpec > ;
#[doc = "DMA Multiplexer Channel 9 Control register"] pub mod c9cr {
#[doc = "Register `C9CR` reader"] pub type R = crate :: R < C9crSpec > ;
#[doc = "Register `C9CR` writer"] pub type W = crate :: W < C9crSpec > ;
#[doc = "Field `DMAREQ_ID` reader - DMA Request ID"] pub type DmareqIdR = crate :: FieldReader ;
#[doc = "Field `DMAREQ_ID` writer - DMA Request ID"] pub type DmareqIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `SOIE` reader - Synchronization Overrun Interrupt Enable"] pub type SoieR = crate :: BitReader ;
#[doc = "Field `SOIE` writer - Synchronization Overrun Interrupt Enable"] pub type SoieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EGE` reader - Event Generation Enable"] pub type EgeR = crate :: BitReader ;
#[doc = "Field `EGE` writer - Event Generation Enable"] pub type EgeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SE` reader - Synchronization enable"] pub type SeR = crate :: BitReader ;
#[doc = "Field `SE` writer - Synchronization enable"] pub type SeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPOL` reader - Sync polarity"] pub type SpolR = crate :: FieldReader ;
#[doc = "Field `SPOL` writer - Sync polarity"] pub type SpolW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `NBREQ` reader - Nb request"] pub type NbreqR = crate :: FieldReader ;
#[doc = "Field `NBREQ` writer - Nb request"] pub type NbreqW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SYNC_ID` reader - SYNC_ID"] pub type SyncIdR = crate :: FieldReader ;
#[doc = "Field `SYNC_ID` writer - SYNC_ID"] pub type SyncIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& self) -> DmareqIdR { DmareqIdR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& self) -> SoieR { SoieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& self) -> EgeR { EgeR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& self) -> SeR { SeR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& self) -> SpolR { SpolR :: new (((self . bits >> 17) & 3) as u8) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& self) -> NbreqR { NbreqR :: new (((self . bits >> 19) & 0x1f) as u8) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& self) -> SyncIdR { SyncIdR :: new (((self . bits >> 24) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& mut self) -> DmareqIdW < '_ , C9crSpec > { DmareqIdW :: new (self , 0) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& mut self) -> SoieW < '_ , C9crSpec > { SoieW :: new (self , 8) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& mut self) -> EgeW < '_ , C9crSpec > { EgeW :: new (self , 9) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& mut self) -> SeW < '_ , C9crSpec > { SeW :: new (self , 16) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& mut self) -> SpolW < '_ , C9crSpec > { SpolW :: new (self , 17) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& mut self) -> NbreqW < '_ , C9crSpec > { NbreqW :: new (self , 19) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& mut self) -> SyncIdW < '_ , C9crSpec > { SyncIdW :: new (self , 24) } }
#[doc = "DMA Multiplexer Channel 9 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c9cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c9cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C9crSpec ; impl crate :: RegisterSpec for C9crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c9cr::R`](R) reader structure"] impl crate :: Readable for C9crSpec { }
#[doc = "`write(|w| ..)` method takes [`c9cr::W`](W) writer structure"] impl crate :: Writable for C9crSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C9CR to value 0"] impl crate :: Resettable for C9crSpec { } }
#[doc = "C10CR (rw) register accessor: DMA Multiplexer Channel 10 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c10cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c10cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c10cr`] module"]
#[doc (alias = "C10CR")] pub type C10cr = crate :: Reg < c10cr :: C10crSpec > ;
#[doc = "DMA Multiplexer Channel 10 Control register"] pub mod c10cr {
#[doc = "Register `C10CR` reader"] pub type R = crate :: R < C10crSpec > ;
#[doc = "Register `C10CR` writer"] pub type W = crate :: W < C10crSpec > ;
#[doc = "Field `DMAREQ_ID` reader - DMA Request ID"] pub type DmareqIdR = crate :: FieldReader ;
#[doc = "Field `DMAREQ_ID` writer - DMA Request ID"] pub type DmareqIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `SOIE` reader - Synchronization Overrun Interrupt Enable"] pub type SoieR = crate :: BitReader ;
#[doc = "Field `SOIE` writer - Synchronization Overrun Interrupt Enable"] pub type SoieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EGE` reader - Event Generation Enable"] pub type EgeR = crate :: BitReader ;
#[doc = "Field `EGE` writer - Event Generation Enable"] pub type EgeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SE` reader - Synchronization enable"] pub type SeR = crate :: BitReader ;
#[doc = "Field `SE` writer - Synchronization enable"] pub type SeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPOL` reader - Sync polarity"] pub type SpolR = crate :: FieldReader ;
#[doc = "Field `SPOL` writer - Sync polarity"] pub type SpolW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `NBREQ` reader - Nb request"] pub type NbreqR = crate :: FieldReader ;
#[doc = "Field `NBREQ` writer - Nb request"] pub type NbreqW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SYNC_ID` reader - SYNC_ID"] pub type SyncIdR = crate :: FieldReader ;
#[doc = "Field `SYNC_ID` writer - SYNC_ID"] pub type SyncIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& self) -> DmareqIdR { DmareqIdR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& self) -> SoieR { SoieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& self) -> EgeR { EgeR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& self) -> SeR { SeR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& self) -> SpolR { SpolR :: new (((self . bits >> 17) & 3) as u8) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& self) -> NbreqR { NbreqR :: new (((self . bits >> 19) & 0x1f) as u8) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& self) -> SyncIdR { SyncIdR :: new (((self . bits >> 24) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& mut self) -> DmareqIdW < '_ , C10crSpec > { DmareqIdW :: new (self , 0) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& mut self) -> SoieW < '_ , C10crSpec > { SoieW :: new (self , 8) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& mut self) -> EgeW < '_ , C10crSpec > { EgeW :: new (self , 9) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& mut self) -> SeW < '_ , C10crSpec > { SeW :: new (self , 16) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& mut self) -> SpolW < '_ , C10crSpec > { SpolW :: new (self , 17) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& mut self) -> NbreqW < '_ , C10crSpec > { NbreqW :: new (self , 19) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& mut self) -> SyncIdW < '_ , C10crSpec > { SyncIdW :: new (self , 24) } }
#[doc = "DMA Multiplexer Channel 10 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c10cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c10cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C10crSpec ; impl crate :: RegisterSpec for C10crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c10cr::R`](R) reader structure"] impl crate :: Readable for C10crSpec { }
#[doc = "`write(|w| ..)` method takes [`c10cr::W`](W) writer structure"] impl crate :: Writable for C10crSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C10CR to value 0"] impl crate :: Resettable for C10crSpec { } }
#[doc = "C11CR (rw) register accessor: DMA Multiplexer Channel 11 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c11cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c11cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c11cr`] module"]
#[doc (alias = "C11CR")] pub type C11cr = crate :: Reg < c11cr :: C11crSpec > ;
#[doc = "DMA Multiplexer Channel 11 Control register"] pub mod c11cr {
#[doc = "Register `C11CR` reader"] pub type R = crate :: R < C11crSpec > ;
#[doc = "Register `C11CR` writer"] pub type W = crate :: W < C11crSpec > ;
#[doc = "Field `DMAREQ_ID` reader - DMA Request ID"] pub type DmareqIdR = crate :: FieldReader ;
#[doc = "Field `DMAREQ_ID` writer - DMA Request ID"] pub type DmareqIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `SOIE` reader - Synchronization Overrun Interrupt Enable"] pub type SoieR = crate :: BitReader ;
#[doc = "Field `SOIE` writer - Synchronization Overrun Interrupt Enable"] pub type SoieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EGE` reader - Event Generation Enable"] pub type EgeR = crate :: BitReader ;
#[doc = "Field `EGE` writer - Event Generation Enable"] pub type EgeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SE` reader - Synchronization enable"] pub type SeR = crate :: BitReader ;
#[doc = "Field `SE` writer - Synchronization enable"] pub type SeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPOL` reader - Sync polarity"] pub type SpolR = crate :: FieldReader ;
#[doc = "Field `SPOL` writer - Sync polarity"] pub type SpolW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `NBREQ` reader - Nb request"] pub type NbreqR = crate :: FieldReader ;
#[doc = "Field `NBREQ` writer - Nb request"] pub type NbreqW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SYNC_ID` reader - SYNC_ID"] pub type SyncIdR = crate :: FieldReader ;
#[doc = "Field `SYNC_ID` writer - SYNC_ID"] pub type SyncIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& self) -> DmareqIdR { DmareqIdR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& self) -> SoieR { SoieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& self) -> EgeR { EgeR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& self) -> SeR { SeR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& self) -> SpolR { SpolR :: new (((self . bits >> 17) & 3) as u8) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& self) -> NbreqR { NbreqR :: new (((self . bits >> 19) & 0x1f) as u8) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& self) -> SyncIdR { SyncIdR :: new (((self . bits >> 24) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& mut self) -> DmareqIdW < '_ , C11crSpec > { DmareqIdW :: new (self , 0) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& mut self) -> SoieW < '_ , C11crSpec > { SoieW :: new (self , 8) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& mut self) -> EgeW < '_ , C11crSpec > { EgeW :: new (self , 9) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& mut self) -> SeW < '_ , C11crSpec > { SeW :: new (self , 16) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& mut self) -> SpolW < '_ , C11crSpec > { SpolW :: new (self , 17) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& mut self) -> NbreqW < '_ , C11crSpec > { NbreqW :: new (self , 19) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& mut self) -> SyncIdW < '_ , C11crSpec > { SyncIdW :: new (self , 24) } }
#[doc = "DMA Multiplexer Channel 11 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c11cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c11cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C11crSpec ; impl crate :: RegisterSpec for C11crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c11cr::R`](R) reader structure"] impl crate :: Readable for C11crSpec { }
#[doc = "`write(|w| ..)` method takes [`c11cr::W`](W) writer structure"] impl crate :: Writable for C11crSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C11CR to value 0"] impl crate :: Resettable for C11crSpec { } }
#[doc = "C12CR (rw) register accessor: DMA Multiplexer Channel 12 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c12cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c12cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c12cr`] module"]
#[doc (alias = "C12CR")] pub type C12cr = crate :: Reg < c12cr :: C12crSpec > ;
#[doc = "DMA Multiplexer Channel 12 Control register"] pub mod c12cr {
#[doc = "Register `C12CR` reader"] pub type R = crate :: R < C12crSpec > ;
#[doc = "Register `C12CR` writer"] pub type W = crate :: W < C12crSpec > ;
#[doc = "Field `DMAREQ_ID` reader - DMA Request ID"] pub type DmareqIdR = crate :: FieldReader ;
#[doc = "Field `DMAREQ_ID` writer - DMA Request ID"] pub type DmareqIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `SOIE` reader - Synchronization Overrun Interrupt Enable"] pub type SoieR = crate :: BitReader ;
#[doc = "Field `SOIE` writer - Synchronization Overrun Interrupt Enable"] pub type SoieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EGE` reader - Event Generation Enable"] pub type EgeR = crate :: BitReader ;
#[doc = "Field `EGE` writer - Event Generation Enable"] pub type EgeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SE` reader - Synchronization enable"] pub type SeR = crate :: BitReader ;
#[doc = "Field `SE` writer - Synchronization enable"] pub type SeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPOL` reader - Sync polarity"] pub type SpolR = crate :: FieldReader ;
#[doc = "Field `SPOL` writer - Sync polarity"] pub type SpolW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `NBREQ` reader - Nb request"] pub type NbreqR = crate :: FieldReader ;
#[doc = "Field `NBREQ` writer - Nb request"] pub type NbreqW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SYNC_ID` reader - SYNC_ID"] pub type SyncIdR = crate :: FieldReader ;
#[doc = "Field `SYNC_ID` writer - SYNC_ID"] pub type SyncIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& self) -> DmareqIdR { DmareqIdR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& self) -> SoieR { SoieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& self) -> EgeR { EgeR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& self) -> SeR { SeR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& self) -> SpolR { SpolR :: new (((self . bits >> 17) & 3) as u8) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& self) -> NbreqR { NbreqR :: new (((self . bits >> 19) & 0x1f) as u8) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& self) -> SyncIdR { SyncIdR :: new (((self . bits >> 24) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& mut self) -> DmareqIdW < '_ , C12crSpec > { DmareqIdW :: new (self , 0) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& mut self) -> SoieW < '_ , C12crSpec > { SoieW :: new (self , 8) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& mut self) -> EgeW < '_ , C12crSpec > { EgeW :: new (self , 9) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& mut self) -> SeW < '_ , C12crSpec > { SeW :: new (self , 16) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& mut self) -> SpolW < '_ , C12crSpec > { SpolW :: new (self , 17) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& mut self) -> NbreqW < '_ , C12crSpec > { NbreqW :: new (self , 19) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& mut self) -> SyncIdW < '_ , C12crSpec > { SyncIdW :: new (self , 24) } }
#[doc = "DMA Multiplexer Channel 12 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c12cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c12cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C12crSpec ; impl crate :: RegisterSpec for C12crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c12cr::R`](R) reader structure"] impl crate :: Readable for C12crSpec { }
#[doc = "`write(|w| ..)` method takes [`c12cr::W`](W) writer structure"] impl crate :: Writable for C12crSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C12CR to value 0"] impl crate :: Resettable for C12crSpec { } }
#[doc = "C13CR (rw) register accessor: DMA Multiplexer Channel 13 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c13cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c13cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c13cr`] module"]
#[doc (alias = "C13CR")] pub type C13cr = crate :: Reg < c13cr :: C13crSpec > ;
#[doc = "DMA Multiplexer Channel 13 Control register"] pub mod c13cr {
#[doc = "Register `C13CR` reader"] pub type R = crate :: R < C13crSpec > ;
#[doc = "Register `C13CR` writer"] pub type W = crate :: W < C13crSpec > ;
#[doc = "Field `DMAREQ_ID` reader - DMA Request ID"] pub type DmareqIdR = crate :: FieldReader ;
#[doc = "Field `DMAREQ_ID` writer - DMA Request ID"] pub type DmareqIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `SOIE` reader - Synchronization Overrun Interrupt Enable"] pub type SoieR = crate :: BitReader ;
#[doc = "Field `SOIE` writer - Synchronization Overrun Interrupt Enable"] pub type SoieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EGE` reader - Event Generation Enable"] pub type EgeR = crate :: BitReader ;
#[doc = "Field `EGE` writer - Event Generation Enable"] pub type EgeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SE` reader - Synchronization enable"] pub type SeR = crate :: BitReader ;
#[doc = "Field `SE` writer - Synchronization enable"] pub type SeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPOL` reader - Sync polarity"] pub type SpolR = crate :: FieldReader ;
#[doc = "Field `SPOL` writer - Sync polarity"] pub type SpolW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `NBREQ` reader - Nb request"] pub type NbreqR = crate :: FieldReader ;
#[doc = "Field `NBREQ` writer - Nb request"] pub type NbreqW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SYNC_ID` reader - SYNC_ID"] pub type SyncIdR = crate :: FieldReader ;
#[doc = "Field `SYNC_ID` writer - SYNC_ID"] pub type SyncIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& self) -> DmareqIdR { DmareqIdR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& self) -> SoieR { SoieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& self) -> EgeR { EgeR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& self) -> SeR { SeR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& self) -> SpolR { SpolR :: new (((self . bits >> 17) & 3) as u8) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& self) -> NbreqR { NbreqR :: new (((self . bits >> 19) & 0x1f) as u8) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& self) -> SyncIdR { SyncIdR :: new (((self . bits >> 24) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:7 - DMA Request ID"]
#[inline (always)] pub fn dmareq_id (& mut self) -> DmareqIdW < '_ , C13crSpec > { DmareqIdW :: new (self , 0) }
#[doc = "Bit 8 - Synchronization Overrun Interrupt Enable"]
#[inline (always)] pub fn soie (& mut self) -> SoieW < '_ , C13crSpec > { SoieW :: new (self , 8) }
#[doc = "Bit 9 - Event Generation Enable"]
#[inline (always)] pub fn ege (& mut self) -> EgeW < '_ , C13crSpec > { EgeW :: new (self , 9) }
#[doc = "Bit 16 - Synchronization enable"]
#[inline (always)] pub fn se (& mut self) -> SeW < '_ , C13crSpec > { SeW :: new (self , 16) }
#[doc = "Bits 17:18 - Sync polarity"]
#[inline (always)] pub fn spol (& mut self) -> SpolW < '_ , C13crSpec > { SpolW :: new (self , 17) }
#[doc = "Bits 19:23 - Nb request"]
#[inline (always)] pub fn nbreq (& mut self) -> NbreqW < '_ , C13crSpec > { NbreqW :: new (self , 19) }
#[doc = "Bits 24:28 - SYNC_ID"]
#[inline (always)] pub fn sync_id (& mut self) -> SyncIdW < '_ , C13crSpec > { SyncIdW :: new (self , 24) } }
#[doc = "DMA Multiplexer Channel 13 Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c13cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c13cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C13crSpec ; impl crate :: RegisterSpec for C13crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c13cr::R`](R) reader structure"] impl crate :: Readable for C13crSpec { }
#[doc = "`write(|w| ..)` method takes [`c13cr::W`](W) writer structure"] impl crate :: Writable for C13crSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C13CR to value 0"] impl crate :: Resettable for C13crSpec { } }
#[doc = "CSR (r) register accessor: DMA Multiplexer Channel Status register\n\nYou can [`read`](crate::Reg::read) this register and get [`csr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@csr`] module"]
#[doc (alias = "CSR")] pub type Csr = crate :: Reg < csr :: CsrSpec > ;
#[doc = "DMA Multiplexer Channel Status register"] pub mod csr {
#[doc = "Register `CSR` reader"] pub type R = crate :: R < CsrSpec > ;
#[doc = "Field `SOF0` reader - Synchronization Overrun Flag 0"] pub type Sof0R = crate :: BitReader ;
#[doc = "Field `SOF1` reader - Synchronization Overrun Flag 1"] pub type Sof1R = crate :: BitReader ;
#[doc = "Field `SOF2` reader - Synchronization Overrun Flag 2"] pub type Sof2R = crate :: BitReader ;
#[doc = "Field `SOF3` reader - Synchronization Overrun Flag 3"] pub type Sof3R = crate :: BitReader ;
#[doc = "Field `SOF4` reader - Synchronization Overrun Flag 4"] pub type Sof4R = crate :: BitReader ;
#[doc = "Field `SOF5` reader - Synchronization Overrun Flag 5"] pub type Sof5R = crate :: BitReader ;
#[doc = "Field `SOF6` reader - Synchronization Overrun Flag 6"] pub type Sof6R = crate :: BitReader ;
#[doc = "Field `SOF7` reader - Synchronization Overrun Flag 7"] pub type Sof7R = crate :: BitReader ;
#[doc = "Field `SOF8` reader - Synchronization Overrun Flag 8"] pub type Sof8R = crate :: BitReader ;
#[doc = "Field `SOF9` reader - Synchronization Overrun Flag 9"] pub type Sof9R = crate :: BitReader ;
#[doc = "Field `SOF10` reader - Synchronization Overrun Flag 10"] pub type Sof10R = crate :: BitReader ;
#[doc = "Field `SOF11` reader - Synchronization Overrun Flag 11"] pub type Sof11R = crate :: BitReader ;
#[doc = "Field `SOF12` reader - Synchronization Overrun Flag 12"] pub type Sof12R = crate :: BitReader ;
#[doc = "Field `SOF13` reader - Synchronization Overrun Flag 13"] pub type Sof13R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Synchronization Overrun Flag 0"]
#[inline (always)] pub fn sof0 (& self) -> Sof0R { Sof0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Synchronization Overrun Flag 1"]
#[inline (always)] pub fn sof1 (& self) -> Sof1R { Sof1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Synchronization Overrun Flag 2"]
#[inline (always)] pub fn sof2 (& self) -> Sof2R { Sof2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Synchronization Overrun Flag 3"]
#[inline (always)] pub fn sof3 (& self) -> Sof3R { Sof3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Synchronization Overrun Flag 4"]
#[inline (always)] pub fn sof4 (& self) -> Sof4R { Sof4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Synchronization Overrun Flag 5"]
#[inline (always)] pub fn sof5 (& self) -> Sof5R { Sof5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Synchronization Overrun Flag 6"]
#[inline (always)] pub fn sof6 (& self) -> Sof6R { Sof6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Synchronization Overrun Flag 7"]
#[inline (always)] pub fn sof7 (& self) -> Sof7R { Sof7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Synchronization Overrun Flag 8"]
#[inline (always)] pub fn sof8 (& self) -> Sof8R { Sof8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Synchronization Overrun Flag 9"]
#[inline (always)] pub fn sof9 (& self) -> Sof9R { Sof9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Synchronization Overrun Flag 10"]
#[inline (always)] pub fn sof10 (& self) -> Sof10R { Sof10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Synchronization Overrun Flag 11"]
#[inline (always)] pub fn sof11 (& self) -> Sof11R { Sof11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Synchronization Overrun Flag 12"]
#[inline (always)] pub fn sof12 (& self) -> Sof12R { Sof12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Synchronization Overrun Flag 13"]
#[inline (always)] pub fn sof13 (& self) -> Sof13R { Sof13R :: new (((self . bits >> 13) & 1) != 0) } }
#[doc = "DMA Multiplexer Channel Status register\n\nYou can [`read`](crate::Reg::read) this register and get [`csr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CsrSpec ; impl crate :: RegisterSpec for CsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`csr::R`](R) reader structure"] impl crate :: Readable for CsrSpec { }
#[doc = "`reset()` method sets CSR to value 0"] impl crate :: Resettable for CsrSpec { } }
#[doc = "CFR (w) register accessor: DMA Channel Clear Flag Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfr`] module"]
#[doc (alias = "CFR")] pub type Cfr = crate :: Reg < cfr :: CfrSpec > ;
#[doc = "DMA Channel Clear Flag Register"] pub mod cfr {
#[doc = "Register `CFR` writer"] pub type W = crate :: W < CfrSpec > ;
#[doc = "Field `CSOF0` writer - Synchronization Clear Overrun Flag 0"] pub type Csof0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CSOF1` writer - Synchronization Clear Overrun Flag 1"] pub type Csof1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CSOF2` writer - Synchronization Clear Overrun Flag 2"] pub type Csof2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CSOF3` writer - Synchronization Clear Overrun Flag 3"] pub type Csof3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CSOF4` writer - Synchronization Clear Overrun Flag 4"] pub type Csof4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CSOF5` writer - Synchronization Clear Overrun Flag 5"] pub type Csof5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CSOF6` writer - Synchronization Clear Overrun Flag 6"] pub type Csof6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CSOF7` writer - Synchronization Clear Overrun Flag 7"] pub type Csof7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CSOF8` writer - Synchronization Clear Overrun Flag 8"] pub type Csof8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CSOF9` writer - Synchronization Clear Overrun Flag 9"] pub type Csof9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CSOF10` writer - Synchronization Clear Overrun Flag 10"] pub type Csof10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CSOF11` writer - Synchronization Clear Overrun Flag 11"] pub type Csof11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CSOF12` writer - Synchronization Clear Overrun Flag 12"] pub type Csof12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CSOF13` writer - Synchronization Clear Overrun Flag 13"] pub type Csof13W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Synchronization Clear Overrun Flag 0"]
#[inline (always)] pub fn csof0 (& mut self) -> Csof0W < '_ , CfrSpec > { Csof0W :: new (self , 0) }
#[doc = "Bit 1 - Synchronization Clear Overrun Flag 1"]
#[inline (always)] pub fn csof1 (& mut self) -> Csof1W < '_ , CfrSpec > { Csof1W :: new (self , 1) }
#[doc = "Bit 2 - Synchronization Clear Overrun Flag 2"]
#[inline (always)] pub fn csof2 (& mut self) -> Csof2W < '_ , CfrSpec > { Csof2W :: new (self , 2) }
#[doc = "Bit 3 - Synchronization Clear Overrun Flag 3"]
#[inline (always)] pub fn csof3 (& mut self) -> Csof3W < '_ , CfrSpec > { Csof3W :: new (self , 3) }
#[doc = "Bit 4 - Synchronization Clear Overrun Flag 4"]
#[inline (always)] pub fn csof4 (& mut self) -> Csof4W < '_ , CfrSpec > { Csof4W :: new (self , 4) }
#[doc = "Bit 5 - Synchronization Clear Overrun Flag 5"]
#[inline (always)] pub fn csof5 (& mut self) -> Csof5W < '_ , CfrSpec > { Csof5W :: new (self , 5) }
#[doc = "Bit 6 - Synchronization Clear Overrun Flag 6"]
#[inline (always)] pub fn csof6 (& mut self) -> Csof6W < '_ , CfrSpec > { Csof6W :: new (self , 6) }
#[doc = "Bit 7 - Synchronization Clear Overrun Flag 7"]
#[inline (always)] pub fn csof7 (& mut self) -> Csof7W < '_ , CfrSpec > { Csof7W :: new (self , 7) }
#[doc = "Bit 8 - Synchronization Clear Overrun Flag 8"]
#[inline (always)] pub fn csof8 (& mut self) -> Csof8W < '_ , CfrSpec > { Csof8W :: new (self , 8) }
#[doc = "Bit 9 - Synchronization Clear Overrun Flag 9"]
#[inline (always)] pub fn csof9 (& mut self) -> Csof9W < '_ , CfrSpec > { Csof9W :: new (self , 9) }
#[doc = "Bit 10 - Synchronization Clear Overrun Flag 10"]
#[inline (always)] pub fn csof10 (& mut self) -> Csof10W < '_ , CfrSpec > { Csof10W :: new (self , 10) }
#[doc = "Bit 11 - Synchronization Clear Overrun Flag 11"]
#[inline (always)] pub fn csof11 (& mut self) -> Csof11W < '_ , CfrSpec > { Csof11W :: new (self , 11) }
#[doc = "Bit 12 - Synchronization Clear Overrun Flag 12"]
#[inline (always)] pub fn csof12 (& mut self) -> Csof12W < '_ , CfrSpec > { Csof12W :: new (self , 12) }
#[doc = "Bit 13 - Synchronization Clear Overrun Flag 13"]
#[inline (always)] pub fn csof13 (& mut self) -> Csof13W < '_ , CfrSpec > { Csof13W :: new (self , 13) } }
#[doc = "DMA Channel Clear Flag Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CfrSpec ; impl crate :: RegisterSpec for CfrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`cfr::W`](W) writer structure"] impl crate :: Writable for CfrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CFR to value 0"] impl crate :: Resettable for CfrSpec { } }
#[doc = "RG0CR (rw) register accessor: DMA Request Generator 0 Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rg0cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rg0cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rg0cr`] module"]
#[doc (alias = "RG0CR")] pub type Rg0cr = crate :: Reg < rg0cr :: Rg0crSpec > ;
#[doc = "DMA Request Generator 0 Control Register"] pub mod rg0cr {
#[doc = "Register `RG0CR` reader"] pub type R = crate :: R < Rg0crSpec > ;
#[doc = "Register `RG0CR` writer"] pub type W = crate :: W < Rg0crSpec > ;
#[doc = "Field `SIG_ID` reader - Signal ID"] pub type SigIdR = crate :: FieldReader ;
#[doc = "Field `SIG_ID` writer - Signal ID"] pub type SigIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `OIE` reader - Overrun Interrupt Enable"] pub type OieR = crate :: BitReader ;
#[doc = "Field `OIE` writer - Overrun Interrupt Enable"] pub type OieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GE` reader - Generation Enable"] pub type GeR = crate :: BitReader ;
#[doc = "Field `GE` writer - Generation Enable"] pub type GeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPOL` reader - Generation Polarity"] pub type GpolR = crate :: FieldReader ;
#[doc = "Field `GPOL` writer - Generation Polarity"] pub type GpolW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `GNBREQ` reader - Number of Request"] pub type GnbreqR = crate :: FieldReader ;
#[doc = "Field `GNBREQ` writer - Number of Request"] pub type GnbreqW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:4 - Signal ID"]
#[inline (always)] pub fn sig_id (& self) -> SigIdR { SigIdR :: new ((self . bits & 0x1f) as u8) }
#[doc = "Bit 8 - Overrun Interrupt Enable"]
#[inline (always)] pub fn oie (& self) -> OieR { OieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 16 - Generation Enable"]
#[inline (always)] pub fn ge (& self) -> GeR { GeR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:18 - Generation Polarity"]
#[inline (always)] pub fn gpol (& self) -> GpolR { GpolR :: new (((self . bits >> 17) & 3) as u8) }
#[doc = "Bits 19:23 - Number of Request"]
#[inline (always)] pub fn gnbreq (& self) -> GnbreqR { GnbreqR :: new (((self . bits >> 19) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:4 - Signal ID"]
#[inline (always)] pub fn sig_id (& mut self) -> SigIdW < '_ , Rg0crSpec > { SigIdW :: new (self , 0) }
#[doc = "Bit 8 - Overrun Interrupt Enable"]
#[inline (always)] pub fn oie (& mut self) -> OieW < '_ , Rg0crSpec > { OieW :: new (self , 8) }
#[doc = "Bit 16 - Generation Enable"]
#[inline (always)] pub fn ge (& mut self) -> GeW < '_ , Rg0crSpec > { GeW :: new (self , 16) }
#[doc = "Bits 17:18 - Generation Polarity"]
#[inline (always)] pub fn gpol (& mut self) -> GpolW < '_ , Rg0crSpec > { GpolW :: new (self , 17) }
#[doc = "Bits 19:23 - Number of Request"]
#[inline (always)] pub fn gnbreq (& mut self) -> GnbreqW < '_ , Rg0crSpec > { GnbreqW :: new (self , 19) } }
#[doc = "DMA Request Generator 0 Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rg0cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rg0cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rg0crSpec ; impl crate :: RegisterSpec for Rg0crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rg0cr::R`](R) reader structure"] impl crate :: Readable for Rg0crSpec { }
#[doc = "`write(|w| ..)` method takes [`rg0cr::W`](W) writer structure"] impl crate :: Writable for Rg0crSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RG0CR to value 0"] impl crate :: Resettable for Rg0crSpec { } }
#[doc = "RG1CR (rw) register accessor: DMA Request Generator 1 Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rg1cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rg1cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rg1cr`] module"]
#[doc (alias = "RG1CR")] pub type Rg1cr = crate :: Reg < rg1cr :: Rg1crSpec > ;
#[doc = "DMA Request Generator 1 Control Register"] pub mod rg1cr {
#[doc = "Register `RG1CR` reader"] pub type R = crate :: R < Rg1crSpec > ;
#[doc = "Register `RG1CR` writer"] pub type W = crate :: W < Rg1crSpec > ;
#[doc = "Field `SIG_ID` reader - Signal ID"] pub type SigIdR = crate :: FieldReader ;
#[doc = "Field `SIG_ID` writer - Signal ID"] pub type SigIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `OIE` reader - Overrun Interrupt Enable"] pub type OieR = crate :: BitReader ;
#[doc = "Field `OIE` writer - Overrun Interrupt Enable"] pub type OieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GE` reader - Generation Enable"] pub type GeR = crate :: BitReader ;
#[doc = "Field `GE` writer - Generation Enable"] pub type GeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPOL` reader - Generation Polarity"] pub type GpolR = crate :: FieldReader ;
#[doc = "Field `GPOL` writer - Generation Polarity"] pub type GpolW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `GNBREQ` reader - Number of Request"] pub type GnbreqR = crate :: FieldReader ;
#[doc = "Field `GNBREQ` writer - Number of Request"] pub type GnbreqW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:4 - Signal ID"]
#[inline (always)] pub fn sig_id (& self) -> SigIdR { SigIdR :: new ((self . bits & 0x1f) as u8) }
#[doc = "Bit 8 - Overrun Interrupt Enable"]
#[inline (always)] pub fn oie (& self) -> OieR { OieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 16 - Generation Enable"]
#[inline (always)] pub fn ge (& self) -> GeR { GeR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:18 - Generation Polarity"]
#[inline (always)] pub fn gpol (& self) -> GpolR { GpolR :: new (((self . bits >> 17) & 3) as u8) }
#[doc = "Bits 19:23 - Number of Request"]
#[inline (always)] pub fn gnbreq (& self) -> GnbreqR { GnbreqR :: new (((self . bits >> 19) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:4 - Signal ID"]
#[inline (always)] pub fn sig_id (& mut self) -> SigIdW < '_ , Rg1crSpec > { SigIdW :: new (self , 0) }
#[doc = "Bit 8 - Overrun Interrupt Enable"]
#[inline (always)] pub fn oie (& mut self) -> OieW < '_ , Rg1crSpec > { OieW :: new (self , 8) }
#[doc = "Bit 16 - Generation Enable"]
#[inline (always)] pub fn ge (& mut self) -> GeW < '_ , Rg1crSpec > { GeW :: new (self , 16) }
#[doc = "Bits 17:18 - Generation Polarity"]
#[inline (always)] pub fn gpol (& mut self) -> GpolW < '_ , Rg1crSpec > { GpolW :: new (self , 17) }
#[doc = "Bits 19:23 - Number of Request"]
#[inline (always)] pub fn gnbreq (& mut self) -> GnbreqW < '_ , Rg1crSpec > { GnbreqW :: new (self , 19) } }
#[doc = "DMA Request Generator 1 Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rg1cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rg1cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rg1crSpec ; impl crate :: RegisterSpec for Rg1crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rg1cr::R`](R) reader structure"] impl crate :: Readable for Rg1crSpec { }
#[doc = "`write(|w| ..)` method takes [`rg1cr::W`](W) writer structure"] impl crate :: Writable for Rg1crSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RG1CR to value 0"] impl crate :: Resettable for Rg1crSpec { } }
#[doc = "RG2CR (rw) register accessor: DMA Request Generator 2 Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rg2cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rg2cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rg2cr`] module"]
#[doc (alias = "RG2CR")] pub type Rg2cr = crate :: Reg < rg2cr :: Rg2crSpec > ;
#[doc = "DMA Request Generator 2 Control Register"] pub mod rg2cr {
#[doc = "Register `RG2CR` reader"] pub type R = crate :: R < Rg2crSpec > ;
#[doc = "Register `RG2CR` writer"] pub type W = crate :: W < Rg2crSpec > ;
#[doc = "Field `SIG_ID` reader - Signal ID"] pub type SigIdR = crate :: FieldReader ;
#[doc = "Field `SIG_ID` writer - Signal ID"] pub type SigIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `OIE` reader - Overrun Interrupt Enable"] pub type OieR = crate :: BitReader ;
#[doc = "Field `OIE` writer - Overrun Interrupt Enable"] pub type OieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GE` reader - Generation Enable"] pub type GeR = crate :: BitReader ;
#[doc = "Field `GE` writer - Generation Enable"] pub type GeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPOL` reader - Generation Polarity"] pub type GpolR = crate :: FieldReader ;
#[doc = "Field `GPOL` writer - Generation Polarity"] pub type GpolW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `GNBREQ` reader - Number of Request"] pub type GnbreqR = crate :: FieldReader ;
#[doc = "Field `GNBREQ` writer - Number of Request"] pub type GnbreqW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:4 - Signal ID"]
#[inline (always)] pub fn sig_id (& self) -> SigIdR { SigIdR :: new ((self . bits & 0x1f) as u8) }
#[doc = "Bit 8 - Overrun Interrupt Enable"]
#[inline (always)] pub fn oie (& self) -> OieR { OieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 16 - Generation Enable"]
#[inline (always)] pub fn ge (& self) -> GeR { GeR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:18 - Generation Polarity"]
#[inline (always)] pub fn gpol (& self) -> GpolR { GpolR :: new (((self . bits >> 17) & 3) as u8) }
#[doc = "Bits 19:23 - Number of Request"]
#[inline (always)] pub fn gnbreq (& self) -> GnbreqR { GnbreqR :: new (((self . bits >> 19) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:4 - Signal ID"]
#[inline (always)] pub fn sig_id (& mut self) -> SigIdW < '_ , Rg2crSpec > { SigIdW :: new (self , 0) }
#[doc = "Bit 8 - Overrun Interrupt Enable"]
#[inline (always)] pub fn oie (& mut self) -> OieW < '_ , Rg2crSpec > { OieW :: new (self , 8) }
#[doc = "Bit 16 - Generation Enable"]
#[inline (always)] pub fn ge (& mut self) -> GeW < '_ , Rg2crSpec > { GeW :: new (self , 16) }
#[doc = "Bits 17:18 - Generation Polarity"]
#[inline (always)] pub fn gpol (& mut self) -> GpolW < '_ , Rg2crSpec > { GpolW :: new (self , 17) }
#[doc = "Bits 19:23 - Number of Request"]
#[inline (always)] pub fn gnbreq (& mut self) -> GnbreqW < '_ , Rg2crSpec > { GnbreqW :: new (self , 19) } }
#[doc = "DMA Request Generator 2 Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rg2cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rg2cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rg2crSpec ; impl crate :: RegisterSpec for Rg2crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rg2cr::R`](R) reader structure"] impl crate :: Readable for Rg2crSpec { }
#[doc = "`write(|w| ..)` method takes [`rg2cr::W`](W) writer structure"] impl crate :: Writable for Rg2crSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RG2CR to value 0"] impl crate :: Resettable for Rg2crSpec { } }
#[doc = "RG3CR (rw) register accessor: DMA Request Generator 3 Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rg3cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rg3cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rg3cr`] module"]
#[doc (alias = "RG3CR")] pub type Rg3cr = crate :: Reg < rg3cr :: Rg3crSpec > ;
#[doc = "DMA Request Generator 3 Control Register"] pub mod rg3cr {
#[doc = "Register `RG3CR` reader"] pub type R = crate :: R < Rg3crSpec > ;
#[doc = "Register `RG3CR` writer"] pub type W = crate :: W < Rg3crSpec > ;
#[doc = "Field `SIG_ID` reader - Signal ID"] pub type SigIdR = crate :: FieldReader ;
#[doc = "Field `SIG_ID` writer - Signal ID"] pub type SigIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `OIE` reader - Overrun Interrupt Enable"] pub type OieR = crate :: BitReader ;
#[doc = "Field `OIE` writer - Overrun Interrupt Enable"] pub type OieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GE` reader - Generation Enable"] pub type GeR = crate :: BitReader ;
#[doc = "Field `GE` writer - Generation Enable"] pub type GeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPOL` reader - Generation Polarity"] pub type GpolR = crate :: FieldReader ;
#[doc = "Field `GPOL` writer - Generation Polarity"] pub type GpolW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `GNBREQ` reader - Number of Request"] pub type GnbreqR = crate :: FieldReader ;
#[doc = "Field `GNBREQ` writer - Number of Request"] pub type GnbreqW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:4 - Signal ID"]
#[inline (always)] pub fn sig_id (& self) -> SigIdR { SigIdR :: new ((self . bits & 0x1f) as u8) }
#[doc = "Bit 8 - Overrun Interrupt Enable"]
#[inline (always)] pub fn oie (& self) -> OieR { OieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 16 - Generation Enable"]
#[inline (always)] pub fn ge (& self) -> GeR { GeR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:18 - Generation Polarity"]
#[inline (always)] pub fn gpol (& self) -> GpolR { GpolR :: new (((self . bits >> 17) & 3) as u8) }
#[doc = "Bits 19:23 - Number of Request"]
#[inline (always)] pub fn gnbreq (& self) -> GnbreqR { GnbreqR :: new (((self . bits >> 19) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:4 - Signal ID"]
#[inline (always)] pub fn sig_id (& mut self) -> SigIdW < '_ , Rg3crSpec > { SigIdW :: new (self , 0) }
#[doc = "Bit 8 - Overrun Interrupt Enable"]
#[inline (always)] pub fn oie (& mut self) -> OieW < '_ , Rg3crSpec > { OieW :: new (self , 8) }
#[doc = "Bit 16 - Generation Enable"]
#[inline (always)] pub fn ge (& mut self) -> GeW < '_ , Rg3crSpec > { GeW :: new (self , 16) }
#[doc = "Bits 17:18 - Generation Polarity"]
#[inline (always)] pub fn gpol (& mut self) -> GpolW < '_ , Rg3crSpec > { GpolW :: new (self , 17) }
#[doc = "Bits 19:23 - Number of Request"]
#[inline (always)] pub fn gnbreq (& mut self) -> GnbreqW < '_ , Rg3crSpec > { GnbreqW :: new (self , 19) } }
#[doc = "DMA Request Generator 3 Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rg3cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rg3cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rg3crSpec ; impl crate :: RegisterSpec for Rg3crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rg3cr::R`](R) reader structure"] impl crate :: Readable for Rg3crSpec { }
#[doc = "`write(|w| ..)` method takes [`rg3cr::W`](W) writer structure"] impl crate :: Writable for Rg3crSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RG3CR to value 0"] impl crate :: Resettable for Rg3crSpec { } }
#[doc = "RGSR (r) register accessor: DMA Request Generator Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rgsr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rgsr`] module"]
#[doc (alias = "RGSR")] pub type Rgsr = crate :: Reg < rgsr :: RgsrSpec > ;
#[doc = "DMA Request Generator Status Register"] pub mod rgsr {
#[doc = "Register `RGSR` reader"] pub type R = crate :: R < RgsrSpec > ;
#[doc = "Field `OF0` reader - Generator Overrun Flag 0"] pub type Of0R = crate :: BitReader ;
#[doc = "Field `OF1` reader - Generator Overrun Flag 1"] pub type Of1R = crate :: BitReader ;
#[doc = "Field `OF2` reader - Generator Overrun Flag 2"] pub type Of2R = crate :: BitReader ;
#[doc = "Field `OF3` reader - Generator Overrun Flag 3"] pub type Of3R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Generator Overrun Flag 0"]
#[inline (always)] pub fn of0 (& self) -> Of0R { Of0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Generator Overrun Flag 1"]
#[inline (always)] pub fn of1 (& self) -> Of1R { Of1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Generator Overrun Flag 2"]
#[inline (always)] pub fn of2 (& self) -> Of2R { Of2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Generator Overrun Flag 3"]
#[inline (always)] pub fn of3 (& self) -> Of3R { Of3R :: new (((self . bits >> 3) & 1) != 0) } }
#[doc = "DMA Request Generator Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rgsr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RgsrSpec ; impl crate :: RegisterSpec for RgsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rgsr::R`](R) reader structure"] impl crate :: Readable for RgsrSpec { }
#[doc = "`reset()` method sets RGSR to value 0"] impl crate :: Resettable for RgsrSpec { } }
#[doc = "RGCFR (w) register accessor: DMA Request Generator Clear Flag Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rgcfr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rgcfr`] module"]
#[doc (alias = "RGCFR")] pub type Rgcfr = crate :: Reg < rgcfr :: RgcfrSpec > ;
#[doc = "DMA Request Generator Clear Flag Register"] pub mod rgcfr {
#[doc = "Register `RGCFR` writer"] pub type W = crate :: W < RgcfrSpec > ;
#[doc = "Field `COF0` writer - Clear trigger Overrun Flag 0"] pub type Cof0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COF1` writer - Clear trigger Overrun Flag 1"] pub type Cof1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COF2` writer - Clear trigger Overrun Flag 2"] pub type Cof2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COF3` writer - Clear trigger Overrun Flag 3"] pub type Cof3W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Clear trigger Overrun Flag 0"]
#[inline (always)] pub fn cof0 (& mut self) -> Cof0W < '_ , RgcfrSpec > { Cof0W :: new (self , 0) }
#[doc = "Bit 1 - Clear trigger Overrun Flag 1"]
#[inline (always)] pub fn cof1 (& mut self) -> Cof1W < '_ , RgcfrSpec > { Cof1W :: new (self , 1) }
#[doc = "Bit 2 - Clear trigger Overrun Flag 2"]
#[inline (always)] pub fn cof2 (& mut self) -> Cof2W < '_ , RgcfrSpec > { Cof2W :: new (self , 2) }
#[doc = "Bit 3 - Clear trigger Overrun Flag 3"]
#[inline (always)] pub fn cof3 (& mut self) -> Cof3W < '_ , RgcfrSpec > { Cof3W :: new (self , 3) } }
#[doc = "DMA Request Generator Clear Flag Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rgcfr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RgcfrSpec ; impl crate :: RegisterSpec for RgcfrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`rgcfr::W`](W) writer structure"] impl crate :: Writable for RgcfrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RGCFR to value 0"] impl crate :: Resettable for RgcfrSpec { } } }
#[doc = "Cyclic redundancy check calculation unit"] pub type Crc = crate :: Periph < crc :: RegisterBlock , 0x4002_3000 > ; impl core :: fmt :: Debug for Crc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Crc") . finish () } }
#[doc = "Cyclic redundancy check calculation unit"] pub mod crc {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { dr : Dr , idr : Idr , cr : Cr , _reserved3 : [u8 ; 0x04] , init : Init , pol : Pol , } impl RegisterBlock {
#[doc = "0x00 - Data register"]
#[inline (always)] pub const fn dr (& self) -> & Dr { & self . dr }
#[doc = "0x04 - Independent data register"]
#[inline (always)] pub const fn idr (& self) -> & Idr { & self . idr }
#[doc = "0x08 - Control register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x10 - Initial CRC value"]
#[inline (always)] pub const fn init (& self) -> & Init { & self . init }
#[doc = "0x14 - polynomial"]
#[inline (always)] pub const fn pol (& self) -> & Pol { & self . pol } }
#[doc = "DR (rw) register accessor: Data register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr`] module"]
#[doc (alias = "DR")] pub type Dr = crate :: Reg < dr :: DrSpec > ;
#[doc = "Data register"] pub mod dr {
#[doc = "Register `DR` reader"] pub type R = crate :: R < DrSpec > ;
#[doc = "Register `DR` writer"] pub type W = crate :: W < DrSpec > ;
#[doc = "Field `DR` reader - Data register bits"] pub type DrR = crate :: FieldReader < u32 > ;
#[doc = "Field `DR` writer - Data register bits"] pub type DrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Data register bits"]
#[inline (always)] pub fn dr (& self) -> DrR { DrR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Data register bits"]
#[inline (always)] pub fn dr (& mut self) -> DrW < '_ , DrSpec > { DrW :: new (self , 0) } }
#[doc = "Data register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DrSpec ; impl crate :: RegisterSpec for DrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr::R`](R) reader structure"] impl crate :: Readable for DrSpec { }
#[doc = "`write(|w| ..)` method takes [`dr::W`](W) writer structure"] impl crate :: Writable for DrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR to value 0xffff_ffff"] impl crate :: Resettable for DrSpec { const RESET_VALUE : u32 = 0xffff_ffff ; } }
#[doc = "IDR (rw) register accessor: Independent data register\n\nYou can [`read`](crate::Reg::read) this register and get [`idr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`idr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@idr`] module"]
#[doc (alias = "IDR")] pub type Idr = crate :: Reg < idr :: IdrSpec > ;
#[doc = "Independent data register"] pub mod idr {
#[doc = "Register `IDR` reader"] pub type R = crate :: R < IdrSpec > ;
#[doc = "Register `IDR` writer"] pub type W = crate :: W < IdrSpec > ;
#[doc = "Field `IDR` reader - General-purpose 32-bit data register bits"] pub type IdrR = crate :: FieldReader < u32 > ;
#[doc = "Field `IDR` writer - General-purpose 32-bit data register bits"] pub type IdrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - General-purpose 32-bit data register bits"]
#[inline (always)] pub fn idr (& self) -> IdrR { IdrR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - General-purpose 32-bit data register bits"]
#[inline (always)] pub fn idr (& mut self) -> IdrW < '_ , IdrSpec > { IdrW :: new (self , 0) } }
#[doc = "Independent data register\n\nYou can [`read`](crate::Reg::read) this register and get [`idr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`idr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IdrSpec ; impl crate :: RegisterSpec for IdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`idr::R`](R) reader structure"] impl crate :: Readable for IdrSpec { }
#[doc = "`write(|w| ..)` method takes [`idr::W`](W) writer structure"] impl crate :: Writable for IdrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IDR to value 0"] impl crate :: Resettable for IdrSpec { } }
#[doc = "CR (rw) register accessor: Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "Control register"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `RESET` reader - RESET bit"] pub type ResetR = crate :: BitReader ;
#[doc = "Field `RESET` writer - RESET bit"] pub type ResetW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `POLYSIZE` reader - Polynomial size"] pub type PolysizeR = crate :: FieldReader ;
#[doc = "Field `POLYSIZE` writer - Polynomial size"] pub type PolysizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `REV_IN` reader - Reverse input data"] pub type RevInR = crate :: FieldReader ;
#[doc = "Field `REV_IN` writer - Reverse input data"] pub type RevInW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `REV_OUT` reader - Reverse output data"] pub type RevOutR = crate :: BitReader ;
#[doc = "Field `REV_OUT` writer - Reverse output data"] pub type RevOutW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RESET bit"]
#[inline (always)] pub fn reset (& self) -> ResetR { ResetR :: new ((self . bits & 1) != 0) }
#[doc = "Bits 3:4 - Polynomial size"]
#[inline (always)] pub fn polysize (& self) -> PolysizeR { PolysizeR :: new (((self . bits >> 3) & 3) as u8) }
#[doc = "Bits 5:6 - Reverse input data"]
#[inline (always)] pub fn rev_in (& self) -> RevInR { RevInR :: new (((self . bits >> 5) & 3) as u8) }
#[doc = "Bit 7 - Reverse output data"]
#[inline (always)] pub fn rev_out (& self) -> RevOutR { RevOutR :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RESET bit"]
#[inline (always)] pub fn reset (& mut self) -> ResetW < '_ , CrSpec > { ResetW :: new (self , 0) }
#[doc = "Bits 3:4 - Polynomial size"]
#[inline (always)] pub fn polysize (& mut self) -> PolysizeW < '_ , CrSpec > { PolysizeW :: new (self , 3) }
#[doc = "Bits 5:6 - Reverse input data"]
#[inline (always)] pub fn rev_in (& mut self) -> RevInW < '_ , CrSpec > { RevInW :: new (self , 5) }
#[doc = "Bit 7 - Reverse output data"]
#[inline (always)] pub fn rev_out (& mut self) -> RevOutW < '_ , CrSpec > { RevOutW :: new (self , 7) } }
#[doc = "Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { } }
#[doc = "INIT (rw) register accessor: Initial CRC value\n\nYou can [`read`](crate::Reg::read) this register and get [`init::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`init::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@init`] module"]
#[doc (alias = "INIT")] pub type Init = crate :: Reg < init :: InitSpec > ;
#[doc = "Initial CRC value"] pub mod init {
#[doc = "Register `INIT` reader"] pub type R = crate :: R < InitSpec > ;
#[doc = "Register `INIT` writer"] pub type W = crate :: W < InitSpec > ;
#[doc = "Field `CRC_INIT` reader - Programmable initial CRC value"] pub type CrcInitR = crate :: FieldReader < u32 > ;
#[doc = "Field `CRC_INIT` writer - Programmable initial CRC value"] pub type CrcInitW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Programmable initial CRC value"]
#[inline (always)] pub fn crc_init (& self) -> CrcInitR { CrcInitR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Programmable initial CRC value"]
#[inline (always)] pub fn crc_init (& mut self) -> CrcInitW < '_ , InitSpec > { CrcInitW :: new (self , 0) } }
#[doc = "Initial CRC value\n\nYou can [`read`](crate::Reg::read) this register and get [`init::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`init::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct InitSpec ; impl crate :: RegisterSpec for InitSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`init::R`](R) reader structure"] impl crate :: Readable for InitSpec { }
#[doc = "`write(|w| ..)` method takes [`init::W`](W) writer structure"] impl crate :: Writable for InitSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INIT to value 0xffff_ffff"] impl crate :: Resettable for InitSpec { const RESET_VALUE : u32 = 0xffff_ffff ; } }
#[doc = "POL (rw) register accessor: polynomial\n\nYou can [`read`](crate::Reg::read) this register and get [`pol::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pol::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pol`] module"]
#[doc (alias = "POL")] pub type Pol = crate :: Reg < pol :: PolSpec > ;
#[doc = "polynomial"] pub mod pol {
#[doc = "Register `POL` reader"] pub type R = crate :: R < PolSpec > ;
#[doc = "Register `POL` writer"] pub type W = crate :: W < PolSpec > ;
#[doc = "Field `POL` reader - Programmable polynomial"] pub type PolR = crate :: FieldReader < u32 > ;
#[doc = "Field `POL` writer - Programmable polynomial"] pub type PolW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Programmable polynomial"]
#[inline (always)] pub fn pol (& self) -> PolR { PolR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Programmable polynomial"]
#[inline (always)] pub fn pol (& mut self) -> PolW < '_ , PolSpec > { PolW :: new (self , 0) } }
#[doc = "polynomial\n\nYou can [`read`](crate::Reg::read) this register and get [`pol::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pol::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PolSpec ; impl crate :: RegisterSpec for PolSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pol::R`](R) reader structure"] impl crate :: Readable for PolSpec { }
#[doc = "`write(|w| ..)` method takes [`pol::W`](W) writer structure"] impl crate :: Writable for PolSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets POL to value 0x04c1_1db7"] impl crate :: Resettable for PolSpec { const RESET_VALUE : u32 = 0x04c1_1db7 ; } } }
#[doc = "Liquid crystal display controller"] pub type Lcd = crate :: Periph < lcd :: RegisterBlock , 0x4000_2400 > ; impl core :: fmt :: Debug for Lcd { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Lcd") . finish () } }
#[doc = "Liquid crystal display controller"] pub mod lcd {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr : Cr , fcr : Fcr , sr : Sr , clr : Clr , _reserved4 : [u8 ; 0x04] , ram_com0 : RamCom0 , _reserved5 : [u8 ; 0x04] , ram_com1 : RamCom1 , _reserved6 : [u8 ; 0x04] , ram_com2 : RamCom2 , _reserved7 : [u8 ; 0x04] , ram_com3 : RamCom3 , _reserved8 : [u8 ; 0x04] , ram_com4 : RamCom4 , _reserved9 : [u8 ; 0x04] , ram_com5 : RamCom5 , _reserved10 : [u8 ; 0x04] , ram_com6 : RamCom6 , _reserved11 : [u8 ; 0x04] , ram_com7 : RamCom7 , } impl RegisterBlock {
#[doc = "0x00 - control register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x04 - frame control register"]
#[inline (always)] pub const fn fcr (& self) -> & Fcr { & self . fcr }
#[doc = "0x08 - status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x0c - clear register"]
#[inline (always)] pub const fn clr (& self) -> & Clr { & self . clr }
#[doc = "0x14 - display memory"]
#[inline (always)] pub const fn ram_com0 (& self) -> & RamCom0 { & self . ram_com0 }
#[doc = "0x1c - display memory"]
#[inline (always)] pub const fn ram_com1 (& self) -> & RamCom1 { & self . ram_com1 }
#[doc = "0x24 - display memory"]
#[inline (always)] pub const fn ram_com2 (& self) -> & RamCom2 { & self . ram_com2 }
#[doc = "0x2c - display memory"]
#[inline (always)] pub const fn ram_com3 (& self) -> & RamCom3 { & self . ram_com3 }
#[doc = "0x34 - display memory"]
#[inline (always)] pub const fn ram_com4 (& self) -> & RamCom4 { & self . ram_com4 }
#[doc = "0x3c - display memory"]
#[inline (always)] pub const fn ram_com5 (& self) -> & RamCom5 { & self . ram_com5 }
#[doc = "0x44 - display memory"]
#[inline (always)] pub const fn ram_com6 (& self) -> & RamCom6 { & self . ram_com6 }
#[doc = "0x4c - display memory"]
#[inline (always)] pub const fn ram_com7 (& self) -> & RamCom7 { & self . ram_com7 } }
#[doc = "CR (rw) register accessor: control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "control register"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `LCDEN` reader - LCD controller enable"] pub type LcdenR = crate :: BitReader ;
#[doc = "Field `LCDEN` writer - LCD controller enable"] pub type LcdenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `VSEL` reader - Voltage source selection"] pub type VselR = crate :: BitReader ;
#[doc = "Field `VSEL` writer - Voltage source selection"] pub type VselW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DUTY` reader - Duty selection"] pub type DutyR = crate :: FieldReader ;
#[doc = "Field `DUTY` writer - Duty selection"] pub type DutyW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `BIAS` reader - Bias selector"] pub type BiasR = crate :: FieldReader ;
#[doc = "Field `BIAS` writer - Bias selector"] pub type BiasW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MUX_SEG` reader - Mux segment enable"] pub type MuxSegR = crate :: BitReader ;
#[doc = "Field `MUX_SEG` writer - Mux segment enable"] pub type MuxSegW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BUFEN` reader - Voltage output buffer enable"] pub type BufenR = crate :: BitReader ;
#[doc = "Field `BUFEN` writer - Voltage output buffer enable"] pub type BufenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - LCD controller enable"]
#[inline (always)] pub fn lcden (& self) -> LcdenR { LcdenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Voltage source selection"]
#[inline (always)] pub fn vsel (& self) -> VselR { VselR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bits 2:4 - Duty selection"]
#[inline (always)] pub fn duty (& self) -> DutyR { DutyR :: new (((self . bits >> 2) & 7) as u8) }
#[doc = "Bits 5:6 - Bias selector"]
#[inline (always)] pub fn bias (& self) -> BiasR { BiasR :: new (((self . bits >> 5) & 3) as u8) }
#[doc = "Bit 7 - Mux segment enable"]
#[inline (always)] pub fn mux_seg (& self) -> MuxSegR { MuxSegR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Voltage output buffer enable"]
#[inline (always)] pub fn bufen (& self) -> BufenR { BufenR :: new (((self . bits >> 8) & 1) != 0) } } impl W {
#[doc = "Bit 0 - LCD controller enable"]
#[inline (always)] pub fn lcden (& mut self) -> LcdenW < '_ , CrSpec > { LcdenW :: new (self , 0) }
#[doc = "Bit 1 - Voltage source selection"]
#[inline (always)] pub fn vsel (& mut self) -> VselW < '_ , CrSpec > { VselW :: new (self , 1) }
#[doc = "Bits 2:4 - Duty selection"]
#[inline (always)] pub fn duty (& mut self) -> DutyW < '_ , CrSpec > { DutyW :: new (self , 2) }
#[doc = "Bits 5:6 - Bias selector"]
#[inline (always)] pub fn bias (& mut self) -> BiasW < '_ , CrSpec > { BiasW :: new (self , 5) }
#[doc = "Bit 7 - Mux segment enable"]
#[inline (always)] pub fn mux_seg (& mut self) -> MuxSegW < '_ , CrSpec > { MuxSegW :: new (self , 7) }
#[doc = "Bit 8 - Voltage output buffer enable"]
#[inline (always)] pub fn bufen (& mut self) -> BufenW < '_ , CrSpec > { BufenW :: new (self , 8) } }
#[doc = "control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { } }
#[doc = "FCR (rw) register accessor: frame control register\n\nYou can [`read`](crate::Reg::read) this register and get [`fcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fcr`] module"]
#[doc (alias = "FCR")] pub type Fcr = crate :: Reg < fcr :: FcrSpec > ;
#[doc = "frame control register"] pub mod fcr {
#[doc = "Register `FCR` reader"] pub type R = crate :: R < FcrSpec > ;
#[doc = "Register `FCR` writer"] pub type W = crate :: W < FcrSpec > ;
#[doc = "Field `HD` reader - High drive enable"] pub type HdR = crate :: BitReader ;
#[doc = "Field `HD` writer - High drive enable"] pub type HdW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SOFIE` reader - Start of frame interrupt enable"] pub type SofieR = crate :: BitReader ;
#[doc = "Field `SOFIE` writer - Start of frame interrupt enable"] pub type SofieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDDIE` reader - Update display done interrupt enable"] pub type UddieR = crate :: BitReader ;
#[doc = "Field `UDDIE` writer - Update display done interrupt enable"] pub type UddieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PON` reader - Pulse ON duration"] pub type PonR = crate :: FieldReader ;
#[doc = "Field `PON` writer - Pulse ON duration"] pub type PonW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `DEAD` reader - Dead time duration"] pub type DeadR = crate :: FieldReader ;
#[doc = "Field `DEAD` writer - Dead time duration"] pub type DeadW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `CC` reader - Contrast control"] pub type CcR = crate :: FieldReader ;
#[doc = "Field `CC` writer - Contrast control"] pub type CcW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `BLINKF` reader - Blink frequency selection"] pub type BlinkfR = crate :: FieldReader ;
#[doc = "Field `BLINKF` writer - Blink frequency selection"] pub type BlinkfW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `BLINK` reader - Blink mode selection"] pub type BlinkR = crate :: FieldReader ;
#[doc = "Field `BLINK` writer - Blink mode selection"] pub type BlinkW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DIV` reader - DIV clock divider"] pub type DivR = crate :: FieldReader ;
#[doc = "Field `DIV` writer - DIV clock divider"] pub type DivW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `PS` reader - PS 16-bit prescaler"] pub type PsR = crate :: FieldReader ;
#[doc = "Field `PS` writer - PS 16-bit prescaler"] pub type PsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bit 0 - High drive enable"]
#[inline (always)] pub fn hd (& self) -> HdR { HdR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Start of frame interrupt enable"]
#[inline (always)] pub fn sofie (& self) -> SofieR { SofieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - Update display done interrupt enable"]
#[inline (always)] pub fn uddie (& self) -> UddieR { UddieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Pulse ON duration"]
#[inline (always)] pub fn pon (& self) -> PonR { PonR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bits 7:9 - Dead time duration"]
#[inline (always)] pub fn dead (& self) -> DeadR { DeadR :: new (((self . bits >> 7) & 7) as u8) }
#[doc = "Bits 10:12 - Contrast control"]
#[inline (always)] pub fn cc (& self) -> CcR { CcR :: new (((self . bits >> 10) & 7) as u8) }
#[doc = "Bits 13:15 - Blink frequency selection"]
#[inline (always)] pub fn blinkf (& self) -> BlinkfR { BlinkfR :: new (((self . bits >> 13) & 7) as u8) }
#[doc = "Bits 16:17 - Blink mode selection"]
#[inline (always)] pub fn blink (& self) -> BlinkR { BlinkR :: new (((self . bits >> 16) & 3) as u8) }
#[doc = "Bits 18:21 - DIV clock divider"]
#[inline (always)] pub fn div (& self) -> DivR { DivR :: new (((self . bits >> 18) & 0x0f) as u8) }
#[doc = "Bits 22:25 - PS 16-bit prescaler"]
#[inline (always)] pub fn ps (& self) -> PsR { PsR :: new (((self . bits >> 22) & 0x0f) as u8) } } impl W {
#[doc = "Bit 0 - High drive enable"]
#[inline (always)] pub fn hd (& mut self) -> HdW < '_ , FcrSpec > { HdW :: new (self , 0) }
#[doc = "Bit 1 - Start of frame interrupt enable"]
#[inline (always)] pub fn sofie (& mut self) -> SofieW < '_ , FcrSpec > { SofieW :: new (self , 1) }
#[doc = "Bit 3 - Update display done interrupt enable"]
#[inline (always)] pub fn uddie (& mut self) -> UddieW < '_ , FcrSpec > { UddieW :: new (self , 3) }
#[doc = "Bits 4:6 - Pulse ON duration"]
#[inline (always)] pub fn pon (& mut self) -> PonW < '_ , FcrSpec > { PonW :: new (self , 4) }
#[doc = "Bits 7:9 - Dead time duration"]
#[inline (always)] pub fn dead (& mut self) -> DeadW < '_ , FcrSpec > { DeadW :: new (self , 7) }
#[doc = "Bits 10:12 - Contrast control"]
#[inline (always)] pub fn cc (& mut self) -> CcW < '_ , FcrSpec > { CcW :: new (self , 10) }
#[doc = "Bits 13:15 - Blink frequency selection"]
#[inline (always)] pub fn blinkf (& mut self) -> BlinkfW < '_ , FcrSpec > { BlinkfW :: new (self , 13) }
#[doc = "Bits 16:17 - Blink mode selection"]
#[inline (always)] pub fn blink (& mut self) -> BlinkW < '_ , FcrSpec > { BlinkW :: new (self , 16) }
#[doc = "Bits 18:21 - DIV clock divider"]
#[inline (always)] pub fn div (& mut self) -> DivW < '_ , FcrSpec > { DivW :: new (self , 18) }
#[doc = "Bits 22:25 - PS 16-bit prescaler"]
#[inline (always)] pub fn ps (& mut self) -> PsW < '_ , FcrSpec > { PsW :: new (self , 22) } }
#[doc = "frame control register\n\nYou can [`read`](crate::Reg::read) this register and get [`fcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FcrSpec ; impl crate :: RegisterSpec for FcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fcr::R`](R) reader structure"] impl crate :: Readable for FcrSpec { }
#[doc = "`write(|w| ..)` method takes [`fcr::W`](W) writer structure"] impl crate :: Writable for FcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FCR to value 0"] impl crate :: Resettable for FcrSpec { } }
#[doc = "SR (rw) register accessor: status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `ENS` reader - ENS"] pub type EnsR = crate :: BitReader ;
#[doc = "Field `SOF` reader - Start of frame flag"] pub type SofR = crate :: BitReader ;
#[doc = "Field `UDR` reader - Update display request"] pub type UdrR = crate :: BitReader ;
#[doc = "Field `UDR` writer - Update display request"] pub type UdrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDD` reader - Update Display Done"] pub type UddR = crate :: BitReader ;
#[doc = "Field `RDY` reader - Ready flag"] pub type RdyR = crate :: BitReader ;
#[doc = "Field `FCRSF` reader - LCD Frame Control Register Synchronization flag"] pub type FcrsfR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - ENS"]
#[inline (always)] pub fn ens (& self) -> EnsR { EnsR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Start of frame flag"]
#[inline (always)] pub fn sof (& self) -> SofR { SofR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Update display request"]
#[inline (always)] pub fn udr (& self) -> UdrR { UdrR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Update Display Done"]
#[inline (always)] pub fn udd (& self) -> UddR { UddR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Ready flag"]
#[inline (always)] pub fn rdy (& self) -> RdyR { RdyR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - LCD Frame Control Register Synchronization flag"]
#[inline (always)] pub fn fcrsf (& self) -> FcrsfR { FcrsfR :: new (((self . bits >> 5) & 1) != 0) } } impl W {
#[doc = "Bit 2 - Update display request"]
#[inline (always)] pub fn udr (& mut self) -> UdrW < '_ , SrSpec > { UdrW :: new (self , 2) } }
#[doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0x20"] impl crate :: Resettable for SrSpec { const RESET_VALUE : u32 = 0x20 ; } }
#[doc = "CLR (w) register accessor: clear register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clr`] module"]
#[doc (alias = "CLR")] pub type Clr = crate :: Reg < clr :: ClrSpec > ;
#[doc = "clear register"] pub mod clr {
#[doc = "Register `CLR` writer"] pub type W = crate :: W < ClrSpec > ;
#[doc = "Field `SOFC` writer - Start of frame flag clear"] pub type SofcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDDC` writer - Update display done clear"] pub type UddcW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 1 - Start of frame flag clear"]
#[inline (always)] pub fn sofc (& mut self) -> SofcW < '_ , ClrSpec > { SofcW :: new (self , 1) }
#[doc = "Bit 3 - Update display done clear"]
#[inline (always)] pub fn uddc (& mut self) -> UddcW < '_ , ClrSpec > { UddcW :: new (self , 3) } }
#[doc = "clear register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ClrSpec ; impl crate :: RegisterSpec for ClrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`clr::W`](W) writer structure"] impl crate :: Writable for ClrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CLR to value 0"] impl crate :: Resettable for ClrSpec { } }
#[doc = "RAM_COM0 (rw) register accessor: display memory\n\nYou can [`read`](crate::Reg::read) this register and get [`ram_com0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ram_com0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ram_com0`] module"]
#[doc (alias = "RAM_COM0")] pub type RamCom0 = crate :: Reg < ram_com0 :: RamCom0Spec > ;
#[doc = "display memory"] pub mod ram_com0 {
#[doc = "Register `RAM_COM0` reader"] pub type R = crate :: R < RamCom0Spec > ;
#[doc = "Register `RAM_COM0` writer"] pub type W = crate :: W < RamCom0Spec > ;
#[doc = "Field `S00` reader - S00"] pub type S00R = crate :: BitReader ;
#[doc = "Field `S00` writer - S00"] pub type S00W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S01` reader - S01"] pub type S01R = crate :: BitReader ;
#[doc = "Field `S01` writer - S01"] pub type S01W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S02` reader - S02"] pub type S02R = crate :: BitReader ;
#[doc = "Field `S02` writer - S02"] pub type S02W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S03` reader - S03"] pub type S03R = crate :: BitReader ;
#[doc = "Field `S03` writer - S03"] pub type S03W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S04` reader - S04"] pub type S04R = crate :: BitReader ;
#[doc = "Field `S04` writer - S04"] pub type S04W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S05` reader - S05"] pub type S05R = crate :: BitReader ;
#[doc = "Field `S05` writer - S05"] pub type S05W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S06` reader - S06"] pub type S06R = crate :: BitReader ;
#[doc = "Field `S06` writer - S06"] pub type S06W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S07` reader - S07"] pub type S07R = crate :: BitReader ;
#[doc = "Field `S07` writer - S07"] pub type S07W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S08` reader - S08"] pub type S08R = crate :: BitReader ;
#[doc = "Field `S08` writer - S08"] pub type S08W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S09` reader - S09"] pub type S09R = crate :: BitReader ;
#[doc = "Field `S09` writer - S09"] pub type S09W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S10` reader - S10"] pub type S10R = crate :: BitReader ;
#[doc = "Field `S10` writer - S10"] pub type S10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S11` reader - S11"] pub type S11R = crate :: BitReader ;
#[doc = "Field `S11` writer - S11"] pub type S11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S12` reader - S12"] pub type S12R = crate :: BitReader ;
#[doc = "Field `S12` writer - S12"] pub type S12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S13` reader - S13"] pub type S13R = crate :: BitReader ;
#[doc = "Field `S13` writer - S13"] pub type S13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S14` reader - S14"] pub type S14R = crate :: BitReader ;
#[doc = "Field `S14` writer - S14"] pub type S14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S15` reader - S15"] pub type S15R = crate :: BitReader ;
#[doc = "Field `S15` writer - S15"] pub type S15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S16` reader - S16"] pub type S16R = crate :: BitReader ;
#[doc = "Field `S16` writer - S16"] pub type S16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S17` reader - S17"] pub type S17R = crate :: BitReader ;
#[doc = "Field `S17` writer - S17"] pub type S17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S18` reader - S18"] pub type S18R = crate :: BitReader ;
#[doc = "Field `S18` writer - S18"] pub type S18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S19` reader - S19"] pub type S19R = crate :: BitReader ;
#[doc = "Field `S19` writer - S19"] pub type S19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S20` reader - S20"] pub type S20R = crate :: BitReader ;
#[doc = "Field `S20` writer - S20"] pub type S20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S21` reader - S21"] pub type S21R = crate :: BitReader ;
#[doc = "Field `S21` writer - S21"] pub type S21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S22` reader - S22"] pub type S22R = crate :: BitReader ;
#[doc = "Field `S22` writer - S22"] pub type S22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S23` reader - S23"] pub type S23R = crate :: BitReader ;
#[doc = "Field `S23` writer - S23"] pub type S23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S24` reader - S24"] pub type S24R = crate :: BitReader ;
#[doc = "Field `S24` writer - S24"] pub type S24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S25` reader - S25"] pub type S25R = crate :: BitReader ;
#[doc = "Field `S25` writer - S25"] pub type S25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S26` reader - S26"] pub type S26R = crate :: BitReader ;
#[doc = "Field `S26` writer - S26"] pub type S26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S27` reader - S27"] pub type S27R = crate :: BitReader ;
#[doc = "Field `S27` writer - S27"] pub type S27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S28` reader - S28"] pub type S28R = crate :: BitReader ;
#[doc = "Field `S28` writer - S28"] pub type S28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S29` reader - S29"] pub type S29R = crate :: BitReader ;
#[doc = "Field `S29` writer - S29"] pub type S29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S30` reader - S30"] pub type S30R = crate :: BitReader ;
#[doc = "Field `S30` writer - S30"] pub type S30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S31` reader - S31"] pub type S31R = crate :: BitReader ;
#[doc = "Field `S31` writer - S31"] pub type S31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - S00"]
#[inline (always)] pub fn s00 (& self) -> S00R { S00R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - S01"]
#[inline (always)] pub fn s01 (& self) -> S01R { S01R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - S02"]
#[inline (always)] pub fn s02 (& self) -> S02R { S02R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - S03"]
#[inline (always)] pub fn s03 (& self) -> S03R { S03R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - S04"]
#[inline (always)] pub fn s04 (& self) -> S04R { S04R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - S05"]
#[inline (always)] pub fn s05 (& self) -> S05R { S05R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - S06"]
#[inline (always)] pub fn s06 (& self) -> S06R { S06R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - S07"]
#[inline (always)] pub fn s07 (& self) -> S07R { S07R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - S08"]
#[inline (always)] pub fn s08 (& self) -> S08R { S08R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - S09"]
#[inline (always)] pub fn s09 (& self) -> S09R { S09R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - S10"]
#[inline (always)] pub fn s10 (& self) -> S10R { S10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - S11"]
#[inline (always)] pub fn s11 (& self) -> S11R { S11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - S12"]
#[inline (always)] pub fn s12 (& self) -> S12R { S12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - S13"]
#[inline (always)] pub fn s13 (& self) -> S13R { S13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - S14"]
#[inline (always)] pub fn s14 (& self) -> S14R { S14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - S15"]
#[inline (always)] pub fn s15 (& self) -> S15R { S15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - S16"]
#[inline (always)] pub fn s16 (& self) -> S16R { S16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - S17"]
#[inline (always)] pub fn s17 (& self) -> S17R { S17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - S18"]
#[inline (always)] pub fn s18 (& self) -> S18R { S18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - S19"]
#[inline (always)] pub fn s19 (& self) -> S19R { S19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - S20"]
#[inline (always)] pub fn s20 (& self) -> S20R { S20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - S21"]
#[inline (always)] pub fn s21 (& self) -> S21R { S21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - S22"]
#[inline (always)] pub fn s22 (& self) -> S22R { S22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - S23"]
#[inline (always)] pub fn s23 (& self) -> S23R { S23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - S24"]
#[inline (always)] pub fn s24 (& self) -> S24R { S24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - S25"]
#[inline (always)] pub fn s25 (& self) -> S25R { S25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - S26"]
#[inline (always)] pub fn s26 (& self) -> S26R { S26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - S27"]
#[inline (always)] pub fn s27 (& self) -> S27R { S27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - S28"]
#[inline (always)] pub fn s28 (& self) -> S28R { S28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - S29"]
#[inline (always)] pub fn s29 (& self) -> S29R { S29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - S30"]
#[inline (always)] pub fn s30 (& self) -> S30R { S30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - S31"]
#[inline (always)] pub fn s31 (& self) -> S31R { S31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - S00"]
#[inline (always)] pub fn s00 (& mut self) -> S00W < '_ , RamCom0Spec > { S00W :: new (self , 0) }
#[doc = "Bit 1 - S01"]
#[inline (always)] pub fn s01 (& mut self) -> S01W < '_ , RamCom0Spec > { S01W :: new (self , 1) }
#[doc = "Bit 2 - S02"]
#[inline (always)] pub fn s02 (& mut self) -> S02W < '_ , RamCom0Spec > { S02W :: new (self , 2) }
#[doc = "Bit 3 - S03"]
#[inline (always)] pub fn s03 (& mut self) -> S03W < '_ , RamCom0Spec > { S03W :: new (self , 3) }
#[doc = "Bit 4 - S04"]
#[inline (always)] pub fn s04 (& mut self) -> S04W < '_ , RamCom0Spec > { S04W :: new (self , 4) }
#[doc = "Bit 5 - S05"]
#[inline (always)] pub fn s05 (& mut self) -> S05W < '_ , RamCom0Spec > { S05W :: new (self , 5) }
#[doc = "Bit 6 - S06"]
#[inline (always)] pub fn s06 (& mut self) -> S06W < '_ , RamCom0Spec > { S06W :: new (self , 6) }
#[doc = "Bit 7 - S07"]
#[inline (always)] pub fn s07 (& mut self) -> S07W < '_ , RamCom0Spec > { S07W :: new (self , 7) }
#[doc = "Bit 8 - S08"]
#[inline (always)] pub fn s08 (& mut self) -> S08W < '_ , RamCom0Spec > { S08W :: new (self , 8) }
#[doc = "Bit 9 - S09"]
#[inline (always)] pub fn s09 (& mut self) -> S09W < '_ , RamCom0Spec > { S09W :: new (self , 9) }
#[doc = "Bit 10 - S10"]
#[inline (always)] pub fn s10 (& mut self) -> S10W < '_ , RamCom0Spec > { S10W :: new (self , 10) }
#[doc = "Bit 11 - S11"]
#[inline (always)] pub fn s11 (& mut self) -> S11W < '_ , RamCom0Spec > { S11W :: new (self , 11) }
#[doc = "Bit 12 - S12"]
#[inline (always)] pub fn s12 (& mut self) -> S12W < '_ , RamCom0Spec > { S12W :: new (self , 12) }
#[doc = "Bit 13 - S13"]
#[inline (always)] pub fn s13 (& mut self) -> S13W < '_ , RamCom0Spec > { S13W :: new (self , 13) }
#[doc = "Bit 14 - S14"]
#[inline (always)] pub fn s14 (& mut self) -> S14W < '_ , RamCom0Spec > { S14W :: new (self , 14) }
#[doc = "Bit 15 - S15"]
#[inline (always)] pub fn s15 (& mut self) -> S15W < '_ , RamCom0Spec > { S15W :: new (self , 15) }
#[doc = "Bit 16 - S16"]
#[inline (always)] pub fn s16 (& mut self) -> S16W < '_ , RamCom0Spec > { S16W :: new (self , 16) }
#[doc = "Bit 17 - S17"]
#[inline (always)] pub fn s17 (& mut self) -> S17W < '_ , RamCom0Spec > { S17W :: new (self , 17) }
#[doc = "Bit 18 - S18"]
#[inline (always)] pub fn s18 (& mut self) -> S18W < '_ , RamCom0Spec > { S18W :: new (self , 18) }
#[doc = "Bit 19 - S19"]
#[inline (always)] pub fn s19 (& mut self) -> S19W < '_ , RamCom0Spec > { S19W :: new (self , 19) }
#[doc = "Bit 20 - S20"]
#[inline (always)] pub fn s20 (& mut self) -> S20W < '_ , RamCom0Spec > { S20W :: new (self , 20) }
#[doc = "Bit 21 - S21"]
#[inline (always)] pub fn s21 (& mut self) -> S21W < '_ , RamCom0Spec > { S21W :: new (self , 21) }
#[doc = "Bit 22 - S22"]
#[inline (always)] pub fn s22 (& mut self) -> S22W < '_ , RamCom0Spec > { S22W :: new (self , 22) }
#[doc = "Bit 23 - S23"]
#[inline (always)] pub fn s23 (& mut self) -> S23W < '_ , RamCom0Spec > { S23W :: new (self , 23) }
#[doc = "Bit 24 - S24"]
#[inline (always)] pub fn s24 (& mut self) -> S24W < '_ , RamCom0Spec > { S24W :: new (self , 24) }
#[doc = "Bit 25 - S25"]
#[inline (always)] pub fn s25 (& mut self) -> S25W < '_ , RamCom0Spec > { S25W :: new (self , 25) }
#[doc = "Bit 26 - S26"]
#[inline (always)] pub fn s26 (& mut self) -> S26W < '_ , RamCom0Spec > { S26W :: new (self , 26) }
#[doc = "Bit 27 - S27"]
#[inline (always)] pub fn s27 (& mut self) -> S27W < '_ , RamCom0Spec > { S27W :: new (self , 27) }
#[doc = "Bit 28 - S28"]
#[inline (always)] pub fn s28 (& mut self) -> S28W < '_ , RamCom0Spec > { S28W :: new (self , 28) }
#[doc = "Bit 29 - S29"]
#[inline (always)] pub fn s29 (& mut self) -> S29W < '_ , RamCom0Spec > { S29W :: new (self , 29) }
#[doc = "Bit 30 - S30"]
#[inline (always)] pub fn s30 (& mut self) -> S30W < '_ , RamCom0Spec > { S30W :: new (self , 30) }
#[doc = "Bit 31 - S31"]
#[inline (always)] pub fn s31 (& mut self) -> S31W < '_ , RamCom0Spec > { S31W :: new (self , 31) } }
#[doc = "display memory\n\nYou can [`read`](crate::Reg::read) this register and get [`ram_com0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ram_com0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RamCom0Spec ; impl crate :: RegisterSpec for RamCom0Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ram_com0::R`](R) reader structure"] impl crate :: Readable for RamCom0Spec { }
#[doc = "`write(|w| ..)` method takes [`ram_com0::W`](W) writer structure"] impl crate :: Writable for RamCom0Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RAM_COM0 to value 0"] impl crate :: Resettable for RamCom0Spec { } }
#[doc = "RAM_COM1 (rw) register accessor: display memory\n\nYou can [`read`](crate::Reg::read) this register and get [`ram_com1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ram_com1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ram_com1`] module"]
#[doc (alias = "RAM_COM1")] pub type RamCom1 = crate :: Reg < ram_com1 :: RamCom1Spec > ;
#[doc = "display memory"] pub mod ram_com1 {
#[doc = "Register `RAM_COM1` reader"] pub type R = crate :: R < RamCom1Spec > ;
#[doc = "Register `RAM_COM1` writer"] pub type W = crate :: W < RamCom1Spec > ;
#[doc = "Field `S00` reader - S00"] pub type S00R = crate :: BitReader ;
#[doc = "Field `S00` writer - S00"] pub type S00W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S01` reader - S01"] pub type S01R = crate :: BitReader ;
#[doc = "Field `S01` writer - S01"] pub type S01W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S02` reader - S02"] pub type S02R = crate :: BitReader ;
#[doc = "Field `S02` writer - S02"] pub type S02W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S03` reader - S03"] pub type S03R = crate :: BitReader ;
#[doc = "Field `S03` writer - S03"] pub type S03W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S04` reader - S04"] pub type S04R = crate :: BitReader ;
#[doc = "Field `S04` writer - S04"] pub type S04W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S05` reader - S05"] pub type S05R = crate :: BitReader ;
#[doc = "Field `S05` writer - S05"] pub type S05W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S06` reader - S06"] pub type S06R = crate :: BitReader ;
#[doc = "Field `S06` writer - S06"] pub type S06W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S07` reader - S07"] pub type S07R = crate :: BitReader ;
#[doc = "Field `S07` writer - S07"] pub type S07W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S08` reader - S08"] pub type S08R = crate :: BitReader ;
#[doc = "Field `S08` writer - S08"] pub type S08W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S09` reader - S09"] pub type S09R = crate :: BitReader ;
#[doc = "Field `S09` writer - S09"] pub type S09W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S10` reader - S10"] pub type S10R = crate :: BitReader ;
#[doc = "Field `S10` writer - S10"] pub type S10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S11` reader - S11"] pub type S11R = crate :: BitReader ;
#[doc = "Field `S11` writer - S11"] pub type S11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S12` reader - S12"] pub type S12R = crate :: BitReader ;
#[doc = "Field `S12` writer - S12"] pub type S12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S13` reader - S13"] pub type S13R = crate :: BitReader ;
#[doc = "Field `S13` writer - S13"] pub type S13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S14` reader - S14"] pub type S14R = crate :: BitReader ;
#[doc = "Field `S14` writer - S14"] pub type S14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S15` reader - S15"] pub type S15R = crate :: BitReader ;
#[doc = "Field `S15` writer - S15"] pub type S15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S16` reader - S16"] pub type S16R = crate :: BitReader ;
#[doc = "Field `S16` writer - S16"] pub type S16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S17` reader - S17"] pub type S17R = crate :: BitReader ;
#[doc = "Field `S17` writer - S17"] pub type S17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S18` reader - S18"] pub type S18R = crate :: BitReader ;
#[doc = "Field `S18` writer - S18"] pub type S18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S19` reader - S19"] pub type S19R = crate :: BitReader ;
#[doc = "Field `S19` writer - S19"] pub type S19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S20` reader - S20"] pub type S20R = crate :: BitReader ;
#[doc = "Field `S20` writer - S20"] pub type S20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S21` reader - S21"] pub type S21R = crate :: BitReader ;
#[doc = "Field `S21` writer - S21"] pub type S21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S22` reader - S22"] pub type S22R = crate :: BitReader ;
#[doc = "Field `S22` writer - S22"] pub type S22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S23` reader - S23"] pub type S23R = crate :: BitReader ;
#[doc = "Field `S23` writer - S23"] pub type S23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S24` reader - S24"] pub type S24R = crate :: BitReader ;
#[doc = "Field `S24` writer - S24"] pub type S24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S25` reader - S25"] pub type S25R = crate :: BitReader ;
#[doc = "Field `S25` writer - S25"] pub type S25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S26` reader - S26"] pub type S26R = crate :: BitReader ;
#[doc = "Field `S26` writer - S26"] pub type S26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S27` reader - S27"] pub type S27R = crate :: BitReader ;
#[doc = "Field `S27` writer - S27"] pub type S27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S28` reader - S28"] pub type S28R = crate :: BitReader ;
#[doc = "Field `S28` writer - S28"] pub type S28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S29` reader - S29"] pub type S29R = crate :: BitReader ;
#[doc = "Field `S29` writer - S29"] pub type S29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S30` reader - S30"] pub type S30R = crate :: BitReader ;
#[doc = "Field `S30` writer - S30"] pub type S30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S31` reader - S31"] pub type S31R = crate :: BitReader ;
#[doc = "Field `S31` writer - S31"] pub type S31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - S00"]
#[inline (always)] pub fn s00 (& self) -> S00R { S00R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - S01"]
#[inline (always)] pub fn s01 (& self) -> S01R { S01R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - S02"]
#[inline (always)] pub fn s02 (& self) -> S02R { S02R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - S03"]
#[inline (always)] pub fn s03 (& self) -> S03R { S03R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - S04"]
#[inline (always)] pub fn s04 (& self) -> S04R { S04R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - S05"]
#[inline (always)] pub fn s05 (& self) -> S05R { S05R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - S06"]
#[inline (always)] pub fn s06 (& self) -> S06R { S06R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - S07"]
#[inline (always)] pub fn s07 (& self) -> S07R { S07R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - S08"]
#[inline (always)] pub fn s08 (& self) -> S08R { S08R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - S09"]
#[inline (always)] pub fn s09 (& self) -> S09R { S09R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - S10"]
#[inline (always)] pub fn s10 (& self) -> S10R { S10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - S11"]
#[inline (always)] pub fn s11 (& self) -> S11R { S11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - S12"]
#[inline (always)] pub fn s12 (& self) -> S12R { S12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - S13"]
#[inline (always)] pub fn s13 (& self) -> S13R { S13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - S14"]
#[inline (always)] pub fn s14 (& self) -> S14R { S14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - S15"]
#[inline (always)] pub fn s15 (& self) -> S15R { S15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - S16"]
#[inline (always)] pub fn s16 (& self) -> S16R { S16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - S17"]
#[inline (always)] pub fn s17 (& self) -> S17R { S17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - S18"]
#[inline (always)] pub fn s18 (& self) -> S18R { S18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - S19"]
#[inline (always)] pub fn s19 (& self) -> S19R { S19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - S20"]
#[inline (always)] pub fn s20 (& self) -> S20R { S20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - S21"]
#[inline (always)] pub fn s21 (& self) -> S21R { S21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - S22"]
#[inline (always)] pub fn s22 (& self) -> S22R { S22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - S23"]
#[inline (always)] pub fn s23 (& self) -> S23R { S23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - S24"]
#[inline (always)] pub fn s24 (& self) -> S24R { S24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - S25"]
#[inline (always)] pub fn s25 (& self) -> S25R { S25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - S26"]
#[inline (always)] pub fn s26 (& self) -> S26R { S26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - S27"]
#[inline (always)] pub fn s27 (& self) -> S27R { S27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - S28"]
#[inline (always)] pub fn s28 (& self) -> S28R { S28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - S29"]
#[inline (always)] pub fn s29 (& self) -> S29R { S29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - S30"]
#[inline (always)] pub fn s30 (& self) -> S30R { S30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - S31"]
#[inline (always)] pub fn s31 (& self) -> S31R { S31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - S00"]
#[inline (always)] pub fn s00 (& mut self) -> S00W < '_ , RamCom1Spec > { S00W :: new (self , 0) }
#[doc = "Bit 1 - S01"]
#[inline (always)] pub fn s01 (& mut self) -> S01W < '_ , RamCom1Spec > { S01W :: new (self , 1) }
#[doc = "Bit 2 - S02"]
#[inline (always)] pub fn s02 (& mut self) -> S02W < '_ , RamCom1Spec > { S02W :: new (self , 2) }
#[doc = "Bit 3 - S03"]
#[inline (always)] pub fn s03 (& mut self) -> S03W < '_ , RamCom1Spec > { S03W :: new (self , 3) }
#[doc = "Bit 4 - S04"]
#[inline (always)] pub fn s04 (& mut self) -> S04W < '_ , RamCom1Spec > { S04W :: new (self , 4) }
#[doc = "Bit 5 - S05"]
#[inline (always)] pub fn s05 (& mut self) -> S05W < '_ , RamCom1Spec > { S05W :: new (self , 5) }
#[doc = "Bit 6 - S06"]
#[inline (always)] pub fn s06 (& mut self) -> S06W < '_ , RamCom1Spec > { S06W :: new (self , 6) }
#[doc = "Bit 7 - S07"]
#[inline (always)] pub fn s07 (& mut self) -> S07W < '_ , RamCom1Spec > { S07W :: new (self , 7) }
#[doc = "Bit 8 - S08"]
#[inline (always)] pub fn s08 (& mut self) -> S08W < '_ , RamCom1Spec > { S08W :: new (self , 8) }
#[doc = "Bit 9 - S09"]
#[inline (always)] pub fn s09 (& mut self) -> S09W < '_ , RamCom1Spec > { S09W :: new (self , 9) }
#[doc = "Bit 10 - S10"]
#[inline (always)] pub fn s10 (& mut self) -> S10W < '_ , RamCom1Spec > { S10W :: new (self , 10) }
#[doc = "Bit 11 - S11"]
#[inline (always)] pub fn s11 (& mut self) -> S11W < '_ , RamCom1Spec > { S11W :: new (self , 11) }
#[doc = "Bit 12 - S12"]
#[inline (always)] pub fn s12 (& mut self) -> S12W < '_ , RamCom1Spec > { S12W :: new (self , 12) }
#[doc = "Bit 13 - S13"]
#[inline (always)] pub fn s13 (& mut self) -> S13W < '_ , RamCom1Spec > { S13W :: new (self , 13) }
#[doc = "Bit 14 - S14"]
#[inline (always)] pub fn s14 (& mut self) -> S14W < '_ , RamCom1Spec > { S14W :: new (self , 14) }
#[doc = "Bit 15 - S15"]
#[inline (always)] pub fn s15 (& mut self) -> S15W < '_ , RamCom1Spec > { S15W :: new (self , 15) }
#[doc = "Bit 16 - S16"]
#[inline (always)] pub fn s16 (& mut self) -> S16W < '_ , RamCom1Spec > { S16W :: new (self , 16) }
#[doc = "Bit 17 - S17"]
#[inline (always)] pub fn s17 (& mut self) -> S17W < '_ , RamCom1Spec > { S17W :: new (self , 17) }
#[doc = "Bit 18 - S18"]
#[inline (always)] pub fn s18 (& mut self) -> S18W < '_ , RamCom1Spec > { S18W :: new (self , 18) }
#[doc = "Bit 19 - S19"]
#[inline (always)] pub fn s19 (& mut self) -> S19W < '_ , RamCom1Spec > { S19W :: new (self , 19) }
#[doc = "Bit 20 - S20"]
#[inline (always)] pub fn s20 (& mut self) -> S20W < '_ , RamCom1Spec > { S20W :: new (self , 20) }
#[doc = "Bit 21 - S21"]
#[inline (always)] pub fn s21 (& mut self) -> S21W < '_ , RamCom1Spec > { S21W :: new (self , 21) }
#[doc = "Bit 22 - S22"]
#[inline (always)] pub fn s22 (& mut self) -> S22W < '_ , RamCom1Spec > { S22W :: new (self , 22) }
#[doc = "Bit 23 - S23"]
#[inline (always)] pub fn s23 (& mut self) -> S23W < '_ , RamCom1Spec > { S23W :: new (self , 23) }
#[doc = "Bit 24 - S24"]
#[inline (always)] pub fn s24 (& mut self) -> S24W < '_ , RamCom1Spec > { S24W :: new (self , 24) }
#[doc = "Bit 25 - S25"]
#[inline (always)] pub fn s25 (& mut self) -> S25W < '_ , RamCom1Spec > { S25W :: new (self , 25) }
#[doc = "Bit 26 - S26"]
#[inline (always)] pub fn s26 (& mut self) -> S26W < '_ , RamCom1Spec > { S26W :: new (self , 26) }
#[doc = "Bit 27 - S27"]
#[inline (always)] pub fn s27 (& mut self) -> S27W < '_ , RamCom1Spec > { S27W :: new (self , 27) }
#[doc = "Bit 28 - S28"]
#[inline (always)] pub fn s28 (& mut self) -> S28W < '_ , RamCom1Spec > { S28W :: new (self , 28) }
#[doc = "Bit 29 - S29"]
#[inline (always)] pub fn s29 (& mut self) -> S29W < '_ , RamCom1Spec > { S29W :: new (self , 29) }
#[doc = "Bit 30 - S30"]
#[inline (always)] pub fn s30 (& mut self) -> S30W < '_ , RamCom1Spec > { S30W :: new (self , 30) }
#[doc = "Bit 31 - S31"]
#[inline (always)] pub fn s31 (& mut self) -> S31W < '_ , RamCom1Spec > { S31W :: new (self , 31) } }
#[doc = "display memory\n\nYou can [`read`](crate::Reg::read) this register and get [`ram_com1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ram_com1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RamCom1Spec ; impl crate :: RegisterSpec for RamCom1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ram_com1::R`](R) reader structure"] impl crate :: Readable for RamCom1Spec { }
#[doc = "`write(|w| ..)` method takes [`ram_com1::W`](W) writer structure"] impl crate :: Writable for RamCom1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RAM_COM1 to value 0"] impl crate :: Resettable for RamCom1Spec { } }
#[doc = "RAM_COM2 (rw) register accessor: display memory\n\nYou can [`read`](crate::Reg::read) this register and get [`ram_com2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ram_com2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ram_com2`] module"]
#[doc (alias = "RAM_COM2")] pub type RamCom2 = crate :: Reg < ram_com2 :: RamCom2Spec > ;
#[doc = "display memory"] pub mod ram_com2 {
#[doc = "Register `RAM_COM2` reader"] pub type R = crate :: R < RamCom2Spec > ;
#[doc = "Register `RAM_COM2` writer"] pub type W = crate :: W < RamCom2Spec > ;
#[doc = "Field `S00` reader - S00"] pub type S00R = crate :: BitReader ;
#[doc = "Field `S00` writer - S00"] pub type S00W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S01` reader - S01"] pub type S01R = crate :: BitReader ;
#[doc = "Field `S01` writer - S01"] pub type S01W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S02` reader - S02"] pub type S02R = crate :: BitReader ;
#[doc = "Field `S02` writer - S02"] pub type S02W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S03` reader - S03"] pub type S03R = crate :: BitReader ;
#[doc = "Field `S03` writer - S03"] pub type S03W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S04` reader - S04"] pub type S04R = crate :: BitReader ;
#[doc = "Field `S04` writer - S04"] pub type S04W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S05` reader - S05"] pub type S05R = crate :: BitReader ;
#[doc = "Field `S05` writer - S05"] pub type S05W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S06` reader - S06"] pub type S06R = crate :: BitReader ;
#[doc = "Field `S06` writer - S06"] pub type S06W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S07` reader - S07"] pub type S07R = crate :: BitReader ;
#[doc = "Field `S07` writer - S07"] pub type S07W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S08` reader - S08"] pub type S08R = crate :: BitReader ;
#[doc = "Field `S08` writer - S08"] pub type S08W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S09` reader - S09"] pub type S09R = crate :: BitReader ;
#[doc = "Field `S09` writer - S09"] pub type S09W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S10` reader - S10"] pub type S10R = crate :: BitReader ;
#[doc = "Field `S10` writer - S10"] pub type S10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S11` reader - S11"] pub type S11R = crate :: BitReader ;
#[doc = "Field `S11` writer - S11"] pub type S11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S12` reader - S12"] pub type S12R = crate :: BitReader ;
#[doc = "Field `S12` writer - S12"] pub type S12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S13` reader - S13"] pub type S13R = crate :: BitReader ;
#[doc = "Field `S13` writer - S13"] pub type S13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S14` reader - S14"] pub type S14R = crate :: BitReader ;
#[doc = "Field `S14` writer - S14"] pub type S14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S15` reader - S15"] pub type S15R = crate :: BitReader ;
#[doc = "Field `S15` writer - S15"] pub type S15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S16` reader - S16"] pub type S16R = crate :: BitReader ;
#[doc = "Field `S16` writer - S16"] pub type S16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S17` reader - S17"] pub type S17R = crate :: BitReader ;
#[doc = "Field `S17` writer - S17"] pub type S17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S18` reader - S18"] pub type S18R = crate :: BitReader ;
#[doc = "Field `S18` writer - S18"] pub type S18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S19` reader - S19"] pub type S19R = crate :: BitReader ;
#[doc = "Field `S19` writer - S19"] pub type S19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S20` reader - S20"] pub type S20R = crate :: BitReader ;
#[doc = "Field `S20` writer - S20"] pub type S20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S21` reader - S21"] pub type S21R = crate :: BitReader ;
#[doc = "Field `S21` writer - S21"] pub type S21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S22` reader - S22"] pub type S22R = crate :: BitReader ;
#[doc = "Field `S22` writer - S22"] pub type S22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S23` reader - S23"] pub type S23R = crate :: BitReader ;
#[doc = "Field `S23` writer - S23"] pub type S23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S24` reader - S24"] pub type S24R = crate :: BitReader ;
#[doc = "Field `S24` writer - S24"] pub type S24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S25` reader - S25"] pub type S25R = crate :: BitReader ;
#[doc = "Field `S25` writer - S25"] pub type S25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S26` reader - S26"] pub type S26R = crate :: BitReader ;
#[doc = "Field `S26` writer - S26"] pub type S26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S27` reader - S27"] pub type S27R = crate :: BitReader ;
#[doc = "Field `S27` writer - S27"] pub type S27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S28` reader - S28"] pub type S28R = crate :: BitReader ;
#[doc = "Field `S28` writer - S28"] pub type S28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S29` reader - S29"] pub type S29R = crate :: BitReader ;
#[doc = "Field `S29` writer - S29"] pub type S29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S30` reader - S30"] pub type S30R = crate :: BitReader ;
#[doc = "Field `S30` writer - S30"] pub type S30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S31` reader - S31"] pub type S31R = crate :: BitReader ;
#[doc = "Field `S31` writer - S31"] pub type S31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - S00"]
#[inline (always)] pub fn s00 (& self) -> S00R { S00R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - S01"]
#[inline (always)] pub fn s01 (& self) -> S01R { S01R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - S02"]
#[inline (always)] pub fn s02 (& self) -> S02R { S02R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - S03"]
#[inline (always)] pub fn s03 (& self) -> S03R { S03R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - S04"]
#[inline (always)] pub fn s04 (& self) -> S04R { S04R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - S05"]
#[inline (always)] pub fn s05 (& self) -> S05R { S05R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - S06"]
#[inline (always)] pub fn s06 (& self) -> S06R { S06R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - S07"]
#[inline (always)] pub fn s07 (& self) -> S07R { S07R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - S08"]
#[inline (always)] pub fn s08 (& self) -> S08R { S08R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - S09"]
#[inline (always)] pub fn s09 (& self) -> S09R { S09R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - S10"]
#[inline (always)] pub fn s10 (& self) -> S10R { S10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - S11"]
#[inline (always)] pub fn s11 (& self) -> S11R { S11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - S12"]
#[inline (always)] pub fn s12 (& self) -> S12R { S12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - S13"]
#[inline (always)] pub fn s13 (& self) -> S13R { S13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - S14"]
#[inline (always)] pub fn s14 (& self) -> S14R { S14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - S15"]
#[inline (always)] pub fn s15 (& self) -> S15R { S15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - S16"]
#[inline (always)] pub fn s16 (& self) -> S16R { S16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - S17"]
#[inline (always)] pub fn s17 (& self) -> S17R { S17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - S18"]
#[inline (always)] pub fn s18 (& self) -> S18R { S18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - S19"]
#[inline (always)] pub fn s19 (& self) -> S19R { S19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - S20"]
#[inline (always)] pub fn s20 (& self) -> S20R { S20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - S21"]
#[inline (always)] pub fn s21 (& self) -> S21R { S21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - S22"]
#[inline (always)] pub fn s22 (& self) -> S22R { S22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - S23"]
#[inline (always)] pub fn s23 (& self) -> S23R { S23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - S24"]
#[inline (always)] pub fn s24 (& self) -> S24R { S24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - S25"]
#[inline (always)] pub fn s25 (& self) -> S25R { S25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - S26"]
#[inline (always)] pub fn s26 (& self) -> S26R { S26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - S27"]
#[inline (always)] pub fn s27 (& self) -> S27R { S27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - S28"]
#[inline (always)] pub fn s28 (& self) -> S28R { S28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - S29"]
#[inline (always)] pub fn s29 (& self) -> S29R { S29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - S30"]
#[inline (always)] pub fn s30 (& self) -> S30R { S30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - S31"]
#[inline (always)] pub fn s31 (& self) -> S31R { S31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - S00"]
#[inline (always)] pub fn s00 (& mut self) -> S00W < '_ , RamCom2Spec > { S00W :: new (self , 0) }
#[doc = "Bit 1 - S01"]
#[inline (always)] pub fn s01 (& mut self) -> S01W < '_ , RamCom2Spec > { S01W :: new (self , 1) }
#[doc = "Bit 2 - S02"]
#[inline (always)] pub fn s02 (& mut self) -> S02W < '_ , RamCom2Spec > { S02W :: new (self , 2) }
#[doc = "Bit 3 - S03"]
#[inline (always)] pub fn s03 (& mut self) -> S03W < '_ , RamCom2Spec > { S03W :: new (self , 3) }
#[doc = "Bit 4 - S04"]
#[inline (always)] pub fn s04 (& mut self) -> S04W < '_ , RamCom2Spec > { S04W :: new (self , 4) }
#[doc = "Bit 5 - S05"]
#[inline (always)] pub fn s05 (& mut self) -> S05W < '_ , RamCom2Spec > { S05W :: new (self , 5) }
#[doc = "Bit 6 - S06"]
#[inline (always)] pub fn s06 (& mut self) -> S06W < '_ , RamCom2Spec > { S06W :: new (self , 6) }
#[doc = "Bit 7 - S07"]
#[inline (always)] pub fn s07 (& mut self) -> S07W < '_ , RamCom2Spec > { S07W :: new (self , 7) }
#[doc = "Bit 8 - S08"]
#[inline (always)] pub fn s08 (& mut self) -> S08W < '_ , RamCom2Spec > { S08W :: new (self , 8) }
#[doc = "Bit 9 - S09"]
#[inline (always)] pub fn s09 (& mut self) -> S09W < '_ , RamCom2Spec > { S09W :: new (self , 9) }
#[doc = "Bit 10 - S10"]
#[inline (always)] pub fn s10 (& mut self) -> S10W < '_ , RamCom2Spec > { S10W :: new (self , 10) }
#[doc = "Bit 11 - S11"]
#[inline (always)] pub fn s11 (& mut self) -> S11W < '_ , RamCom2Spec > { S11W :: new (self , 11) }
#[doc = "Bit 12 - S12"]
#[inline (always)] pub fn s12 (& mut self) -> S12W < '_ , RamCom2Spec > { S12W :: new (self , 12) }
#[doc = "Bit 13 - S13"]
#[inline (always)] pub fn s13 (& mut self) -> S13W < '_ , RamCom2Spec > { S13W :: new (self , 13) }
#[doc = "Bit 14 - S14"]
#[inline (always)] pub fn s14 (& mut self) -> S14W < '_ , RamCom2Spec > { S14W :: new (self , 14) }
#[doc = "Bit 15 - S15"]
#[inline (always)] pub fn s15 (& mut self) -> S15W < '_ , RamCom2Spec > { S15W :: new (self , 15) }
#[doc = "Bit 16 - S16"]
#[inline (always)] pub fn s16 (& mut self) -> S16W < '_ , RamCom2Spec > { S16W :: new (self , 16) }
#[doc = "Bit 17 - S17"]
#[inline (always)] pub fn s17 (& mut self) -> S17W < '_ , RamCom2Spec > { S17W :: new (self , 17) }
#[doc = "Bit 18 - S18"]
#[inline (always)] pub fn s18 (& mut self) -> S18W < '_ , RamCom2Spec > { S18W :: new (self , 18) }
#[doc = "Bit 19 - S19"]
#[inline (always)] pub fn s19 (& mut self) -> S19W < '_ , RamCom2Spec > { S19W :: new (self , 19) }
#[doc = "Bit 20 - S20"]
#[inline (always)] pub fn s20 (& mut self) -> S20W < '_ , RamCom2Spec > { S20W :: new (self , 20) }
#[doc = "Bit 21 - S21"]
#[inline (always)] pub fn s21 (& mut self) -> S21W < '_ , RamCom2Spec > { S21W :: new (self , 21) }
#[doc = "Bit 22 - S22"]
#[inline (always)] pub fn s22 (& mut self) -> S22W < '_ , RamCom2Spec > { S22W :: new (self , 22) }
#[doc = "Bit 23 - S23"]
#[inline (always)] pub fn s23 (& mut self) -> S23W < '_ , RamCom2Spec > { S23W :: new (self , 23) }
#[doc = "Bit 24 - S24"]
#[inline (always)] pub fn s24 (& mut self) -> S24W < '_ , RamCom2Spec > { S24W :: new (self , 24) }
#[doc = "Bit 25 - S25"]
#[inline (always)] pub fn s25 (& mut self) -> S25W < '_ , RamCom2Spec > { S25W :: new (self , 25) }
#[doc = "Bit 26 - S26"]
#[inline (always)] pub fn s26 (& mut self) -> S26W < '_ , RamCom2Spec > { S26W :: new (self , 26) }
#[doc = "Bit 27 - S27"]
#[inline (always)] pub fn s27 (& mut self) -> S27W < '_ , RamCom2Spec > { S27W :: new (self , 27) }
#[doc = "Bit 28 - S28"]
#[inline (always)] pub fn s28 (& mut self) -> S28W < '_ , RamCom2Spec > { S28W :: new (self , 28) }
#[doc = "Bit 29 - S29"]
#[inline (always)] pub fn s29 (& mut self) -> S29W < '_ , RamCom2Spec > { S29W :: new (self , 29) }
#[doc = "Bit 30 - S30"]
#[inline (always)] pub fn s30 (& mut self) -> S30W < '_ , RamCom2Spec > { S30W :: new (self , 30) }
#[doc = "Bit 31 - S31"]
#[inline (always)] pub fn s31 (& mut self) -> S31W < '_ , RamCom2Spec > { S31W :: new (self , 31) } }
#[doc = "display memory\n\nYou can [`read`](crate::Reg::read) this register and get [`ram_com2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ram_com2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RamCom2Spec ; impl crate :: RegisterSpec for RamCom2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ram_com2::R`](R) reader structure"] impl crate :: Readable for RamCom2Spec { }
#[doc = "`write(|w| ..)` method takes [`ram_com2::W`](W) writer structure"] impl crate :: Writable for RamCom2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RAM_COM2 to value 0"] impl crate :: Resettable for RamCom2Spec { } }
#[doc = "RAM_COM3 (rw) register accessor: display memory\n\nYou can [`read`](crate::Reg::read) this register and get [`ram_com3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ram_com3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ram_com3`] module"]
#[doc (alias = "RAM_COM3")] pub type RamCom3 = crate :: Reg < ram_com3 :: RamCom3Spec > ;
#[doc = "display memory"] pub mod ram_com3 {
#[doc = "Register `RAM_COM3` reader"] pub type R = crate :: R < RamCom3Spec > ;
#[doc = "Register `RAM_COM3` writer"] pub type W = crate :: W < RamCom3Spec > ;
#[doc = "Field `S00` reader - S00"] pub type S00R = crate :: BitReader ;
#[doc = "Field `S00` writer - S00"] pub type S00W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S01` reader - S01"] pub type S01R = crate :: BitReader ;
#[doc = "Field `S01` writer - S01"] pub type S01W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S02` reader - S02"] pub type S02R = crate :: BitReader ;
#[doc = "Field `S02` writer - S02"] pub type S02W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S03` reader - S03"] pub type S03R = crate :: BitReader ;
#[doc = "Field `S03` writer - S03"] pub type S03W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S04` reader - S04"] pub type S04R = crate :: BitReader ;
#[doc = "Field `S04` writer - S04"] pub type S04W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S05` reader - S05"] pub type S05R = crate :: BitReader ;
#[doc = "Field `S05` writer - S05"] pub type S05W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S06` reader - S06"] pub type S06R = crate :: BitReader ;
#[doc = "Field `S06` writer - S06"] pub type S06W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S07` reader - S07"] pub type S07R = crate :: BitReader ;
#[doc = "Field `S07` writer - S07"] pub type S07W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S08` reader - S08"] pub type S08R = crate :: BitReader ;
#[doc = "Field `S08` writer - S08"] pub type S08W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S09` reader - S09"] pub type S09R = crate :: BitReader ;
#[doc = "Field `S09` writer - S09"] pub type S09W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S10` reader - S10"] pub type S10R = crate :: BitReader ;
#[doc = "Field `S10` writer - S10"] pub type S10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S11` reader - S11"] pub type S11R = crate :: BitReader ;
#[doc = "Field `S11` writer - S11"] pub type S11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S12` reader - S12"] pub type S12R = crate :: BitReader ;
#[doc = "Field `S12` writer - S12"] pub type S12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S13` reader - S13"] pub type S13R = crate :: BitReader ;
#[doc = "Field `S13` writer - S13"] pub type S13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S14` reader - S14"] pub type S14R = crate :: BitReader ;
#[doc = "Field `S14` writer - S14"] pub type S14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S15` reader - S15"] pub type S15R = crate :: BitReader ;
#[doc = "Field `S15` writer - S15"] pub type S15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S16` reader - S16"] pub type S16R = crate :: BitReader ;
#[doc = "Field `S16` writer - S16"] pub type S16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S17` reader - S17"] pub type S17R = crate :: BitReader ;
#[doc = "Field `S17` writer - S17"] pub type S17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S18` reader - S18"] pub type S18R = crate :: BitReader ;
#[doc = "Field `S18` writer - S18"] pub type S18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S19` reader - S19"] pub type S19R = crate :: BitReader ;
#[doc = "Field `S19` writer - S19"] pub type S19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S20` reader - S20"] pub type S20R = crate :: BitReader ;
#[doc = "Field `S20` writer - S20"] pub type S20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S21` reader - S21"] pub type S21R = crate :: BitReader ;
#[doc = "Field `S21` writer - S21"] pub type S21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S22` reader - S22"] pub type S22R = crate :: BitReader ;
#[doc = "Field `S22` writer - S22"] pub type S22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S23` reader - S23"] pub type S23R = crate :: BitReader ;
#[doc = "Field `S23` writer - S23"] pub type S23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S24` reader - S24"] pub type S24R = crate :: BitReader ;
#[doc = "Field `S24` writer - S24"] pub type S24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S25` reader - S25"] pub type S25R = crate :: BitReader ;
#[doc = "Field `S25` writer - S25"] pub type S25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S26` reader - S26"] pub type S26R = crate :: BitReader ;
#[doc = "Field `S26` writer - S26"] pub type S26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S27` reader - S27"] pub type S27R = crate :: BitReader ;
#[doc = "Field `S27` writer - S27"] pub type S27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S28` reader - S28"] pub type S28R = crate :: BitReader ;
#[doc = "Field `S28` writer - S28"] pub type S28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S29` reader - S29"] pub type S29R = crate :: BitReader ;
#[doc = "Field `S29` writer - S29"] pub type S29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S30` reader - S30"] pub type S30R = crate :: BitReader ;
#[doc = "Field `S30` writer - S30"] pub type S30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S31` reader - S31"] pub type S31R = crate :: BitReader ;
#[doc = "Field `S31` writer - S31"] pub type S31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - S00"]
#[inline (always)] pub fn s00 (& self) -> S00R { S00R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - S01"]
#[inline (always)] pub fn s01 (& self) -> S01R { S01R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - S02"]
#[inline (always)] pub fn s02 (& self) -> S02R { S02R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - S03"]
#[inline (always)] pub fn s03 (& self) -> S03R { S03R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - S04"]
#[inline (always)] pub fn s04 (& self) -> S04R { S04R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - S05"]
#[inline (always)] pub fn s05 (& self) -> S05R { S05R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - S06"]
#[inline (always)] pub fn s06 (& self) -> S06R { S06R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - S07"]
#[inline (always)] pub fn s07 (& self) -> S07R { S07R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - S08"]
#[inline (always)] pub fn s08 (& self) -> S08R { S08R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - S09"]
#[inline (always)] pub fn s09 (& self) -> S09R { S09R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - S10"]
#[inline (always)] pub fn s10 (& self) -> S10R { S10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - S11"]
#[inline (always)] pub fn s11 (& self) -> S11R { S11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - S12"]
#[inline (always)] pub fn s12 (& self) -> S12R { S12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - S13"]
#[inline (always)] pub fn s13 (& self) -> S13R { S13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - S14"]
#[inline (always)] pub fn s14 (& self) -> S14R { S14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - S15"]
#[inline (always)] pub fn s15 (& self) -> S15R { S15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - S16"]
#[inline (always)] pub fn s16 (& self) -> S16R { S16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - S17"]
#[inline (always)] pub fn s17 (& self) -> S17R { S17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - S18"]
#[inline (always)] pub fn s18 (& self) -> S18R { S18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - S19"]
#[inline (always)] pub fn s19 (& self) -> S19R { S19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - S20"]
#[inline (always)] pub fn s20 (& self) -> S20R { S20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - S21"]
#[inline (always)] pub fn s21 (& self) -> S21R { S21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - S22"]
#[inline (always)] pub fn s22 (& self) -> S22R { S22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - S23"]
#[inline (always)] pub fn s23 (& self) -> S23R { S23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - S24"]
#[inline (always)] pub fn s24 (& self) -> S24R { S24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - S25"]
#[inline (always)] pub fn s25 (& self) -> S25R { S25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - S26"]
#[inline (always)] pub fn s26 (& self) -> S26R { S26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - S27"]
#[inline (always)] pub fn s27 (& self) -> S27R { S27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - S28"]
#[inline (always)] pub fn s28 (& self) -> S28R { S28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - S29"]
#[inline (always)] pub fn s29 (& self) -> S29R { S29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - S30"]
#[inline (always)] pub fn s30 (& self) -> S30R { S30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - S31"]
#[inline (always)] pub fn s31 (& self) -> S31R { S31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - S00"]
#[inline (always)] pub fn s00 (& mut self) -> S00W < '_ , RamCom3Spec > { S00W :: new (self , 0) }
#[doc = "Bit 1 - S01"]
#[inline (always)] pub fn s01 (& mut self) -> S01W < '_ , RamCom3Spec > { S01W :: new (self , 1) }
#[doc = "Bit 2 - S02"]
#[inline (always)] pub fn s02 (& mut self) -> S02W < '_ , RamCom3Spec > { S02W :: new (self , 2) }
#[doc = "Bit 3 - S03"]
#[inline (always)] pub fn s03 (& mut self) -> S03W < '_ , RamCom3Spec > { S03W :: new (self , 3) }
#[doc = "Bit 4 - S04"]
#[inline (always)] pub fn s04 (& mut self) -> S04W < '_ , RamCom3Spec > { S04W :: new (self , 4) }
#[doc = "Bit 5 - S05"]
#[inline (always)] pub fn s05 (& mut self) -> S05W < '_ , RamCom3Spec > { S05W :: new (self , 5) }
#[doc = "Bit 6 - S06"]
#[inline (always)] pub fn s06 (& mut self) -> S06W < '_ , RamCom3Spec > { S06W :: new (self , 6) }
#[doc = "Bit 7 - S07"]
#[inline (always)] pub fn s07 (& mut self) -> S07W < '_ , RamCom3Spec > { S07W :: new (self , 7) }
#[doc = "Bit 8 - S08"]
#[inline (always)] pub fn s08 (& mut self) -> S08W < '_ , RamCom3Spec > { S08W :: new (self , 8) }
#[doc = "Bit 9 - S09"]
#[inline (always)] pub fn s09 (& mut self) -> S09W < '_ , RamCom3Spec > { S09W :: new (self , 9) }
#[doc = "Bit 10 - S10"]
#[inline (always)] pub fn s10 (& mut self) -> S10W < '_ , RamCom3Spec > { S10W :: new (self , 10) }
#[doc = "Bit 11 - S11"]
#[inline (always)] pub fn s11 (& mut self) -> S11W < '_ , RamCom3Spec > { S11W :: new (self , 11) }
#[doc = "Bit 12 - S12"]
#[inline (always)] pub fn s12 (& mut self) -> S12W < '_ , RamCom3Spec > { S12W :: new (self , 12) }
#[doc = "Bit 13 - S13"]
#[inline (always)] pub fn s13 (& mut self) -> S13W < '_ , RamCom3Spec > { S13W :: new (self , 13) }
#[doc = "Bit 14 - S14"]
#[inline (always)] pub fn s14 (& mut self) -> S14W < '_ , RamCom3Spec > { S14W :: new (self , 14) }
#[doc = "Bit 15 - S15"]
#[inline (always)] pub fn s15 (& mut self) -> S15W < '_ , RamCom3Spec > { S15W :: new (self , 15) }
#[doc = "Bit 16 - S16"]
#[inline (always)] pub fn s16 (& mut self) -> S16W < '_ , RamCom3Spec > { S16W :: new (self , 16) }
#[doc = "Bit 17 - S17"]
#[inline (always)] pub fn s17 (& mut self) -> S17W < '_ , RamCom3Spec > { S17W :: new (self , 17) }
#[doc = "Bit 18 - S18"]
#[inline (always)] pub fn s18 (& mut self) -> S18W < '_ , RamCom3Spec > { S18W :: new (self , 18) }
#[doc = "Bit 19 - S19"]
#[inline (always)] pub fn s19 (& mut self) -> S19W < '_ , RamCom3Spec > { S19W :: new (self , 19) }
#[doc = "Bit 20 - S20"]
#[inline (always)] pub fn s20 (& mut self) -> S20W < '_ , RamCom3Spec > { S20W :: new (self , 20) }
#[doc = "Bit 21 - S21"]
#[inline (always)] pub fn s21 (& mut self) -> S21W < '_ , RamCom3Spec > { S21W :: new (self , 21) }
#[doc = "Bit 22 - S22"]
#[inline (always)] pub fn s22 (& mut self) -> S22W < '_ , RamCom3Spec > { S22W :: new (self , 22) }
#[doc = "Bit 23 - S23"]
#[inline (always)] pub fn s23 (& mut self) -> S23W < '_ , RamCom3Spec > { S23W :: new (self , 23) }
#[doc = "Bit 24 - S24"]
#[inline (always)] pub fn s24 (& mut self) -> S24W < '_ , RamCom3Spec > { S24W :: new (self , 24) }
#[doc = "Bit 25 - S25"]
#[inline (always)] pub fn s25 (& mut self) -> S25W < '_ , RamCom3Spec > { S25W :: new (self , 25) }
#[doc = "Bit 26 - S26"]
#[inline (always)] pub fn s26 (& mut self) -> S26W < '_ , RamCom3Spec > { S26W :: new (self , 26) }
#[doc = "Bit 27 - S27"]
#[inline (always)] pub fn s27 (& mut self) -> S27W < '_ , RamCom3Spec > { S27W :: new (self , 27) }
#[doc = "Bit 28 - S28"]
#[inline (always)] pub fn s28 (& mut self) -> S28W < '_ , RamCom3Spec > { S28W :: new (self , 28) }
#[doc = "Bit 29 - S29"]
#[inline (always)] pub fn s29 (& mut self) -> S29W < '_ , RamCom3Spec > { S29W :: new (self , 29) }
#[doc = "Bit 30 - S30"]
#[inline (always)] pub fn s30 (& mut self) -> S30W < '_ , RamCom3Spec > { S30W :: new (self , 30) }
#[doc = "Bit 31 - S31"]
#[inline (always)] pub fn s31 (& mut self) -> S31W < '_ , RamCom3Spec > { S31W :: new (self , 31) } }
#[doc = "display memory\n\nYou can [`read`](crate::Reg::read) this register and get [`ram_com3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ram_com3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RamCom3Spec ; impl crate :: RegisterSpec for RamCom3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ram_com3::R`](R) reader structure"] impl crate :: Readable for RamCom3Spec { }
#[doc = "`write(|w| ..)` method takes [`ram_com3::W`](W) writer structure"] impl crate :: Writable for RamCom3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RAM_COM3 to value 0"] impl crate :: Resettable for RamCom3Spec { } }
#[doc = "RAM_COM4 (rw) register accessor: display memory\n\nYou can [`read`](crate::Reg::read) this register and get [`ram_com4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ram_com4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ram_com4`] module"]
#[doc (alias = "RAM_COM4")] pub type RamCom4 = crate :: Reg < ram_com4 :: RamCom4Spec > ;
#[doc = "display memory"] pub mod ram_com4 {
#[doc = "Register `RAM_COM4` reader"] pub type R = crate :: R < RamCom4Spec > ;
#[doc = "Register `RAM_COM4` writer"] pub type W = crate :: W < RamCom4Spec > ;
#[doc = "Field `S00` reader - S00"] pub type S00R = crate :: BitReader ;
#[doc = "Field `S00` writer - S00"] pub type S00W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S01` reader - S01"] pub type S01R = crate :: BitReader ;
#[doc = "Field `S01` writer - S01"] pub type S01W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S02` reader - S02"] pub type S02R = crate :: BitReader ;
#[doc = "Field `S02` writer - S02"] pub type S02W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S03` reader - S03"] pub type S03R = crate :: BitReader ;
#[doc = "Field `S03` writer - S03"] pub type S03W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S04` reader - S04"] pub type S04R = crate :: BitReader ;
#[doc = "Field `S04` writer - S04"] pub type S04W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S05` reader - S05"] pub type S05R = crate :: BitReader ;
#[doc = "Field `S05` writer - S05"] pub type S05W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S06` reader - S06"] pub type S06R = crate :: BitReader ;
#[doc = "Field `S06` writer - S06"] pub type S06W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S07` reader - S07"] pub type S07R = crate :: BitReader ;
#[doc = "Field `S07` writer - S07"] pub type S07W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S08` reader - S08"] pub type S08R = crate :: BitReader ;
#[doc = "Field `S08` writer - S08"] pub type S08W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S09` reader - S09"] pub type S09R = crate :: BitReader ;
#[doc = "Field `S09` writer - S09"] pub type S09W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S10` reader - S10"] pub type S10R = crate :: BitReader ;
#[doc = "Field `S10` writer - S10"] pub type S10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S11` reader - S11"] pub type S11R = crate :: BitReader ;
#[doc = "Field `S11` writer - S11"] pub type S11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S12` reader - S12"] pub type S12R = crate :: BitReader ;
#[doc = "Field `S12` writer - S12"] pub type S12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S13` reader - S13"] pub type S13R = crate :: BitReader ;
#[doc = "Field `S13` writer - S13"] pub type S13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S14` reader - S14"] pub type S14R = crate :: BitReader ;
#[doc = "Field `S14` writer - S14"] pub type S14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S15` reader - S15"] pub type S15R = crate :: BitReader ;
#[doc = "Field `S15` writer - S15"] pub type S15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S16` reader - S16"] pub type S16R = crate :: BitReader ;
#[doc = "Field `S16` writer - S16"] pub type S16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S17` reader - S17"] pub type S17R = crate :: BitReader ;
#[doc = "Field `S17` writer - S17"] pub type S17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S18` reader - S18"] pub type S18R = crate :: BitReader ;
#[doc = "Field `S18` writer - S18"] pub type S18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S19` reader - S19"] pub type S19R = crate :: BitReader ;
#[doc = "Field `S19` writer - S19"] pub type S19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S20` reader - S20"] pub type S20R = crate :: BitReader ;
#[doc = "Field `S20` writer - S20"] pub type S20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S21` reader - S21"] pub type S21R = crate :: BitReader ;
#[doc = "Field `S21` writer - S21"] pub type S21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S22` reader - S22"] pub type S22R = crate :: BitReader ;
#[doc = "Field `S22` writer - S22"] pub type S22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S23` reader - S23"] pub type S23R = crate :: BitReader ;
#[doc = "Field `S23` writer - S23"] pub type S23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S24` reader - S24"] pub type S24R = crate :: BitReader ;
#[doc = "Field `S24` writer - S24"] pub type S24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S25` reader - S25"] pub type S25R = crate :: BitReader ;
#[doc = "Field `S25` writer - S25"] pub type S25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S26` reader - S26"] pub type S26R = crate :: BitReader ;
#[doc = "Field `S26` writer - S26"] pub type S26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S27` reader - S27"] pub type S27R = crate :: BitReader ;
#[doc = "Field `S27` writer - S27"] pub type S27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S28` reader - S28"] pub type S28R = crate :: BitReader ;
#[doc = "Field `S28` writer - S28"] pub type S28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S29` reader - S29"] pub type S29R = crate :: BitReader ;
#[doc = "Field `S29` writer - S29"] pub type S29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S30` reader - S30"] pub type S30R = crate :: BitReader ;
#[doc = "Field `S30` writer - S30"] pub type S30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S31` reader - S31"] pub type S31R = crate :: BitReader ;
#[doc = "Field `S31` writer - S31"] pub type S31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - S00"]
#[inline (always)] pub fn s00 (& self) -> S00R { S00R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - S01"]
#[inline (always)] pub fn s01 (& self) -> S01R { S01R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - S02"]
#[inline (always)] pub fn s02 (& self) -> S02R { S02R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - S03"]
#[inline (always)] pub fn s03 (& self) -> S03R { S03R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - S04"]
#[inline (always)] pub fn s04 (& self) -> S04R { S04R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - S05"]
#[inline (always)] pub fn s05 (& self) -> S05R { S05R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - S06"]
#[inline (always)] pub fn s06 (& self) -> S06R { S06R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - S07"]
#[inline (always)] pub fn s07 (& self) -> S07R { S07R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - S08"]
#[inline (always)] pub fn s08 (& self) -> S08R { S08R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - S09"]
#[inline (always)] pub fn s09 (& self) -> S09R { S09R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - S10"]
#[inline (always)] pub fn s10 (& self) -> S10R { S10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - S11"]
#[inline (always)] pub fn s11 (& self) -> S11R { S11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - S12"]
#[inline (always)] pub fn s12 (& self) -> S12R { S12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - S13"]
#[inline (always)] pub fn s13 (& self) -> S13R { S13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - S14"]
#[inline (always)] pub fn s14 (& self) -> S14R { S14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - S15"]
#[inline (always)] pub fn s15 (& self) -> S15R { S15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - S16"]
#[inline (always)] pub fn s16 (& self) -> S16R { S16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - S17"]
#[inline (always)] pub fn s17 (& self) -> S17R { S17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - S18"]
#[inline (always)] pub fn s18 (& self) -> S18R { S18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - S19"]
#[inline (always)] pub fn s19 (& self) -> S19R { S19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - S20"]
#[inline (always)] pub fn s20 (& self) -> S20R { S20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - S21"]
#[inline (always)] pub fn s21 (& self) -> S21R { S21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - S22"]
#[inline (always)] pub fn s22 (& self) -> S22R { S22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - S23"]
#[inline (always)] pub fn s23 (& self) -> S23R { S23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - S24"]
#[inline (always)] pub fn s24 (& self) -> S24R { S24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - S25"]
#[inline (always)] pub fn s25 (& self) -> S25R { S25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - S26"]
#[inline (always)] pub fn s26 (& self) -> S26R { S26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - S27"]
#[inline (always)] pub fn s27 (& self) -> S27R { S27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - S28"]
#[inline (always)] pub fn s28 (& self) -> S28R { S28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - S29"]
#[inline (always)] pub fn s29 (& self) -> S29R { S29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - S30"]
#[inline (always)] pub fn s30 (& self) -> S30R { S30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - S31"]
#[inline (always)] pub fn s31 (& self) -> S31R { S31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - S00"]
#[inline (always)] pub fn s00 (& mut self) -> S00W < '_ , RamCom4Spec > { S00W :: new (self , 0) }
#[doc = "Bit 1 - S01"]
#[inline (always)] pub fn s01 (& mut self) -> S01W < '_ , RamCom4Spec > { S01W :: new (self , 1) }
#[doc = "Bit 2 - S02"]
#[inline (always)] pub fn s02 (& mut self) -> S02W < '_ , RamCom4Spec > { S02W :: new (self , 2) }
#[doc = "Bit 3 - S03"]
#[inline (always)] pub fn s03 (& mut self) -> S03W < '_ , RamCom4Spec > { S03W :: new (self , 3) }
#[doc = "Bit 4 - S04"]
#[inline (always)] pub fn s04 (& mut self) -> S04W < '_ , RamCom4Spec > { S04W :: new (self , 4) }
#[doc = "Bit 5 - S05"]
#[inline (always)] pub fn s05 (& mut self) -> S05W < '_ , RamCom4Spec > { S05W :: new (self , 5) }
#[doc = "Bit 6 - S06"]
#[inline (always)] pub fn s06 (& mut self) -> S06W < '_ , RamCom4Spec > { S06W :: new (self , 6) }
#[doc = "Bit 7 - S07"]
#[inline (always)] pub fn s07 (& mut self) -> S07W < '_ , RamCom4Spec > { S07W :: new (self , 7) }
#[doc = "Bit 8 - S08"]
#[inline (always)] pub fn s08 (& mut self) -> S08W < '_ , RamCom4Spec > { S08W :: new (self , 8) }
#[doc = "Bit 9 - S09"]
#[inline (always)] pub fn s09 (& mut self) -> S09W < '_ , RamCom4Spec > { S09W :: new (self , 9) }
#[doc = "Bit 10 - S10"]
#[inline (always)] pub fn s10 (& mut self) -> S10W < '_ , RamCom4Spec > { S10W :: new (self , 10) }
#[doc = "Bit 11 - S11"]
#[inline (always)] pub fn s11 (& mut self) -> S11W < '_ , RamCom4Spec > { S11W :: new (self , 11) }
#[doc = "Bit 12 - S12"]
#[inline (always)] pub fn s12 (& mut self) -> S12W < '_ , RamCom4Spec > { S12W :: new (self , 12) }
#[doc = "Bit 13 - S13"]
#[inline (always)] pub fn s13 (& mut self) -> S13W < '_ , RamCom4Spec > { S13W :: new (self , 13) }
#[doc = "Bit 14 - S14"]
#[inline (always)] pub fn s14 (& mut self) -> S14W < '_ , RamCom4Spec > { S14W :: new (self , 14) }
#[doc = "Bit 15 - S15"]
#[inline (always)] pub fn s15 (& mut self) -> S15W < '_ , RamCom4Spec > { S15W :: new (self , 15) }
#[doc = "Bit 16 - S16"]
#[inline (always)] pub fn s16 (& mut self) -> S16W < '_ , RamCom4Spec > { S16W :: new (self , 16) }
#[doc = "Bit 17 - S17"]
#[inline (always)] pub fn s17 (& mut self) -> S17W < '_ , RamCom4Spec > { S17W :: new (self , 17) }
#[doc = "Bit 18 - S18"]
#[inline (always)] pub fn s18 (& mut self) -> S18W < '_ , RamCom4Spec > { S18W :: new (self , 18) }
#[doc = "Bit 19 - S19"]
#[inline (always)] pub fn s19 (& mut self) -> S19W < '_ , RamCom4Spec > { S19W :: new (self , 19) }
#[doc = "Bit 20 - S20"]
#[inline (always)] pub fn s20 (& mut self) -> S20W < '_ , RamCom4Spec > { S20W :: new (self , 20) }
#[doc = "Bit 21 - S21"]
#[inline (always)] pub fn s21 (& mut self) -> S21W < '_ , RamCom4Spec > { S21W :: new (self , 21) }
#[doc = "Bit 22 - S22"]
#[inline (always)] pub fn s22 (& mut self) -> S22W < '_ , RamCom4Spec > { S22W :: new (self , 22) }
#[doc = "Bit 23 - S23"]
#[inline (always)] pub fn s23 (& mut self) -> S23W < '_ , RamCom4Spec > { S23W :: new (self , 23) }
#[doc = "Bit 24 - S24"]
#[inline (always)] pub fn s24 (& mut self) -> S24W < '_ , RamCom4Spec > { S24W :: new (self , 24) }
#[doc = "Bit 25 - S25"]
#[inline (always)] pub fn s25 (& mut self) -> S25W < '_ , RamCom4Spec > { S25W :: new (self , 25) }
#[doc = "Bit 26 - S26"]
#[inline (always)] pub fn s26 (& mut self) -> S26W < '_ , RamCom4Spec > { S26W :: new (self , 26) }
#[doc = "Bit 27 - S27"]
#[inline (always)] pub fn s27 (& mut self) -> S27W < '_ , RamCom4Spec > { S27W :: new (self , 27) }
#[doc = "Bit 28 - S28"]
#[inline (always)] pub fn s28 (& mut self) -> S28W < '_ , RamCom4Spec > { S28W :: new (self , 28) }
#[doc = "Bit 29 - S29"]
#[inline (always)] pub fn s29 (& mut self) -> S29W < '_ , RamCom4Spec > { S29W :: new (self , 29) }
#[doc = "Bit 30 - S30"]
#[inline (always)] pub fn s30 (& mut self) -> S30W < '_ , RamCom4Spec > { S30W :: new (self , 30) }
#[doc = "Bit 31 - S31"]
#[inline (always)] pub fn s31 (& mut self) -> S31W < '_ , RamCom4Spec > { S31W :: new (self , 31) } }
#[doc = "display memory\n\nYou can [`read`](crate::Reg::read) this register and get [`ram_com4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ram_com4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RamCom4Spec ; impl crate :: RegisterSpec for RamCom4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ram_com4::R`](R) reader structure"] impl crate :: Readable for RamCom4Spec { }
#[doc = "`write(|w| ..)` method takes [`ram_com4::W`](W) writer structure"] impl crate :: Writable for RamCom4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RAM_COM4 to value 0"] impl crate :: Resettable for RamCom4Spec { } }
#[doc = "RAM_COM5 (rw) register accessor: display memory\n\nYou can [`read`](crate::Reg::read) this register and get [`ram_com5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ram_com5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ram_com5`] module"]
#[doc (alias = "RAM_COM5")] pub type RamCom5 = crate :: Reg < ram_com5 :: RamCom5Spec > ;
#[doc = "display memory"] pub mod ram_com5 {
#[doc = "Register `RAM_COM5` reader"] pub type R = crate :: R < RamCom5Spec > ;
#[doc = "Register `RAM_COM5` writer"] pub type W = crate :: W < RamCom5Spec > ;
#[doc = "Field `S00` reader - S00"] pub type S00R = crate :: BitReader ;
#[doc = "Field `S00` writer - S00"] pub type S00W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S01` reader - S01"] pub type S01R = crate :: BitReader ;
#[doc = "Field `S01` writer - S01"] pub type S01W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S02` reader - S02"] pub type S02R = crate :: BitReader ;
#[doc = "Field `S02` writer - S02"] pub type S02W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S03` reader - S03"] pub type S03R = crate :: BitReader ;
#[doc = "Field `S03` writer - S03"] pub type S03W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S04` reader - S04"] pub type S04R = crate :: BitReader ;
#[doc = "Field `S04` writer - S04"] pub type S04W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S05` reader - S05"] pub type S05R = crate :: BitReader ;
#[doc = "Field `S05` writer - S05"] pub type S05W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S06` reader - S06"] pub type S06R = crate :: BitReader ;
#[doc = "Field `S06` writer - S06"] pub type S06W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S07` reader - S07"] pub type S07R = crate :: BitReader ;
#[doc = "Field `S07` writer - S07"] pub type S07W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S08` reader - S08"] pub type S08R = crate :: BitReader ;
#[doc = "Field `S08` writer - S08"] pub type S08W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S09` reader - S09"] pub type S09R = crate :: BitReader ;
#[doc = "Field `S09` writer - S09"] pub type S09W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S10` reader - S10"] pub type S10R = crate :: BitReader ;
#[doc = "Field `S10` writer - S10"] pub type S10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S11` reader - S11"] pub type S11R = crate :: BitReader ;
#[doc = "Field `S11` writer - S11"] pub type S11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S12` reader - S12"] pub type S12R = crate :: BitReader ;
#[doc = "Field `S12` writer - S12"] pub type S12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S13` reader - S13"] pub type S13R = crate :: BitReader ;
#[doc = "Field `S13` writer - S13"] pub type S13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S14` reader - S14"] pub type S14R = crate :: BitReader ;
#[doc = "Field `S14` writer - S14"] pub type S14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S15` reader - S15"] pub type S15R = crate :: BitReader ;
#[doc = "Field `S15` writer - S15"] pub type S15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S16` reader - S16"] pub type S16R = crate :: BitReader ;
#[doc = "Field `S16` writer - S16"] pub type S16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S17` reader - S17"] pub type S17R = crate :: BitReader ;
#[doc = "Field `S17` writer - S17"] pub type S17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S18` reader - S18"] pub type S18R = crate :: BitReader ;
#[doc = "Field `S18` writer - S18"] pub type S18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S19` reader - S19"] pub type S19R = crate :: BitReader ;
#[doc = "Field `S19` writer - S19"] pub type S19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S20` reader - S20"] pub type S20R = crate :: BitReader ;
#[doc = "Field `S20` writer - S20"] pub type S20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S21` reader - S21"] pub type S21R = crate :: BitReader ;
#[doc = "Field `S21` writer - S21"] pub type S21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S22` reader - S22"] pub type S22R = crate :: BitReader ;
#[doc = "Field `S22` writer - S22"] pub type S22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S23` reader - S23"] pub type S23R = crate :: BitReader ;
#[doc = "Field `S23` writer - S23"] pub type S23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S24` reader - S24"] pub type S24R = crate :: BitReader ;
#[doc = "Field `S24` writer - S24"] pub type S24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S25` reader - S25"] pub type S25R = crate :: BitReader ;
#[doc = "Field `S25` writer - S25"] pub type S25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S26` reader - S26"] pub type S26R = crate :: BitReader ;
#[doc = "Field `S26` writer - S26"] pub type S26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S27` reader - S27"] pub type S27R = crate :: BitReader ;
#[doc = "Field `S27` writer - S27"] pub type S27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S28` reader - S28"] pub type S28R = crate :: BitReader ;
#[doc = "Field `S28` writer - S28"] pub type S28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S29` reader - S29"] pub type S29R = crate :: BitReader ;
#[doc = "Field `S29` writer - S29"] pub type S29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S30` reader - S30"] pub type S30R = crate :: BitReader ;
#[doc = "Field `S30` writer - S30"] pub type S30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S31` reader - S31"] pub type S31R = crate :: BitReader ;
#[doc = "Field `S31` writer - S31"] pub type S31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - S00"]
#[inline (always)] pub fn s00 (& self) -> S00R { S00R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - S01"]
#[inline (always)] pub fn s01 (& self) -> S01R { S01R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - S02"]
#[inline (always)] pub fn s02 (& self) -> S02R { S02R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - S03"]
#[inline (always)] pub fn s03 (& self) -> S03R { S03R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - S04"]
#[inline (always)] pub fn s04 (& self) -> S04R { S04R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - S05"]
#[inline (always)] pub fn s05 (& self) -> S05R { S05R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - S06"]
#[inline (always)] pub fn s06 (& self) -> S06R { S06R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - S07"]
#[inline (always)] pub fn s07 (& self) -> S07R { S07R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - S08"]
#[inline (always)] pub fn s08 (& self) -> S08R { S08R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - S09"]
#[inline (always)] pub fn s09 (& self) -> S09R { S09R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - S10"]
#[inline (always)] pub fn s10 (& self) -> S10R { S10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - S11"]
#[inline (always)] pub fn s11 (& self) -> S11R { S11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - S12"]
#[inline (always)] pub fn s12 (& self) -> S12R { S12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - S13"]
#[inline (always)] pub fn s13 (& self) -> S13R { S13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - S14"]
#[inline (always)] pub fn s14 (& self) -> S14R { S14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - S15"]
#[inline (always)] pub fn s15 (& self) -> S15R { S15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - S16"]
#[inline (always)] pub fn s16 (& self) -> S16R { S16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - S17"]
#[inline (always)] pub fn s17 (& self) -> S17R { S17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - S18"]
#[inline (always)] pub fn s18 (& self) -> S18R { S18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - S19"]
#[inline (always)] pub fn s19 (& self) -> S19R { S19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - S20"]
#[inline (always)] pub fn s20 (& self) -> S20R { S20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - S21"]
#[inline (always)] pub fn s21 (& self) -> S21R { S21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - S22"]
#[inline (always)] pub fn s22 (& self) -> S22R { S22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - S23"]
#[inline (always)] pub fn s23 (& self) -> S23R { S23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - S24"]
#[inline (always)] pub fn s24 (& self) -> S24R { S24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - S25"]
#[inline (always)] pub fn s25 (& self) -> S25R { S25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - S26"]
#[inline (always)] pub fn s26 (& self) -> S26R { S26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - S27"]
#[inline (always)] pub fn s27 (& self) -> S27R { S27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - S28"]
#[inline (always)] pub fn s28 (& self) -> S28R { S28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - S29"]
#[inline (always)] pub fn s29 (& self) -> S29R { S29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - S30"]
#[inline (always)] pub fn s30 (& self) -> S30R { S30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - S31"]
#[inline (always)] pub fn s31 (& self) -> S31R { S31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - S00"]
#[inline (always)] pub fn s00 (& mut self) -> S00W < '_ , RamCom5Spec > { S00W :: new (self , 0) }
#[doc = "Bit 1 - S01"]
#[inline (always)] pub fn s01 (& mut self) -> S01W < '_ , RamCom5Spec > { S01W :: new (self , 1) }
#[doc = "Bit 2 - S02"]
#[inline (always)] pub fn s02 (& mut self) -> S02W < '_ , RamCom5Spec > { S02W :: new (self , 2) }
#[doc = "Bit 3 - S03"]
#[inline (always)] pub fn s03 (& mut self) -> S03W < '_ , RamCom5Spec > { S03W :: new (self , 3) }
#[doc = "Bit 4 - S04"]
#[inline (always)] pub fn s04 (& mut self) -> S04W < '_ , RamCom5Spec > { S04W :: new (self , 4) }
#[doc = "Bit 5 - S05"]
#[inline (always)] pub fn s05 (& mut self) -> S05W < '_ , RamCom5Spec > { S05W :: new (self , 5) }
#[doc = "Bit 6 - S06"]
#[inline (always)] pub fn s06 (& mut self) -> S06W < '_ , RamCom5Spec > { S06W :: new (self , 6) }
#[doc = "Bit 7 - S07"]
#[inline (always)] pub fn s07 (& mut self) -> S07W < '_ , RamCom5Spec > { S07W :: new (self , 7) }
#[doc = "Bit 8 - S08"]
#[inline (always)] pub fn s08 (& mut self) -> S08W < '_ , RamCom5Spec > { S08W :: new (self , 8) }
#[doc = "Bit 9 - S09"]
#[inline (always)] pub fn s09 (& mut self) -> S09W < '_ , RamCom5Spec > { S09W :: new (self , 9) }
#[doc = "Bit 10 - S10"]
#[inline (always)] pub fn s10 (& mut self) -> S10W < '_ , RamCom5Spec > { S10W :: new (self , 10) }
#[doc = "Bit 11 - S11"]
#[inline (always)] pub fn s11 (& mut self) -> S11W < '_ , RamCom5Spec > { S11W :: new (self , 11) }
#[doc = "Bit 12 - S12"]
#[inline (always)] pub fn s12 (& mut self) -> S12W < '_ , RamCom5Spec > { S12W :: new (self , 12) }
#[doc = "Bit 13 - S13"]
#[inline (always)] pub fn s13 (& mut self) -> S13W < '_ , RamCom5Spec > { S13W :: new (self , 13) }
#[doc = "Bit 14 - S14"]
#[inline (always)] pub fn s14 (& mut self) -> S14W < '_ , RamCom5Spec > { S14W :: new (self , 14) }
#[doc = "Bit 15 - S15"]
#[inline (always)] pub fn s15 (& mut self) -> S15W < '_ , RamCom5Spec > { S15W :: new (self , 15) }
#[doc = "Bit 16 - S16"]
#[inline (always)] pub fn s16 (& mut self) -> S16W < '_ , RamCom5Spec > { S16W :: new (self , 16) }
#[doc = "Bit 17 - S17"]
#[inline (always)] pub fn s17 (& mut self) -> S17W < '_ , RamCom5Spec > { S17W :: new (self , 17) }
#[doc = "Bit 18 - S18"]
#[inline (always)] pub fn s18 (& mut self) -> S18W < '_ , RamCom5Spec > { S18W :: new (self , 18) }
#[doc = "Bit 19 - S19"]
#[inline (always)] pub fn s19 (& mut self) -> S19W < '_ , RamCom5Spec > { S19W :: new (self , 19) }
#[doc = "Bit 20 - S20"]
#[inline (always)] pub fn s20 (& mut self) -> S20W < '_ , RamCom5Spec > { S20W :: new (self , 20) }
#[doc = "Bit 21 - S21"]
#[inline (always)] pub fn s21 (& mut self) -> S21W < '_ , RamCom5Spec > { S21W :: new (self , 21) }
#[doc = "Bit 22 - S22"]
#[inline (always)] pub fn s22 (& mut self) -> S22W < '_ , RamCom5Spec > { S22W :: new (self , 22) }
#[doc = "Bit 23 - S23"]
#[inline (always)] pub fn s23 (& mut self) -> S23W < '_ , RamCom5Spec > { S23W :: new (self , 23) }
#[doc = "Bit 24 - S24"]
#[inline (always)] pub fn s24 (& mut self) -> S24W < '_ , RamCom5Spec > { S24W :: new (self , 24) }
#[doc = "Bit 25 - S25"]
#[inline (always)] pub fn s25 (& mut self) -> S25W < '_ , RamCom5Spec > { S25W :: new (self , 25) }
#[doc = "Bit 26 - S26"]
#[inline (always)] pub fn s26 (& mut self) -> S26W < '_ , RamCom5Spec > { S26W :: new (self , 26) }
#[doc = "Bit 27 - S27"]
#[inline (always)] pub fn s27 (& mut self) -> S27W < '_ , RamCom5Spec > { S27W :: new (self , 27) }
#[doc = "Bit 28 - S28"]
#[inline (always)] pub fn s28 (& mut self) -> S28W < '_ , RamCom5Spec > { S28W :: new (self , 28) }
#[doc = "Bit 29 - S29"]
#[inline (always)] pub fn s29 (& mut self) -> S29W < '_ , RamCom5Spec > { S29W :: new (self , 29) }
#[doc = "Bit 30 - S30"]
#[inline (always)] pub fn s30 (& mut self) -> S30W < '_ , RamCom5Spec > { S30W :: new (self , 30) }
#[doc = "Bit 31 - S31"]
#[inline (always)] pub fn s31 (& mut self) -> S31W < '_ , RamCom5Spec > { S31W :: new (self , 31) } }
#[doc = "display memory\n\nYou can [`read`](crate::Reg::read) this register and get [`ram_com5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ram_com5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RamCom5Spec ; impl crate :: RegisterSpec for RamCom5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ram_com5::R`](R) reader structure"] impl crate :: Readable for RamCom5Spec { }
#[doc = "`write(|w| ..)` method takes [`ram_com5::W`](W) writer structure"] impl crate :: Writable for RamCom5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RAM_COM5 to value 0"] impl crate :: Resettable for RamCom5Spec { } }
#[doc = "RAM_COM6 (rw) register accessor: display memory\n\nYou can [`read`](crate::Reg::read) this register and get [`ram_com6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ram_com6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ram_com6`] module"]
#[doc (alias = "RAM_COM6")] pub type RamCom6 = crate :: Reg < ram_com6 :: RamCom6Spec > ;
#[doc = "display memory"] pub mod ram_com6 {
#[doc = "Register `RAM_COM6` reader"] pub type R = crate :: R < RamCom6Spec > ;
#[doc = "Register `RAM_COM6` writer"] pub type W = crate :: W < RamCom6Spec > ;
#[doc = "Field `S00` reader - S00"] pub type S00R = crate :: BitReader ;
#[doc = "Field `S00` writer - S00"] pub type S00W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S01` reader - S01"] pub type S01R = crate :: BitReader ;
#[doc = "Field `S01` writer - S01"] pub type S01W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S02` reader - S02"] pub type S02R = crate :: BitReader ;
#[doc = "Field `S02` writer - S02"] pub type S02W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S03` reader - S03"] pub type S03R = crate :: BitReader ;
#[doc = "Field `S03` writer - S03"] pub type S03W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S04` reader - S04"] pub type S04R = crate :: BitReader ;
#[doc = "Field `S04` writer - S04"] pub type S04W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S05` reader - S05"] pub type S05R = crate :: BitReader ;
#[doc = "Field `S05` writer - S05"] pub type S05W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S06` reader - S06"] pub type S06R = crate :: BitReader ;
#[doc = "Field `S06` writer - S06"] pub type S06W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S07` reader - S07"] pub type S07R = crate :: BitReader ;
#[doc = "Field `S07` writer - S07"] pub type S07W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S08` reader - S08"] pub type S08R = crate :: BitReader ;
#[doc = "Field `S08` writer - S08"] pub type S08W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S09` reader - S09"] pub type S09R = crate :: BitReader ;
#[doc = "Field `S09` writer - S09"] pub type S09W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S10` reader - S10"] pub type S10R = crate :: BitReader ;
#[doc = "Field `S10` writer - S10"] pub type S10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S11` reader - S11"] pub type S11R = crate :: BitReader ;
#[doc = "Field `S11` writer - S11"] pub type S11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S12` reader - S12"] pub type S12R = crate :: BitReader ;
#[doc = "Field `S12` writer - S12"] pub type S12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S13` reader - S13"] pub type S13R = crate :: BitReader ;
#[doc = "Field `S13` writer - S13"] pub type S13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S14` reader - S14"] pub type S14R = crate :: BitReader ;
#[doc = "Field `S14` writer - S14"] pub type S14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S15` reader - S15"] pub type S15R = crate :: BitReader ;
#[doc = "Field `S15` writer - S15"] pub type S15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S16` reader - S16"] pub type S16R = crate :: BitReader ;
#[doc = "Field `S16` writer - S16"] pub type S16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S17` reader - S17"] pub type S17R = crate :: BitReader ;
#[doc = "Field `S17` writer - S17"] pub type S17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S18` reader - S18"] pub type S18R = crate :: BitReader ;
#[doc = "Field `S18` writer - S18"] pub type S18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S19` reader - S19"] pub type S19R = crate :: BitReader ;
#[doc = "Field `S19` writer - S19"] pub type S19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S20` reader - S20"] pub type S20R = crate :: BitReader ;
#[doc = "Field `S20` writer - S20"] pub type S20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S21` reader - S21"] pub type S21R = crate :: BitReader ;
#[doc = "Field `S21` writer - S21"] pub type S21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S22` reader - S22"] pub type S22R = crate :: BitReader ;
#[doc = "Field `S22` writer - S22"] pub type S22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S23` reader - S23"] pub type S23R = crate :: BitReader ;
#[doc = "Field `S23` writer - S23"] pub type S23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S24` reader - S24"] pub type S24R = crate :: BitReader ;
#[doc = "Field `S24` writer - S24"] pub type S24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S25` reader - S25"] pub type S25R = crate :: BitReader ;
#[doc = "Field `S25` writer - S25"] pub type S25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S26` reader - S26"] pub type S26R = crate :: BitReader ;
#[doc = "Field `S26` writer - S26"] pub type S26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S27` reader - S27"] pub type S27R = crate :: BitReader ;
#[doc = "Field `S27` writer - S27"] pub type S27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S28` reader - S28"] pub type S28R = crate :: BitReader ;
#[doc = "Field `S28` writer - S28"] pub type S28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S29` reader - S29"] pub type S29R = crate :: BitReader ;
#[doc = "Field `S29` writer - S29"] pub type S29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S30` reader - S30"] pub type S30R = crate :: BitReader ;
#[doc = "Field `S30` writer - S30"] pub type S30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S31` reader - S31"] pub type S31R = crate :: BitReader ;
#[doc = "Field `S31` writer - S31"] pub type S31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - S00"]
#[inline (always)] pub fn s00 (& self) -> S00R { S00R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - S01"]
#[inline (always)] pub fn s01 (& self) -> S01R { S01R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - S02"]
#[inline (always)] pub fn s02 (& self) -> S02R { S02R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - S03"]
#[inline (always)] pub fn s03 (& self) -> S03R { S03R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - S04"]
#[inline (always)] pub fn s04 (& self) -> S04R { S04R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - S05"]
#[inline (always)] pub fn s05 (& self) -> S05R { S05R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - S06"]
#[inline (always)] pub fn s06 (& self) -> S06R { S06R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - S07"]
#[inline (always)] pub fn s07 (& self) -> S07R { S07R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - S08"]
#[inline (always)] pub fn s08 (& self) -> S08R { S08R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - S09"]
#[inline (always)] pub fn s09 (& self) -> S09R { S09R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - S10"]
#[inline (always)] pub fn s10 (& self) -> S10R { S10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - S11"]
#[inline (always)] pub fn s11 (& self) -> S11R { S11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - S12"]
#[inline (always)] pub fn s12 (& self) -> S12R { S12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - S13"]
#[inline (always)] pub fn s13 (& self) -> S13R { S13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - S14"]
#[inline (always)] pub fn s14 (& self) -> S14R { S14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - S15"]
#[inline (always)] pub fn s15 (& self) -> S15R { S15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - S16"]
#[inline (always)] pub fn s16 (& self) -> S16R { S16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - S17"]
#[inline (always)] pub fn s17 (& self) -> S17R { S17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - S18"]
#[inline (always)] pub fn s18 (& self) -> S18R { S18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - S19"]
#[inline (always)] pub fn s19 (& self) -> S19R { S19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - S20"]
#[inline (always)] pub fn s20 (& self) -> S20R { S20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - S21"]
#[inline (always)] pub fn s21 (& self) -> S21R { S21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - S22"]
#[inline (always)] pub fn s22 (& self) -> S22R { S22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - S23"]
#[inline (always)] pub fn s23 (& self) -> S23R { S23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - S24"]
#[inline (always)] pub fn s24 (& self) -> S24R { S24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - S25"]
#[inline (always)] pub fn s25 (& self) -> S25R { S25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - S26"]
#[inline (always)] pub fn s26 (& self) -> S26R { S26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - S27"]
#[inline (always)] pub fn s27 (& self) -> S27R { S27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - S28"]
#[inline (always)] pub fn s28 (& self) -> S28R { S28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - S29"]
#[inline (always)] pub fn s29 (& self) -> S29R { S29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - S30"]
#[inline (always)] pub fn s30 (& self) -> S30R { S30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - S31"]
#[inline (always)] pub fn s31 (& self) -> S31R { S31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - S00"]
#[inline (always)] pub fn s00 (& mut self) -> S00W < '_ , RamCom6Spec > { S00W :: new (self , 0) }
#[doc = "Bit 1 - S01"]
#[inline (always)] pub fn s01 (& mut self) -> S01W < '_ , RamCom6Spec > { S01W :: new (self , 1) }
#[doc = "Bit 2 - S02"]
#[inline (always)] pub fn s02 (& mut self) -> S02W < '_ , RamCom6Spec > { S02W :: new (self , 2) }
#[doc = "Bit 3 - S03"]
#[inline (always)] pub fn s03 (& mut self) -> S03W < '_ , RamCom6Spec > { S03W :: new (self , 3) }
#[doc = "Bit 4 - S04"]
#[inline (always)] pub fn s04 (& mut self) -> S04W < '_ , RamCom6Spec > { S04W :: new (self , 4) }
#[doc = "Bit 5 - S05"]
#[inline (always)] pub fn s05 (& mut self) -> S05W < '_ , RamCom6Spec > { S05W :: new (self , 5) }
#[doc = "Bit 6 - S06"]
#[inline (always)] pub fn s06 (& mut self) -> S06W < '_ , RamCom6Spec > { S06W :: new (self , 6) }
#[doc = "Bit 7 - S07"]
#[inline (always)] pub fn s07 (& mut self) -> S07W < '_ , RamCom6Spec > { S07W :: new (self , 7) }
#[doc = "Bit 8 - S08"]
#[inline (always)] pub fn s08 (& mut self) -> S08W < '_ , RamCom6Spec > { S08W :: new (self , 8) }
#[doc = "Bit 9 - S09"]
#[inline (always)] pub fn s09 (& mut self) -> S09W < '_ , RamCom6Spec > { S09W :: new (self , 9) }
#[doc = "Bit 10 - S10"]
#[inline (always)] pub fn s10 (& mut self) -> S10W < '_ , RamCom6Spec > { S10W :: new (self , 10) }
#[doc = "Bit 11 - S11"]
#[inline (always)] pub fn s11 (& mut self) -> S11W < '_ , RamCom6Spec > { S11W :: new (self , 11) }
#[doc = "Bit 12 - S12"]
#[inline (always)] pub fn s12 (& mut self) -> S12W < '_ , RamCom6Spec > { S12W :: new (self , 12) }
#[doc = "Bit 13 - S13"]
#[inline (always)] pub fn s13 (& mut self) -> S13W < '_ , RamCom6Spec > { S13W :: new (self , 13) }
#[doc = "Bit 14 - S14"]
#[inline (always)] pub fn s14 (& mut self) -> S14W < '_ , RamCom6Spec > { S14W :: new (self , 14) }
#[doc = "Bit 15 - S15"]
#[inline (always)] pub fn s15 (& mut self) -> S15W < '_ , RamCom6Spec > { S15W :: new (self , 15) }
#[doc = "Bit 16 - S16"]
#[inline (always)] pub fn s16 (& mut self) -> S16W < '_ , RamCom6Spec > { S16W :: new (self , 16) }
#[doc = "Bit 17 - S17"]
#[inline (always)] pub fn s17 (& mut self) -> S17W < '_ , RamCom6Spec > { S17W :: new (self , 17) }
#[doc = "Bit 18 - S18"]
#[inline (always)] pub fn s18 (& mut self) -> S18W < '_ , RamCom6Spec > { S18W :: new (self , 18) }
#[doc = "Bit 19 - S19"]
#[inline (always)] pub fn s19 (& mut self) -> S19W < '_ , RamCom6Spec > { S19W :: new (self , 19) }
#[doc = "Bit 20 - S20"]
#[inline (always)] pub fn s20 (& mut self) -> S20W < '_ , RamCom6Spec > { S20W :: new (self , 20) }
#[doc = "Bit 21 - S21"]
#[inline (always)] pub fn s21 (& mut self) -> S21W < '_ , RamCom6Spec > { S21W :: new (self , 21) }
#[doc = "Bit 22 - S22"]
#[inline (always)] pub fn s22 (& mut self) -> S22W < '_ , RamCom6Spec > { S22W :: new (self , 22) }
#[doc = "Bit 23 - S23"]
#[inline (always)] pub fn s23 (& mut self) -> S23W < '_ , RamCom6Spec > { S23W :: new (self , 23) }
#[doc = "Bit 24 - S24"]
#[inline (always)] pub fn s24 (& mut self) -> S24W < '_ , RamCom6Spec > { S24W :: new (self , 24) }
#[doc = "Bit 25 - S25"]
#[inline (always)] pub fn s25 (& mut self) -> S25W < '_ , RamCom6Spec > { S25W :: new (self , 25) }
#[doc = "Bit 26 - S26"]
#[inline (always)] pub fn s26 (& mut self) -> S26W < '_ , RamCom6Spec > { S26W :: new (self , 26) }
#[doc = "Bit 27 - S27"]
#[inline (always)] pub fn s27 (& mut self) -> S27W < '_ , RamCom6Spec > { S27W :: new (self , 27) }
#[doc = "Bit 28 - S28"]
#[inline (always)] pub fn s28 (& mut self) -> S28W < '_ , RamCom6Spec > { S28W :: new (self , 28) }
#[doc = "Bit 29 - S29"]
#[inline (always)] pub fn s29 (& mut self) -> S29W < '_ , RamCom6Spec > { S29W :: new (self , 29) }
#[doc = "Bit 30 - S30"]
#[inline (always)] pub fn s30 (& mut self) -> S30W < '_ , RamCom6Spec > { S30W :: new (self , 30) }
#[doc = "Bit 31 - S31"]
#[inline (always)] pub fn s31 (& mut self) -> S31W < '_ , RamCom6Spec > { S31W :: new (self , 31) } }
#[doc = "display memory\n\nYou can [`read`](crate::Reg::read) this register and get [`ram_com6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ram_com6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RamCom6Spec ; impl crate :: RegisterSpec for RamCom6Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ram_com6::R`](R) reader structure"] impl crate :: Readable for RamCom6Spec { }
#[doc = "`write(|w| ..)` method takes [`ram_com6::W`](W) writer structure"] impl crate :: Writable for RamCom6Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RAM_COM6 to value 0"] impl crate :: Resettable for RamCom6Spec { } }
#[doc = "RAM_COM7 (rw) register accessor: display memory\n\nYou can [`read`](crate::Reg::read) this register and get [`ram_com7::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ram_com7::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ram_com7`] module"]
#[doc (alias = "RAM_COM7")] pub type RamCom7 = crate :: Reg < ram_com7 :: RamCom7Spec > ;
#[doc = "display memory"] pub mod ram_com7 {
#[doc = "Register `RAM_COM7` reader"] pub type R = crate :: R < RamCom7Spec > ;
#[doc = "Register `RAM_COM7` writer"] pub type W = crate :: W < RamCom7Spec > ;
#[doc = "Field `S00` reader - S00"] pub type S00R = crate :: BitReader ;
#[doc = "Field `S00` writer - S00"] pub type S00W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S01` reader - S01"] pub type S01R = crate :: BitReader ;
#[doc = "Field `S01` writer - S01"] pub type S01W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S02` reader - S02"] pub type S02R = crate :: BitReader ;
#[doc = "Field `S02` writer - S02"] pub type S02W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S03` reader - S03"] pub type S03R = crate :: BitReader ;
#[doc = "Field `S03` writer - S03"] pub type S03W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S04` reader - S04"] pub type S04R = crate :: BitReader ;
#[doc = "Field `S04` writer - S04"] pub type S04W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S05` reader - S05"] pub type S05R = crate :: BitReader ;
#[doc = "Field `S05` writer - S05"] pub type S05W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S06` reader - S06"] pub type S06R = crate :: BitReader ;
#[doc = "Field `S06` writer - S06"] pub type S06W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S07` reader - S07"] pub type S07R = crate :: BitReader ;
#[doc = "Field `S07` writer - S07"] pub type S07W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S08` reader - S08"] pub type S08R = crate :: BitReader ;
#[doc = "Field `S08` writer - S08"] pub type S08W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S09` reader - S09"] pub type S09R = crate :: BitReader ;
#[doc = "Field `S09` writer - S09"] pub type S09W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S10` reader - S10"] pub type S10R = crate :: BitReader ;
#[doc = "Field `S10` writer - S10"] pub type S10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S11` reader - S11"] pub type S11R = crate :: BitReader ;
#[doc = "Field `S11` writer - S11"] pub type S11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S12` reader - S12"] pub type S12R = crate :: BitReader ;
#[doc = "Field `S12` writer - S12"] pub type S12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S13` reader - S13"] pub type S13R = crate :: BitReader ;
#[doc = "Field `S13` writer - S13"] pub type S13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S14` reader - S14"] pub type S14R = crate :: BitReader ;
#[doc = "Field `S14` writer - S14"] pub type S14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S15` reader - S15"] pub type S15R = crate :: BitReader ;
#[doc = "Field `S15` writer - S15"] pub type S15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S16` reader - S16"] pub type S16R = crate :: BitReader ;
#[doc = "Field `S16` writer - S16"] pub type S16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S17` reader - S17"] pub type S17R = crate :: BitReader ;
#[doc = "Field `S17` writer - S17"] pub type S17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S18` reader - S18"] pub type S18R = crate :: BitReader ;
#[doc = "Field `S18` writer - S18"] pub type S18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S19` reader - S19"] pub type S19R = crate :: BitReader ;
#[doc = "Field `S19` writer - S19"] pub type S19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S20` reader - S20"] pub type S20R = crate :: BitReader ;
#[doc = "Field `S20` writer - S20"] pub type S20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S21` reader - S21"] pub type S21R = crate :: BitReader ;
#[doc = "Field `S21` writer - S21"] pub type S21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S22` reader - S22"] pub type S22R = crate :: BitReader ;
#[doc = "Field `S22` writer - S22"] pub type S22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S23` reader - S23"] pub type S23R = crate :: BitReader ;
#[doc = "Field `S23` writer - S23"] pub type S23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S24` reader - S24"] pub type S24R = crate :: BitReader ;
#[doc = "Field `S24` writer - S24"] pub type S24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S25` reader - S25"] pub type S25R = crate :: BitReader ;
#[doc = "Field `S25` writer - S25"] pub type S25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S26` reader - S26"] pub type S26R = crate :: BitReader ;
#[doc = "Field `S26` writer - S26"] pub type S26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S27` reader - S27"] pub type S27R = crate :: BitReader ;
#[doc = "Field `S27` writer - S27"] pub type S27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S28` reader - S28"] pub type S28R = crate :: BitReader ;
#[doc = "Field `S28` writer - S28"] pub type S28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S29` reader - S29"] pub type S29R = crate :: BitReader ;
#[doc = "Field `S29` writer - S29"] pub type S29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S30` reader - S30"] pub type S30R = crate :: BitReader ;
#[doc = "Field `S30` writer - S30"] pub type S30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `S31` reader - S31"] pub type S31R = crate :: BitReader ;
#[doc = "Field `S31` writer - S31"] pub type S31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - S00"]
#[inline (always)] pub fn s00 (& self) -> S00R { S00R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - S01"]
#[inline (always)] pub fn s01 (& self) -> S01R { S01R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - S02"]
#[inline (always)] pub fn s02 (& self) -> S02R { S02R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - S03"]
#[inline (always)] pub fn s03 (& self) -> S03R { S03R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - S04"]
#[inline (always)] pub fn s04 (& self) -> S04R { S04R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - S05"]
#[inline (always)] pub fn s05 (& self) -> S05R { S05R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - S06"]
#[inline (always)] pub fn s06 (& self) -> S06R { S06R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - S07"]
#[inline (always)] pub fn s07 (& self) -> S07R { S07R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - S08"]
#[inline (always)] pub fn s08 (& self) -> S08R { S08R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - S09"]
#[inline (always)] pub fn s09 (& self) -> S09R { S09R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - S10"]
#[inline (always)] pub fn s10 (& self) -> S10R { S10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - S11"]
#[inline (always)] pub fn s11 (& self) -> S11R { S11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - S12"]
#[inline (always)] pub fn s12 (& self) -> S12R { S12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - S13"]
#[inline (always)] pub fn s13 (& self) -> S13R { S13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - S14"]
#[inline (always)] pub fn s14 (& self) -> S14R { S14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - S15"]
#[inline (always)] pub fn s15 (& self) -> S15R { S15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - S16"]
#[inline (always)] pub fn s16 (& self) -> S16R { S16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - S17"]
#[inline (always)] pub fn s17 (& self) -> S17R { S17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - S18"]
#[inline (always)] pub fn s18 (& self) -> S18R { S18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - S19"]
#[inline (always)] pub fn s19 (& self) -> S19R { S19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - S20"]
#[inline (always)] pub fn s20 (& self) -> S20R { S20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - S21"]
#[inline (always)] pub fn s21 (& self) -> S21R { S21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - S22"]
#[inline (always)] pub fn s22 (& self) -> S22R { S22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - S23"]
#[inline (always)] pub fn s23 (& self) -> S23R { S23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - S24"]
#[inline (always)] pub fn s24 (& self) -> S24R { S24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - S25"]
#[inline (always)] pub fn s25 (& self) -> S25R { S25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - S26"]
#[inline (always)] pub fn s26 (& self) -> S26R { S26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - S27"]
#[inline (always)] pub fn s27 (& self) -> S27R { S27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - S28"]
#[inline (always)] pub fn s28 (& self) -> S28R { S28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - S29"]
#[inline (always)] pub fn s29 (& self) -> S29R { S29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - S30"]
#[inline (always)] pub fn s30 (& self) -> S30R { S30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - S31"]
#[inline (always)] pub fn s31 (& self) -> S31R { S31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - S00"]
#[inline (always)] pub fn s00 (& mut self) -> S00W < '_ , RamCom7Spec > { S00W :: new (self , 0) }
#[doc = "Bit 1 - S01"]
#[inline (always)] pub fn s01 (& mut self) -> S01W < '_ , RamCom7Spec > { S01W :: new (self , 1) }
#[doc = "Bit 2 - S02"]
#[inline (always)] pub fn s02 (& mut self) -> S02W < '_ , RamCom7Spec > { S02W :: new (self , 2) }
#[doc = "Bit 3 - S03"]
#[inline (always)] pub fn s03 (& mut self) -> S03W < '_ , RamCom7Spec > { S03W :: new (self , 3) }
#[doc = "Bit 4 - S04"]
#[inline (always)] pub fn s04 (& mut self) -> S04W < '_ , RamCom7Spec > { S04W :: new (self , 4) }
#[doc = "Bit 5 - S05"]
#[inline (always)] pub fn s05 (& mut self) -> S05W < '_ , RamCom7Spec > { S05W :: new (self , 5) }
#[doc = "Bit 6 - S06"]
#[inline (always)] pub fn s06 (& mut self) -> S06W < '_ , RamCom7Spec > { S06W :: new (self , 6) }
#[doc = "Bit 7 - S07"]
#[inline (always)] pub fn s07 (& mut self) -> S07W < '_ , RamCom7Spec > { S07W :: new (self , 7) }
#[doc = "Bit 8 - S08"]
#[inline (always)] pub fn s08 (& mut self) -> S08W < '_ , RamCom7Spec > { S08W :: new (self , 8) }
#[doc = "Bit 9 - S09"]
#[inline (always)] pub fn s09 (& mut self) -> S09W < '_ , RamCom7Spec > { S09W :: new (self , 9) }
#[doc = "Bit 10 - S10"]
#[inline (always)] pub fn s10 (& mut self) -> S10W < '_ , RamCom7Spec > { S10W :: new (self , 10) }
#[doc = "Bit 11 - S11"]
#[inline (always)] pub fn s11 (& mut self) -> S11W < '_ , RamCom7Spec > { S11W :: new (self , 11) }
#[doc = "Bit 12 - S12"]
#[inline (always)] pub fn s12 (& mut self) -> S12W < '_ , RamCom7Spec > { S12W :: new (self , 12) }
#[doc = "Bit 13 - S13"]
#[inline (always)] pub fn s13 (& mut self) -> S13W < '_ , RamCom7Spec > { S13W :: new (self , 13) }
#[doc = "Bit 14 - S14"]
#[inline (always)] pub fn s14 (& mut self) -> S14W < '_ , RamCom7Spec > { S14W :: new (self , 14) }
#[doc = "Bit 15 - S15"]
#[inline (always)] pub fn s15 (& mut self) -> S15W < '_ , RamCom7Spec > { S15W :: new (self , 15) }
#[doc = "Bit 16 - S16"]
#[inline (always)] pub fn s16 (& mut self) -> S16W < '_ , RamCom7Spec > { S16W :: new (self , 16) }
#[doc = "Bit 17 - S17"]
#[inline (always)] pub fn s17 (& mut self) -> S17W < '_ , RamCom7Spec > { S17W :: new (self , 17) }
#[doc = "Bit 18 - S18"]
#[inline (always)] pub fn s18 (& mut self) -> S18W < '_ , RamCom7Spec > { S18W :: new (self , 18) }
#[doc = "Bit 19 - S19"]
#[inline (always)] pub fn s19 (& mut self) -> S19W < '_ , RamCom7Spec > { S19W :: new (self , 19) }
#[doc = "Bit 20 - S20"]
#[inline (always)] pub fn s20 (& mut self) -> S20W < '_ , RamCom7Spec > { S20W :: new (self , 20) }
#[doc = "Bit 21 - S21"]
#[inline (always)] pub fn s21 (& mut self) -> S21W < '_ , RamCom7Spec > { S21W :: new (self , 21) }
#[doc = "Bit 22 - S22"]
#[inline (always)] pub fn s22 (& mut self) -> S22W < '_ , RamCom7Spec > { S22W :: new (self , 22) }
#[doc = "Bit 23 - S23"]
#[inline (always)] pub fn s23 (& mut self) -> S23W < '_ , RamCom7Spec > { S23W :: new (self , 23) }
#[doc = "Bit 24 - S24"]
#[inline (always)] pub fn s24 (& mut self) -> S24W < '_ , RamCom7Spec > { S24W :: new (self , 24) }
#[doc = "Bit 25 - S25"]
#[inline (always)] pub fn s25 (& mut self) -> S25W < '_ , RamCom7Spec > { S25W :: new (self , 25) }
#[doc = "Bit 26 - S26"]
#[inline (always)] pub fn s26 (& mut self) -> S26W < '_ , RamCom7Spec > { S26W :: new (self , 26) }
#[doc = "Bit 27 - S27"]
#[inline (always)] pub fn s27 (& mut self) -> S27W < '_ , RamCom7Spec > { S27W :: new (self , 27) }
#[doc = "Bit 28 - S28"]
#[inline (always)] pub fn s28 (& mut self) -> S28W < '_ , RamCom7Spec > { S28W :: new (self , 28) }
#[doc = "Bit 29 - S29"]
#[inline (always)] pub fn s29 (& mut self) -> S29W < '_ , RamCom7Spec > { S29W :: new (self , 29) }
#[doc = "Bit 30 - S30"]
#[inline (always)] pub fn s30 (& mut self) -> S30W < '_ , RamCom7Spec > { S30W :: new (self , 30) }
#[doc = "Bit 31 - S31"]
#[inline (always)] pub fn s31 (& mut self) -> S31W < '_ , RamCom7Spec > { S31W :: new (self , 31) } }
#[doc = "display memory\n\nYou can [`read`](crate::Reg::read) this register and get [`ram_com7::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ram_com7::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RamCom7Spec ; impl crate :: RegisterSpec for RamCom7Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ram_com7::R`](R) reader structure"] impl crate :: Readable for RamCom7Spec { }
#[doc = "`write(|w| ..)` method takes [`ram_com7::W`](W) writer structure"] impl crate :: Writable for RamCom7Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RAM_COM7 to value 0"] impl crate :: Resettable for RamCom7Spec { } } }
#[doc = "Touch sensing controller"] pub type Tsc = crate :: Periph < tsc :: RegisterBlock , 0x4002_4000 > ; impl core :: fmt :: Debug for Tsc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tsc") . finish () } }
#[doc = "Touch sensing controller"] pub mod tsc {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr : Cr , ier : Ier , icr : Icr , isr : Isr , iohcr : Iohcr , _reserved5 : [u8 ; 0x04] , ioascr : Ioascr , _reserved6 : [u8 ; 0x04] , ioscr : Ioscr , _reserved7 : [u8 ; 0x04] , ioccr : Ioccr , _reserved8 : [u8 ; 0x04] , iogcsr : Iogcsr , iog1cr : Iog1cr , iog2cr : Iog2cr , iog3cr : Iog3cr , iog4cr : Iog4cr , iog5cr : Iog5cr , iog6cr : Iog6cr , iog7cr : Iog7cr , } impl RegisterBlock {
#[doc = "0x00 - control register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x04 - interrupt enable register"]
#[inline (always)] pub const fn ier (& self) -> & Ier { & self . ier }
#[doc = "0x08 - interrupt clear register"]
#[inline (always)] pub const fn icr (& self) -> & Icr { & self . icr }
#[doc = "0x0c - interrupt status register"]
#[inline (always)] pub const fn isr (& self) -> & Isr { & self . isr }
#[doc = "0x10 - I/O hysteresis control register"]
#[inline (always)] pub const fn iohcr (& self) -> & Iohcr { & self . iohcr }
#[doc = "0x18 - I/O analog switch control register"]
#[inline (always)] pub const fn ioascr (& self) -> & Ioascr { & self . ioascr }
#[doc = "0x20 - I/O sampling control register"]
#[inline (always)] pub const fn ioscr (& self) -> & Ioscr { & self . ioscr }
#[doc = "0x28 - I/O channel control register"]
#[inline (always)] pub const fn ioccr (& self) -> & Ioccr { & self . ioccr }
#[doc = "0x30 - I/O group control status register"]
#[inline (always)] pub const fn iogcsr (& self) -> & Iogcsr { & self . iogcsr }
#[doc = "0x34 - I/O group x counter register"]
#[inline (always)] pub const fn iog1cr (& self) -> & Iog1cr { & self . iog1cr }
#[doc = "0x38 - I/O group x counter register"]
#[inline (always)] pub const fn iog2cr (& self) -> & Iog2cr { & self . iog2cr }
#[doc = "0x3c - I/O group x counter register"]
#[inline (always)] pub const fn iog3cr (& self) -> & Iog3cr { & self . iog3cr }
#[doc = "0x40 - I/O group x counter register"]
#[inline (always)] pub const fn iog4cr (& self) -> & Iog4cr { & self . iog4cr }
#[doc = "0x44 - I/O group x counter register"]
#[inline (always)] pub const fn iog5cr (& self) -> & Iog5cr { & self . iog5cr }
#[doc = "0x48 - I/O group x counter register"]
#[inline (always)] pub const fn iog6cr (& self) -> & Iog6cr { & self . iog6cr }
#[doc = "0x4c - I/O group x counter register"]
#[inline (always)] pub const fn iog7cr (& self) -> & Iog7cr { & self . iog7cr } }
#[doc = "CR (rw) register accessor: control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "control register"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `TSCE` reader - Touch sensing controller enable"] pub type TsceR = crate :: BitReader ;
#[doc = "Field `TSCE` writer - Touch sensing controller enable"] pub type TsceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `START` reader - Start a new acquisition"] pub type StartR = crate :: BitReader ;
#[doc = "Field `START` writer - Start a new acquisition"] pub type StartW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AM` reader - Acquisition mode"] pub type AmR = crate :: BitReader ;
#[doc = "Field `AM` writer - Acquisition mode"] pub type AmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SYNCPOL` reader - Synchronization pin polarity"] pub type SyncpolR = crate :: BitReader ;
#[doc = "Field `SYNCPOL` writer - Synchronization pin polarity"] pub type SyncpolW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IODEF` reader - I/O Default mode"] pub type IodefR = crate :: BitReader ;
#[doc = "Field `IODEF` writer - I/O Default mode"] pub type IodefW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MCV` reader - Max count value"] pub type McvR = crate :: FieldReader ;
#[doc = "Field `MCV` writer - Max count value"] pub type McvW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `PGPSC` reader - pulse generator prescaler"] pub type PgpscR = crate :: FieldReader ;
#[doc = "Field `PGPSC` writer - pulse generator prescaler"] pub type PgpscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SSPSC` reader - Spread spectrum prescaler"] pub type SspscR = crate :: BitReader ;
#[doc = "Field `SSPSC` writer - Spread spectrum prescaler"] pub type SspscW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SSE` reader - Spread spectrum enable"] pub type SseR = crate :: BitReader ;
#[doc = "Field `SSE` writer - Spread spectrum enable"] pub type SseW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SSD` reader - Spread spectrum deviation"] pub type SsdR = crate :: FieldReader ;
#[doc = "Field `SSD` writer - Spread spectrum deviation"] pub type SsdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `CTPL` reader - Charge transfer pulse low"] pub type CtplR = crate :: FieldReader ;
#[doc = "Field `CTPL` writer - Charge transfer pulse low"] pub type CtplW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `CTPH` reader - Charge transfer pulse high"] pub type CtphR = crate :: FieldReader ;
#[doc = "Field `CTPH` writer - Charge transfer pulse high"] pub type CtphW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bit 0 - Touch sensing controller enable"]
#[inline (always)] pub fn tsce (& self) -> TsceR { TsceR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Start a new acquisition"]
#[inline (always)] pub fn start (& self) -> StartR { StartR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Acquisition mode"]
#[inline (always)] pub fn am (& self) -> AmR { AmR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Synchronization pin polarity"]
#[inline (always)] pub fn syncpol (& self) -> SyncpolR { SyncpolR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - I/O Default mode"]
#[inline (always)] pub fn iodef (& self) -> IodefR { IodefR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bits 5:7 - Max count value"]
#[inline (always)] pub fn mcv (& self) -> McvR { McvR :: new (((self . bits >> 5) & 7) as u8) }
#[doc = "Bits 12:14 - pulse generator prescaler"]
#[inline (always)] pub fn pgpsc (& self) -> PgpscR { PgpscR :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bit 15 - Spread spectrum prescaler"]
#[inline (always)] pub fn sspsc (& self) -> SspscR { SspscR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Spread spectrum enable"]
#[inline (always)] pub fn sse (& self) -> SseR { SseR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:23 - Spread spectrum deviation"]
#[inline (always)] pub fn ssd (& self) -> SsdR { SsdR :: new (((self . bits >> 17) & 0x7f) as u8) }
#[doc = "Bits 24:27 - Charge transfer pulse low"]
#[inline (always)] pub fn ctpl (& self) -> CtplR { CtplR :: new (((self . bits >> 24) & 0x0f) as u8) }
#[doc = "Bits 28:31 - Charge transfer pulse high"]
#[inline (always)] pub fn ctph (& self) -> CtphR { CtphR :: new (((self . bits >> 28) & 0x0f) as u8) } } impl W {
#[doc = "Bit 0 - Touch sensing controller enable"]
#[inline (always)] pub fn tsce (& mut self) -> TsceW < '_ , CrSpec > { TsceW :: new (self , 0) }
#[doc = "Bit 1 - Start a new acquisition"]
#[inline (always)] pub fn start (& mut self) -> StartW < '_ , CrSpec > { StartW :: new (self , 1) }
#[doc = "Bit 2 - Acquisition mode"]
#[inline (always)] pub fn am (& mut self) -> AmW < '_ , CrSpec > { AmW :: new (self , 2) }
#[doc = "Bit 3 - Synchronization pin polarity"]
#[inline (always)] pub fn syncpol (& mut self) -> SyncpolW < '_ , CrSpec > { SyncpolW :: new (self , 3) }
#[doc = "Bit 4 - I/O Default mode"]
#[inline (always)] pub fn iodef (& mut self) -> IodefW < '_ , CrSpec > { IodefW :: new (self , 4) }
#[doc = "Bits 5:7 - Max count value"]
#[inline (always)] pub fn mcv (& mut self) -> McvW < '_ , CrSpec > { McvW :: new (self , 5) }
#[doc = "Bits 12:14 - pulse generator prescaler"]
#[inline (always)] pub fn pgpsc (& mut self) -> PgpscW < '_ , CrSpec > { PgpscW :: new (self , 12) }
#[doc = "Bit 15 - Spread spectrum prescaler"]
#[inline (always)] pub fn sspsc (& mut self) -> SspscW < '_ , CrSpec > { SspscW :: new (self , 15) }
#[doc = "Bit 16 - Spread spectrum enable"]
#[inline (always)] pub fn sse (& mut self) -> SseW < '_ , CrSpec > { SseW :: new (self , 16) }
#[doc = "Bits 17:23 - Spread spectrum deviation"]
#[inline (always)] pub fn ssd (& mut self) -> SsdW < '_ , CrSpec > { SsdW :: new (self , 17) }
#[doc = "Bits 24:27 - Charge transfer pulse low"]
#[inline (always)] pub fn ctpl (& mut self) -> CtplW < '_ , CrSpec > { CtplW :: new (self , 24) }
#[doc = "Bits 28:31 - Charge transfer pulse high"]
#[inline (always)] pub fn ctph (& mut self) -> CtphW < '_ , CrSpec > { CtphW :: new (self , 28) } }
#[doc = "control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { } }
#[doc = "IER (rw) register accessor: interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ier`] module"]
#[doc (alias = "IER")] pub type Ier = crate :: Reg < ier :: IerSpec > ;
#[doc = "interrupt enable register"] pub mod ier {
#[doc = "Register `IER` reader"] pub type R = crate :: R < IerSpec > ;
#[doc = "Register `IER` writer"] pub type W = crate :: W < IerSpec > ;
#[doc = "Field `EOAIE` reader - End of acquisition interrupt enable"] pub type EoaieR = crate :: BitReader ;
#[doc = "Field `EOAIE` writer - End of acquisition interrupt enable"] pub type EoaieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MCEIE` reader - Max count error interrupt enable"] pub type MceieR = crate :: BitReader ;
#[doc = "Field `MCEIE` writer - Max count error interrupt enable"] pub type MceieW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - End of acquisition interrupt enable"]
#[inline (always)] pub fn eoaie (& self) -> EoaieR { EoaieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Max count error interrupt enable"]
#[inline (always)] pub fn mceie (& self) -> MceieR { MceieR :: new (((self . bits >> 1) & 1) != 0) } } impl W {
#[doc = "Bit 0 - End of acquisition interrupt enable"]
#[inline (always)] pub fn eoaie (& mut self) -> EoaieW < '_ , IerSpec > { EoaieW :: new (self , 0) }
#[doc = "Bit 1 - Max count error interrupt enable"]
#[inline (always)] pub fn mceie (& mut self) -> MceieW < '_ , IerSpec > { MceieW :: new (self , 1) } }
#[doc = "interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IerSpec ; impl crate :: RegisterSpec for IerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ier::R`](R) reader structure"] impl crate :: Readable for IerSpec { }
#[doc = "`write(|w| ..)` method takes [`ier::W`](W) writer structure"] impl crate :: Writable for IerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IER to value 0"] impl crate :: Resettable for IerSpec { } }
#[doc = "ICR (rw) register accessor: interrupt clear register\n\nYou can [`read`](crate::Reg::read) this register and get [`icr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@icr`] module"]
#[doc (alias = "ICR")] pub type Icr = crate :: Reg < icr :: IcrSpec > ;
#[doc = "interrupt clear register"] pub mod icr {
#[doc = "Register `ICR` reader"] pub type R = crate :: R < IcrSpec > ;
#[doc = "Register `ICR` writer"] pub type W = crate :: W < IcrSpec > ;
#[doc = "Field `EOAIC` reader - End of acquisition interrupt clear"] pub type EoaicR = crate :: BitReader ;
#[doc = "Field `EOAIC` writer - End of acquisition interrupt clear"] pub type EoaicW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MCEIC` reader - Max count error interrupt clear"] pub type MceicR = crate :: BitReader ;
#[doc = "Field `MCEIC` writer - Max count error interrupt clear"] pub type MceicW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - End of acquisition interrupt clear"]
#[inline (always)] pub fn eoaic (& self) -> EoaicR { EoaicR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Max count error interrupt clear"]
#[inline (always)] pub fn mceic (& self) -> MceicR { MceicR :: new (((self . bits >> 1) & 1) != 0) } } impl W {
#[doc = "Bit 0 - End of acquisition interrupt clear"]
#[inline (always)] pub fn eoaic (& mut self) -> EoaicW < '_ , IcrSpec > { EoaicW :: new (self , 0) }
#[doc = "Bit 1 - Max count error interrupt clear"]
#[inline (always)] pub fn mceic (& mut self) -> MceicW < '_ , IcrSpec > { MceicW :: new (self , 1) } }
#[doc = "interrupt clear register\n\nYou can [`read`](crate::Reg::read) this register and get [`icr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IcrSpec ; impl crate :: RegisterSpec for IcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`icr::R`](R) reader structure"] impl crate :: Readable for IcrSpec { }
#[doc = "`write(|w| ..)` method takes [`icr::W`](W) writer structure"] impl crate :: Writable for IcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ICR to value 0"] impl crate :: Resettable for IcrSpec { } }
#[doc = "ISR (rw) register accessor: interrupt status register\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`isr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@isr`] module"]
#[doc (alias = "ISR")] pub type Isr = crate :: Reg < isr :: IsrSpec > ;
#[doc = "interrupt status register"] pub mod isr {
#[doc = "Register `ISR` reader"] pub type R = crate :: R < IsrSpec > ;
#[doc = "Register `ISR` writer"] pub type W = crate :: W < IsrSpec > ;
#[doc = "Field `EOAF` reader - End of acquisition flag"] pub type EoafR = crate :: BitReader ;
#[doc = "Field `EOAF` writer - End of acquisition flag"] pub type EoafW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MCEF` reader - Max count error flag"] pub type McefR = crate :: BitReader ;
#[doc = "Field `MCEF` writer - Max count error flag"] pub type McefW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - End of acquisition flag"]
#[inline (always)] pub fn eoaf (& self) -> EoafR { EoafR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Max count error flag"]
#[inline (always)] pub fn mcef (& self) -> McefR { McefR :: new (((self . bits >> 1) & 1) != 0) } } impl W {
#[doc = "Bit 0 - End of acquisition flag"]
#[inline (always)] pub fn eoaf (& mut self) -> EoafW < '_ , IsrSpec > { EoafW :: new (self , 0) }
#[doc = "Bit 1 - Max count error flag"]
#[inline (always)] pub fn mcef (& mut self) -> McefW < '_ , IsrSpec > { McefW :: new (self , 1) } }
#[doc = "interrupt status register\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`isr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IsrSpec ; impl crate :: RegisterSpec for IsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`isr::R`](R) reader structure"] impl crate :: Readable for IsrSpec { }
#[doc = "`write(|w| ..)` method takes [`isr::W`](W) writer structure"] impl crate :: Writable for IsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ISR to value 0"] impl crate :: Resettable for IsrSpec { } }
#[doc = "IOHCR (rw) register accessor: I/O hysteresis control register\n\nYou can [`read`](crate::Reg::read) this register and get [`iohcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iohcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iohcr`] module"]
#[doc (alias = "IOHCR")] pub type Iohcr = crate :: Reg < iohcr :: IohcrSpec > ;
#[doc = "I/O hysteresis control register"] pub mod iohcr {
#[doc = "Register `IOHCR` reader"] pub type R = crate :: R < IohcrSpec > ;
#[doc = "Register `IOHCR` writer"] pub type W = crate :: W < IohcrSpec > ;
#[doc = "Field `G1_IO1` reader - G1_IO1"] pub type G1Io1R = crate :: BitReader ;
#[doc = "Field `G1_IO1` writer - G1_IO1"] pub type G1Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G1_IO2` reader - G1_IO2"] pub type G1Io2R = crate :: BitReader ;
#[doc = "Field `G1_IO2` writer - G1_IO2"] pub type G1Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G1_IO3` reader - G1_IO3"] pub type G1Io3R = crate :: BitReader ;
#[doc = "Field `G1_IO3` writer - G1_IO3"] pub type G1Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G1_IO4` reader - G1_IO4"] pub type G1Io4R = crate :: BitReader ;
#[doc = "Field `G1_IO4` writer - G1_IO4"] pub type G1Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G2_IO1` reader - G2_IO1"] pub type G2Io1R = crate :: BitReader ;
#[doc = "Field `G2_IO1` writer - G2_IO1"] pub type G2Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G2_IO2` reader - G2_IO2"] pub type G2Io2R = crate :: BitReader ;
#[doc = "Field `G2_IO2` writer - G2_IO2"] pub type G2Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G2_IO3` reader - G2_IO3"] pub type G2Io3R = crate :: BitReader ;
#[doc = "Field `G2_IO3` writer - G2_IO3"] pub type G2Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G2_IO4` reader - G2_IO4"] pub type G2Io4R = crate :: BitReader ;
#[doc = "Field `G2_IO4` writer - G2_IO4"] pub type G2Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G3_IO1` reader - G3_IO1"] pub type G3Io1R = crate :: BitReader ;
#[doc = "Field `G3_IO1` writer - G3_IO1"] pub type G3Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G3_IO2` reader - G3_IO2"] pub type G3Io2R = crate :: BitReader ;
#[doc = "Field `G3_IO2` writer - G3_IO2"] pub type G3Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G3_IO3` reader - G3_IO3"] pub type G3Io3R = crate :: BitReader ;
#[doc = "Field `G3_IO3` writer - G3_IO3"] pub type G3Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G3_IO4` reader - G3_IO4"] pub type G3Io4R = crate :: BitReader ;
#[doc = "Field `G3_IO4` writer - G3_IO4"] pub type G3Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G4_IO1` reader - G4_IO1"] pub type G4Io1R = crate :: BitReader ;
#[doc = "Field `G4_IO1` writer - G4_IO1"] pub type G4Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G4_IO2` reader - G4_IO2"] pub type G4Io2R = crate :: BitReader ;
#[doc = "Field `G4_IO2` writer - G4_IO2"] pub type G4Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G4_IO3` reader - G4_IO3"] pub type G4Io3R = crate :: BitReader ;
#[doc = "Field `G4_IO3` writer - G4_IO3"] pub type G4Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G4_IO4` reader - G4_IO4"] pub type G4Io4R = crate :: BitReader ;
#[doc = "Field `G4_IO4` writer - G4_IO4"] pub type G4Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G5_IO1` reader - G5_IO1"] pub type G5Io1R = crate :: BitReader ;
#[doc = "Field `G5_IO1` writer - G5_IO1"] pub type G5Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G5_IO2` reader - G5_IO2"] pub type G5Io2R = crate :: BitReader ;
#[doc = "Field `G5_IO2` writer - G5_IO2"] pub type G5Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G5_IO3` reader - G5_IO3"] pub type G5Io3R = crate :: BitReader ;
#[doc = "Field `G5_IO3` writer - G5_IO3"] pub type G5Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G5_IO4` reader - G5_IO4"] pub type G5Io4R = crate :: BitReader ;
#[doc = "Field `G5_IO4` writer - G5_IO4"] pub type G5Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G6_IO1` reader - G6_IO1"] pub type G6Io1R = crate :: BitReader ;
#[doc = "Field `G6_IO1` writer - G6_IO1"] pub type G6Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G6_IO2` reader - G6_IO2"] pub type G6Io2R = crate :: BitReader ;
#[doc = "Field `G6_IO2` writer - G6_IO2"] pub type G6Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G6_IO3` reader - G6_IO3"] pub type G6Io3R = crate :: BitReader ;
#[doc = "Field `G6_IO3` writer - G6_IO3"] pub type G6Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G6_IO4` reader - G6_IO4"] pub type G6Io4R = crate :: BitReader ;
#[doc = "Field `G6_IO4` writer - G6_IO4"] pub type G6Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G7_IO1` reader - G7_IO1"] pub type G7Io1R = crate :: BitReader ;
#[doc = "Field `G7_IO1` writer - G7_IO1"] pub type G7Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G7_IO2` reader - G7_IO2"] pub type G7Io2R = crate :: BitReader ;
#[doc = "Field `G7_IO2` writer - G7_IO2"] pub type G7Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G7_IO3` reader - G7_IO3"] pub type G7Io3R = crate :: BitReader ;
#[doc = "Field `G7_IO3` writer - G7_IO3"] pub type G7Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G7_IO4` reader - G7_IO4"] pub type G7Io4R = crate :: BitReader ;
#[doc = "Field `G7_IO4` writer - G7_IO4"] pub type G7Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - G1_IO1"]
#[inline (always)] pub fn g1_io1 (& self) -> G1Io1R { G1Io1R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - G1_IO2"]
#[inline (always)] pub fn g1_io2 (& self) -> G1Io2R { G1Io2R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - G1_IO3"]
#[inline (always)] pub fn g1_io3 (& self) -> G1Io3R { G1Io3R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - G1_IO4"]
#[inline (always)] pub fn g1_io4 (& self) -> G1Io4R { G1Io4R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - G2_IO1"]
#[inline (always)] pub fn g2_io1 (& self) -> G2Io1R { G2Io1R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - G2_IO2"]
#[inline (always)] pub fn g2_io2 (& self) -> G2Io2R { G2Io2R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - G2_IO3"]
#[inline (always)] pub fn g2_io3 (& self) -> G2Io3R { G2Io3R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - G2_IO4"]
#[inline (always)] pub fn g2_io4 (& self) -> G2Io4R { G2Io4R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - G3_IO1"]
#[inline (always)] pub fn g3_io1 (& self) -> G3Io1R { G3Io1R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - G3_IO2"]
#[inline (always)] pub fn g3_io2 (& self) -> G3Io2R { G3Io2R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - G3_IO3"]
#[inline (always)] pub fn g3_io3 (& self) -> G3Io3R { G3Io3R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - G3_IO4"]
#[inline (always)] pub fn g3_io4 (& self) -> G3Io4R { G3Io4R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - G4_IO1"]
#[inline (always)] pub fn g4_io1 (& self) -> G4Io1R { G4Io1R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - G4_IO2"]
#[inline (always)] pub fn g4_io2 (& self) -> G4Io2R { G4Io2R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - G4_IO3"]
#[inline (always)] pub fn g4_io3 (& self) -> G4Io3R { G4Io3R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - G4_IO4"]
#[inline (always)] pub fn g4_io4 (& self) -> G4Io4R { G4Io4R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - G5_IO1"]
#[inline (always)] pub fn g5_io1 (& self) -> G5Io1R { G5Io1R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - G5_IO2"]
#[inline (always)] pub fn g5_io2 (& self) -> G5Io2R { G5Io2R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - G5_IO3"]
#[inline (always)] pub fn g5_io3 (& self) -> G5Io3R { G5Io3R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - G5_IO4"]
#[inline (always)] pub fn g5_io4 (& self) -> G5Io4R { G5Io4R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - G6_IO1"]
#[inline (always)] pub fn g6_io1 (& self) -> G6Io1R { G6Io1R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - G6_IO2"]
#[inline (always)] pub fn g6_io2 (& self) -> G6Io2R { G6Io2R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - G6_IO3"]
#[inline (always)] pub fn g6_io3 (& self) -> G6Io3R { G6Io3R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - G6_IO4"]
#[inline (always)] pub fn g6_io4 (& self) -> G6Io4R { G6Io4R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - G7_IO1"]
#[inline (always)] pub fn g7_io1 (& self) -> G7Io1R { G7Io1R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - G7_IO2"]
#[inline (always)] pub fn g7_io2 (& self) -> G7Io2R { G7Io2R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - G7_IO3"]
#[inline (always)] pub fn g7_io3 (& self) -> G7Io3R { G7Io3R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - G7_IO4"]
#[inline (always)] pub fn g7_io4 (& self) -> G7Io4R { G7Io4R :: new (((self . bits >> 27) & 1) != 0) } } impl W {
#[doc = "Bit 0 - G1_IO1"]
#[inline (always)] pub fn g1_io1 (& mut self) -> G1Io1W < '_ , IohcrSpec > { G1Io1W :: new (self , 0) }
#[doc = "Bit 1 - G1_IO2"]
#[inline (always)] pub fn g1_io2 (& mut self) -> G1Io2W < '_ , IohcrSpec > { G1Io2W :: new (self , 1) }
#[doc = "Bit 2 - G1_IO3"]
#[inline (always)] pub fn g1_io3 (& mut self) -> G1Io3W < '_ , IohcrSpec > { G1Io3W :: new (self , 2) }
#[doc = "Bit 3 - G1_IO4"]
#[inline (always)] pub fn g1_io4 (& mut self) -> G1Io4W < '_ , IohcrSpec > { G1Io4W :: new (self , 3) }
#[doc = "Bit 4 - G2_IO1"]
#[inline (always)] pub fn g2_io1 (& mut self) -> G2Io1W < '_ , IohcrSpec > { G2Io1W :: new (self , 4) }
#[doc = "Bit 5 - G2_IO2"]
#[inline (always)] pub fn g2_io2 (& mut self) -> G2Io2W < '_ , IohcrSpec > { G2Io2W :: new (self , 5) }
#[doc = "Bit 6 - G2_IO3"]
#[inline (always)] pub fn g2_io3 (& mut self) -> G2Io3W < '_ , IohcrSpec > { G2Io3W :: new (self , 6) }
#[doc = "Bit 7 - G2_IO4"]
#[inline (always)] pub fn g2_io4 (& mut self) -> G2Io4W < '_ , IohcrSpec > { G2Io4W :: new (self , 7) }
#[doc = "Bit 8 - G3_IO1"]
#[inline (always)] pub fn g3_io1 (& mut self) -> G3Io1W < '_ , IohcrSpec > { G3Io1W :: new (self , 8) }
#[doc = "Bit 9 - G3_IO2"]
#[inline (always)] pub fn g3_io2 (& mut self) -> G3Io2W < '_ , IohcrSpec > { G3Io2W :: new (self , 9) }
#[doc = "Bit 10 - G3_IO3"]
#[inline (always)] pub fn g3_io3 (& mut self) -> G3Io3W < '_ , IohcrSpec > { G3Io3W :: new (self , 10) }
#[doc = "Bit 11 - G3_IO4"]
#[inline (always)] pub fn g3_io4 (& mut self) -> G3Io4W < '_ , IohcrSpec > { G3Io4W :: new (self , 11) }
#[doc = "Bit 12 - G4_IO1"]
#[inline (always)] pub fn g4_io1 (& mut self) -> G4Io1W < '_ , IohcrSpec > { G4Io1W :: new (self , 12) }
#[doc = "Bit 13 - G4_IO2"]
#[inline (always)] pub fn g4_io2 (& mut self) -> G4Io2W < '_ , IohcrSpec > { G4Io2W :: new (self , 13) }
#[doc = "Bit 14 - G4_IO3"]
#[inline (always)] pub fn g4_io3 (& mut self) -> G4Io3W < '_ , IohcrSpec > { G4Io3W :: new (self , 14) }
#[doc = "Bit 15 - G4_IO4"]
#[inline (always)] pub fn g4_io4 (& mut self) -> G4Io4W < '_ , IohcrSpec > { G4Io4W :: new (self , 15) }
#[doc = "Bit 16 - G5_IO1"]
#[inline (always)] pub fn g5_io1 (& mut self) -> G5Io1W < '_ , IohcrSpec > { G5Io1W :: new (self , 16) }
#[doc = "Bit 17 - G5_IO2"]
#[inline (always)] pub fn g5_io2 (& mut self) -> G5Io2W < '_ , IohcrSpec > { G5Io2W :: new (self , 17) }
#[doc = "Bit 18 - G5_IO3"]
#[inline (always)] pub fn g5_io3 (& mut self) -> G5Io3W < '_ , IohcrSpec > { G5Io3W :: new (self , 18) }
#[doc = "Bit 19 - G5_IO4"]
#[inline (always)] pub fn g5_io4 (& mut self) -> G5Io4W < '_ , IohcrSpec > { G5Io4W :: new (self , 19) }
#[doc = "Bit 20 - G6_IO1"]
#[inline (always)] pub fn g6_io1 (& mut self) -> G6Io1W < '_ , IohcrSpec > { G6Io1W :: new (self , 20) }
#[doc = "Bit 21 - G6_IO2"]
#[inline (always)] pub fn g6_io2 (& mut self) -> G6Io2W < '_ , IohcrSpec > { G6Io2W :: new (self , 21) }
#[doc = "Bit 22 - G6_IO3"]
#[inline (always)] pub fn g6_io3 (& mut self) -> G6Io3W < '_ , IohcrSpec > { G6Io3W :: new (self , 22) }
#[doc = "Bit 23 - G6_IO4"]
#[inline (always)] pub fn g6_io4 (& mut self) -> G6Io4W < '_ , IohcrSpec > { G6Io4W :: new (self , 23) }
#[doc = "Bit 24 - G7_IO1"]
#[inline (always)] pub fn g7_io1 (& mut self) -> G7Io1W < '_ , IohcrSpec > { G7Io1W :: new (self , 24) }
#[doc = "Bit 25 - G7_IO2"]
#[inline (always)] pub fn g7_io2 (& mut self) -> G7Io2W < '_ , IohcrSpec > { G7Io2W :: new (self , 25) }
#[doc = "Bit 26 - G7_IO3"]
#[inline (always)] pub fn g7_io3 (& mut self) -> G7Io3W < '_ , IohcrSpec > { G7Io3W :: new (self , 26) }
#[doc = "Bit 27 - G7_IO4"]
#[inline (always)] pub fn g7_io4 (& mut self) -> G7Io4W < '_ , IohcrSpec > { G7Io4W :: new (self , 27) } }
#[doc = "I/O hysteresis control register\n\nYou can [`read`](crate::Reg::read) this register and get [`iohcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iohcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IohcrSpec ; impl crate :: RegisterSpec for IohcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`iohcr::R`](R) reader structure"] impl crate :: Readable for IohcrSpec { }
#[doc = "`write(|w| ..)` method takes [`iohcr::W`](W) writer structure"] impl crate :: Writable for IohcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IOHCR to value 0xffff_ffff"] impl crate :: Resettable for IohcrSpec { const RESET_VALUE : u32 = 0xffff_ffff ; } }
#[doc = "IOASCR (rw) register accessor: I/O analog switch control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ioascr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ioascr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ioascr`] module"]
#[doc (alias = "IOASCR")] pub type Ioascr = crate :: Reg < ioascr :: IoascrSpec > ;
#[doc = "I/O analog switch control register"] pub mod ioascr {
#[doc = "Register `IOASCR` reader"] pub type R = crate :: R < IoascrSpec > ;
#[doc = "Register `IOASCR` writer"] pub type W = crate :: W < IoascrSpec > ;
#[doc = "Field `G1_IO1` reader - G1_IO1"] pub type G1Io1R = crate :: BitReader ;
#[doc = "Field `G1_IO1` writer - G1_IO1"] pub type G1Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G1_IO2` reader - G1_IO2"] pub type G1Io2R = crate :: BitReader ;
#[doc = "Field `G1_IO2` writer - G1_IO2"] pub type G1Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G1_IO3` reader - G1_IO3"] pub type G1Io3R = crate :: BitReader ;
#[doc = "Field `G1_IO3` writer - G1_IO3"] pub type G1Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G1_IO4` reader - G1_IO4"] pub type G1Io4R = crate :: BitReader ;
#[doc = "Field `G1_IO4` writer - G1_IO4"] pub type G1Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G2_IO1` reader - G2_IO1"] pub type G2Io1R = crate :: BitReader ;
#[doc = "Field `G2_IO1` writer - G2_IO1"] pub type G2Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G2_IO2` reader - G2_IO2"] pub type G2Io2R = crate :: BitReader ;
#[doc = "Field `G2_IO2` writer - G2_IO2"] pub type G2Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G2_IO3` reader - G2_IO3"] pub type G2Io3R = crate :: BitReader ;
#[doc = "Field `G2_IO3` writer - G2_IO3"] pub type G2Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G2_IO4` reader - G2_IO4"] pub type G2Io4R = crate :: BitReader ;
#[doc = "Field `G2_IO4` writer - G2_IO4"] pub type G2Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G3_IO1` reader - G3_IO1"] pub type G3Io1R = crate :: BitReader ;
#[doc = "Field `G3_IO1` writer - G3_IO1"] pub type G3Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G3_IO2` reader - G3_IO2"] pub type G3Io2R = crate :: BitReader ;
#[doc = "Field `G3_IO2` writer - G3_IO2"] pub type G3Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G3_IO3` reader - G3_IO3"] pub type G3Io3R = crate :: BitReader ;
#[doc = "Field `G3_IO3` writer - G3_IO3"] pub type G3Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G3_IO4` reader - G3_IO4"] pub type G3Io4R = crate :: BitReader ;
#[doc = "Field `G3_IO4` writer - G3_IO4"] pub type G3Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G4_IO1` reader - G4_IO1"] pub type G4Io1R = crate :: BitReader ;
#[doc = "Field `G4_IO1` writer - G4_IO1"] pub type G4Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G4_IO2` reader - G4_IO2"] pub type G4Io2R = crate :: BitReader ;
#[doc = "Field `G4_IO2` writer - G4_IO2"] pub type G4Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G4_IO3` reader - G4_IO3"] pub type G4Io3R = crate :: BitReader ;
#[doc = "Field `G4_IO3` writer - G4_IO3"] pub type G4Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G4_IO4` reader - G4_IO4"] pub type G4Io4R = crate :: BitReader ;
#[doc = "Field `G4_IO4` writer - G4_IO4"] pub type G4Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G5_IO1` reader - G5_IO1"] pub type G5Io1R = crate :: BitReader ;
#[doc = "Field `G5_IO1` writer - G5_IO1"] pub type G5Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G5_IO2` reader - G5_IO2"] pub type G5Io2R = crate :: BitReader ;
#[doc = "Field `G5_IO2` writer - G5_IO2"] pub type G5Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G5_IO3` reader - G5_IO3"] pub type G5Io3R = crate :: BitReader ;
#[doc = "Field `G5_IO3` writer - G5_IO3"] pub type G5Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G5_IO4` reader - G5_IO4"] pub type G5Io4R = crate :: BitReader ;
#[doc = "Field `G5_IO4` writer - G5_IO4"] pub type G5Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G6_IO1` reader - G6_IO1"] pub type G6Io1R = crate :: BitReader ;
#[doc = "Field `G6_IO1` writer - G6_IO1"] pub type G6Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G6_IO2` reader - G6_IO2"] pub type G6Io2R = crate :: BitReader ;
#[doc = "Field `G6_IO2` writer - G6_IO2"] pub type G6Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G6_IO3` reader - G6_IO3"] pub type G6Io3R = crate :: BitReader ;
#[doc = "Field `G6_IO3` writer - G6_IO3"] pub type G6Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G6_IO4` reader - G6_IO4"] pub type G6Io4R = crate :: BitReader ;
#[doc = "Field `G6_IO4` writer - G6_IO4"] pub type G6Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G7_IO1` reader - G7_IO1"] pub type G7Io1R = crate :: BitReader ;
#[doc = "Field `G7_IO1` writer - G7_IO1"] pub type G7Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G7_IO2` reader - G7_IO2"] pub type G7Io2R = crate :: BitReader ;
#[doc = "Field `G7_IO2` writer - G7_IO2"] pub type G7Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G7_IO3` reader - G7_IO3"] pub type G7Io3R = crate :: BitReader ;
#[doc = "Field `G7_IO3` writer - G7_IO3"] pub type G7Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G7_IO4` reader - G7_IO4"] pub type G7Io4R = crate :: BitReader ;
#[doc = "Field `G7_IO4` writer - G7_IO4"] pub type G7Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - G1_IO1"]
#[inline (always)] pub fn g1_io1 (& self) -> G1Io1R { G1Io1R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - G1_IO2"]
#[inline (always)] pub fn g1_io2 (& self) -> G1Io2R { G1Io2R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - G1_IO3"]
#[inline (always)] pub fn g1_io3 (& self) -> G1Io3R { G1Io3R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - G1_IO4"]
#[inline (always)] pub fn g1_io4 (& self) -> G1Io4R { G1Io4R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - G2_IO1"]
#[inline (always)] pub fn g2_io1 (& self) -> G2Io1R { G2Io1R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - G2_IO2"]
#[inline (always)] pub fn g2_io2 (& self) -> G2Io2R { G2Io2R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - G2_IO3"]
#[inline (always)] pub fn g2_io3 (& self) -> G2Io3R { G2Io3R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - G2_IO4"]
#[inline (always)] pub fn g2_io4 (& self) -> G2Io4R { G2Io4R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - G3_IO1"]
#[inline (always)] pub fn g3_io1 (& self) -> G3Io1R { G3Io1R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - G3_IO2"]
#[inline (always)] pub fn g3_io2 (& self) -> G3Io2R { G3Io2R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - G3_IO3"]
#[inline (always)] pub fn g3_io3 (& self) -> G3Io3R { G3Io3R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - G3_IO4"]
#[inline (always)] pub fn g3_io4 (& self) -> G3Io4R { G3Io4R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - G4_IO1"]
#[inline (always)] pub fn g4_io1 (& self) -> G4Io1R { G4Io1R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - G4_IO2"]
#[inline (always)] pub fn g4_io2 (& self) -> G4Io2R { G4Io2R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - G4_IO3"]
#[inline (always)] pub fn g4_io3 (& self) -> G4Io3R { G4Io3R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - G4_IO4"]
#[inline (always)] pub fn g4_io4 (& self) -> G4Io4R { G4Io4R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - G5_IO1"]
#[inline (always)] pub fn g5_io1 (& self) -> G5Io1R { G5Io1R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - G5_IO2"]
#[inline (always)] pub fn g5_io2 (& self) -> G5Io2R { G5Io2R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - G5_IO3"]
#[inline (always)] pub fn g5_io3 (& self) -> G5Io3R { G5Io3R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - G5_IO4"]
#[inline (always)] pub fn g5_io4 (& self) -> G5Io4R { G5Io4R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - G6_IO1"]
#[inline (always)] pub fn g6_io1 (& self) -> G6Io1R { G6Io1R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - G6_IO2"]
#[inline (always)] pub fn g6_io2 (& self) -> G6Io2R { G6Io2R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - G6_IO3"]
#[inline (always)] pub fn g6_io3 (& self) -> G6Io3R { G6Io3R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - G6_IO4"]
#[inline (always)] pub fn g6_io4 (& self) -> G6Io4R { G6Io4R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - G7_IO1"]
#[inline (always)] pub fn g7_io1 (& self) -> G7Io1R { G7Io1R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - G7_IO2"]
#[inline (always)] pub fn g7_io2 (& self) -> G7Io2R { G7Io2R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - G7_IO3"]
#[inline (always)] pub fn g7_io3 (& self) -> G7Io3R { G7Io3R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - G7_IO4"]
#[inline (always)] pub fn g7_io4 (& self) -> G7Io4R { G7Io4R :: new (((self . bits >> 27) & 1) != 0) } } impl W {
#[doc = "Bit 0 - G1_IO1"]
#[inline (always)] pub fn g1_io1 (& mut self) -> G1Io1W < '_ , IoascrSpec > { G1Io1W :: new (self , 0) }
#[doc = "Bit 1 - G1_IO2"]
#[inline (always)] pub fn g1_io2 (& mut self) -> G1Io2W < '_ , IoascrSpec > { G1Io2W :: new (self , 1) }
#[doc = "Bit 2 - G1_IO3"]
#[inline (always)] pub fn g1_io3 (& mut self) -> G1Io3W < '_ , IoascrSpec > { G1Io3W :: new (self , 2) }
#[doc = "Bit 3 - G1_IO4"]
#[inline (always)] pub fn g1_io4 (& mut self) -> G1Io4W < '_ , IoascrSpec > { G1Io4W :: new (self , 3) }
#[doc = "Bit 4 - G2_IO1"]
#[inline (always)] pub fn g2_io1 (& mut self) -> G2Io1W < '_ , IoascrSpec > { G2Io1W :: new (self , 4) }
#[doc = "Bit 5 - G2_IO2"]
#[inline (always)] pub fn g2_io2 (& mut self) -> G2Io2W < '_ , IoascrSpec > { G2Io2W :: new (self , 5) }
#[doc = "Bit 6 - G2_IO3"]
#[inline (always)] pub fn g2_io3 (& mut self) -> G2Io3W < '_ , IoascrSpec > { G2Io3W :: new (self , 6) }
#[doc = "Bit 7 - G2_IO4"]
#[inline (always)] pub fn g2_io4 (& mut self) -> G2Io4W < '_ , IoascrSpec > { G2Io4W :: new (self , 7) }
#[doc = "Bit 8 - G3_IO1"]
#[inline (always)] pub fn g3_io1 (& mut self) -> G3Io1W < '_ , IoascrSpec > { G3Io1W :: new (self , 8) }
#[doc = "Bit 9 - G3_IO2"]
#[inline (always)] pub fn g3_io2 (& mut self) -> G3Io2W < '_ , IoascrSpec > { G3Io2W :: new (self , 9) }
#[doc = "Bit 10 - G3_IO3"]
#[inline (always)] pub fn g3_io3 (& mut self) -> G3Io3W < '_ , IoascrSpec > { G3Io3W :: new (self , 10) }
#[doc = "Bit 11 - G3_IO4"]
#[inline (always)] pub fn g3_io4 (& mut self) -> G3Io4W < '_ , IoascrSpec > { G3Io4W :: new (self , 11) }
#[doc = "Bit 12 - G4_IO1"]
#[inline (always)] pub fn g4_io1 (& mut self) -> G4Io1W < '_ , IoascrSpec > { G4Io1W :: new (self , 12) }
#[doc = "Bit 13 - G4_IO2"]
#[inline (always)] pub fn g4_io2 (& mut self) -> G4Io2W < '_ , IoascrSpec > { G4Io2W :: new (self , 13) }
#[doc = "Bit 14 - G4_IO3"]
#[inline (always)] pub fn g4_io3 (& mut self) -> G4Io3W < '_ , IoascrSpec > { G4Io3W :: new (self , 14) }
#[doc = "Bit 15 - G4_IO4"]
#[inline (always)] pub fn g4_io4 (& mut self) -> G4Io4W < '_ , IoascrSpec > { G4Io4W :: new (self , 15) }
#[doc = "Bit 16 - G5_IO1"]
#[inline (always)] pub fn g5_io1 (& mut self) -> G5Io1W < '_ , IoascrSpec > { G5Io1W :: new (self , 16) }
#[doc = "Bit 17 - G5_IO2"]
#[inline (always)] pub fn g5_io2 (& mut self) -> G5Io2W < '_ , IoascrSpec > { G5Io2W :: new (self , 17) }
#[doc = "Bit 18 - G5_IO3"]
#[inline (always)] pub fn g5_io3 (& mut self) -> G5Io3W < '_ , IoascrSpec > { G5Io3W :: new (self , 18) }
#[doc = "Bit 19 - G5_IO4"]
#[inline (always)] pub fn g5_io4 (& mut self) -> G5Io4W < '_ , IoascrSpec > { G5Io4W :: new (self , 19) }
#[doc = "Bit 20 - G6_IO1"]
#[inline (always)] pub fn g6_io1 (& mut self) -> G6Io1W < '_ , IoascrSpec > { G6Io1W :: new (self , 20) }
#[doc = "Bit 21 - G6_IO2"]
#[inline (always)] pub fn g6_io2 (& mut self) -> G6Io2W < '_ , IoascrSpec > { G6Io2W :: new (self , 21) }
#[doc = "Bit 22 - G6_IO3"]
#[inline (always)] pub fn g6_io3 (& mut self) -> G6Io3W < '_ , IoascrSpec > { G6Io3W :: new (self , 22) }
#[doc = "Bit 23 - G6_IO4"]
#[inline (always)] pub fn g6_io4 (& mut self) -> G6Io4W < '_ , IoascrSpec > { G6Io4W :: new (self , 23) }
#[doc = "Bit 24 - G7_IO1"]
#[inline (always)] pub fn g7_io1 (& mut self) -> G7Io1W < '_ , IoascrSpec > { G7Io1W :: new (self , 24) }
#[doc = "Bit 25 - G7_IO2"]
#[inline (always)] pub fn g7_io2 (& mut self) -> G7Io2W < '_ , IoascrSpec > { G7Io2W :: new (self , 25) }
#[doc = "Bit 26 - G7_IO3"]
#[inline (always)] pub fn g7_io3 (& mut self) -> G7Io3W < '_ , IoascrSpec > { G7Io3W :: new (self , 26) }
#[doc = "Bit 27 - G7_IO4"]
#[inline (always)] pub fn g7_io4 (& mut self) -> G7Io4W < '_ , IoascrSpec > { G7Io4W :: new (self , 27) } }
#[doc = "I/O analog switch control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ioascr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ioascr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IoascrSpec ; impl crate :: RegisterSpec for IoascrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ioascr::R`](R) reader structure"] impl crate :: Readable for IoascrSpec { }
#[doc = "`write(|w| ..)` method takes [`ioascr::W`](W) writer structure"] impl crate :: Writable for IoascrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IOASCR to value 0"] impl crate :: Resettable for IoascrSpec { } }
#[doc = "IOSCR (rw) register accessor: I/O sampling control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ioscr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ioscr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ioscr`] module"]
#[doc (alias = "IOSCR")] pub type Ioscr = crate :: Reg < ioscr :: IoscrSpec > ;
#[doc = "I/O sampling control register"] pub mod ioscr {
#[doc = "Register `IOSCR` reader"] pub type R = crate :: R < IoscrSpec > ;
#[doc = "Register `IOSCR` writer"] pub type W = crate :: W < IoscrSpec > ;
#[doc = "Field `G1_IO1` reader - G1_IO1"] pub type G1Io1R = crate :: BitReader ;
#[doc = "Field `G1_IO1` writer - G1_IO1"] pub type G1Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G1_IO2` reader - G1_IO2"] pub type G1Io2R = crate :: BitReader ;
#[doc = "Field `G1_IO2` writer - G1_IO2"] pub type G1Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G1_IO3` reader - G1_IO3"] pub type G1Io3R = crate :: BitReader ;
#[doc = "Field `G1_IO3` writer - G1_IO3"] pub type G1Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G1_IO4` reader - G1_IO4"] pub type G1Io4R = crate :: BitReader ;
#[doc = "Field `G1_IO4` writer - G1_IO4"] pub type G1Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G2_IO1` reader - G2_IO1"] pub type G2Io1R = crate :: BitReader ;
#[doc = "Field `G2_IO1` writer - G2_IO1"] pub type G2Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G2_IO2` reader - G2_IO2"] pub type G2Io2R = crate :: BitReader ;
#[doc = "Field `G2_IO2` writer - G2_IO2"] pub type G2Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G2_IO3` reader - G2_IO3"] pub type G2Io3R = crate :: BitReader ;
#[doc = "Field `G2_IO3` writer - G2_IO3"] pub type G2Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G2_IO4` reader - G2_IO4"] pub type G2Io4R = crate :: BitReader ;
#[doc = "Field `G2_IO4` writer - G2_IO4"] pub type G2Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G3_IO1` reader - G3_IO1"] pub type G3Io1R = crate :: BitReader ;
#[doc = "Field `G3_IO1` writer - G3_IO1"] pub type G3Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G3_IO2` reader - G3_IO2"] pub type G3Io2R = crate :: BitReader ;
#[doc = "Field `G3_IO2` writer - G3_IO2"] pub type G3Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G3_IO3` reader - G3_IO3"] pub type G3Io3R = crate :: BitReader ;
#[doc = "Field `G3_IO3` writer - G3_IO3"] pub type G3Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G3_IO4` reader - G3_IO4"] pub type G3Io4R = crate :: BitReader ;
#[doc = "Field `G3_IO4` writer - G3_IO4"] pub type G3Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G4_IO1` reader - G4_IO1"] pub type G4Io1R = crate :: BitReader ;
#[doc = "Field `G4_IO1` writer - G4_IO1"] pub type G4Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G4_IO2` reader - G4_IO2"] pub type G4Io2R = crate :: BitReader ;
#[doc = "Field `G4_IO2` writer - G4_IO2"] pub type G4Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G4_IO3` reader - G4_IO3"] pub type G4Io3R = crate :: BitReader ;
#[doc = "Field `G4_IO3` writer - G4_IO3"] pub type G4Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G4_IO4` reader - G4_IO4"] pub type G4Io4R = crate :: BitReader ;
#[doc = "Field `G4_IO4` writer - G4_IO4"] pub type G4Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G5_IO1` reader - G5_IO1"] pub type G5Io1R = crate :: BitReader ;
#[doc = "Field `G5_IO1` writer - G5_IO1"] pub type G5Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G5_IO2` reader - G5_IO2"] pub type G5Io2R = crate :: BitReader ;
#[doc = "Field `G5_IO2` writer - G5_IO2"] pub type G5Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G5_IO3` reader - G5_IO3"] pub type G5Io3R = crate :: BitReader ;
#[doc = "Field `G5_IO3` writer - G5_IO3"] pub type G5Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G5_IO4` reader - G5_IO4"] pub type G5Io4R = crate :: BitReader ;
#[doc = "Field `G5_IO4` writer - G5_IO4"] pub type G5Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G6_IO1` reader - G6_IO1"] pub type G6Io1R = crate :: BitReader ;
#[doc = "Field `G6_IO1` writer - G6_IO1"] pub type G6Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G6_IO2` reader - G6_IO2"] pub type G6Io2R = crate :: BitReader ;
#[doc = "Field `G6_IO2` writer - G6_IO2"] pub type G6Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G6_IO3` reader - G6_IO3"] pub type G6Io3R = crate :: BitReader ;
#[doc = "Field `G6_IO3` writer - G6_IO3"] pub type G6Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G6_IO4` reader - G6_IO4"] pub type G6Io4R = crate :: BitReader ;
#[doc = "Field `G6_IO4` writer - G6_IO4"] pub type G6Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G7_IO1` reader - G7_IO1"] pub type G7Io1R = crate :: BitReader ;
#[doc = "Field `G7_IO1` writer - G7_IO1"] pub type G7Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G7_IO2` reader - G7_IO2"] pub type G7Io2R = crate :: BitReader ;
#[doc = "Field `G7_IO2` writer - G7_IO2"] pub type G7Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G7_IO3` reader - G7_IO3"] pub type G7Io3R = crate :: BitReader ;
#[doc = "Field `G7_IO3` writer - G7_IO3"] pub type G7Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G7_IO4` reader - G7_IO4"] pub type G7Io4R = crate :: BitReader ;
#[doc = "Field `G7_IO4` writer - G7_IO4"] pub type G7Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - G1_IO1"]
#[inline (always)] pub fn g1_io1 (& self) -> G1Io1R { G1Io1R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - G1_IO2"]
#[inline (always)] pub fn g1_io2 (& self) -> G1Io2R { G1Io2R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - G1_IO3"]
#[inline (always)] pub fn g1_io3 (& self) -> G1Io3R { G1Io3R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - G1_IO4"]
#[inline (always)] pub fn g1_io4 (& self) -> G1Io4R { G1Io4R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - G2_IO1"]
#[inline (always)] pub fn g2_io1 (& self) -> G2Io1R { G2Io1R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - G2_IO2"]
#[inline (always)] pub fn g2_io2 (& self) -> G2Io2R { G2Io2R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - G2_IO3"]
#[inline (always)] pub fn g2_io3 (& self) -> G2Io3R { G2Io3R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - G2_IO4"]
#[inline (always)] pub fn g2_io4 (& self) -> G2Io4R { G2Io4R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - G3_IO1"]
#[inline (always)] pub fn g3_io1 (& self) -> G3Io1R { G3Io1R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - G3_IO2"]
#[inline (always)] pub fn g3_io2 (& self) -> G3Io2R { G3Io2R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - G3_IO3"]
#[inline (always)] pub fn g3_io3 (& self) -> G3Io3R { G3Io3R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - G3_IO4"]
#[inline (always)] pub fn g3_io4 (& self) -> G3Io4R { G3Io4R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - G4_IO1"]
#[inline (always)] pub fn g4_io1 (& self) -> G4Io1R { G4Io1R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - G4_IO2"]
#[inline (always)] pub fn g4_io2 (& self) -> G4Io2R { G4Io2R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - G4_IO3"]
#[inline (always)] pub fn g4_io3 (& self) -> G4Io3R { G4Io3R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - G4_IO4"]
#[inline (always)] pub fn g4_io4 (& self) -> G4Io4R { G4Io4R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - G5_IO1"]
#[inline (always)] pub fn g5_io1 (& self) -> G5Io1R { G5Io1R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - G5_IO2"]
#[inline (always)] pub fn g5_io2 (& self) -> G5Io2R { G5Io2R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - G5_IO3"]
#[inline (always)] pub fn g5_io3 (& self) -> G5Io3R { G5Io3R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - G5_IO4"]
#[inline (always)] pub fn g5_io4 (& self) -> G5Io4R { G5Io4R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - G6_IO1"]
#[inline (always)] pub fn g6_io1 (& self) -> G6Io1R { G6Io1R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - G6_IO2"]
#[inline (always)] pub fn g6_io2 (& self) -> G6Io2R { G6Io2R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - G6_IO3"]
#[inline (always)] pub fn g6_io3 (& self) -> G6Io3R { G6Io3R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - G6_IO4"]
#[inline (always)] pub fn g6_io4 (& self) -> G6Io4R { G6Io4R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - G7_IO1"]
#[inline (always)] pub fn g7_io1 (& self) -> G7Io1R { G7Io1R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - G7_IO2"]
#[inline (always)] pub fn g7_io2 (& self) -> G7Io2R { G7Io2R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - G7_IO3"]
#[inline (always)] pub fn g7_io3 (& self) -> G7Io3R { G7Io3R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - G7_IO4"]
#[inline (always)] pub fn g7_io4 (& self) -> G7Io4R { G7Io4R :: new (((self . bits >> 27) & 1) != 0) } } impl W {
#[doc = "Bit 0 - G1_IO1"]
#[inline (always)] pub fn g1_io1 (& mut self) -> G1Io1W < '_ , IoscrSpec > { G1Io1W :: new (self , 0) }
#[doc = "Bit 1 - G1_IO2"]
#[inline (always)] pub fn g1_io2 (& mut self) -> G1Io2W < '_ , IoscrSpec > { G1Io2W :: new (self , 1) }
#[doc = "Bit 2 - G1_IO3"]
#[inline (always)] pub fn g1_io3 (& mut self) -> G1Io3W < '_ , IoscrSpec > { G1Io3W :: new (self , 2) }
#[doc = "Bit 3 - G1_IO4"]
#[inline (always)] pub fn g1_io4 (& mut self) -> G1Io4W < '_ , IoscrSpec > { G1Io4W :: new (self , 3) }
#[doc = "Bit 4 - G2_IO1"]
#[inline (always)] pub fn g2_io1 (& mut self) -> G2Io1W < '_ , IoscrSpec > { G2Io1W :: new (self , 4) }
#[doc = "Bit 5 - G2_IO2"]
#[inline (always)] pub fn g2_io2 (& mut self) -> G2Io2W < '_ , IoscrSpec > { G2Io2W :: new (self , 5) }
#[doc = "Bit 6 - G2_IO3"]
#[inline (always)] pub fn g2_io3 (& mut self) -> G2Io3W < '_ , IoscrSpec > { G2Io3W :: new (self , 6) }
#[doc = "Bit 7 - G2_IO4"]
#[inline (always)] pub fn g2_io4 (& mut self) -> G2Io4W < '_ , IoscrSpec > { G2Io4W :: new (self , 7) }
#[doc = "Bit 8 - G3_IO1"]
#[inline (always)] pub fn g3_io1 (& mut self) -> G3Io1W < '_ , IoscrSpec > { G3Io1W :: new (self , 8) }
#[doc = "Bit 9 - G3_IO2"]
#[inline (always)] pub fn g3_io2 (& mut self) -> G3Io2W < '_ , IoscrSpec > { G3Io2W :: new (self , 9) }
#[doc = "Bit 10 - G3_IO3"]
#[inline (always)] pub fn g3_io3 (& mut self) -> G3Io3W < '_ , IoscrSpec > { G3Io3W :: new (self , 10) }
#[doc = "Bit 11 - G3_IO4"]
#[inline (always)] pub fn g3_io4 (& mut self) -> G3Io4W < '_ , IoscrSpec > { G3Io4W :: new (self , 11) }
#[doc = "Bit 12 - G4_IO1"]
#[inline (always)] pub fn g4_io1 (& mut self) -> G4Io1W < '_ , IoscrSpec > { G4Io1W :: new (self , 12) }
#[doc = "Bit 13 - G4_IO2"]
#[inline (always)] pub fn g4_io2 (& mut self) -> G4Io2W < '_ , IoscrSpec > { G4Io2W :: new (self , 13) }
#[doc = "Bit 14 - G4_IO3"]
#[inline (always)] pub fn g4_io3 (& mut self) -> G4Io3W < '_ , IoscrSpec > { G4Io3W :: new (self , 14) }
#[doc = "Bit 15 - G4_IO4"]
#[inline (always)] pub fn g4_io4 (& mut self) -> G4Io4W < '_ , IoscrSpec > { G4Io4W :: new (self , 15) }
#[doc = "Bit 16 - G5_IO1"]
#[inline (always)] pub fn g5_io1 (& mut self) -> G5Io1W < '_ , IoscrSpec > { G5Io1W :: new (self , 16) }
#[doc = "Bit 17 - G5_IO2"]
#[inline (always)] pub fn g5_io2 (& mut self) -> G5Io2W < '_ , IoscrSpec > { G5Io2W :: new (self , 17) }
#[doc = "Bit 18 - G5_IO3"]
#[inline (always)] pub fn g5_io3 (& mut self) -> G5Io3W < '_ , IoscrSpec > { G5Io3W :: new (self , 18) }
#[doc = "Bit 19 - G5_IO4"]
#[inline (always)] pub fn g5_io4 (& mut self) -> G5Io4W < '_ , IoscrSpec > { G5Io4W :: new (self , 19) }
#[doc = "Bit 20 - G6_IO1"]
#[inline (always)] pub fn g6_io1 (& mut self) -> G6Io1W < '_ , IoscrSpec > { G6Io1W :: new (self , 20) }
#[doc = "Bit 21 - G6_IO2"]
#[inline (always)] pub fn g6_io2 (& mut self) -> G6Io2W < '_ , IoscrSpec > { G6Io2W :: new (self , 21) }
#[doc = "Bit 22 - G6_IO3"]
#[inline (always)] pub fn g6_io3 (& mut self) -> G6Io3W < '_ , IoscrSpec > { G6Io3W :: new (self , 22) }
#[doc = "Bit 23 - G6_IO4"]
#[inline (always)] pub fn g6_io4 (& mut self) -> G6Io4W < '_ , IoscrSpec > { G6Io4W :: new (self , 23) }
#[doc = "Bit 24 - G7_IO1"]
#[inline (always)] pub fn g7_io1 (& mut self) -> G7Io1W < '_ , IoscrSpec > { G7Io1W :: new (self , 24) }
#[doc = "Bit 25 - G7_IO2"]
#[inline (always)] pub fn g7_io2 (& mut self) -> G7Io2W < '_ , IoscrSpec > { G7Io2W :: new (self , 25) }
#[doc = "Bit 26 - G7_IO3"]
#[inline (always)] pub fn g7_io3 (& mut self) -> G7Io3W < '_ , IoscrSpec > { G7Io3W :: new (self , 26) }
#[doc = "Bit 27 - G7_IO4"]
#[inline (always)] pub fn g7_io4 (& mut self) -> G7Io4W < '_ , IoscrSpec > { G7Io4W :: new (self , 27) } }
#[doc = "I/O sampling control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ioscr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ioscr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IoscrSpec ; impl crate :: RegisterSpec for IoscrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ioscr::R`](R) reader structure"] impl crate :: Readable for IoscrSpec { }
#[doc = "`write(|w| ..)` method takes [`ioscr::W`](W) writer structure"] impl crate :: Writable for IoscrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IOSCR to value 0"] impl crate :: Resettable for IoscrSpec { } }
#[doc = "IOCCR (rw) register accessor: I/O channel control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ioccr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ioccr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ioccr`] module"]
#[doc (alias = "IOCCR")] pub type Ioccr = crate :: Reg < ioccr :: IoccrSpec > ;
#[doc = "I/O channel control register"] pub mod ioccr {
#[doc = "Register `IOCCR` reader"] pub type R = crate :: R < IoccrSpec > ;
#[doc = "Register `IOCCR` writer"] pub type W = crate :: W < IoccrSpec > ;
#[doc = "Field `G1_IO1` reader - G1_IO1"] pub type G1Io1R = crate :: BitReader ;
#[doc = "Field `G1_IO1` writer - G1_IO1"] pub type G1Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G1_IO2` reader - G1_IO2"] pub type G1Io2R = crate :: BitReader ;
#[doc = "Field `G1_IO2` writer - G1_IO2"] pub type G1Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G1_IO3` reader - G1_IO3"] pub type G1Io3R = crate :: BitReader ;
#[doc = "Field `G1_IO3` writer - G1_IO3"] pub type G1Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G1_IO4` reader - G1_IO4"] pub type G1Io4R = crate :: BitReader ;
#[doc = "Field `G1_IO4` writer - G1_IO4"] pub type G1Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G2_IO1` reader - G2_IO1"] pub type G2Io1R = crate :: BitReader ;
#[doc = "Field `G2_IO1` writer - G2_IO1"] pub type G2Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G2_IO2` reader - G2_IO2"] pub type G2Io2R = crate :: BitReader ;
#[doc = "Field `G2_IO2` writer - G2_IO2"] pub type G2Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G2_IO3` reader - G2_IO3"] pub type G2Io3R = crate :: BitReader ;
#[doc = "Field `G2_IO3` writer - G2_IO3"] pub type G2Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G2_IO4` reader - G2_IO4"] pub type G2Io4R = crate :: BitReader ;
#[doc = "Field `G2_IO4` writer - G2_IO4"] pub type G2Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G3_IO1` reader - G3_IO1"] pub type G3Io1R = crate :: BitReader ;
#[doc = "Field `G3_IO1` writer - G3_IO1"] pub type G3Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G3_IO2` reader - G3_IO2"] pub type G3Io2R = crate :: BitReader ;
#[doc = "Field `G3_IO2` writer - G3_IO2"] pub type G3Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G3_IO3` reader - G3_IO3"] pub type G3Io3R = crate :: BitReader ;
#[doc = "Field `G3_IO3` writer - G3_IO3"] pub type G3Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G3_IO4` reader - G3_IO4"] pub type G3Io4R = crate :: BitReader ;
#[doc = "Field `G3_IO4` writer - G3_IO4"] pub type G3Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G4_IO1` reader - G4_IO1"] pub type G4Io1R = crate :: BitReader ;
#[doc = "Field `G4_IO1` writer - G4_IO1"] pub type G4Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G4_IO2` reader - G4_IO2"] pub type G4Io2R = crate :: BitReader ;
#[doc = "Field `G4_IO2` writer - G4_IO2"] pub type G4Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G4_IO3` reader - G4_IO3"] pub type G4Io3R = crate :: BitReader ;
#[doc = "Field `G4_IO3` writer - G4_IO3"] pub type G4Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G4_IO4` reader - G4_IO4"] pub type G4Io4R = crate :: BitReader ;
#[doc = "Field `G4_IO4` writer - G4_IO4"] pub type G4Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G5_IO1` reader - G5_IO1"] pub type G5Io1R = crate :: BitReader ;
#[doc = "Field `G5_IO1` writer - G5_IO1"] pub type G5Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G5_IO2` reader - G5_IO2"] pub type G5Io2R = crate :: BitReader ;
#[doc = "Field `G5_IO2` writer - G5_IO2"] pub type G5Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G5_IO3` reader - G5_IO3"] pub type G5Io3R = crate :: BitReader ;
#[doc = "Field `G5_IO3` writer - G5_IO3"] pub type G5Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G5_IO4` reader - G5_IO4"] pub type G5Io4R = crate :: BitReader ;
#[doc = "Field `G5_IO4` writer - G5_IO4"] pub type G5Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G6_IO1` reader - G6_IO1"] pub type G6Io1R = crate :: BitReader ;
#[doc = "Field `G6_IO1` writer - G6_IO1"] pub type G6Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G6_IO2` reader - G6_IO2"] pub type G6Io2R = crate :: BitReader ;
#[doc = "Field `G6_IO2` writer - G6_IO2"] pub type G6Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G6_IO3` reader - G6_IO3"] pub type G6Io3R = crate :: BitReader ;
#[doc = "Field `G6_IO3` writer - G6_IO3"] pub type G6Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G6_IO4` reader - G6_IO4"] pub type G6Io4R = crate :: BitReader ;
#[doc = "Field `G6_IO4` writer - G6_IO4"] pub type G6Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G7_IO1` reader - G7_IO1"] pub type G7Io1R = crate :: BitReader ;
#[doc = "Field `G7_IO1` writer - G7_IO1"] pub type G7Io1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G7_IO2` reader - G7_IO2"] pub type G7Io2R = crate :: BitReader ;
#[doc = "Field `G7_IO2` writer - G7_IO2"] pub type G7Io2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G7_IO3` reader - G7_IO3"] pub type G7Io3R = crate :: BitReader ;
#[doc = "Field `G7_IO3` writer - G7_IO3"] pub type G7Io3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G7_IO4` reader - G7_IO4"] pub type G7Io4R = crate :: BitReader ;
#[doc = "Field `G7_IO4` writer - G7_IO4"] pub type G7Io4W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - G1_IO1"]
#[inline (always)] pub fn g1_io1 (& self) -> G1Io1R { G1Io1R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - G1_IO2"]
#[inline (always)] pub fn g1_io2 (& self) -> G1Io2R { G1Io2R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - G1_IO3"]
#[inline (always)] pub fn g1_io3 (& self) -> G1Io3R { G1Io3R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - G1_IO4"]
#[inline (always)] pub fn g1_io4 (& self) -> G1Io4R { G1Io4R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - G2_IO1"]
#[inline (always)] pub fn g2_io1 (& self) -> G2Io1R { G2Io1R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - G2_IO2"]
#[inline (always)] pub fn g2_io2 (& self) -> G2Io2R { G2Io2R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - G2_IO3"]
#[inline (always)] pub fn g2_io3 (& self) -> G2Io3R { G2Io3R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - G2_IO4"]
#[inline (always)] pub fn g2_io4 (& self) -> G2Io4R { G2Io4R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - G3_IO1"]
#[inline (always)] pub fn g3_io1 (& self) -> G3Io1R { G3Io1R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - G3_IO2"]
#[inline (always)] pub fn g3_io2 (& self) -> G3Io2R { G3Io2R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - G3_IO3"]
#[inline (always)] pub fn g3_io3 (& self) -> G3Io3R { G3Io3R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - G3_IO4"]
#[inline (always)] pub fn g3_io4 (& self) -> G3Io4R { G3Io4R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - G4_IO1"]
#[inline (always)] pub fn g4_io1 (& self) -> G4Io1R { G4Io1R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - G4_IO2"]
#[inline (always)] pub fn g4_io2 (& self) -> G4Io2R { G4Io2R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - G4_IO3"]
#[inline (always)] pub fn g4_io3 (& self) -> G4Io3R { G4Io3R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - G4_IO4"]
#[inline (always)] pub fn g4_io4 (& self) -> G4Io4R { G4Io4R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - G5_IO1"]
#[inline (always)] pub fn g5_io1 (& self) -> G5Io1R { G5Io1R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - G5_IO2"]
#[inline (always)] pub fn g5_io2 (& self) -> G5Io2R { G5Io2R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - G5_IO3"]
#[inline (always)] pub fn g5_io3 (& self) -> G5Io3R { G5Io3R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - G5_IO4"]
#[inline (always)] pub fn g5_io4 (& self) -> G5Io4R { G5Io4R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - G6_IO1"]
#[inline (always)] pub fn g6_io1 (& self) -> G6Io1R { G6Io1R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - G6_IO2"]
#[inline (always)] pub fn g6_io2 (& self) -> G6Io2R { G6Io2R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - G6_IO3"]
#[inline (always)] pub fn g6_io3 (& self) -> G6Io3R { G6Io3R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - G6_IO4"]
#[inline (always)] pub fn g6_io4 (& self) -> G6Io4R { G6Io4R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - G7_IO1"]
#[inline (always)] pub fn g7_io1 (& self) -> G7Io1R { G7Io1R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - G7_IO2"]
#[inline (always)] pub fn g7_io2 (& self) -> G7Io2R { G7Io2R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - G7_IO3"]
#[inline (always)] pub fn g7_io3 (& self) -> G7Io3R { G7Io3R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - G7_IO4"]
#[inline (always)] pub fn g7_io4 (& self) -> G7Io4R { G7Io4R :: new (((self . bits >> 27) & 1) != 0) } } impl W {
#[doc = "Bit 0 - G1_IO1"]
#[inline (always)] pub fn g1_io1 (& mut self) -> G1Io1W < '_ , IoccrSpec > { G1Io1W :: new (self , 0) }
#[doc = "Bit 1 - G1_IO2"]
#[inline (always)] pub fn g1_io2 (& mut self) -> G1Io2W < '_ , IoccrSpec > { G1Io2W :: new (self , 1) }
#[doc = "Bit 2 - G1_IO3"]
#[inline (always)] pub fn g1_io3 (& mut self) -> G1Io3W < '_ , IoccrSpec > { G1Io3W :: new (self , 2) }
#[doc = "Bit 3 - G1_IO4"]
#[inline (always)] pub fn g1_io4 (& mut self) -> G1Io4W < '_ , IoccrSpec > { G1Io4W :: new (self , 3) }
#[doc = "Bit 4 - G2_IO1"]
#[inline (always)] pub fn g2_io1 (& mut self) -> G2Io1W < '_ , IoccrSpec > { G2Io1W :: new (self , 4) }
#[doc = "Bit 5 - G2_IO2"]
#[inline (always)] pub fn g2_io2 (& mut self) -> G2Io2W < '_ , IoccrSpec > { G2Io2W :: new (self , 5) }
#[doc = "Bit 6 - G2_IO3"]
#[inline (always)] pub fn g2_io3 (& mut self) -> G2Io3W < '_ , IoccrSpec > { G2Io3W :: new (self , 6) }
#[doc = "Bit 7 - G2_IO4"]
#[inline (always)] pub fn g2_io4 (& mut self) -> G2Io4W < '_ , IoccrSpec > { G2Io4W :: new (self , 7) }
#[doc = "Bit 8 - G3_IO1"]
#[inline (always)] pub fn g3_io1 (& mut self) -> G3Io1W < '_ , IoccrSpec > { G3Io1W :: new (self , 8) }
#[doc = "Bit 9 - G3_IO2"]
#[inline (always)] pub fn g3_io2 (& mut self) -> G3Io2W < '_ , IoccrSpec > { G3Io2W :: new (self , 9) }
#[doc = "Bit 10 - G3_IO3"]
#[inline (always)] pub fn g3_io3 (& mut self) -> G3Io3W < '_ , IoccrSpec > { G3Io3W :: new (self , 10) }
#[doc = "Bit 11 - G3_IO4"]
#[inline (always)] pub fn g3_io4 (& mut self) -> G3Io4W < '_ , IoccrSpec > { G3Io4W :: new (self , 11) }
#[doc = "Bit 12 - G4_IO1"]
#[inline (always)] pub fn g4_io1 (& mut self) -> G4Io1W < '_ , IoccrSpec > { G4Io1W :: new (self , 12) }
#[doc = "Bit 13 - G4_IO2"]
#[inline (always)] pub fn g4_io2 (& mut self) -> G4Io2W < '_ , IoccrSpec > { G4Io2W :: new (self , 13) }
#[doc = "Bit 14 - G4_IO3"]
#[inline (always)] pub fn g4_io3 (& mut self) -> G4Io3W < '_ , IoccrSpec > { G4Io3W :: new (self , 14) }
#[doc = "Bit 15 - G4_IO4"]
#[inline (always)] pub fn g4_io4 (& mut self) -> G4Io4W < '_ , IoccrSpec > { G4Io4W :: new (self , 15) }
#[doc = "Bit 16 - G5_IO1"]
#[inline (always)] pub fn g5_io1 (& mut self) -> G5Io1W < '_ , IoccrSpec > { G5Io1W :: new (self , 16) }
#[doc = "Bit 17 - G5_IO2"]
#[inline (always)] pub fn g5_io2 (& mut self) -> G5Io2W < '_ , IoccrSpec > { G5Io2W :: new (self , 17) }
#[doc = "Bit 18 - G5_IO3"]
#[inline (always)] pub fn g5_io3 (& mut self) -> G5Io3W < '_ , IoccrSpec > { G5Io3W :: new (self , 18) }
#[doc = "Bit 19 - G5_IO4"]
#[inline (always)] pub fn g5_io4 (& mut self) -> G5Io4W < '_ , IoccrSpec > { G5Io4W :: new (self , 19) }
#[doc = "Bit 20 - G6_IO1"]
#[inline (always)] pub fn g6_io1 (& mut self) -> G6Io1W < '_ , IoccrSpec > { G6Io1W :: new (self , 20) }
#[doc = "Bit 21 - G6_IO2"]
#[inline (always)] pub fn g6_io2 (& mut self) -> G6Io2W < '_ , IoccrSpec > { G6Io2W :: new (self , 21) }
#[doc = "Bit 22 - G6_IO3"]
#[inline (always)] pub fn g6_io3 (& mut self) -> G6Io3W < '_ , IoccrSpec > { G6Io3W :: new (self , 22) }
#[doc = "Bit 23 - G6_IO4"]
#[inline (always)] pub fn g6_io4 (& mut self) -> G6Io4W < '_ , IoccrSpec > { G6Io4W :: new (self , 23) }
#[doc = "Bit 24 - G7_IO1"]
#[inline (always)] pub fn g7_io1 (& mut self) -> G7Io1W < '_ , IoccrSpec > { G7Io1W :: new (self , 24) }
#[doc = "Bit 25 - G7_IO2"]
#[inline (always)] pub fn g7_io2 (& mut self) -> G7Io2W < '_ , IoccrSpec > { G7Io2W :: new (self , 25) }
#[doc = "Bit 26 - G7_IO3"]
#[inline (always)] pub fn g7_io3 (& mut self) -> G7Io3W < '_ , IoccrSpec > { G7Io3W :: new (self , 26) }
#[doc = "Bit 27 - G7_IO4"]
#[inline (always)] pub fn g7_io4 (& mut self) -> G7Io4W < '_ , IoccrSpec > { G7Io4W :: new (self , 27) } }
#[doc = "I/O channel control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ioccr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ioccr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IoccrSpec ; impl crate :: RegisterSpec for IoccrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ioccr::R`](R) reader structure"] impl crate :: Readable for IoccrSpec { }
#[doc = "`write(|w| ..)` method takes [`ioccr::W`](W) writer structure"] impl crate :: Writable for IoccrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IOCCR to value 0"] impl crate :: Resettable for IoccrSpec { } }
#[doc = "IOGCSR (rw) register accessor: I/O group control status register\n\nYou can [`read`](crate::Reg::read) this register and get [`iogcsr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iogcsr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iogcsr`] module"]
#[doc (alias = "IOGCSR")] pub type Iogcsr = crate :: Reg < iogcsr :: IogcsrSpec > ;
#[doc = "I/O group control status register"] pub mod iogcsr {
#[doc = "Register `IOGCSR` reader"] pub type R = crate :: R < IogcsrSpec > ;
#[doc = "Register `IOGCSR` writer"] pub type W = crate :: W < IogcsrSpec > ;
#[doc = "Field `G1E` reader - Analog I/O group x enable"] pub type G1eR = crate :: BitReader ;
#[doc = "Field `G1E` writer - Analog I/O group x enable"] pub type G1eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G2E` reader - Analog I/O group x enable"] pub type G2eR = crate :: BitReader ;
#[doc = "Field `G2E` writer - Analog I/O group x enable"] pub type G2eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G3E` reader - Analog I/O group x enable"] pub type G3eR = crate :: BitReader ;
#[doc = "Field `G3E` writer - Analog I/O group x enable"] pub type G3eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G4E` reader - Analog I/O group x enable"] pub type G4eR = crate :: BitReader ;
#[doc = "Field `G4E` writer - Analog I/O group x enable"] pub type G4eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G5E` reader - Analog I/O group x enable"] pub type G5eR = crate :: BitReader ;
#[doc = "Field `G5E` writer - Analog I/O group x enable"] pub type G5eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G6E` reader - Analog I/O group x enable"] pub type G6eR = crate :: BitReader ;
#[doc = "Field `G6E` writer - Analog I/O group x enable"] pub type G6eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G7E` reader - Analog I/O group x enable"] pub type G7eR = crate :: BitReader ;
#[doc = "Field `G7E` writer - Analog I/O group x enable"] pub type G7eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `G1S` reader - Analog I/O group x status"] pub type G1sR = crate :: BitReader ;
#[doc = "Field `G2S` reader - Analog I/O group x status"] pub type G2sR = crate :: BitReader ;
#[doc = "Field `G3S` reader - Analog I/O group x status"] pub type G3sR = crate :: BitReader ;
#[doc = "Field `G4S` reader - Analog I/O group x status"] pub type G4sR = crate :: BitReader ;
#[doc = "Field `G5S` reader - Analog I/O group x status"] pub type G5sR = crate :: BitReader ;
#[doc = "Field `G6S` reader - Analog I/O group x status"] pub type G6sR = crate :: BitReader ;
#[doc = "Field `G7S` reader - Analog I/O group x status"] pub type G7sR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Analog I/O group x enable"]
#[inline (always)] pub fn g1e (& self) -> G1eR { G1eR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Analog I/O group x enable"]
#[inline (always)] pub fn g2e (& self) -> G2eR { G2eR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Analog I/O group x enable"]
#[inline (always)] pub fn g3e (& self) -> G3eR { G3eR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Analog I/O group x enable"]
#[inline (always)] pub fn g4e (& self) -> G4eR { G4eR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Analog I/O group x enable"]
#[inline (always)] pub fn g5e (& self) -> G5eR { G5eR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Analog I/O group x enable"]
#[inline (always)] pub fn g6e (& self) -> G6eR { G6eR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Analog I/O group x enable"]
#[inline (always)] pub fn g7e (& self) -> G7eR { G7eR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 16 - Analog I/O group x status"]
#[inline (always)] pub fn g1s (& self) -> G1sR { G1sR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Analog I/O group x status"]
#[inline (always)] pub fn g2s (& self) -> G2sR { G2sR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Analog I/O group x status"]
#[inline (always)] pub fn g3s (& self) -> G3sR { G3sR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Analog I/O group x status"]
#[inline (always)] pub fn g4s (& self) -> G4sR { G4sR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Analog I/O group x status"]
#[inline (always)] pub fn g5s (& self) -> G5sR { G5sR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Analog I/O group x status"]
#[inline (always)] pub fn g6s (& self) -> G6sR { G6sR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Analog I/O group x status"]
#[inline (always)] pub fn g7s (& self) -> G7sR { G7sR :: new (((self . bits >> 22) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Analog I/O group x enable"]
#[inline (always)] pub fn g1e (& mut self) -> G1eW < '_ , IogcsrSpec > { G1eW :: new (self , 0) }
#[doc = "Bit 1 - Analog I/O group x enable"]
#[inline (always)] pub fn g2e (& mut self) -> G2eW < '_ , IogcsrSpec > { G2eW :: new (self , 1) }
#[doc = "Bit 2 - Analog I/O group x enable"]
#[inline (always)] pub fn g3e (& mut self) -> G3eW < '_ , IogcsrSpec > { G3eW :: new (self , 2) }
#[doc = "Bit 3 - Analog I/O group x enable"]
#[inline (always)] pub fn g4e (& mut self) -> G4eW < '_ , IogcsrSpec > { G4eW :: new (self , 3) }
#[doc = "Bit 4 - Analog I/O group x enable"]
#[inline (always)] pub fn g5e (& mut self) -> G5eW < '_ , IogcsrSpec > { G5eW :: new (self , 4) }
#[doc = "Bit 5 - Analog I/O group x enable"]
#[inline (always)] pub fn g6e (& mut self) -> G6eW < '_ , IogcsrSpec > { G6eW :: new (self , 5) }
#[doc = "Bit 6 - Analog I/O group x enable"]
#[inline (always)] pub fn g7e (& mut self) -> G7eW < '_ , IogcsrSpec > { G7eW :: new (self , 6) } }
#[doc = "I/O group control status register\n\nYou can [`read`](crate::Reg::read) this register and get [`iogcsr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iogcsr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IogcsrSpec ; impl crate :: RegisterSpec for IogcsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`iogcsr::R`](R) reader structure"] impl crate :: Readable for IogcsrSpec { }
#[doc = "`write(|w| ..)` method takes [`iogcsr::W`](W) writer structure"] impl crate :: Writable for IogcsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IOGCSR to value 0"] impl crate :: Resettable for IogcsrSpec { } }
#[doc = "IOG1CR (r) register accessor: I/O group x counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`iog1cr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iog1cr`] module"]
#[doc (alias = "IOG1CR")] pub type Iog1cr = crate :: Reg < iog1cr :: Iog1crSpec > ;
#[doc = "I/O group x counter register"] pub mod iog1cr {
#[doc = "Register `IOG1CR` reader"] pub type R = crate :: R < Iog1crSpec > ;
#[doc = "Field `CNT` reader - Counter value"] pub type CntR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:13 - Counter value"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0x3fff) as u16) } }
#[doc = "I/O group x counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`iog1cr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Iog1crSpec ; impl crate :: RegisterSpec for Iog1crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`iog1cr::R`](R) reader structure"] impl crate :: Readable for Iog1crSpec { }
#[doc = "`reset()` method sets IOG1CR to value 0"] impl crate :: Resettable for Iog1crSpec { } }
#[doc = "IOG2CR (r) register accessor: I/O group x counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`iog2cr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iog2cr`] module"]
#[doc (alias = "IOG2CR")] pub type Iog2cr = crate :: Reg < iog2cr :: Iog2crSpec > ;
#[doc = "I/O group x counter register"] pub mod iog2cr {
#[doc = "Register `IOG2CR` reader"] pub type R = crate :: R < Iog2crSpec > ;
#[doc = "Field `CNT` reader - Counter value"] pub type CntR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:13 - Counter value"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0x3fff) as u16) } }
#[doc = "I/O group x counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`iog2cr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Iog2crSpec ; impl crate :: RegisterSpec for Iog2crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`iog2cr::R`](R) reader structure"] impl crate :: Readable for Iog2crSpec { }
#[doc = "`reset()` method sets IOG2CR to value 0"] impl crate :: Resettable for Iog2crSpec { } }
#[doc = "IOG3CR (r) register accessor: I/O group x counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`iog3cr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iog3cr`] module"]
#[doc (alias = "IOG3CR")] pub type Iog3cr = crate :: Reg < iog3cr :: Iog3crSpec > ;
#[doc = "I/O group x counter register"] pub mod iog3cr {
#[doc = "Register `IOG3CR` reader"] pub type R = crate :: R < Iog3crSpec > ;
#[doc = "Field `CNT` reader - Counter value"] pub type CntR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:13 - Counter value"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0x3fff) as u16) } }
#[doc = "I/O group x counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`iog3cr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Iog3crSpec ; impl crate :: RegisterSpec for Iog3crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`iog3cr::R`](R) reader structure"] impl crate :: Readable for Iog3crSpec { }
#[doc = "`reset()` method sets IOG3CR to value 0"] impl crate :: Resettable for Iog3crSpec { } }
#[doc = "IOG4CR (r) register accessor: I/O group x counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`iog4cr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iog4cr`] module"]
#[doc (alias = "IOG4CR")] pub type Iog4cr = crate :: Reg < iog4cr :: Iog4crSpec > ;
#[doc = "I/O group x counter register"] pub mod iog4cr {
#[doc = "Register `IOG4CR` reader"] pub type R = crate :: R < Iog4crSpec > ;
#[doc = "Field `CNT` reader - Counter value"] pub type CntR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:13 - Counter value"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0x3fff) as u16) } }
#[doc = "I/O group x counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`iog4cr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Iog4crSpec ; impl crate :: RegisterSpec for Iog4crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`iog4cr::R`](R) reader structure"] impl crate :: Readable for Iog4crSpec { }
#[doc = "`reset()` method sets IOG4CR to value 0"] impl crate :: Resettable for Iog4crSpec { } }
#[doc = "IOG5CR (r) register accessor: I/O group x counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`iog5cr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iog5cr`] module"]
#[doc (alias = "IOG5CR")] pub type Iog5cr = crate :: Reg < iog5cr :: Iog5crSpec > ;
#[doc = "I/O group x counter register"] pub mod iog5cr {
#[doc = "Register `IOG5CR` reader"] pub type R = crate :: R < Iog5crSpec > ;
#[doc = "Field `CNT` reader - Counter value"] pub type CntR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:13 - Counter value"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0x3fff) as u16) } }
#[doc = "I/O group x counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`iog5cr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Iog5crSpec ; impl crate :: RegisterSpec for Iog5crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`iog5cr::R`](R) reader structure"] impl crate :: Readable for Iog5crSpec { }
#[doc = "`reset()` method sets IOG5CR to value 0"] impl crate :: Resettable for Iog5crSpec { } }
#[doc = "IOG6CR (r) register accessor: I/O group x counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`iog6cr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iog6cr`] module"]
#[doc (alias = "IOG6CR")] pub type Iog6cr = crate :: Reg < iog6cr :: Iog6crSpec > ;
#[doc = "I/O group x counter register"] pub mod iog6cr {
#[doc = "Register `IOG6CR` reader"] pub type R = crate :: R < Iog6crSpec > ;
#[doc = "Field `CNT` reader - Counter value"] pub type CntR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:13 - Counter value"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0x3fff) as u16) } }
#[doc = "I/O group x counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`iog6cr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Iog6crSpec ; impl crate :: RegisterSpec for Iog6crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`iog6cr::R`](R) reader structure"] impl crate :: Readable for Iog6crSpec { }
#[doc = "`reset()` method sets IOG6CR to value 0"] impl crate :: Resettable for Iog6crSpec { } }
#[doc = "IOG7CR (r) register accessor: I/O group x counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`iog7cr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iog7cr`] module"]
#[doc (alias = "IOG7CR")] pub type Iog7cr = crate :: Reg < iog7cr :: Iog7crSpec > ;
#[doc = "I/O group x counter register"] pub mod iog7cr {
#[doc = "Register `IOG7CR` reader"] pub type R = crate :: R < Iog7crSpec > ;
#[doc = "Field `CNT` reader - Counter value"] pub type CntR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:13 - Counter value"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0x3fff) as u16) } }
#[doc = "I/O group x counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`iog7cr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Iog7crSpec ; impl crate :: RegisterSpec for Iog7crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`iog7cr::R`](R) reader structure"] impl crate :: Readable for Iog7crSpec { }
#[doc = "`reset()` method sets IOG7CR to value 0"] impl crate :: Resettable for Iog7crSpec { } } }
#[doc = "Independent watchdog"] pub type Iwdg = crate :: Periph < iwdg :: RegisterBlock , 0x4000_3000 > ; impl core :: fmt :: Debug for Iwdg { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Iwdg") . finish () } }
#[doc = "Independent watchdog"] pub mod iwdg {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { kr : Kr , pr : Pr , rlr : Rlr , sr : Sr , winr : Winr , } impl RegisterBlock {
#[doc = "0x00 - Key register"]
#[inline (always)] pub const fn kr (& self) -> & Kr { & self . kr }
#[doc = "0x04 - Prescaler register"]
#[inline (always)] pub const fn pr (& self) -> & Pr { & self . pr }
#[doc = "0x08 - Reload register"]
#[inline (always)] pub const fn rlr (& self) -> & Rlr { & self . rlr }
#[doc = "0x0c - Status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x10 - Window register"]
#[inline (always)] pub const fn winr (& self) -> & Winr { & self . winr } }
#[doc = "KR (w) register accessor: Key register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`kr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@kr`] module"]
#[doc (alias = "KR")] pub type Kr = crate :: Reg < kr :: KrSpec > ;
#[doc = "Key register"] pub mod kr {
#[doc = "Register `KR` writer"] pub type W = crate :: W < KrSpec > ;
#[doc = "Field `KEY` writer - Key value (write only, read 0x0000)"] pub type KeyW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl W {
#[doc = "Bits 0:15 - Key value (write only, read 0x0000)"]
#[inline (always)] pub fn key (& mut self) -> KeyW < '_ , KrSpec > { KeyW :: new (self , 0) } }
#[doc = "Key register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`kr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct KrSpec ; impl crate :: RegisterSpec for KrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`kr::W`](W) writer structure"] impl crate :: Writable for KrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets KR to value 0"] impl crate :: Resettable for KrSpec { } }
#[doc = "PR (rw) register accessor: Prescaler register\n\nYou can [`read`](crate::Reg::read) this register and get [`pr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pr`] module"]
#[doc (alias = "PR")] pub type Pr = crate :: Reg < pr :: PrSpec > ;
#[doc = "Prescaler register"] pub mod pr {
#[doc = "Register `PR` reader"] pub type R = crate :: R < PrSpec > ;
#[doc = "Register `PR` writer"] pub type W = crate :: W < PrSpec > ;
#[doc = "Field `PR` reader - Prescaler divider"] pub type PrR = crate :: FieldReader ;
#[doc = "Field `PR` writer - Prescaler divider"] pub type PrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:2 - Prescaler divider"]
#[inline (always)] pub fn pr (& self) -> PrR { PrR :: new ((self . bits & 7) as u8) } } impl W {
#[doc = "Bits 0:2 - Prescaler divider"]
#[inline (always)] pub fn pr (& mut self) -> PrW < '_ , PrSpec > { PrW :: new (self , 0) } }
#[doc = "Prescaler register\n\nYou can [`read`](crate::Reg::read) this register and get [`pr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PrSpec ; impl crate :: RegisterSpec for PrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pr::R`](R) reader structure"] impl crate :: Readable for PrSpec { }
#[doc = "`write(|w| ..)` method takes [`pr::W`](W) writer structure"] impl crate :: Writable for PrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PR to value 0"] impl crate :: Resettable for PrSpec { } }
#[doc = "RLR (rw) register accessor: Reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rlr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr`] module"]
#[doc (alias = "RLR")] pub type Rlr = crate :: Reg < rlr :: RlrSpec > ;
#[doc = "Reload register"] pub mod rlr {
#[doc = "Register `RLR` reader"] pub type R = crate :: R < RlrSpec > ;
#[doc = "Register `RLR` writer"] pub type W = crate :: W < RlrSpec > ;
#[doc = "Field `RL` reader - Watchdog counter reload value"] pub type RlR = crate :: FieldReader < u16 > ;
#[doc = "Field `RL` writer - Watchdog counter reload value"] pub type RlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 0:11 - Watchdog counter reload value"]
#[inline (always)] pub fn rl (& self) -> RlR { RlR :: new ((self . bits & 0x0fff) as u16) } } impl W {
#[doc = "Bits 0:11 - Watchdog counter reload value"]
#[inline (always)] pub fn rl (& mut self) -> RlW < '_ , RlrSpec > { RlW :: new (self , 0) } }
#[doc = "Reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rlr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RlrSpec ; impl crate :: RegisterSpec for RlrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr::R`](R) reader structure"] impl crate :: Readable for RlrSpec { }
#[doc = "`write(|w| ..)` method takes [`rlr::W`](W) writer structure"] impl crate :: Writable for RlrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RLR to value 0x0fff"] impl crate :: Resettable for RlrSpec { const RESET_VALUE : u32 = 0x0fff ; } }
#[doc = "SR (r) register accessor: Status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "Status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Field `PVU` reader - Watchdog prescaler value update"] pub type PvuR = crate :: BitReader ;
#[doc = "Field `RVU` reader - Watchdog counter reload value update"] pub type RvuR = crate :: BitReader ;
#[doc = "Field `WVU` reader - Watchdog counter window value update"] pub type WvuR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Watchdog prescaler value update"]
#[inline (always)] pub fn pvu (& self) -> PvuR { PvuR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Watchdog counter reload value update"]
#[inline (always)] pub fn rvu (& self) -> RvuR { RvuR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Watchdog counter window value update"]
#[inline (always)] pub fn wvu (& self) -> WvuR { WvuR :: new (((self . bits >> 2) & 1) != 0) } }
#[doc = "Status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "WINR (rw) register accessor: Window register\n\nYou can [`read`](crate::Reg::read) this register and get [`winr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`winr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@winr`] module"]
#[doc (alias = "WINR")] pub type Winr = crate :: Reg < winr :: WinrSpec > ;
#[doc = "Window register"] pub mod winr {
#[doc = "Register `WINR` reader"] pub type R = crate :: R < WinrSpec > ;
#[doc = "Register `WINR` writer"] pub type W = crate :: W < WinrSpec > ;
#[doc = "Field `WIN` reader - Watchdog counter window value"] pub type WinR = crate :: FieldReader < u16 > ;
#[doc = "Field `WIN` writer - Watchdog counter window value"] pub type WinW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 0:11 - Watchdog counter window value"]
#[inline (always)] pub fn win (& self) -> WinR { WinR :: new ((self . bits & 0x0fff) as u16) } } impl W {
#[doc = "Bits 0:11 - Watchdog counter window value"]
#[inline (always)] pub fn win (& mut self) -> WinW < '_ , WinrSpec > { WinW :: new (self , 0) } }
#[doc = "Window register\n\nYou can [`read`](crate::Reg::read) this register and get [`winr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`winr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct WinrSpec ; impl crate :: RegisterSpec for WinrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`winr::R`](R) reader structure"] impl crate :: Readable for WinrSpec { }
#[doc = "`write(|w| ..)` method takes [`winr::W`](W) writer structure"] impl crate :: Writable for WinrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets WINR to value 0x0fff"] impl crate :: Resettable for WinrSpec { const RESET_VALUE : u32 = 0x0fff ; } } }
#[doc = "System window watchdog"] pub type Wwdg = crate :: Periph < wwdg :: RegisterBlock , 0x4000_2c00 > ; impl core :: fmt :: Debug for Wwdg { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Wwdg") . finish () } }
#[doc = "System window watchdog"] pub mod wwdg {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr : Cr , cfr : Cfr , sr : Sr , } impl RegisterBlock {
#[doc = "0x00 - Control register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x04 - Configuration register"]
#[inline (always)] pub const fn cfr (& self) -> & Cfr { & self . cfr }
#[doc = "0x08 - Status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr } }
#[doc = "CR (rw) register accessor: Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "Control register"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `T` reader - 7-bit counter (MSB to LSB)"] pub type TR = crate :: FieldReader ;
#[doc = "Field `T` writer - 7-bit counter (MSB to LSB)"] pub type TW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `WDGA` reader - Activation bit"] pub type WdgaR = crate :: BitReader ;
#[doc = "Field `WDGA` writer - Activation bit"] pub type WdgaW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:6 - 7-bit counter (MSB to LSB)"]
#[inline (always)] pub fn t (& self) -> TR { TR :: new ((self . bits & 0x7f) as u8) }
#[doc = "Bit 7 - Activation bit"]
#[inline (always)] pub fn wdga (& self) -> WdgaR { WdgaR :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:6 - 7-bit counter (MSB to LSB)"]
#[inline (always)] pub fn t (& mut self) -> TW < '_ , CrSpec > { TW :: new (self , 0) }
#[doc = "Bit 7 - Activation bit"]
#[inline (always)] pub fn wdga (& mut self) -> WdgaW < '_ , CrSpec > { WdgaW :: new (self , 7) } }
#[doc = "Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0x7f"] impl crate :: Resettable for CrSpec { const RESET_VALUE : u32 = 0x7f ; } }
#[doc = "CFR (rw) register accessor: Configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`cfr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfr`] module"]
#[doc (alias = "CFR")] pub type Cfr = crate :: Reg < cfr :: CfrSpec > ;
#[doc = "Configuration register"] pub mod cfr {
#[doc = "Register `CFR` reader"] pub type R = crate :: R < CfrSpec > ;
#[doc = "Register `CFR` writer"] pub type W = crate :: W < CfrSpec > ;
#[doc = "Field `W` reader - 7-bit window value"] pub type WR = crate :: FieldReader ;
#[doc = "Field `W` writer - 7-bit window value"] pub type WW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `EWI` reader - Early wakeup interrupt"] pub type EwiR = crate :: BitReader ;
#[doc = "Field `EWI` writer - Early wakeup interrupt"] pub type EwiW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WDGTB` reader - Timer base"] pub type WdgtbR = crate :: FieldReader ;
#[doc = "Field `WDGTB` writer - Timer base"] pub type WdgtbW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:6 - 7-bit window value"]
#[inline (always)] pub fn w (& self) -> WR { WR :: new ((self . bits & 0x7f) as u8) }
#[doc = "Bit 9 - Early wakeup interrupt"]
#[inline (always)] pub fn ewi (& self) -> EwiR { EwiR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bits 11:13 - Timer base"]
#[inline (always)] pub fn wdgtb (& self) -> WdgtbR { WdgtbR :: new (((self . bits >> 11) & 7) as u8) } } impl W {
#[doc = "Bits 0:6 - 7-bit window value"]
#[inline (always)] pub fn w (& mut self) -> WW < '_ , CfrSpec > { WW :: new (self , 0) }
#[doc = "Bit 9 - Early wakeup interrupt"]
#[inline (always)] pub fn ewi (& mut self) -> EwiW < '_ , CfrSpec > { EwiW :: new (self , 9) }
#[doc = "Bits 11:13 - Timer base"]
#[inline (always)] pub fn wdgtb (& mut self) -> WdgtbW < '_ , CfrSpec > { WdgtbW :: new (self , 11) } }
#[doc = "Configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`cfr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CfrSpec ; impl crate :: RegisterSpec for CfrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cfr::R`](R) reader structure"] impl crate :: Readable for CfrSpec { }
#[doc = "`write(|w| ..)` method takes [`cfr::W`](W) writer structure"] impl crate :: Writable for CfrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CFR to value 0x7f"] impl crate :: Resettable for CfrSpec { const RESET_VALUE : u32 = 0x7f ; } }
#[doc = "SR (rw) register accessor: Status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "Status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `EWIF` reader - Early wakeup interrupt flag"] pub type EwifR = crate :: BitReader ;
#[doc = "Field `EWIF` writer - Early wakeup interrupt flag"] pub type EwifW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Early wakeup interrupt flag"]
#[inline (always)] pub fn ewif (& self) -> EwifR { EwifR :: new ((self . bits & 1) != 0) } } impl W {
#[doc = "Bit 0 - Early wakeup interrupt flag"]
#[inline (always)] pub fn ewif (& mut self) -> EwifW < '_ , SrSpec > { EwifW :: new (self , 0) } }
#[doc = "Status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } } }
#[doc = "Inter-integrated circuit"] pub type I2c1 = crate :: Periph < i2c1 :: RegisterBlock , 0x4000_5400 > ; impl core :: fmt :: Debug for I2c1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("I2c1") . finish () } }
#[doc = "Inter-integrated circuit"] pub mod i2c1 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr1 : Cr1 , cr2 : Cr2 , oar1 : Oar1 , oar2 : Oar2 , timingr : Timingr , timeoutr : Timeoutr , isr : Isr , icr : Icr , pecr : Pecr , rxdr : Rxdr , txdr : Txdr , } impl RegisterBlock {
#[doc = "0x00 - Control register 1"]
#[inline (always)] pub const fn cr1 (& self) -> & Cr1 { & self . cr1 }
#[doc = "0x04 - Control register 2"]
#[inline (always)] pub const fn cr2 (& self) -> & Cr2 { & self . cr2 }
#[doc = "0x08 - Own address register 1"]
#[inline (always)] pub const fn oar1 (& self) -> & Oar1 { & self . oar1 }
#[doc = "0x0c - Own address register 2"]
#[inline (always)] pub const fn oar2 (& self) -> & Oar2 { & self . oar2 }
#[doc = "0x10 - Timing register"]
#[inline (always)] pub const fn timingr (& self) -> & Timingr { & self . timingr }
#[doc = "0x14 - Status register 1"]
#[inline (always)] pub const fn timeoutr (& self) -> & Timeoutr { & self . timeoutr }
#[doc = "0x18 - Interrupt and Status register"]
#[inline (always)] pub const fn isr (& self) -> & Isr { & self . isr }
#[doc = "0x1c - Interrupt clear register"]
#[inline (always)] pub const fn icr (& self) -> & Icr { & self . icr }
#[doc = "0x20 - PEC register"]
#[inline (always)] pub const fn pecr (& self) -> & Pecr { & self . pecr }
#[doc = "0x24 - Receive data register"]
#[inline (always)] pub const fn rxdr (& self) -> & Rxdr { & self . rxdr }
#[doc = "0x28 - Transmit data register"]
#[inline (always)] pub const fn txdr (& self) -> & Txdr { & self . txdr } }
#[doc = "CR1 (rw) register accessor: Control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
#[doc (alias = "CR1")] pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ;
#[doc = "Control register 1"] pub mod cr1 {
#[doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ;
#[doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ;
#[doc = "Field `PE` reader - Peripheral enable"] pub type PeR = crate :: BitReader ;
#[doc = "Field `PE` writer - Peripheral enable"] pub type PeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXIE` reader - TX Interrupt enable"] pub type TxieR = crate :: BitReader ;
#[doc = "Field `TXIE` writer - TX Interrupt enable"] pub type TxieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXIE` reader - RX Interrupt enable"] pub type RxieR = crate :: BitReader ;
#[doc = "Field `RXIE` writer - RX Interrupt enable"] pub type RxieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADDRIE` reader - Address match interrupt enable (slave only)"] pub type AddrieR = crate :: BitReader ;
#[doc = "Field `ADDRIE` writer - Address match interrupt enable (slave only)"] pub type AddrieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NACKIE` reader - Not acknowledge received interrupt enable"] pub type NackieR = crate :: BitReader ;
#[doc = "Field `NACKIE` writer - Not acknowledge received interrupt enable"] pub type NackieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STOPIE` reader - STOP detection Interrupt enable"] pub type StopieR = crate :: BitReader ;
#[doc = "Field `STOPIE` writer - STOP detection Interrupt enable"] pub type StopieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer Complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer Complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ERRIE` reader - Error interrupts enable"] pub type ErrieR = crate :: BitReader ;
#[doc = "Field `ERRIE` writer - Error interrupts enable"] pub type ErrieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DNF` reader - Digital noise filter"] pub type DnfR = crate :: FieldReader ;
#[doc = "Field `DNF` writer - Digital noise filter"] pub type DnfW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ANFOFF` reader - Analog noise filter OFF"] pub type AnfoffR = crate :: BitReader ;
#[doc = "Field `ANFOFF` writer - Analog noise filter OFF"] pub type AnfoffW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXDMAEN` reader - DMA transmission requests enable"] pub type TxdmaenR = crate :: BitReader ;
#[doc = "Field `TXDMAEN` writer - DMA transmission requests enable"] pub type TxdmaenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXDMAEN` reader - DMA reception requests enable"] pub type RxdmaenR = crate :: BitReader ;
#[doc = "Field `RXDMAEN` writer - DMA reception requests enable"] pub type RxdmaenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SBC` reader - Slave byte control"] pub type SbcR = crate :: BitReader ;
#[doc = "Field `SBC` writer - Slave byte control"] pub type SbcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NOSTRETCH` reader - Clock stretching disable"] pub type NostretchR = crate :: BitReader ;
#[doc = "Field `NOSTRETCH` writer - Clock stretching disable"] pub type NostretchW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WUPEN` reader - Wakeup from STOP enable"] pub type WupenR = crate :: BitReader ;
#[doc = "Field `WUPEN` writer - Wakeup from STOP enable"] pub type WupenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GCEN` reader - General call enable"] pub type GcenR = crate :: BitReader ;
#[doc = "Field `GCEN` writer - General call enable"] pub type GcenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SMBHEN` reader - SMBus Host address enable"] pub type SmbhenR = crate :: BitReader ;
#[doc = "Field `SMBHEN` writer - SMBus Host address enable"] pub type SmbhenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SMBDEN` reader - SMBus Device Default address enable"] pub type SmbdenR = crate :: BitReader ;
#[doc = "Field `SMBDEN` writer - SMBus Device Default address enable"] pub type SmbdenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ALERTEN` reader - SMBUS alert enable"] pub type AlertenR = crate :: BitReader ;
#[doc = "Field `ALERTEN` writer - SMBUS alert enable"] pub type AlertenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PECEN` reader - PEC enable"] pub type PecenR = crate :: BitReader ;
#[doc = "Field `PECEN` writer - PEC enable"] pub type PecenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Peripheral enable"]
#[inline (always)] pub fn pe (& self) -> PeR { PeR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - TX Interrupt enable"]
#[inline (always)] pub fn txie (& self) -> TxieR { TxieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RX Interrupt enable"]
#[inline (always)] pub fn rxie (& self) -> RxieR { RxieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Address match interrupt enable (slave only)"]
#[inline (always)] pub fn addrie (& self) -> AddrieR { AddrieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Not acknowledge received interrupt enable"]
#[inline (always)] pub fn nackie (& self) -> NackieR { NackieR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - STOP detection Interrupt enable"]
#[inline (always)] pub fn stopie (& self) -> StopieR { StopieR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Transfer Complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Error interrupts enable"]
#[inline (always)] pub fn errie (& self) -> ErrieR { ErrieR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:11 - Digital noise filter"]
#[inline (always)] pub fn dnf (& self) -> DnfR { DnfR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 12 - Analog noise filter OFF"]
#[inline (always)] pub fn anfoff (& self) -> AnfoffR { AnfoffR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 14 - DMA transmission requests enable"]
#[inline (always)] pub fn txdmaen (& self) -> TxdmaenR { TxdmaenR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - DMA reception requests enable"]
#[inline (always)] pub fn rxdmaen (& self) -> RxdmaenR { RxdmaenR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Slave byte control"]
#[inline (always)] pub fn sbc (& self) -> SbcR { SbcR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Clock stretching disable"]
#[inline (always)] pub fn nostretch (& self) -> NostretchR { NostretchR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Wakeup from STOP enable"]
#[inline (always)] pub fn wupen (& self) -> WupenR { WupenR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - General call enable"]
#[inline (always)] pub fn gcen (& self) -> GcenR { GcenR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - SMBus Host address enable"]
#[inline (always)] pub fn smbhen (& self) -> SmbhenR { SmbhenR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - SMBus Device Default address enable"]
#[inline (always)] pub fn smbden (& self) -> SmbdenR { SmbdenR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - SMBUS alert enable"]
#[inline (always)] pub fn alerten (& self) -> AlertenR { AlertenR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - PEC enable"]
#[inline (always)] pub fn pecen (& self) -> PecenR { PecenR :: new (((self . bits >> 23) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Peripheral enable"]
#[inline (always)] pub fn pe (& mut self) -> PeW < '_ , Cr1Spec > { PeW :: new (self , 0) }
#[doc = "Bit 1 - TX Interrupt enable"]
#[inline (always)] pub fn txie (& mut self) -> TxieW < '_ , Cr1Spec > { TxieW :: new (self , 1) }
#[doc = "Bit 2 - RX Interrupt enable"]
#[inline (always)] pub fn rxie (& mut self) -> RxieW < '_ , Cr1Spec > { RxieW :: new (self , 2) }
#[doc = "Bit 3 - Address match interrupt enable (slave only)"]
#[inline (always)] pub fn addrie (& mut self) -> AddrieW < '_ , Cr1Spec > { AddrieW :: new (self , 3) }
#[doc = "Bit 4 - Not acknowledge received interrupt enable"]
#[inline (always)] pub fn nackie (& mut self) -> NackieW < '_ , Cr1Spec > { NackieW :: new (self , 4) }
#[doc = "Bit 5 - STOP detection Interrupt enable"]
#[inline (always)] pub fn stopie (& mut self) -> StopieW < '_ , Cr1Spec > { StopieW :: new (self , 5) }
#[doc = "Bit 6 - Transfer Complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Cr1Spec > { TcieW :: new (self , 6) }
#[doc = "Bit 7 - Error interrupts enable"]
#[inline (always)] pub fn errie (& mut self) -> ErrieW < '_ , Cr1Spec > { ErrieW :: new (self , 7) }
#[doc = "Bits 8:11 - Digital noise filter"]
#[inline (always)] pub fn dnf (& mut self) -> DnfW < '_ , Cr1Spec > { DnfW :: new (self , 8) }
#[doc = "Bit 12 - Analog noise filter OFF"]
#[inline (always)] pub fn anfoff (& mut self) -> AnfoffW < '_ , Cr1Spec > { AnfoffW :: new (self , 12) }
#[doc = "Bit 14 - DMA transmission requests enable"]
#[inline (always)] pub fn txdmaen (& mut self) -> TxdmaenW < '_ , Cr1Spec > { TxdmaenW :: new (self , 14) }
#[doc = "Bit 15 - DMA reception requests enable"]
#[inline (always)] pub fn rxdmaen (& mut self) -> RxdmaenW < '_ , Cr1Spec > { RxdmaenW :: new (self , 15) }
#[doc = "Bit 16 - Slave byte control"]
#[inline (always)] pub fn sbc (& mut self) -> SbcW < '_ , Cr1Spec > { SbcW :: new (self , 16) }
#[doc = "Bit 17 - Clock stretching disable"]
#[inline (always)] pub fn nostretch (& mut self) -> NostretchW < '_ , Cr1Spec > { NostretchW :: new (self , 17) }
#[doc = "Bit 18 - Wakeup from STOP enable"]
#[inline (always)] pub fn wupen (& mut self) -> WupenW < '_ , Cr1Spec > { WupenW :: new (self , 18) }
#[doc = "Bit 19 - General call enable"]
#[inline (always)] pub fn gcen (& mut self) -> GcenW < '_ , Cr1Spec > { GcenW :: new (self , 19) }
#[doc = "Bit 20 - SMBus Host address enable"]
#[inline (always)] pub fn smbhen (& mut self) -> SmbhenW < '_ , Cr1Spec > { SmbhenW :: new (self , 20) }
#[doc = "Bit 21 - SMBus Device Default address enable"]
#[inline (always)] pub fn smbden (& mut self) -> SmbdenW < '_ , Cr1Spec > { SmbdenW :: new (self , 21) }
#[doc = "Bit 22 - SMBUS alert enable"]
#[inline (always)] pub fn alerten (& mut self) -> AlertenW < '_ , Cr1Spec > { AlertenW :: new (self , 22) }
#[doc = "Bit 23 - PEC enable"]
#[inline (always)] pub fn pecen (& mut self) -> PecenW < '_ , Cr1Spec > { PecenW :: new (self , 23) } }
#[doc = "Control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { } }
#[doc = "CR2 (rw) register accessor: Control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`] module"]
#[doc (alias = "CR2")] pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ;
#[doc = "Control register 2"] pub mod cr2 {
#[doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ;
#[doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ;
#[doc = "Field `SADD` reader - Slave address bit (master mode)"] pub type SaddR = crate :: FieldReader < u16 > ;
#[doc = "Field `SADD` writer - Slave address bit (master mode)"] pub type SaddW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ;
#[doc = "Field `RD_WRN` reader - Transfer direction (master mode)"] pub type RdWrnR = crate :: BitReader ;
#[doc = "Field `RD_WRN` writer - Transfer direction (master mode)"] pub type RdWrnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADD10` reader - 10-bit addressing mode (master mode)"] pub type Add10R = crate :: BitReader ;
#[doc = "Field `ADD10` writer - 10-bit addressing mode (master mode)"] pub type Add10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HEAD10R` reader - 10-bit address header only read direction (master receiver mode)"] pub type Head10rR = crate :: BitReader ;
#[doc = "Field `HEAD10R` writer - 10-bit address header only read direction (master receiver mode)"] pub type Head10rW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `START` reader - Start generation"] pub type StartR = crate :: BitReader ;
#[doc = "Field `START` writer - Start generation"] pub type StartW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STOP` reader - Stop generation (master mode)"] pub type StopR = crate :: BitReader ;
#[doc = "Field `STOP` writer - Stop generation (master mode)"] pub type StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NACK` reader - NACK generation (slave mode)"] pub type NackR = crate :: BitReader ;
#[doc = "Field `NACK` writer - NACK generation (slave mode)"] pub type NackW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NBYTES` reader - Number of bytes"] pub type NbytesR = crate :: FieldReader ;
#[doc = "Field `NBYTES` writer - Number of bytes"] pub type NbytesW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `RELOAD` reader - NBYTES reload mode"] pub type ReloadR = crate :: BitReader ;
#[doc = "Field `RELOAD` writer - NBYTES reload mode"] pub type ReloadW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AUTOEND` reader - Automatic end mode (master mode)"] pub type AutoendR = crate :: BitReader ;
#[doc = "Field `AUTOEND` writer - Automatic end mode (master mode)"] pub type AutoendW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PECBYTE` reader - Packet error checking byte"] pub type PecbyteR = crate :: BitReader ;
#[doc = "Field `PECBYTE` writer - Packet error checking byte"] pub type PecbyteW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:9 - Slave address bit (master mode)"]
#[inline (always)] pub fn sadd (& self) -> SaddR { SaddR :: new ((self . bits & 0x03ff) as u16) }
#[doc = "Bit 10 - Transfer direction (master mode)"]
#[inline (always)] pub fn rd_wrn (& self) -> RdWrnR { RdWrnR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - 10-bit addressing mode (master mode)"]
#[inline (always)] pub fn add10 (& self) -> Add10R { Add10R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - 10-bit address header only read direction (master receiver mode)"]
#[inline (always)] pub fn head10r (& self) -> Head10rR { Head10rR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Start generation"]
#[inline (always)] pub fn start (& self) -> StartR { StartR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Stop generation (master mode)"]
#[inline (always)] pub fn stop (& self) -> StopR { StopR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - NACK generation (slave mode)"]
#[inline (always)] pub fn nack (& self) -> NackR { NackR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bits 16:23 - Number of bytes"]
#[inline (always)] pub fn nbytes (& self) -> NbytesR { NbytesR :: new (((self . bits >> 16) & 0xff) as u8) }
#[doc = "Bit 24 - NBYTES reload mode"]
#[inline (always)] pub fn reload (& self) -> ReloadR { ReloadR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Automatic end mode (master mode)"]
#[inline (always)] pub fn autoend (& self) -> AutoendR { AutoendR :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Packet error checking byte"]
#[inline (always)] pub fn pecbyte (& self) -> PecbyteR { PecbyteR :: new (((self . bits >> 26) & 1) != 0) } } impl W {
#[doc = "Bits 0:9 - Slave address bit (master mode)"]
#[inline (always)] pub fn sadd (& mut self) -> SaddW < '_ , Cr2Spec > { SaddW :: new (self , 0) }
#[doc = "Bit 10 - Transfer direction (master mode)"]
#[inline (always)] pub fn rd_wrn (& mut self) -> RdWrnW < '_ , Cr2Spec > { RdWrnW :: new (self , 10) }
#[doc = "Bit 11 - 10-bit addressing mode (master mode)"]
#[inline (always)] pub fn add10 (& mut self) -> Add10W < '_ , Cr2Spec > { Add10W :: new (self , 11) }
#[doc = "Bit 12 - 10-bit address header only read direction (master receiver mode)"]
#[inline (always)] pub fn head10r (& mut self) -> Head10rW < '_ , Cr2Spec > { Head10rW :: new (self , 12) }
#[doc = "Bit 13 - Start generation"]
#[inline (always)] pub fn start (& mut self) -> StartW < '_ , Cr2Spec > { StartW :: new (self , 13) }
#[doc = "Bit 14 - Stop generation (master mode)"]
#[inline (always)] pub fn stop (& mut self) -> StopW < '_ , Cr2Spec > { StopW :: new (self , 14) }
#[doc = "Bit 15 - NACK generation (slave mode)"]
#[inline (always)] pub fn nack (& mut self) -> NackW < '_ , Cr2Spec > { NackW :: new (self , 15) }
#[doc = "Bits 16:23 - Number of bytes"]
#[inline (always)] pub fn nbytes (& mut self) -> NbytesW < '_ , Cr2Spec > { NbytesW :: new (self , 16) }
#[doc = "Bit 24 - NBYTES reload mode"]
#[inline (always)] pub fn reload (& mut self) -> ReloadW < '_ , Cr2Spec > { ReloadW :: new (self , 24) }
#[doc = "Bit 25 - Automatic end mode (master mode)"]
#[inline (always)] pub fn autoend (& mut self) -> AutoendW < '_ , Cr2Spec > { AutoendW :: new (self , 25) }
#[doc = "Bit 26 - Packet error checking byte"]
#[inline (always)] pub fn pecbyte (& mut self) -> PecbyteW < '_ , Cr2Spec > { PecbyteW :: new (self , 26) } }
#[doc = "Control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR2 to value 0"] impl crate :: Resettable for Cr2Spec { } }
#[doc = "OAR1 (rw) register accessor: Own address register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`oar1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`oar1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@oar1`] module"]
#[doc (alias = "OAR1")] pub type Oar1 = crate :: Reg < oar1 :: Oar1Spec > ;
#[doc = "Own address register 1"] pub mod oar1 {
#[doc = "Register `OAR1` reader"] pub type R = crate :: R < Oar1Spec > ;
#[doc = "Register `OAR1` writer"] pub type W = crate :: W < Oar1Spec > ;
#[doc = "Field `OA1` reader - Interface address"] pub type Oa1R = crate :: FieldReader < u16 > ;
#[doc = "Field `OA1` writer - Interface address"] pub type Oa1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ;
#[doc = "Field `OA1MODE` reader - Own Address 1 10-bit mode"] pub type Oa1modeR = crate :: BitReader ;
#[doc = "Field `OA1MODE` writer - Own Address 1 10-bit mode"] pub type Oa1modeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OA1EN` reader - Own Address 1 enable"] pub type Oa1enR = crate :: BitReader ;
#[doc = "Field `OA1EN` writer - Own Address 1 enable"] pub type Oa1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:9 - Interface address"]
#[inline (always)] pub fn oa1 (& self) -> Oa1R { Oa1R :: new ((self . bits & 0x03ff) as u16) }
#[doc = "Bit 10 - Own Address 1 10-bit mode"]
#[inline (always)] pub fn oa1mode (& self) -> Oa1modeR { Oa1modeR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 15 - Own Address 1 enable"]
#[inline (always)] pub fn oa1en (& self) -> Oa1enR { Oa1enR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:9 - Interface address"]
#[inline (always)] pub fn oa1 (& mut self) -> Oa1W < '_ , Oar1Spec > { Oa1W :: new (self , 0) }
#[doc = "Bit 10 - Own Address 1 10-bit mode"]
#[inline (always)] pub fn oa1mode (& mut self) -> Oa1modeW < '_ , Oar1Spec > { Oa1modeW :: new (self , 10) }
#[doc = "Bit 15 - Own Address 1 enable"]
#[inline (always)] pub fn oa1en (& mut self) -> Oa1enW < '_ , Oar1Spec > { Oa1enW :: new (self , 15) } }
#[doc = "Own address register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`oar1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`oar1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Oar1Spec ; impl crate :: RegisterSpec for Oar1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`oar1::R`](R) reader structure"] impl crate :: Readable for Oar1Spec { }
#[doc = "`write(|w| ..)` method takes [`oar1::W`](W) writer structure"] impl crate :: Writable for Oar1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OAR1 to value 0"] impl crate :: Resettable for Oar1Spec { } }
#[doc = "OAR2 (rw) register accessor: Own address register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`oar2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`oar2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@oar2`] module"]
#[doc (alias = "OAR2")] pub type Oar2 = crate :: Reg < oar2 :: Oar2Spec > ;
#[doc = "Own address register 2"] pub mod oar2 {
#[doc = "Register `OAR2` reader"] pub type R = crate :: R < Oar2Spec > ;
#[doc = "Register `OAR2` writer"] pub type W = crate :: W < Oar2Spec > ;
#[doc = "Field `OA2` reader - Interface address"] pub type Oa2R = crate :: FieldReader ;
#[doc = "Field `OA2` writer - Interface address"] pub type Oa2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `OA2MSK` reader - Own Address 2 masks"] pub type Oa2mskR = crate :: FieldReader ;
#[doc = "Field `OA2MSK` writer - Own Address 2 masks"] pub type Oa2mskW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OA2EN` reader - Own Address 2 enable"] pub type Oa2enR = crate :: BitReader ;
#[doc = "Field `OA2EN` writer - Own Address 2 enable"] pub type Oa2enW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 1:7 - Interface address"]
#[inline (always)] pub fn oa2 (& self) -> Oa2R { Oa2R :: new (((self . bits >> 1) & 0x7f) as u8) }
#[doc = "Bits 8:10 - Own Address 2 masks"]
#[inline (always)] pub fn oa2msk (& self) -> Oa2mskR { Oa2mskR :: new (((self . bits >> 8) & 7) as u8) }
#[doc = "Bit 15 - Own Address 2 enable"]
#[inline (always)] pub fn oa2en (& self) -> Oa2enR { Oa2enR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 1:7 - Interface address"]
#[inline (always)] pub fn oa2 (& mut self) -> Oa2W < '_ , Oar2Spec > { Oa2W :: new (self , 1) }
#[doc = "Bits 8:10 - Own Address 2 masks"]
#[inline (always)] pub fn oa2msk (& mut self) -> Oa2mskW < '_ , Oar2Spec > { Oa2mskW :: new (self , 8) }
#[doc = "Bit 15 - Own Address 2 enable"]
#[inline (always)] pub fn oa2en (& mut self) -> Oa2enW < '_ , Oar2Spec > { Oa2enW :: new (self , 15) } }
#[doc = "Own address register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`oar2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`oar2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Oar2Spec ; impl crate :: RegisterSpec for Oar2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`oar2::R`](R) reader structure"] impl crate :: Readable for Oar2Spec { }
#[doc = "`write(|w| ..)` method takes [`oar2::W`](W) writer structure"] impl crate :: Writable for Oar2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OAR2 to value 0"] impl crate :: Resettable for Oar2Spec { } }
#[doc = "TIMINGR (rw) register accessor: Timing register\n\nYou can [`read`](crate::Reg::read) this register and get [`timingr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`timingr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@timingr`] module"]
#[doc (alias = "TIMINGR")] pub type Timingr = crate :: Reg < timingr :: TimingrSpec > ;
#[doc = "Timing register"] pub mod timingr {
#[doc = "Register `TIMINGR` reader"] pub type R = crate :: R < TimingrSpec > ;
#[doc = "Register `TIMINGR` writer"] pub type W = crate :: W < TimingrSpec > ;
#[doc = "Field `SCLL` reader - SCL low period (master mode)"] pub type ScllR = crate :: FieldReader ;
#[doc = "Field `SCLL` writer - SCL low period (master mode)"] pub type ScllW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `SCLH` reader - SCL high period (master mode)"] pub type SclhR = crate :: FieldReader ;
#[doc = "Field `SCLH` writer - SCL high period (master mode)"] pub type SclhW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `SDADEL` reader - Data hold time"] pub type SdadelR = crate :: FieldReader ;
#[doc = "Field `SDADEL` writer - Data hold time"] pub type SdadelW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `SCLDEL` reader - Data setup time"] pub type ScldelR = crate :: FieldReader ;
#[doc = "Field `SCLDEL` writer - Data setup time"] pub type ScldelW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `PRESC` reader - Timing prescaler"] pub type PrescR = crate :: FieldReader ;
#[doc = "Field `PRESC` writer - Timing prescaler"] pub type PrescW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:7 - SCL low period (master mode)"]
#[inline (always)] pub fn scll (& self) -> ScllR { ScllR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - SCL high period (master mode)"]
#[inline (always)] pub fn sclh (& self) -> SclhR { SclhR :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:19 - Data hold time"]
#[inline (always)] pub fn sdadel (& self) -> SdadelR { SdadelR :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bits 20:23 - Data setup time"]
#[inline (always)] pub fn scldel (& self) -> ScldelR { ScldelR :: new (((self . bits >> 20) & 0x0f) as u8) }
#[doc = "Bits 28:31 - Timing prescaler"]
#[inline (always)] pub fn presc (& self) -> PrescR { PrescR :: new (((self . bits >> 28) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:7 - SCL low period (master mode)"]
#[inline (always)] pub fn scll (& mut self) -> ScllW < '_ , TimingrSpec > { ScllW :: new (self , 0) }
#[doc = "Bits 8:15 - SCL high period (master mode)"]
#[inline (always)] pub fn sclh (& mut self) -> SclhW < '_ , TimingrSpec > { SclhW :: new (self , 8) }
#[doc = "Bits 16:19 - Data hold time"]
#[inline (always)] pub fn sdadel (& mut self) -> SdadelW < '_ , TimingrSpec > { SdadelW :: new (self , 16) }
#[doc = "Bits 20:23 - Data setup time"]
#[inline (always)] pub fn scldel (& mut self) -> ScldelW < '_ , TimingrSpec > { ScldelW :: new (self , 20) }
#[doc = "Bits 28:31 - Timing prescaler"]
#[inline (always)] pub fn presc (& mut self) -> PrescW < '_ , TimingrSpec > { PrescW :: new (self , 28) } }
#[doc = "Timing register\n\nYou can [`read`](crate::Reg::read) this register and get [`timingr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`timingr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TimingrSpec ; impl crate :: RegisterSpec for TimingrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`timingr::R`](R) reader structure"] impl crate :: Readable for TimingrSpec { }
#[doc = "`write(|w| ..)` method takes [`timingr::W`](W) writer structure"] impl crate :: Writable for TimingrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets TIMINGR to value 0"] impl crate :: Resettable for TimingrSpec { } }
#[doc = "TIMEOUTR (rw) register accessor: Status register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`timeoutr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`timeoutr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@timeoutr`] module"]
#[doc (alias = "TIMEOUTR")] pub type Timeoutr = crate :: Reg < timeoutr :: TimeoutrSpec > ;
#[doc = "Status register 1"] pub mod timeoutr {
#[doc = "Register `TIMEOUTR` reader"] pub type R = crate :: R < TimeoutrSpec > ;
#[doc = "Register `TIMEOUTR` writer"] pub type W = crate :: W < TimeoutrSpec > ;
#[doc = "Field `TIMEOUTA` reader - Bus timeout A"] pub type TimeoutaR = crate :: FieldReader < u16 > ;
#[doc = "Field `TIMEOUTA` writer - Bus timeout A"] pub type TimeoutaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ;
#[doc = "Field `TIDLE` reader - Idle clock timeout detection"] pub type TidleR = crate :: BitReader ;
#[doc = "Field `TIDLE` writer - Idle clock timeout detection"] pub type TidleW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIMOUTEN` reader - Clock timeout enable"] pub type TimoutenR = crate :: BitReader ;
#[doc = "Field `TIMOUTEN` writer - Clock timeout enable"] pub type TimoutenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIMEOUTB` reader - Bus timeout B"] pub type TimeoutbR = crate :: FieldReader < u16 > ;
#[doc = "Field `TIMEOUTB` writer - Bus timeout B"] pub type TimeoutbW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ;
#[doc = "Field `TEXTEN` reader - Extended clock timeout enable"] pub type TextenR = crate :: BitReader ;
#[doc = "Field `TEXTEN` writer - Extended clock timeout enable"] pub type TextenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:11 - Bus timeout A"]
#[inline (always)] pub fn timeouta (& self) -> TimeoutaR { TimeoutaR :: new ((self . bits & 0x0fff) as u16) }
#[doc = "Bit 12 - Idle clock timeout detection"]
#[inline (always)] pub fn tidle (& self) -> TidleR { TidleR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 15 - Clock timeout enable"]
#[inline (always)] pub fn timouten (& self) -> TimoutenR { TimoutenR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bits 16:27 - Bus timeout B"]
#[inline (always)] pub fn timeoutb (& self) -> TimeoutbR { TimeoutbR :: new (((self . bits >> 16) & 0x0fff) as u16) }
#[doc = "Bit 31 - Extended clock timeout enable"]
#[inline (always)] pub fn texten (& self) -> TextenR { TextenR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:11 - Bus timeout A"]
#[inline (always)] pub fn timeouta (& mut self) -> TimeoutaW < '_ , TimeoutrSpec > { TimeoutaW :: new (self , 0) }
#[doc = "Bit 12 - Idle clock timeout detection"]
#[inline (always)] pub fn tidle (& mut self) -> TidleW < '_ , TimeoutrSpec > { TidleW :: new (self , 12) }
#[doc = "Bit 15 - Clock timeout enable"]
#[inline (always)] pub fn timouten (& mut self) -> TimoutenW < '_ , TimeoutrSpec > { TimoutenW :: new (self , 15) }
#[doc = "Bits 16:27 - Bus timeout B"]
#[inline (always)] pub fn timeoutb (& mut self) -> TimeoutbW < '_ , TimeoutrSpec > { TimeoutbW :: new (self , 16) }
#[doc = "Bit 31 - Extended clock timeout enable"]
#[inline (always)] pub fn texten (& mut self) -> TextenW < '_ , TimeoutrSpec > { TextenW :: new (self , 31) } }
#[doc = "Status register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`timeoutr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`timeoutr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TimeoutrSpec ; impl crate :: RegisterSpec for TimeoutrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`timeoutr::R`](R) reader structure"] impl crate :: Readable for TimeoutrSpec { }
#[doc = "`write(|w| ..)` method takes [`timeoutr::W`](W) writer structure"] impl crate :: Writable for TimeoutrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets TIMEOUTR to value 0"] impl crate :: Resettable for TimeoutrSpec { } }
#[doc = "ISR (rw) register accessor: Interrupt and Status register\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`isr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@isr`] module"]
#[doc (alias = "ISR")] pub type Isr = crate :: Reg < isr :: IsrSpec > ;
#[doc = "Interrupt and Status register"] pub mod isr {
#[doc = "Register `ISR` reader"] pub type R = crate :: R < IsrSpec > ;
#[doc = "Register `ISR` writer"] pub type W = crate :: W < IsrSpec > ;
#[doc = "Field `TXE` reader - Transmit data register empty (transmitters)"] pub type TxeR = crate :: BitReader ;
#[doc = "Field `TXE` writer - Transmit data register empty (transmitters)"] pub type TxeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXIS` reader - Transmit interrupt status (transmitters)"] pub type TxisR = crate :: BitReader ;
#[doc = "Field `TXIS` writer - Transmit interrupt status (transmitters)"] pub type TxisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXNE` reader - Receive data register not empty (receivers)"] pub type RxneR = crate :: BitReader ;
#[doc = "Field `ADDR` reader - Address matched (slave mode)"] pub type AddrR = crate :: BitReader ;
#[doc = "Field `NACKF` reader - Not acknowledge received flag"] pub type NackfR = crate :: BitReader ;
#[doc = "Field `STOPF` reader - Stop detection flag"] pub type StopfR = crate :: BitReader ;
#[doc = "Field `TC` reader - Transfer Complete (master mode)"] pub type TcR = crate :: BitReader ;
#[doc = "Field `TCR` reader - Transfer Complete Reload"] pub type TcrR = crate :: BitReader ;
#[doc = "Field `BERR` reader - Bus error"] pub type BerrR = crate :: BitReader ;
#[doc = "Field `ARLO` reader - Arbitration lost"] pub type ArloR = crate :: BitReader ;
#[doc = "Field `OVR` reader - Overrun/Underrun (slave mode)"] pub type OvrR = crate :: BitReader ;
#[doc = "Field `PECERR` reader - PEC Error in reception"] pub type PecerrR = crate :: BitReader ;
#[doc = "Field `TIMEOUT` reader - Timeout or t_low detection flag"] pub type TimeoutR = crate :: BitReader ;
#[doc = "Field `ALERT` reader - SMBus alert"] pub type AlertR = crate :: BitReader ;
#[doc = "Field `BUSY` reader - Bus busy"] pub type BusyR = crate :: BitReader ;
#[doc = "Field `DIR` reader - Transfer direction (Slave mode)"] pub type DirR = crate :: BitReader ;
#[doc = "Field `ADDCODE` reader - Address match code (Slave mode)"] pub type AddcodeR = crate :: FieldReader ; impl R {
#[doc = "Bit 0 - Transmit data register empty (transmitters)"]
#[inline (always)] pub fn txe (& self) -> TxeR { TxeR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transmit interrupt status (transmitters)"]
#[inline (always)] pub fn txis (& self) -> TxisR { TxisR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Receive data register not empty (receivers)"]
#[inline (always)] pub fn rxne (& self) -> RxneR { RxneR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Address matched (slave mode)"]
#[inline (always)] pub fn addr (& self) -> AddrR { AddrR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Not acknowledge received flag"]
#[inline (always)] pub fn nackf (& self) -> NackfR { NackfR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Stop detection flag"]
#[inline (always)] pub fn stopf (& self) -> StopfR { StopfR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Transfer Complete (master mode)"]
#[inline (always)] pub fn tc (& self) -> TcR { TcR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Transfer Complete Reload"]
#[inline (always)] pub fn tcr (& self) -> TcrR { TcrR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Bus error"]
#[inline (always)] pub fn berr (& self) -> BerrR { BerrR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Arbitration lost"]
#[inline (always)] pub fn arlo (& self) -> ArloR { ArloR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Overrun/Underrun (slave mode)"]
#[inline (always)] pub fn ovr (& self) -> OvrR { OvrR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - PEC Error in reception"]
#[inline (always)] pub fn pecerr (& self) -> PecerrR { PecerrR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Timeout or t_low detection flag"]
#[inline (always)] pub fn timeout (& self) -> TimeoutR { TimeoutR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - SMBus alert"]
#[inline (always)] pub fn alert (& self) -> AlertR { AlertR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 15 - Bus busy"]
#[inline (always)] pub fn busy (& self) -> BusyR { BusyR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Transfer direction (Slave mode)"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:23 - Address match code (Slave mode)"]
#[inline (always)] pub fn addcode (& self) -> AddcodeR { AddcodeR :: new (((self . bits >> 17) & 0x7f) as u8) } } impl W {
#[doc = "Bit 0 - Transmit data register empty (transmitters)"]
#[inline (always)] pub fn txe (& mut self) -> TxeW < '_ , IsrSpec > { TxeW :: new (self , 0) }
#[doc = "Bit 1 - Transmit interrupt status (transmitters)"]
#[inline (always)] pub fn txis (& mut self) -> TxisW < '_ , IsrSpec > { TxisW :: new (self , 1) } }
#[doc = "Interrupt and Status register\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`isr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IsrSpec ; impl crate :: RegisterSpec for IsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`isr::R`](R) reader structure"] impl crate :: Readable for IsrSpec { }
#[doc = "`write(|w| ..)` method takes [`isr::W`](W) writer structure"] impl crate :: Writable for IsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ISR to value 0x01"] impl crate :: Resettable for IsrSpec { const RESET_VALUE : u32 = 0x01 ; } }
#[doc = "ICR (w) register accessor: Interrupt clear register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@icr`] module"]
#[doc (alias = "ICR")] pub type Icr = crate :: Reg < icr :: IcrSpec > ;
#[doc = "Interrupt clear register"] pub mod icr {
#[doc = "Register `ICR` writer"] pub type W = crate :: W < IcrSpec > ;
#[doc = "Field `ADDRCF` writer - Address Matched flag clear"] pub type AddrcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NACKCF` writer - Not Acknowledge flag clear"] pub type NackcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STOPCF` writer - Stop detection flag clear"] pub type StopcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BERRCF` writer - Bus error flag clear"] pub type BerrcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ARLOCF` writer - Arbitration lost flag clear"] pub type ArlocfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OVRCF` writer - Overrun/Underrun flag clear"] pub type OvrcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PECCF` writer - PEC Error flag clear"] pub type PeccfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIMOUTCF` writer - Timeout detection flag clear"] pub type TimoutcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ALERTCF` writer - Alert flag clear"] pub type AlertcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 3 - Address Matched flag clear"]
#[inline (always)] pub fn addrcf (& mut self) -> AddrcfW < '_ , IcrSpec > { AddrcfW :: new (self , 3) }
#[doc = "Bit 4 - Not Acknowledge flag clear"]
#[inline (always)] pub fn nackcf (& mut self) -> NackcfW < '_ , IcrSpec > { NackcfW :: new (self , 4) }
#[doc = "Bit 5 - Stop detection flag clear"]
#[inline (always)] pub fn stopcf (& mut self) -> StopcfW < '_ , IcrSpec > { StopcfW :: new (self , 5) }
#[doc = "Bit 8 - Bus error flag clear"]
#[inline (always)] pub fn berrcf (& mut self) -> BerrcfW < '_ , IcrSpec > { BerrcfW :: new (self , 8) }
#[doc = "Bit 9 - Arbitration lost flag clear"]
#[inline (always)] pub fn arlocf (& mut self) -> ArlocfW < '_ , IcrSpec > { ArlocfW :: new (self , 9) }
#[doc = "Bit 10 - Overrun/Underrun flag clear"]
#[inline (always)] pub fn ovrcf (& mut self) -> OvrcfW < '_ , IcrSpec > { OvrcfW :: new (self , 10) }
#[doc = "Bit 11 - PEC Error flag clear"]
#[inline (always)] pub fn peccf (& mut self) -> PeccfW < '_ , IcrSpec > { PeccfW :: new (self , 11) }
#[doc = "Bit 12 - Timeout detection flag clear"]
#[inline (always)] pub fn timoutcf (& mut self) -> TimoutcfW < '_ , IcrSpec > { TimoutcfW :: new (self , 12) }
#[doc = "Bit 13 - Alert flag clear"]
#[inline (always)] pub fn alertcf (& mut self) -> AlertcfW < '_ , IcrSpec > { AlertcfW :: new (self , 13) } }
#[doc = "Interrupt clear register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IcrSpec ; impl crate :: RegisterSpec for IcrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`icr::W`](W) writer structure"] impl crate :: Writable for IcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ICR to value 0"] impl crate :: Resettable for IcrSpec { } }
#[doc = "PECR (r) register accessor: PEC register\n\nYou can [`read`](crate::Reg::read) this register and get [`pecr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pecr`] module"]
#[doc (alias = "PECR")] pub type Pecr = crate :: Reg < pecr :: PecrSpec > ;
#[doc = "PEC register"] pub mod pecr {
#[doc = "Register `PECR` reader"] pub type R = crate :: R < PecrSpec > ;
#[doc = "Field `PEC` reader - Packet error checking register"] pub type PecR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - Packet error checking register"]
#[inline (always)] pub fn pec (& self) -> PecR { PecR :: new ((self . bits & 0xff) as u8) } }
#[doc = "PEC register\n\nYou can [`read`](crate::Reg::read) this register and get [`pecr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PecrSpec ; impl crate :: RegisterSpec for PecrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pecr::R`](R) reader structure"] impl crate :: Readable for PecrSpec { }
#[doc = "`reset()` method sets PECR to value 0"] impl crate :: Resettable for PecrSpec { } }
#[doc = "RXDR (r) register accessor: Receive data register\n\nYou can [`read`](crate::Reg::read) this register and get [`rxdr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rxdr`] module"]
#[doc (alias = "RXDR")] pub type Rxdr = crate :: Reg < rxdr :: RxdrSpec > ;
#[doc = "Receive data register"] pub mod rxdr {
#[doc = "Register `RXDR` reader"] pub type R = crate :: R < RxdrSpec > ;
#[doc = "Field `RXDATA` reader - 8-bit receive data"] pub type RxdataR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - 8-bit receive data"]
#[inline (always)] pub fn rxdata (& self) -> RxdataR { RxdataR :: new ((self . bits & 0xff) as u8) } }
#[doc = "Receive data register\n\nYou can [`read`](crate::Reg::read) this register and get [`rxdr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RxdrSpec ; impl crate :: RegisterSpec for RxdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rxdr::R`](R) reader structure"] impl crate :: Readable for RxdrSpec { }
#[doc = "`reset()` method sets RXDR to value 0"] impl crate :: Resettable for RxdrSpec { } }
#[doc = "TXDR (rw) register accessor: Transmit data register\n\nYou can [`read`](crate::Reg::read) this register and get [`txdr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`txdr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@txdr`] module"]
#[doc (alias = "TXDR")] pub type Txdr = crate :: Reg < txdr :: TxdrSpec > ;
#[doc = "Transmit data register"] pub mod txdr {
#[doc = "Register `TXDR` reader"] pub type R = crate :: R < TxdrSpec > ;
#[doc = "Register `TXDR` writer"] pub type W = crate :: W < TxdrSpec > ;
#[doc = "Field `TXDATA` reader - 8-bit transmit data"] pub type TxdataR = crate :: FieldReader ;
#[doc = "Field `TXDATA` writer - 8-bit transmit data"] pub type TxdataW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - 8-bit transmit data"]
#[inline (always)] pub fn txdata (& self) -> TxdataR { TxdataR :: new ((self . bits & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - 8-bit transmit data"]
#[inline (always)] pub fn txdata (& mut self) -> TxdataW < '_ , TxdrSpec > { TxdataW :: new (self , 0) } }
#[doc = "Transmit data register\n\nYou can [`read`](crate::Reg::read) this register and get [`txdr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`txdr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TxdrSpec ; impl crate :: RegisterSpec for TxdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`txdr::R`](R) reader structure"] impl crate :: Readable for TxdrSpec { }
#[doc = "`write(|w| ..)` method takes [`txdr::W`](W) writer structure"] impl crate :: Writable for TxdrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets TXDR to value 0"] impl crate :: Resettable for TxdrSpec { } } }
#[doc = "Inter-integrated circuit"] pub type I2c3 = crate :: Periph < i2c1 :: RegisterBlock , 0x4000_5c00 > ; impl core :: fmt :: Debug for I2c3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("I2c3") . finish () } }
#[doc = "Inter-integrated circuit"] pub use self :: i2c1 as i2c3 ;
#[doc = "Flash"] pub type Flash = crate :: Periph < flash :: RegisterBlock , 0x5800_4000 > ; impl core :: fmt :: Debug for Flash { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Flash") . finish () } }
#[doc = "Flash"] pub mod flash {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { acr : Acr , _reserved1 : [u8 ; 0x04] , keyr : Keyr , optkeyr : Optkeyr , sr : Sr , cr : Cr , eccr : Eccr , _reserved6 : [u8 ; 0x04] , optr : Optr , pcrop1asr : Pcrop1asr , pcrop1aer : Pcrop1aer , wrp1ar : Wrp1ar , wrp1br : Wrp1br , pcrop1bsr : Pcrop1bsr , pcrop1ber : Pcrop1ber , ipccbr : Ipccbr , _reserved14 : [u8 ; 0x1c] , c2acr : C2acr , c2sr : C2sr , c2cr : C2cr , _reserved17 : [u8 ; 0x18] , sfr : Sfr , srrvr : Srrvr , } impl RegisterBlock {
#[doc = "0x00 - Access control register"]
#[inline (always)] pub const fn acr (& self) -> & Acr { & self . acr }
#[doc = "0x08 - Flash key register"]
#[inline (always)] pub const fn keyr (& self) -> & Keyr { & self . keyr }
#[doc = "0x0c - Option byte key register"]
#[inline (always)] pub const fn optkeyr (& self) -> & Optkeyr { & self . optkeyr }
#[doc = "0x10 - Status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x14 - Flash control register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x18 - Flash ECC register"]
#[inline (always)] pub const fn eccr (& self) -> & Eccr { & self . eccr }
#[doc = "0x20 - Flash option register"]
#[inline (always)] pub const fn optr (& self) -> & Optr { & self . optr }
#[doc = "0x24 - Flash Bank 1 PCROP Start address zone A register"]
#[inline (always)] pub const fn pcrop1asr (& self) -> & Pcrop1asr { & self . pcrop1asr }
#[doc = "0x28 - Flash Bank 1 PCROP End address zone A register"]
#[inline (always)] pub const fn pcrop1aer (& self) -> & Pcrop1aer { & self . pcrop1aer }
#[doc = "0x2c - Flash Bank 1 WRP area A address register"]
#[inline (always)] pub const fn wrp1ar (& self) -> & Wrp1ar { & self . wrp1ar }
#[doc = "0x30 - Flash Bank 1 WRP area B address register"]
#[inline (always)] pub const fn wrp1br (& self) -> & Wrp1br { & self . wrp1br }
#[doc = "0x34 - Flash Bank 1 PCROP Start address area B register"]
#[inline (always)] pub const fn pcrop1bsr (& self) -> & Pcrop1bsr { & self . pcrop1bsr }
#[doc = "0x38 - Flash Bank 1 PCROP End address area B register"]
#[inline (always)] pub const fn pcrop1ber (& self) -> & Pcrop1ber { & self . pcrop1ber }
#[doc = "0x3c - IPCC mailbox data buffer address register"]
#[inline (always)] pub const fn ipccbr (& self) -> & Ipccbr { & self . ipccbr }
#[doc = "0x5c - CPU2 cortex M0 access control register"]
#[inline (always)] pub const fn c2acr (& self) -> & C2acr { & self . c2acr }
#[doc = "0x60 - CPU2 cortex M0 status register"]
#[inline (always)] pub const fn c2sr (& self) -> & C2sr { & self . c2sr }
#[doc = "0x64 - CPU2 cortex M0 control register"]
#[inline (always)] pub const fn c2cr (& self) -> & C2cr { & self . c2cr }
#[doc = "0x80 - Secure flash start address register"]
#[inline (always)] pub const fn sfr (& self) -> & Sfr { & self . sfr }
#[doc = "0x84 - Secure SRAM2 start address and cortex M0 reset vector register"]
#[inline (always)] pub const fn srrvr (& self) -> & Srrvr { & self . srrvr } }
#[doc = "ACR (rw) register accessor: Access control register\n\nYou can [`read`](crate::Reg::read) this register and get [`acr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`acr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@acr`] module"]
#[doc (alias = "ACR")] pub type Acr = crate :: Reg < acr :: AcrSpec > ;
#[doc = "Access control register"] pub mod acr {
#[doc = "Register `ACR` reader"] pub type R = crate :: R < AcrSpec > ;
#[doc = "Register `ACR` writer"] pub type W = crate :: W < AcrSpec > ;
#[doc = "Field `LATENCY` reader - Latency"] pub type LatencyR = crate :: FieldReader ;
#[doc = "Field `LATENCY` writer - Latency"] pub type LatencyW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `PRFTEN` reader - Prefetch enable"] pub type PrftenR = crate :: BitReader ;
#[doc = "Field `PRFTEN` writer - Prefetch enable"] pub type PrftenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ICEN` reader - Instruction cache enable"] pub type IcenR = crate :: BitReader ;
#[doc = "Field `ICEN` writer - Instruction cache enable"] pub type IcenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DCEN` reader - Data cache enable"] pub type DcenR = crate :: BitReader ;
#[doc = "Field `DCEN` writer - Data cache enable"] pub type DcenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ICRST` reader - Instruction cache reset"] pub type IcrstR = crate :: BitReader ;
#[doc = "Field `ICRST` writer - Instruction cache reset"] pub type IcrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DCRST` reader - Data cache reset"] pub type DcrstR = crate :: BitReader ;
#[doc = "Field `DCRST` writer - Data cache reset"] pub type DcrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PES` reader - CPU1 CortexM4 program erase suspend request"] pub type PesR = crate :: BitReader ;
#[doc = "Field `PES` writer - CPU1 CortexM4 program erase suspend request"] pub type PesW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EMPTY` reader - Flash User area empty"] pub type EmptyR = crate :: BitReader ;
#[doc = "Field `EMPTY` writer - Flash User area empty"] pub type EmptyW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:2 - Latency"]
#[inline (always)] pub fn latency (& self) -> LatencyR { LatencyR :: new ((self . bits & 7) as u8) }
#[doc = "Bit 8 - Prefetch enable"]
#[inline (always)] pub fn prften (& self) -> PrftenR { PrftenR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Instruction cache enable"]
#[inline (always)] pub fn icen (& self) -> IcenR { IcenR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Data cache enable"]
#[inline (always)] pub fn dcen (& self) -> DcenR { DcenR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Instruction cache reset"]
#[inline (always)] pub fn icrst (& self) -> IcrstR { IcrstR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Data cache reset"]
#[inline (always)] pub fn dcrst (& self) -> DcrstR { DcrstR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 15 - CPU1 CortexM4 program erase suspend request"]
#[inline (always)] pub fn pes (& self) -> PesR { PesR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Flash User area empty"]
#[inline (always)] pub fn empty (& self) -> EmptyR { EmptyR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bits 0:2 - Latency"]
#[inline (always)] pub fn latency (& mut self) -> LatencyW < '_ , AcrSpec > { LatencyW :: new (self , 0) }
#[doc = "Bit 8 - Prefetch enable"]
#[inline (always)] pub fn prften (& mut self) -> PrftenW < '_ , AcrSpec > { PrftenW :: new (self , 8) }
#[doc = "Bit 9 - Instruction cache enable"]
#[inline (always)] pub fn icen (& mut self) -> IcenW < '_ , AcrSpec > { IcenW :: new (self , 9) }
#[doc = "Bit 10 - Data cache enable"]
#[inline (always)] pub fn dcen (& mut self) -> DcenW < '_ , AcrSpec > { DcenW :: new (self , 10) }
#[doc = "Bit 11 - Instruction cache reset"]
#[inline (always)] pub fn icrst (& mut self) -> IcrstW < '_ , AcrSpec > { IcrstW :: new (self , 11) }
#[doc = "Bit 12 - Data cache reset"]
#[inline (always)] pub fn dcrst (& mut self) -> DcrstW < '_ , AcrSpec > { DcrstW :: new (self , 12) }
#[doc = "Bit 15 - CPU1 CortexM4 program erase suspend request"]
#[inline (always)] pub fn pes (& mut self) -> PesW < '_ , AcrSpec > { PesW :: new (self , 15) }
#[doc = "Bit 16 - Flash User area empty"]
#[inline (always)] pub fn empty (& mut self) -> EmptyW < '_ , AcrSpec > { EmptyW :: new (self , 16) } }
#[doc = "Access control register\n\nYou can [`read`](crate::Reg::read) this register and get [`acr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`acr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AcrSpec ; impl crate :: RegisterSpec for AcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`acr::R`](R) reader structure"] impl crate :: Readable for AcrSpec { }
#[doc = "`write(|w| ..)` method takes [`acr::W`](W) writer structure"] impl crate :: Writable for AcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ACR to value 0x0600"] impl crate :: Resettable for AcrSpec { const RESET_VALUE : u32 = 0x0600 ; } }
#[doc = "KEYR (w) register accessor: Flash key register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@keyr`] module"]
#[doc (alias = "KEYR")] pub type Keyr = crate :: Reg < keyr :: KeyrSpec > ;
#[doc = "Flash key register"] pub mod keyr {
#[doc = "Register `KEYR` writer"] pub type W = crate :: W < KeyrSpec > ;
#[doc = "Field `KEYR` writer - KEYR"] pub type KeyrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl W {
#[doc = "Bits 0:31 - KEYR"]
#[inline (always)] pub fn keyr (& mut self) -> KeyrW < '_ , KeyrSpec > { KeyrW :: new (self , 0) } }
#[doc = "Flash key register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct KeyrSpec ; impl crate :: RegisterSpec for KeyrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`keyr::W`](W) writer structure"] impl crate :: Writable for KeyrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets KEYR to value 0"] impl crate :: Resettable for KeyrSpec { } }
#[doc = "OPTKEYR (w) register accessor: Option byte key register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`optkeyr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@optkeyr`] module"]
#[doc (alias = "OPTKEYR")] pub type Optkeyr = crate :: Reg < optkeyr :: OptkeyrSpec > ;
#[doc = "Option byte key register"] pub mod optkeyr {
#[doc = "Register `OPTKEYR` writer"] pub type W = crate :: W < OptkeyrSpec > ;
#[doc = "Field `OPTKEYR` writer - Option byte key"] pub type OptkeyrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl W {
#[doc = "Bits 0:31 - Option byte key"]
#[inline (always)] pub fn optkeyr (& mut self) -> OptkeyrW < '_ , OptkeyrSpec > { OptkeyrW :: new (self , 0) } }
#[doc = "Option byte key register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`optkeyr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OptkeyrSpec ; impl crate :: RegisterSpec for OptkeyrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`optkeyr::W`](W) writer structure"] impl crate :: Writable for OptkeyrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OPTKEYR to value 0"] impl crate :: Resettable for OptkeyrSpec { } }
#[doc = "SR (rw) register accessor: Status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "Status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `EOP` reader - End of operation"] pub type EopR = crate :: BitReader ;
#[doc = "Field `EOP` writer - End of operation"] pub type EopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OPERR` reader - Operation error"] pub type OperrR = crate :: BitReader ;
#[doc = "Field `OPERR` writer - Operation error"] pub type OperrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PROGERR` reader - Programming error"] pub type ProgerrR = crate :: BitReader ;
#[doc = "Field `PROGERR` writer - Programming error"] pub type ProgerrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WRPERR` reader - Write protected error"] pub type WrperrR = crate :: BitReader ;
#[doc = "Field `WRPERR` writer - Write protected error"] pub type WrperrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PGAERR` reader - Programming alignment error"] pub type PgaerrR = crate :: BitReader ;
#[doc = "Field `PGAERR` writer - Programming alignment error"] pub type PgaerrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SIZERR` reader - Size error"] pub type SizerrR = crate :: BitReader ;
#[doc = "Field `SIZERR` writer - Size error"] pub type SizerrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PGSERR` reader - Programming sequence error"] pub type PgserrR = crate :: BitReader ;
#[doc = "Field `PGSERR` writer - Programming sequence error"] pub type PgserrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MISERR` reader - Fast programming data miss error"] pub type MiserrR = crate :: BitReader ;
#[doc = "Field `MISERR` writer - Fast programming data miss error"] pub type MiserrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FASTERR` reader - Fast programming error"] pub type FasterrR = crate :: BitReader ;
#[doc = "Field `FASTERR` writer - Fast programming error"] pub type FasterrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OPTNV` reader - User Option OPTVAL indication"] pub type OptnvR = crate :: BitReader ;
#[doc = "Field `RDERR` reader - PCROP read error"] pub type RderrR = crate :: BitReader ;
#[doc = "Field `RDERR` writer - PCROP read error"] pub type RderrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OPTVERR` reader - Option validity error"] pub type OptverrR = crate :: BitReader ;
#[doc = "Field `OPTVERR` writer - Option validity error"] pub type OptverrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BSY` reader - Busy"] pub type BsyR = crate :: BitReader ;
#[doc = "Field `CFGBSY` reader - Programming or erase configuration busy"] pub type CfgbsyR = crate :: BitReader ;
#[doc = "Field `PESD` reader - Programming or erase operation suspended"] pub type PesdR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - End of operation"]
#[inline (always)] pub fn eop (& self) -> EopR { EopR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Operation error"]
#[inline (always)] pub fn operr (& self) -> OperrR { OperrR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - Programming error"]
#[inline (always)] pub fn progerr (& self) -> ProgerrR { ProgerrR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Write protected error"]
#[inline (always)] pub fn wrperr (& self) -> WrperrR { WrperrR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Programming alignment error"]
#[inline (always)] pub fn pgaerr (& self) -> PgaerrR { PgaerrR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Size error"]
#[inline (always)] pub fn sizerr (& self) -> SizerrR { SizerrR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Programming sequence error"]
#[inline (always)] pub fn pgserr (& self) -> PgserrR { PgserrR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Fast programming data miss error"]
#[inline (always)] pub fn miserr (& self) -> MiserrR { MiserrR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Fast programming error"]
#[inline (always)] pub fn fasterr (& self) -> FasterrR { FasterrR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 13 - User Option OPTVAL indication"]
#[inline (always)] pub fn optnv (& self) -> OptnvR { OptnvR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - PCROP read error"]
#[inline (always)] pub fn rderr (& self) -> RderrR { RderrR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Option validity error"]
#[inline (always)] pub fn optverr (& self) -> OptverrR { OptverrR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Busy"]
#[inline (always)] pub fn bsy (& self) -> BsyR { BsyR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 18 - Programming or erase configuration busy"]
#[inline (always)] pub fn cfgbsy (& self) -> CfgbsyR { CfgbsyR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Programming or erase operation suspended"]
#[inline (always)] pub fn pesd (& self) -> PesdR { PesdR :: new (((self . bits >> 19) & 1) != 0) } } impl W {
#[doc = "Bit 0 - End of operation"]
#[inline (always)] pub fn eop (& mut self) -> EopW < '_ , SrSpec > { EopW :: new (self , 0) }
#[doc = "Bit 1 - Operation error"]
#[inline (always)] pub fn operr (& mut self) -> OperrW < '_ , SrSpec > { OperrW :: new (self , 1) }
#[doc = "Bit 3 - Programming error"]
#[inline (always)] pub fn progerr (& mut self) -> ProgerrW < '_ , SrSpec > { ProgerrW :: new (self , 3) }
#[doc = "Bit 4 - Write protected error"]
#[inline (always)] pub fn wrperr (& mut self) -> WrperrW < '_ , SrSpec > { WrperrW :: new (self , 4) }
#[doc = "Bit 5 - Programming alignment error"]
#[inline (always)] pub fn pgaerr (& mut self) -> PgaerrW < '_ , SrSpec > { PgaerrW :: new (self , 5) }
#[doc = "Bit 6 - Size error"]
#[inline (always)] pub fn sizerr (& mut self) -> SizerrW < '_ , SrSpec > { SizerrW :: new (self , 6) }
#[doc = "Bit 7 - Programming sequence error"]
#[inline (always)] pub fn pgserr (& mut self) -> PgserrW < '_ , SrSpec > { PgserrW :: new (self , 7) }
#[doc = "Bit 8 - Fast programming data miss error"]
#[inline (always)] pub fn miserr (& mut self) -> MiserrW < '_ , SrSpec > { MiserrW :: new (self , 8) }
#[doc = "Bit 9 - Fast programming error"]
#[inline (always)] pub fn fasterr (& mut self) -> FasterrW < '_ , SrSpec > { FasterrW :: new (self , 9) }
#[doc = "Bit 14 - PCROP read error"]
#[inline (always)] pub fn rderr (& mut self) -> RderrW < '_ , SrSpec > { RderrW :: new (self , 14) }
#[doc = "Bit 15 - Option validity error"]
#[inline (always)] pub fn optverr (& mut self) -> OptverrW < '_ , SrSpec > { OptverrW :: new (self , 15) } }
#[doc = "Status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "CR (rw) register accessor: Flash control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "Flash control register"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `PG` reader - Programming"] pub type PgR = crate :: BitReader ;
#[doc = "Field `PG` writer - Programming"] pub type PgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PER` reader - Page erase"] pub type PerR = crate :: BitReader ;
#[doc = "Field `PER` writer - Page erase"] pub type PerW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MER` reader - This bit triggers the mass erase (all user pages) when set"] pub type MerR = crate :: BitReader ;
#[doc = "Field `MER` writer - This bit triggers the mass erase (all user pages) when set"] pub type MerW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PNB` reader - Page number selection"] pub type PnbR = crate :: FieldReader ;
#[doc = "Field `PNB` writer - Page number selection"] pub type PnbW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `STRT` reader - Start"] pub type StrtR = crate :: BitReader ;
#[doc = "Field `STRT` writer - Start"] pub type StrtW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OPTSTRT` reader - Options modification start"] pub type OptstrtR = crate :: BitReader ;
#[doc = "Field `OPTSTRT` writer - Options modification start"] pub type OptstrtW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FSTPG` reader - Fast programming"] pub type FstpgR = crate :: BitReader ;
#[doc = "Field `FSTPG` writer - Fast programming"] pub type FstpgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EOPIE` reader - End of operation interrupt enable"] pub type EopieR = crate :: BitReader ;
#[doc = "Field `EOPIE` writer - End of operation interrupt enable"] pub type EopieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ERRIE` reader - Error interrupt enable"] pub type ErrieR = crate :: BitReader ;
#[doc = "Field `ERRIE` writer - Error interrupt enable"] pub type ErrieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RDERRIE` reader - PCROP read error interrupt enable"] pub type RderrieR = crate :: BitReader ;
#[doc = "Field `RDERRIE` writer - PCROP read error interrupt enable"] pub type RderrieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OBL_LAUNCH` reader - Force the option byte loading"] pub type OblLaunchR = crate :: BitReader ;
#[doc = "Field `OBL_LAUNCH` writer - Force the option byte loading"] pub type OblLaunchW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OPTLOCK` reader - Options Lock"] pub type OptlockR = crate :: BitReader ;
#[doc = "Field `OPTLOCK` writer - Options Lock"] pub type OptlockW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LOCK` reader - FLASH_CR Lock"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - FLASH_CR Lock"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Programming"]
#[inline (always)] pub fn pg (& self) -> PgR { PgR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Page erase"]
#[inline (always)] pub fn per (& self) -> PerR { PerR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - This bit triggers the mass erase (all user pages) when set"]
#[inline (always)] pub fn mer (& self) -> MerR { MerR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 3:10 - Page number selection"]
#[inline (always)] pub fn pnb (& self) -> PnbR { PnbR :: new (((self . bits >> 3) & 0xff) as u8) }
#[doc = "Bit 16 - Start"]
#[inline (always)] pub fn strt (& self) -> StrtR { StrtR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Options modification start"]
#[inline (always)] pub fn optstrt (& self) -> OptstrtR { OptstrtR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Fast programming"]
#[inline (always)] pub fn fstpg (& self) -> FstpgR { FstpgR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 24 - End of operation interrupt enable"]
#[inline (always)] pub fn eopie (& self) -> EopieR { EopieR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Error interrupt enable"]
#[inline (always)] pub fn errie (& self) -> ErrieR { ErrieR :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - PCROP read error interrupt enable"]
#[inline (always)] pub fn rderrie (& self) -> RderrieR { RderrieR :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Force the option byte loading"]
#[inline (always)] pub fn obl_launch (& self) -> OblLaunchR { OblLaunchR :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 30 - Options Lock"]
#[inline (always)] pub fn optlock (& self) -> OptlockR { OptlockR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - FLASH_CR Lock"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Programming"]
#[inline (always)] pub fn pg (& mut self) -> PgW < '_ , CrSpec > { PgW :: new (self , 0) }
#[doc = "Bit 1 - Page erase"]
#[inline (always)] pub fn per (& mut self) -> PerW < '_ , CrSpec > { PerW :: new (self , 1) }
#[doc = "Bit 2 - This bit triggers the mass erase (all user pages) when set"]
#[inline (always)] pub fn mer (& mut self) -> MerW < '_ , CrSpec > { MerW :: new (self , 2) }
#[doc = "Bits 3:10 - Page number selection"]
#[inline (always)] pub fn pnb (& mut self) -> PnbW < '_ , CrSpec > { PnbW :: new (self , 3) }
#[doc = "Bit 16 - Start"]
#[inline (always)] pub fn strt (& mut self) -> StrtW < '_ , CrSpec > { StrtW :: new (self , 16) }
#[doc = "Bit 17 - Options modification start"]
#[inline (always)] pub fn optstrt (& mut self) -> OptstrtW < '_ , CrSpec > { OptstrtW :: new (self , 17) }
#[doc = "Bit 18 - Fast programming"]
#[inline (always)] pub fn fstpg (& mut self) -> FstpgW < '_ , CrSpec > { FstpgW :: new (self , 18) }
#[doc = "Bit 24 - End of operation interrupt enable"]
#[inline (always)] pub fn eopie (& mut self) -> EopieW < '_ , CrSpec > { EopieW :: new (self , 24) }
#[doc = "Bit 25 - Error interrupt enable"]
#[inline (always)] pub fn errie (& mut self) -> ErrieW < '_ , CrSpec > { ErrieW :: new (self , 25) }
#[doc = "Bit 26 - PCROP read error interrupt enable"]
#[inline (always)] pub fn rderrie (& mut self) -> RderrieW < '_ , CrSpec > { RderrieW :: new (self , 26) }
#[doc = "Bit 27 - Force the option byte loading"]
#[inline (always)] pub fn obl_launch (& mut self) -> OblLaunchW < '_ , CrSpec > { OblLaunchW :: new (self , 27) }
#[doc = "Bit 30 - Options Lock"]
#[inline (always)] pub fn optlock (& mut self) -> OptlockW < '_ , CrSpec > { OptlockW :: new (self , 30) }
#[doc = "Bit 31 - FLASH_CR Lock"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , CrSpec > { LockW :: new (self , 31) } }
#[doc = "Flash control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0xc000_0000"] impl crate :: Resettable for CrSpec { const RESET_VALUE : u32 = 0xc000_0000 ; } }
#[doc = "ECCR (rw) register accessor: Flash ECC register\n\nYou can [`read`](crate::Reg::read) this register and get [`eccr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`eccr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@eccr`] module"]
#[doc (alias = "ECCR")] pub type Eccr = crate :: Reg < eccr :: EccrSpec > ;
#[doc = "Flash ECC register"] pub mod eccr {
#[doc = "Register `ECCR` reader"] pub type R = crate :: R < EccrSpec > ;
#[doc = "Register `ECCR` writer"] pub type W = crate :: W < EccrSpec > ;
#[doc = "Field `ADDR_ECC` reader - ECC fail address"] pub type AddrEccR = crate :: FieldReader < u32 > ;
#[doc = "Field `SYSF_ECC` reader - System Flash ECC fail"] pub type SysfEccR = crate :: BitReader ;
#[doc = "Field `ECCCIE` reader - ECC correction interrupt enable"] pub type EcccieR = crate :: BitReader ;
#[doc = "Field `ECCCIE` writer - ECC correction interrupt enable"] pub type EcccieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CPUID` reader - CPU identification"] pub type CpuidR = crate :: FieldReader ;
#[doc = "Field `ECCC` reader - ECC correction"] pub type EcccR = crate :: BitReader ;
#[doc = "Field `ECCC` writer - ECC correction"] pub type EcccW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ECCD` reader - ECC detection"] pub type EccdR = crate :: BitReader ;
#[doc = "Field `ECCD` writer - ECC detection"] pub type EccdW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:16 - ECC fail address"]
#[inline (always)] pub fn addr_ecc (& self) -> AddrEccR { AddrEccR :: new (self . bits & 0x0001_ffff) }
#[doc = "Bit 20 - System Flash ECC fail"]
#[inline (always)] pub fn sysf_ecc (& self) -> SysfEccR { SysfEccR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 24 - ECC correction interrupt enable"]
#[inline (always)] pub fn ecccie (& self) -> EcccieR { EcccieR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bits 26:28 - CPU identification"]
#[inline (always)] pub fn cpuid (& self) -> CpuidR { CpuidR :: new (((self . bits >> 26) & 7) as u8) }
#[doc = "Bit 30 - ECC correction"]
#[inline (always)] pub fn eccc (& self) -> EcccR { EcccR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - ECC detection"]
#[inline (always)] pub fn eccd (& self) -> EccdR { EccdR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 24 - ECC correction interrupt enable"]
#[inline (always)] pub fn ecccie (& mut self) -> EcccieW < '_ , EccrSpec > { EcccieW :: new (self , 24) }
#[doc = "Bit 30 - ECC correction"]
#[inline (always)] pub fn eccc (& mut self) -> EcccW < '_ , EccrSpec > { EcccW :: new (self , 30) }
#[doc = "Bit 31 - ECC detection"]
#[inline (always)] pub fn eccd (& mut self) -> EccdW < '_ , EccrSpec > { EccdW :: new (self , 31) } }
#[doc = "Flash ECC register\n\nYou can [`read`](crate::Reg::read) this register and get [`eccr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`eccr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct EccrSpec ; impl crate :: RegisterSpec for EccrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`eccr::R`](R) reader structure"] impl crate :: Readable for EccrSpec { }
#[doc = "`write(|w| ..)` method takes [`eccr::W`](W) writer structure"] impl crate :: Writable for EccrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ECCR to value 0"] impl crate :: Resettable for EccrSpec { } }
#[doc = "OPTR (rw) register accessor: Flash option register\n\nYou can [`read`](crate::Reg::read) this register and get [`optr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`optr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@optr`] module"]
#[doc (alias = "OPTR")] pub type Optr = crate :: Reg < optr :: OptrSpec > ;
#[doc = "Flash option register"] pub mod optr {
#[doc = "Register `OPTR` reader"] pub type R = crate :: R < OptrSpec > ;
#[doc = "Register `OPTR` writer"] pub type W = crate :: W < OptrSpec > ;
#[doc = "Field `RDP` reader - Read protection level"] pub type RdpR = crate :: FieldReader ;
#[doc = "Field `RDP` writer - Read protection level"] pub type RdpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `ESE` reader - Security enabled"] pub type EseR = crate :: BitReader ;
#[doc = "Field `ESE` writer - Security enabled"] pub type EseW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BOR_LEV` reader - BOR reset Level"] pub type BorLevR = crate :: FieldReader ;
#[doc = "Field `BOR_LEV` writer - BOR reset Level"] pub type BorLevW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `nRST_STOP` reader - nRST_STOP"] pub type NRstStopR = crate :: BitReader ;
#[doc = "Field `nRST_STOP` writer - nRST_STOP"] pub type NRstStopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `nRST_STDBY` reader - nRST_STDBY"] pub type NRstStdbyR = crate :: BitReader ;
#[doc = "Field `nRST_STDBY` writer - nRST_STDBY"] pub type NRstStdbyW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `nRST_SHDW` reader - nRST_SHDW"] pub type NRstShdwR = crate :: BitReader ;
#[doc = "Field `nRST_SHDW` writer - nRST_SHDW"] pub type NRstShdwW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IDWG_SW` reader - Independent watchdog selection"] pub type IdwgSwR = crate :: BitReader ;
#[doc = "Field `IDWG_SW` writer - Independent watchdog selection"] pub type IdwgSwW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IWDG_STOP` reader - Independent watchdog counter freeze in Stop mode"] pub type IwdgStopR = crate :: BitReader ;
#[doc = "Field `IWDG_STOP` writer - Independent watchdog counter freeze in Stop mode"] pub type IwdgStopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IWDG_STDBY` reader - Independent watchdog counter freeze in Standby mode"] pub type IwdgStdbyR = crate :: BitReader ;
#[doc = "Field `IWDG_STDBY` writer - Independent watchdog counter freeze in Standby mode"] pub type IwdgStdbyW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WWDG_SW` reader - Window watchdog selection"] pub type WwdgSwR = crate :: BitReader ;
#[doc = "Field `WWDG_SW` writer - Window watchdog selection"] pub type WwdgSwW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `nBOOT1` reader - Boot configuration"] pub type NBoot1R = crate :: BitReader ;
#[doc = "Field `nBOOT1` writer - Boot configuration"] pub type NBoot1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SRAM2_PE` reader - SRAM2 parity check enable"] pub type Sram2PeR = crate :: BitReader ;
#[doc = "Field `SRAM2_PE` writer - SRAM2 parity check enable"] pub type Sram2PeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SRAM2_RST` reader - SRAM2 Erase when system reset"] pub type Sram2RstR = crate :: BitReader ;
#[doc = "Field `SRAM2_RST` writer - SRAM2 Erase when system reset"] pub type Sram2RstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `nSWBOOT0` reader - Software Boot0"] pub type NSwboot0R = crate :: BitReader ;
#[doc = "Field `nSWBOOT0` writer - Software Boot0"] pub type NSwboot0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `nBOOT0` reader - nBoot0 option bit"] pub type NBoot0R = crate :: BitReader ;
#[doc = "Field `nBOOT0` writer - nBoot0 option bit"] pub type NBoot0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AGC_TRIM` reader - Radio Automatic Gain Control Trimming"] pub type AgcTrimR = crate :: FieldReader ;
#[doc = "Field `AGC_TRIM` writer - Radio Automatic Gain Control Trimming"] pub type AgcTrimW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:7 - Read protection level"]
#[inline (always)] pub fn rdp (& self) -> RdpR { RdpR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bit 8 - Security enabled"]
#[inline (always)] pub fn ese (& self) -> EseR { EseR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bits 9:11 - BOR reset Level"]
#[inline (always)] pub fn bor_lev (& self) -> BorLevR { BorLevR :: new (((self . bits >> 9) & 7) as u8) }
#[doc = "Bit 12 - nRST_STOP"]
#[inline (always)] pub fn n_rst_stop (& self) -> NRstStopR { NRstStopR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - nRST_STDBY"]
#[inline (always)] pub fn n_rst_stdby (& self) -> NRstStdbyR { NRstStdbyR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - nRST_SHDW"]
#[inline (always)] pub fn n_rst_shdw (& self) -> NRstShdwR { NRstShdwR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 16 - Independent watchdog selection"]
#[inline (always)] pub fn idwg_sw (& self) -> IdwgSwR { IdwgSwR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Independent watchdog counter freeze in Stop mode"]
#[inline (always)] pub fn iwdg_stop (& self) -> IwdgStopR { IwdgStopR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Independent watchdog counter freeze in Standby mode"]
#[inline (always)] pub fn iwdg_stdby (& self) -> IwdgStdbyR { IwdgStdbyR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Window watchdog selection"]
#[inline (always)] pub fn wwdg_sw (& self) -> WwdgSwR { WwdgSwR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 23 - Boot configuration"]
#[inline (always)] pub fn n_boot1 (& self) -> NBoot1R { NBoot1R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - SRAM2 parity check enable"]
#[inline (always)] pub fn sram2_pe (& self) -> Sram2PeR { Sram2PeR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - SRAM2 Erase when system reset"]
#[inline (always)] pub fn sram2_rst (& self) -> Sram2RstR { Sram2RstR :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Software Boot0"]
#[inline (always)] pub fn n_swboot0 (& self) -> NSwboot0R { NSwboot0R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - nBoot0 option bit"]
#[inline (always)] pub fn n_boot0 (& self) -> NBoot0R { NBoot0R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bits 29:31 - Radio Automatic Gain Control Trimming"]
#[inline (always)] pub fn agc_trim (& self) -> AgcTrimR { AgcTrimR :: new (((self . bits >> 29) & 7) as u8) } } impl W {
#[doc = "Bits 0:7 - Read protection level"]
#[inline (always)] pub fn rdp (& mut self) -> RdpW < '_ , OptrSpec > { RdpW :: new (self , 0) }
#[doc = "Bit 8 - Security enabled"]
#[inline (always)] pub fn ese (& mut self) -> EseW < '_ , OptrSpec > { EseW :: new (self , 8) }
#[doc = "Bits 9:11 - BOR reset Level"]
#[inline (always)] pub fn bor_lev (& mut self) -> BorLevW < '_ , OptrSpec > { BorLevW :: new (self , 9) }
#[doc = "Bit 12 - nRST_STOP"]
#[inline (always)] pub fn n_rst_stop (& mut self) -> NRstStopW < '_ , OptrSpec > { NRstStopW :: new (self , 12) }
#[doc = "Bit 13 - nRST_STDBY"]
#[inline (always)] pub fn n_rst_stdby (& mut self) -> NRstStdbyW < '_ , OptrSpec > { NRstStdbyW :: new (self , 13) }
#[doc = "Bit 14 - nRST_SHDW"]
#[inline (always)] pub fn n_rst_shdw (& mut self) -> NRstShdwW < '_ , OptrSpec > { NRstShdwW :: new (self , 14) }
#[doc = "Bit 16 - Independent watchdog selection"]
#[inline (always)] pub fn idwg_sw (& mut self) -> IdwgSwW < '_ , OptrSpec > { IdwgSwW :: new (self , 16) }
#[doc = "Bit 17 - Independent watchdog counter freeze in Stop mode"]
#[inline (always)] pub fn iwdg_stop (& mut self) -> IwdgStopW < '_ , OptrSpec > { IwdgStopW :: new (self , 17) }
#[doc = "Bit 18 - Independent watchdog counter freeze in Standby mode"]
#[inline (always)] pub fn iwdg_stdby (& mut self) -> IwdgStdbyW < '_ , OptrSpec > { IwdgStdbyW :: new (self , 18) }
#[doc = "Bit 19 - Window watchdog selection"]
#[inline (always)] pub fn wwdg_sw (& mut self) -> WwdgSwW < '_ , OptrSpec > { WwdgSwW :: new (self , 19) }
#[doc = "Bit 23 - Boot configuration"]
#[inline (always)] pub fn n_boot1 (& mut self) -> NBoot1W < '_ , OptrSpec > { NBoot1W :: new (self , 23) }
#[doc = "Bit 24 - SRAM2 parity check enable"]
#[inline (always)] pub fn sram2_pe (& mut self) -> Sram2PeW < '_ , OptrSpec > { Sram2PeW :: new (self , 24) }
#[doc = "Bit 25 - SRAM2 Erase when system reset"]
#[inline (always)] pub fn sram2_rst (& mut self) -> Sram2RstW < '_ , OptrSpec > { Sram2RstW :: new (self , 25) }
#[doc = "Bit 26 - Software Boot0"]
#[inline (always)] pub fn n_swboot0 (& mut self) -> NSwboot0W < '_ , OptrSpec > { NSwboot0W :: new (self , 26) }
#[doc = "Bit 27 - nBoot0 option bit"]
#[inline (always)] pub fn n_boot0 (& mut self) -> NBoot0W < '_ , OptrSpec > { NBoot0W :: new (self , 27) }
#[doc = "Bits 29:31 - Radio Automatic Gain Control Trimming"]
#[inline (always)] pub fn agc_trim (& mut self) -> AgcTrimW < '_ , OptrSpec > { AgcTrimW :: new (self , 29) } }
#[doc = "Flash option register\n\nYou can [`read`](crate::Reg::read) this register and get [`optr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`optr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OptrSpec ; impl crate :: RegisterSpec for OptrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`optr::R`](R) reader structure"] impl crate :: Readable for OptrSpec { }
#[doc = "`write(|w| ..)` method takes [`optr::W`](W) writer structure"] impl crate :: Writable for OptrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OPTR to value 0x1070_8000"] impl crate :: Resettable for OptrSpec { const RESET_VALUE : u32 = 0x1070_8000 ; } }
#[doc = "PCROP1ASR (rw) register accessor: Flash Bank 1 PCROP Start address zone A register\n\nYou can [`read`](crate::Reg::read) this register and get [`pcrop1asr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pcrop1asr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pcrop1asr`] module"]
#[doc (alias = "PCROP1ASR")] pub type Pcrop1asr = crate :: Reg < pcrop1asr :: Pcrop1asrSpec > ;
#[doc = "Flash Bank 1 PCROP Start address zone A register"] pub mod pcrop1asr {
#[doc = "Register `PCROP1ASR` reader"] pub type R = crate :: R < Pcrop1asrSpec > ;
#[doc = "Register `PCROP1ASR` writer"] pub type W = crate :: W < Pcrop1asrSpec > ;
#[doc = "Field `PCROP1A_STRT` reader - Bank 1 PCROPQ area start offset"] pub type Pcrop1aStrtR = crate :: FieldReader < u16 > ;
#[doc = "Field `PCROP1A_STRT` writer - Bank 1 PCROPQ area start offset"] pub type Pcrop1aStrtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 9 , u16 > ; impl R {
#[doc = "Bits 0:8 - Bank 1 PCROPQ area start offset"]
#[inline (always)] pub fn pcrop1a_strt (& self) -> Pcrop1aStrtR { Pcrop1aStrtR :: new ((self . bits & 0x01ff) as u16) } } impl W {
#[doc = "Bits 0:8 - Bank 1 PCROPQ area start offset"]
#[inline (always)] pub fn pcrop1a_strt (& mut self) -> Pcrop1aStrtW < '_ , Pcrop1asrSpec > { Pcrop1aStrtW :: new (self , 0) } }
#[doc = "Flash Bank 1 PCROP Start address zone A register\n\nYou can [`read`](crate::Reg::read) this register and get [`pcrop1asr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pcrop1asr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Pcrop1asrSpec ; impl crate :: RegisterSpec for Pcrop1asrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pcrop1asr::R`](R) reader structure"] impl crate :: Readable for Pcrop1asrSpec { }
#[doc = "`write(|w| ..)` method takes [`pcrop1asr::W`](W) writer structure"] impl crate :: Writable for Pcrop1asrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PCROP1ASR to value 0xffff_fe00"] impl crate :: Resettable for Pcrop1asrSpec { const RESET_VALUE : u32 = 0xffff_fe00 ; } }
#[doc = "PCROP1AER (rw) register accessor: Flash Bank 1 PCROP End address zone A register\n\nYou can [`read`](crate::Reg::read) this register and get [`pcrop1aer::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pcrop1aer::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pcrop1aer`] module"]
#[doc (alias = "PCROP1AER")] pub type Pcrop1aer = crate :: Reg < pcrop1aer :: Pcrop1aerSpec > ;
#[doc = "Flash Bank 1 PCROP End address zone A register"] pub mod pcrop1aer {
#[doc = "Register `PCROP1AER` reader"] pub type R = crate :: R < Pcrop1aerSpec > ;
#[doc = "Register `PCROP1AER` writer"] pub type W = crate :: W < Pcrop1aerSpec > ;
#[doc = "Field `PCROP1A_END` reader - Bank 1 PCROP area end offset"] pub type Pcrop1aEndR = crate :: FieldReader < u16 > ;
#[doc = "Field `PCROP1A_END` writer - Bank 1 PCROP area end offset"] pub type Pcrop1aEndW < 'a , REG > = crate :: FieldWriter < 'a , REG , 9 , u16 > ;
#[doc = "Field `PCROP_RDP` reader - PCROP area preserved when RDP level decreased"] pub type PcropRdpR = crate :: BitReader ;
#[doc = "Field `PCROP_RDP` writer - PCROP area preserved when RDP level decreased"] pub type PcropRdpW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:8 - Bank 1 PCROP area end offset"]
#[inline (always)] pub fn pcrop1a_end (& self) -> Pcrop1aEndR { Pcrop1aEndR :: new ((self . bits & 0x01ff) as u16) }
#[doc = "Bit 31 - PCROP area preserved when RDP level decreased"]
#[inline (always)] pub fn pcrop_rdp (& self) -> PcropRdpR { PcropRdpR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:8 - Bank 1 PCROP area end offset"]
#[inline (always)] pub fn pcrop1a_end (& mut self) -> Pcrop1aEndW < '_ , Pcrop1aerSpec > { Pcrop1aEndW :: new (self , 0) }
#[doc = "Bit 31 - PCROP area preserved when RDP level decreased"]
#[inline (always)] pub fn pcrop_rdp (& mut self) -> PcropRdpW < '_ , Pcrop1aerSpec > { PcropRdpW :: new (self , 31) } }
#[doc = "Flash Bank 1 PCROP End address zone A register\n\nYou can [`read`](crate::Reg::read) this register and get [`pcrop1aer::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pcrop1aer::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Pcrop1aerSpec ; impl crate :: RegisterSpec for Pcrop1aerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pcrop1aer::R`](R) reader structure"] impl crate :: Readable for Pcrop1aerSpec { }
#[doc = "`write(|w| ..)` method takes [`pcrop1aer::W`](W) writer structure"] impl crate :: Writable for Pcrop1aerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PCROP1AER to value 0x7fff_fe00"] impl crate :: Resettable for Pcrop1aerSpec { const RESET_VALUE : u32 = 0x7fff_fe00 ; } }
#[doc = "WRP1AR (rw) register accessor: Flash Bank 1 WRP area A address register\n\nYou can [`read`](crate::Reg::read) this register and get [`wrp1ar::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`wrp1ar::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@wrp1ar`] module"]
#[doc (alias = "WRP1AR")] pub type Wrp1ar = crate :: Reg < wrp1ar :: Wrp1arSpec > ;
#[doc = "Flash Bank 1 WRP area A address register"] pub mod wrp1ar {
#[doc = "Register `WRP1AR` reader"] pub type R = crate :: R < Wrp1arSpec > ;
#[doc = "Register `WRP1AR` writer"] pub type W = crate :: W < Wrp1arSpec > ;
#[doc = "Field `WRP1A_STRT` reader - Bank 1 WRP first area A start offset"] pub type Wrp1aStrtR = crate :: FieldReader ;
#[doc = "Field `WRP1A_STRT` writer - Bank 1 WRP first area A start offset"] pub type Wrp1aStrtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `WRP1A_END` reader - Bank 1 WRP first area A end offset"] pub type Wrp1aEndR = crate :: FieldReader ;
#[doc = "Field `WRP1A_END` writer - Bank 1 WRP first area A end offset"] pub type Wrp1aEndW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - Bank 1 WRP first area A start offset"]
#[inline (always)] pub fn wrp1a_strt (& self) -> Wrp1aStrtR { Wrp1aStrtR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 16:23 - Bank 1 WRP first area A end offset"]
#[inline (always)] pub fn wrp1a_end (& self) -> Wrp1aEndR { Wrp1aEndR :: new (((self . bits >> 16) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - Bank 1 WRP first area A start offset"]
#[inline (always)] pub fn wrp1a_strt (& mut self) -> Wrp1aStrtW < '_ , Wrp1arSpec > { Wrp1aStrtW :: new (self , 0) }
#[doc = "Bits 16:23 - Bank 1 WRP first area A end offset"]
#[inline (always)] pub fn wrp1a_end (& mut self) -> Wrp1aEndW < '_ , Wrp1arSpec > { Wrp1aEndW :: new (self , 16) } }
#[doc = "Flash Bank 1 WRP area A address register\n\nYou can [`read`](crate::Reg::read) this register and get [`wrp1ar::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`wrp1ar::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Wrp1arSpec ; impl crate :: RegisterSpec for Wrp1arSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`wrp1ar::R`](R) reader structure"] impl crate :: Readable for Wrp1arSpec { }
#[doc = "`write(|w| ..)` method takes [`wrp1ar::W`](W) writer structure"] impl crate :: Writable for Wrp1arSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets WRP1AR to value 0xff00_ff00"] impl crate :: Resettable for Wrp1arSpec { const RESET_VALUE : u32 = 0xff00_ff00 ; } }
#[doc = "WRP1BR (rw) register accessor: Flash Bank 1 WRP area B address register\n\nYou can [`read`](crate::Reg::read) this register and get [`wrp1br::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`wrp1br::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@wrp1br`] module"]
#[doc (alias = "WRP1BR")] pub type Wrp1br = crate :: Reg < wrp1br :: Wrp1brSpec > ;
#[doc = "Flash Bank 1 WRP area B address register"] pub mod wrp1br {
#[doc = "Register `WRP1BR` reader"] pub type R = crate :: R < Wrp1brSpec > ;
#[doc = "Register `WRP1BR` writer"] pub type W = crate :: W < Wrp1brSpec > ;
#[doc = "Field `WRP1B_END` reader - Bank 1 WRP second area B start offset"] pub type Wrp1bEndR = crate :: FieldReader ;
#[doc = "Field `WRP1B_END` writer - Bank 1 WRP second area B start offset"] pub type Wrp1bEndW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `WRP1B_STRT` reader - Bank 1 WRP second area B end offset"] pub type Wrp1bStrtR = crate :: FieldReader ;
#[doc = "Field `WRP1B_STRT` writer - Bank 1 WRP second area B end offset"] pub type Wrp1bStrtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - Bank 1 WRP second area B start offset"]
#[inline (always)] pub fn wrp1b_end (& self) -> Wrp1bEndR { Wrp1bEndR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 16:23 - Bank 1 WRP second area B end offset"]
#[inline (always)] pub fn wrp1b_strt (& self) -> Wrp1bStrtR { Wrp1bStrtR :: new (((self . bits >> 16) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - Bank 1 WRP second area B start offset"]
#[inline (always)] pub fn wrp1b_end (& mut self) -> Wrp1bEndW < '_ , Wrp1brSpec > { Wrp1bEndW :: new (self , 0) }
#[doc = "Bits 16:23 - Bank 1 WRP second area B end offset"]
#[inline (always)] pub fn wrp1b_strt (& mut self) -> Wrp1bStrtW < '_ , Wrp1brSpec > { Wrp1bStrtW :: new (self , 16) } }
#[doc = "Flash Bank 1 WRP area B address register\n\nYou can [`read`](crate::Reg::read) this register and get [`wrp1br::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`wrp1br::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Wrp1brSpec ; impl crate :: RegisterSpec for Wrp1brSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`wrp1br::R`](R) reader structure"] impl crate :: Readable for Wrp1brSpec { }
#[doc = "`write(|w| ..)` method takes [`wrp1br::W`](W) writer structure"] impl crate :: Writable for Wrp1brSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets WRP1BR to value 0xff00_ff00"] impl crate :: Resettable for Wrp1brSpec { const RESET_VALUE : u32 = 0xff00_ff00 ; } }
#[doc = "PCROP1BSR (rw) register accessor: Flash Bank 1 PCROP Start address area B register\n\nYou can [`read`](crate::Reg::read) this register and get [`pcrop1bsr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pcrop1bsr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pcrop1bsr`] module"]
#[doc (alias = "PCROP1BSR")] pub type Pcrop1bsr = crate :: Reg < pcrop1bsr :: Pcrop1bsrSpec > ;
#[doc = "Flash Bank 1 PCROP Start address area B register"] pub mod pcrop1bsr {
#[doc = "Register `PCROP1BSR` reader"] pub type R = crate :: R < Pcrop1bsrSpec > ;
#[doc = "Register `PCROP1BSR` writer"] pub type W = crate :: W < Pcrop1bsrSpec > ;
#[doc = "Field `PCROP1B_STRT` reader - Bank 1 PCROP area B start offset"] pub type Pcrop1bStrtR = crate :: FieldReader < u16 > ;
#[doc = "Field `PCROP1B_STRT` writer - Bank 1 PCROP area B start offset"] pub type Pcrop1bStrtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 9 , u16 > ; impl R {
#[doc = "Bits 0:8 - Bank 1 PCROP area B start offset"]
#[inline (always)] pub fn pcrop1b_strt (& self) -> Pcrop1bStrtR { Pcrop1bStrtR :: new ((self . bits & 0x01ff) as u16) } } impl W {
#[doc = "Bits 0:8 - Bank 1 PCROP area B start offset"]
#[inline (always)] pub fn pcrop1b_strt (& mut self) -> Pcrop1bStrtW < '_ , Pcrop1bsrSpec > { Pcrop1bStrtW :: new (self , 0) } }
#[doc = "Flash Bank 1 PCROP Start address area B register\n\nYou can [`read`](crate::Reg::read) this register and get [`pcrop1bsr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pcrop1bsr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Pcrop1bsrSpec ; impl crate :: RegisterSpec for Pcrop1bsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pcrop1bsr::R`](R) reader structure"] impl crate :: Readable for Pcrop1bsrSpec { }
#[doc = "`write(|w| ..)` method takes [`pcrop1bsr::W`](W) writer structure"] impl crate :: Writable for Pcrop1bsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PCROP1BSR to value 0xffff_fe00"] impl crate :: Resettable for Pcrop1bsrSpec { const RESET_VALUE : u32 = 0xffff_fe00 ; } }
#[doc = "PCROP1BER (rw) register accessor: Flash Bank 1 PCROP End address area B register\n\nYou can [`read`](crate::Reg::read) this register and get [`pcrop1ber::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pcrop1ber::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pcrop1ber`] module"]
#[doc (alias = "PCROP1BER")] pub type Pcrop1ber = crate :: Reg < pcrop1ber :: Pcrop1berSpec > ;
#[doc = "Flash Bank 1 PCROP End address area B register"] pub mod pcrop1ber {
#[doc = "Register `PCROP1BER` reader"] pub type R = crate :: R < Pcrop1berSpec > ;
#[doc = "Register `PCROP1BER` writer"] pub type W = crate :: W < Pcrop1berSpec > ;
#[doc = "Field `PCROP1B_END` reader - Bank 1 PCROP area end area B offset"] pub type Pcrop1bEndR = crate :: FieldReader < u16 > ;
#[doc = "Field `PCROP1B_END` writer - Bank 1 PCROP area end area B offset"] pub type Pcrop1bEndW < 'a , REG > = crate :: FieldWriter < 'a , REG , 9 , u16 > ; impl R {
#[doc = "Bits 0:8 - Bank 1 PCROP area end area B offset"]
#[inline (always)] pub fn pcrop1b_end (& self) -> Pcrop1bEndR { Pcrop1bEndR :: new ((self . bits & 0x01ff) as u16) } } impl W {
#[doc = "Bits 0:8 - Bank 1 PCROP area end area B offset"]
#[inline (always)] pub fn pcrop1b_end (& mut self) -> Pcrop1bEndW < '_ , Pcrop1berSpec > { Pcrop1bEndW :: new (self , 0) } }
#[doc = "Flash Bank 1 PCROP End address area B register\n\nYou can [`read`](crate::Reg::read) this register and get [`pcrop1ber::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pcrop1ber::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Pcrop1berSpec ; impl crate :: RegisterSpec for Pcrop1berSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pcrop1ber::R`](R) reader structure"] impl crate :: Readable for Pcrop1berSpec { }
#[doc = "`write(|w| ..)` method takes [`pcrop1ber::W`](W) writer structure"] impl crate :: Writable for Pcrop1berSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PCROP1BER to value 0xffff_fe00"] impl crate :: Resettable for Pcrop1berSpec { const RESET_VALUE : u32 = 0xffff_fe00 ; } }
#[doc = "IPCCBR (rw) register accessor: IPCC mailbox data buffer address register\n\nYou can [`read`](crate::Reg::read) this register and get [`ipccbr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ipccbr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ipccbr`] module"]
#[doc (alias = "IPCCBR")] pub type Ipccbr = crate :: Reg < ipccbr :: IpccbrSpec > ;
#[doc = "IPCC mailbox data buffer address register"] pub mod ipccbr {
#[doc = "Register `IPCCBR` reader"] pub type R = crate :: R < IpccbrSpec > ;
#[doc = "Register `IPCCBR` writer"] pub type W = crate :: W < IpccbrSpec > ;
#[doc = "Field `IPCCDBA` reader - PCC mailbox data buffer base address"] pub type IpccdbaR = crate :: FieldReader < u16 > ;
#[doc = "Field `IPCCDBA` writer - PCC mailbox data buffer base address"] pub type IpccdbaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 14 , u16 > ; impl R {
#[doc = "Bits 0:13 - PCC mailbox data buffer base address"]
#[inline (always)] pub fn ipccdba (& self) -> IpccdbaR { IpccdbaR :: new ((self . bits & 0x3fff) as u16) } } impl W {
#[doc = "Bits 0:13 - PCC mailbox data buffer base address"]
#[inline (always)] pub fn ipccdba (& mut self) -> IpccdbaW < '_ , IpccbrSpec > { IpccdbaW :: new (self , 0) } }
#[doc = "IPCC mailbox data buffer address register\n\nYou can [`read`](crate::Reg::read) this register and get [`ipccbr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ipccbr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IpccbrSpec ; impl crate :: RegisterSpec for IpccbrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ipccbr::R`](R) reader structure"] impl crate :: Readable for IpccbrSpec { }
#[doc = "`write(|w| ..)` method takes [`ipccbr::W`](W) writer structure"] impl crate :: Writable for IpccbrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPCCBR to value 0xffff_c000"] impl crate :: Resettable for IpccbrSpec { const RESET_VALUE : u32 = 0xffff_c000 ; } }
#[doc = "C2ACR (rw) register accessor: CPU2 cortex M0 access control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2acr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2acr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2acr`] module"]
#[doc (alias = "C2ACR")] pub type C2acr = crate :: Reg < c2acr :: C2acrSpec > ;
#[doc = "CPU2 cortex M0 access control register"] pub mod c2acr {
#[doc = "Register `C2ACR` reader"] pub type R = crate :: R < C2acrSpec > ;
#[doc = "Register `C2ACR` writer"] pub type W = crate :: W < C2acrSpec > ;
#[doc = "Field `PRFTEN` reader - CPU2 cortex M0 prefetch enable"] pub type PrftenR = crate :: BitReader ;
#[doc = "Field `PRFTEN` writer - CPU2 cortex M0 prefetch enable"] pub type PrftenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ICEN` reader - CPU2 cortex M0 instruction cache enable"] pub type IcenR = crate :: BitReader ;
#[doc = "Field `ICEN` writer - CPU2 cortex M0 instruction cache enable"] pub type IcenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ICRST` reader - CPU2 cortex M0 instruction cache reset"] pub type IcrstR = crate :: BitReader ;
#[doc = "Field `ICRST` writer - CPU2 cortex M0 instruction cache reset"] pub type IcrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PES` reader - CPU2 cortex M0 program erase suspend request"] pub type PesR = crate :: BitReader ;
#[doc = "Field `PES` writer - CPU2 cortex M0 program erase suspend request"] pub type PesW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 8 - CPU2 cortex M0 prefetch enable"]
#[inline (always)] pub fn prften (& self) -> PrftenR { PrftenR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - CPU2 cortex M0 instruction cache enable"]
#[inline (always)] pub fn icen (& self) -> IcenR { IcenR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 11 - CPU2 cortex M0 instruction cache reset"]
#[inline (always)] pub fn icrst (& self) -> IcrstR { IcrstR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 15 - CPU2 cortex M0 program erase suspend request"]
#[inline (always)] pub fn pes (& self) -> PesR { PesR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 8 - CPU2 cortex M0 prefetch enable"]
#[inline (always)] pub fn prften (& mut self) -> PrftenW < '_ , C2acrSpec > { PrftenW :: new (self , 8) }
#[doc = "Bit 9 - CPU2 cortex M0 instruction cache enable"]
#[inline (always)] pub fn icen (& mut self) -> IcenW < '_ , C2acrSpec > { IcenW :: new (self , 9) }
#[doc = "Bit 11 - CPU2 cortex M0 instruction cache reset"]
#[inline (always)] pub fn icrst (& mut self) -> IcrstW < '_ , C2acrSpec > { IcrstW :: new (self , 11) }
#[doc = "Bit 15 - CPU2 cortex M0 program erase suspend request"]
#[inline (always)] pub fn pes (& mut self) -> PesW < '_ , C2acrSpec > { PesW :: new (self , 15) } }
#[doc = "CPU2 cortex M0 access control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2acr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2acr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2acrSpec ; impl crate :: RegisterSpec for C2acrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2acr::R`](R) reader structure"] impl crate :: Readable for C2acrSpec { }
#[doc = "`write(|w| ..)` method takes [`c2acr::W`](W) writer structure"] impl crate :: Writable for C2acrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2ACR to value 0x0600"] impl crate :: Resettable for C2acrSpec { const RESET_VALUE : u32 = 0x0600 ; } }
#[doc = "C2SR (rw) register accessor: CPU2 cortex M0 status register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2sr`] module"]
#[doc (alias = "C2SR")] pub type C2sr = crate :: Reg < c2sr :: C2srSpec > ;
#[doc = "CPU2 cortex M0 status register"] pub mod c2sr {
#[doc = "Register `C2SR` reader"] pub type R = crate :: R < C2srSpec > ;
#[doc = "Register `C2SR` writer"] pub type W = crate :: W < C2srSpec > ;
#[doc = "Field `EOP` reader - End of operation"] pub type EopR = crate :: BitReader ;
#[doc = "Field `EOP` writer - End of operation"] pub type EopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OPERR` reader - Operation error"] pub type OperrR = crate :: BitReader ;
#[doc = "Field `OPERR` writer - Operation error"] pub type OperrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PROGERR` reader - Programming error"] pub type ProgerrR = crate :: BitReader ;
#[doc = "Field `PROGERR` writer - Programming error"] pub type ProgerrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WRPERR` reader - write protection error"] pub type WrperrR = crate :: BitReader ;
#[doc = "Field `WRPERR` writer - write protection error"] pub type WrperrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PGAERR` reader - Programming alignment error"] pub type PgaerrR = crate :: BitReader ;
#[doc = "Field `PGAERR` writer - Programming alignment error"] pub type PgaerrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SIZERR` reader - Size error"] pub type SizerrR = crate :: BitReader ;
#[doc = "Field `SIZERR` writer - Size error"] pub type SizerrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PGSERR` reader - Programming sequence error"] pub type PgserrR = crate :: BitReader ;
#[doc = "Field `PGSERR` writer - Programming sequence error"] pub type PgserrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MISSERR` reader - Fast programming data miss error"] pub type MisserrR = crate :: BitReader ;
#[doc = "Field `MISSERR` writer - Fast programming data miss error"] pub type MisserrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FASTERR` reader - Fast programming error"] pub type FasterrR = crate :: BitReader ;
#[doc = "Field `FASTERR` writer - Fast programming error"] pub type FasterrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RDERR` reader - PCROP read error"] pub type RderrR = crate :: BitReader ;
#[doc = "Field `RDERR` writer - PCROP read error"] pub type RderrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BSY` reader - Busy"] pub type BsyR = crate :: BitReader ;
#[doc = "Field `BSY` writer - Busy"] pub type BsyW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CFGBSY` reader - Programming or erase configuration busy"] pub type CfgbsyR = crate :: BitReader ;
#[doc = "Field `CFGBSY` writer - Programming or erase configuration busy"] pub type CfgbsyW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PESD` reader - Programming or erase operation suspended"] pub type PesdR = crate :: BitReader ;
#[doc = "Field `PESD` writer - Programming or erase operation suspended"] pub type PesdW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - End of operation"]
#[inline (always)] pub fn eop (& self) -> EopR { EopR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Operation error"]
#[inline (always)] pub fn operr (& self) -> OperrR { OperrR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - Programming error"]
#[inline (always)] pub fn progerr (& self) -> ProgerrR { ProgerrR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - write protection error"]
#[inline (always)] pub fn wrperr (& self) -> WrperrR { WrperrR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Programming alignment error"]
#[inline (always)] pub fn pgaerr (& self) -> PgaerrR { PgaerrR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Size error"]
#[inline (always)] pub fn sizerr (& self) -> SizerrR { SizerrR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Programming sequence error"]
#[inline (always)] pub fn pgserr (& self) -> PgserrR { PgserrR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Fast programming data miss error"]
#[inline (always)] pub fn misserr (& self) -> MisserrR { MisserrR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Fast programming error"]
#[inline (always)] pub fn fasterr (& self) -> FasterrR { FasterrR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 14 - PCROP read error"]
#[inline (always)] pub fn rderr (& self) -> RderrR { RderrR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 16 - Busy"]
#[inline (always)] pub fn bsy (& self) -> BsyR { BsyR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 18 - Programming or erase configuration busy"]
#[inline (always)] pub fn cfgbsy (& self) -> CfgbsyR { CfgbsyR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Programming or erase operation suspended"]
#[inline (always)] pub fn pesd (& self) -> PesdR { PesdR :: new (((self . bits >> 19) & 1) != 0) } } impl W {
#[doc = "Bit 0 - End of operation"]
#[inline (always)] pub fn eop (& mut self) -> EopW < '_ , C2srSpec > { EopW :: new (self , 0) }
#[doc = "Bit 1 - Operation error"]
#[inline (always)] pub fn operr (& mut self) -> OperrW < '_ , C2srSpec > { OperrW :: new (self , 1) }
#[doc = "Bit 3 - Programming error"]
#[inline (always)] pub fn progerr (& mut self) -> ProgerrW < '_ , C2srSpec > { ProgerrW :: new (self , 3) }
#[doc = "Bit 4 - write protection error"]
#[inline (always)] pub fn wrperr (& mut self) -> WrperrW < '_ , C2srSpec > { WrperrW :: new (self , 4) }
#[doc = "Bit 5 - Programming alignment error"]
#[inline (always)] pub fn pgaerr (& mut self) -> PgaerrW < '_ , C2srSpec > { PgaerrW :: new (self , 5) }
#[doc = "Bit 6 - Size error"]
#[inline (always)] pub fn sizerr (& mut self) -> SizerrW < '_ , C2srSpec > { SizerrW :: new (self , 6) }
#[doc = "Bit 7 - Programming sequence error"]
#[inline (always)] pub fn pgserr (& mut self) -> PgserrW < '_ , C2srSpec > { PgserrW :: new (self , 7) }
#[doc = "Bit 8 - Fast programming data miss error"]
#[inline (always)] pub fn misserr (& mut self) -> MisserrW < '_ , C2srSpec > { MisserrW :: new (self , 8) }
#[doc = "Bit 9 - Fast programming error"]
#[inline (always)] pub fn fasterr (& mut self) -> FasterrW < '_ , C2srSpec > { FasterrW :: new (self , 9) }
#[doc = "Bit 14 - PCROP read error"]
#[inline (always)] pub fn rderr (& mut self) -> RderrW < '_ , C2srSpec > { RderrW :: new (self , 14) }
#[doc = "Bit 16 - Busy"]
#[inline (always)] pub fn bsy (& mut self) -> BsyW < '_ , C2srSpec > { BsyW :: new (self , 16) }
#[doc = "Bit 18 - Programming or erase configuration busy"]
#[inline (always)] pub fn cfgbsy (& mut self) -> CfgbsyW < '_ , C2srSpec > { CfgbsyW :: new (self , 18) }
#[doc = "Bit 19 - Programming or erase operation suspended"]
#[inline (always)] pub fn pesd (& mut self) -> PesdW < '_ , C2srSpec > { PesdW :: new (self , 19) } }
#[doc = "CPU2 cortex M0 status register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2srSpec ; impl crate :: RegisterSpec for C2srSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2sr::R`](R) reader structure"] impl crate :: Readable for C2srSpec { }
#[doc = "`write(|w| ..)` method takes [`c2sr::W`](W) writer structure"] impl crate :: Writable for C2srSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2SR to value 0"] impl crate :: Resettable for C2srSpec { } }
#[doc = "C2CR (rw) register accessor: CPU2 cortex M0 control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2cr`] module"]
#[doc (alias = "C2CR")] pub type C2cr = crate :: Reg < c2cr :: C2crSpec > ;
#[doc = "CPU2 cortex M0 control register"] pub mod c2cr {
#[doc = "Register `C2CR` reader"] pub type R = crate :: R < C2crSpec > ;
#[doc = "Register `C2CR` writer"] pub type W = crate :: W < C2crSpec > ;
#[doc = "Field `PG` reader - Programming"] pub type PgR = crate :: BitReader ;
#[doc = "Field `PG` writer - Programming"] pub type PgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PER` reader - Page erase"] pub type PerR = crate :: BitReader ;
#[doc = "Field `PER` writer - Page erase"] pub type PerW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MER` reader - Masse erase"] pub type MerR = crate :: BitReader ;
#[doc = "Field `MER` writer - Masse erase"] pub type MerW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PNB` reader - Page Number selection"] pub type PnbR = crate :: FieldReader ;
#[doc = "Field `PNB` writer - Page Number selection"] pub type PnbW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `STRT` reader - Start"] pub type StrtR = crate :: BitReader ;
#[doc = "Field `STRT` writer - Start"] pub type StrtW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FSTPG` reader - Fast programming"] pub type FstpgR = crate :: BitReader ;
#[doc = "Field `FSTPG` writer - Fast programming"] pub type FstpgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EOPIE` reader - End of operation interrupt enable"] pub type EopieR = crate :: BitReader ;
#[doc = "Field `EOPIE` writer - End of operation interrupt enable"] pub type EopieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ERRIE` reader - Error interrupt enable"] pub type ErrieR = crate :: BitReader ;
#[doc = "Field `ERRIE` writer - Error interrupt enable"] pub type ErrieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RDERRIE` reader - PCROP read error interrupt enable"] pub type RderrieR = crate :: BitReader ;
#[doc = "Field `RDERRIE` writer - PCROP read error interrupt enable"] pub type RderrieW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Programming"]
#[inline (always)] pub fn pg (& self) -> PgR { PgR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Page erase"]
#[inline (always)] pub fn per (& self) -> PerR { PerR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Masse erase"]
#[inline (always)] pub fn mer (& self) -> MerR { MerR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 3:10 - Page Number selection"]
#[inline (always)] pub fn pnb (& self) -> PnbR { PnbR :: new (((self . bits >> 3) & 0xff) as u8) }
#[doc = "Bit 16 - Start"]
#[inline (always)] pub fn strt (& self) -> StrtR { StrtR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 18 - Fast programming"]
#[inline (always)] pub fn fstpg (& self) -> FstpgR { FstpgR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 24 - End of operation interrupt enable"]
#[inline (always)] pub fn eopie (& self) -> EopieR { EopieR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Error interrupt enable"]
#[inline (always)] pub fn errie (& self) -> ErrieR { ErrieR :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - PCROP read error interrupt enable"]
#[inline (always)] pub fn rderrie (& self) -> RderrieR { RderrieR :: new (((self . bits >> 26) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Programming"]
#[inline (always)] pub fn pg (& mut self) -> PgW < '_ , C2crSpec > { PgW :: new (self , 0) }
#[doc = "Bit 1 - Page erase"]
#[inline (always)] pub fn per (& mut self) -> PerW < '_ , C2crSpec > { PerW :: new (self , 1) }
#[doc = "Bit 2 - Masse erase"]
#[inline (always)] pub fn mer (& mut self) -> MerW < '_ , C2crSpec > { MerW :: new (self , 2) }
#[doc = "Bits 3:10 - Page Number selection"]
#[inline (always)] pub fn pnb (& mut self) -> PnbW < '_ , C2crSpec > { PnbW :: new (self , 3) }
#[doc = "Bit 16 - Start"]
#[inline (always)] pub fn strt (& mut self) -> StrtW < '_ , C2crSpec > { StrtW :: new (self , 16) }
#[doc = "Bit 18 - Fast programming"]
#[inline (always)] pub fn fstpg (& mut self) -> FstpgW < '_ , C2crSpec > { FstpgW :: new (self , 18) }
#[doc = "Bit 24 - End of operation interrupt enable"]
#[inline (always)] pub fn eopie (& mut self) -> EopieW < '_ , C2crSpec > { EopieW :: new (self , 24) }
#[doc = "Bit 25 - Error interrupt enable"]
#[inline (always)] pub fn errie (& mut self) -> ErrieW < '_ , C2crSpec > { ErrieW :: new (self , 25) }
#[doc = "Bit 26 - PCROP read error interrupt enable"]
#[inline (always)] pub fn rderrie (& mut self) -> RderrieW < '_ , C2crSpec > { RderrieW :: new (self , 26) } }
#[doc = "CPU2 cortex M0 control register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2crSpec ; impl crate :: RegisterSpec for C2crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2cr::R`](R) reader structure"] impl crate :: Readable for C2crSpec { }
#[doc = "`write(|w| ..)` method takes [`c2cr::W`](W) writer structure"] impl crate :: Writable for C2crSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2CR to value 0"] impl crate :: Resettable for C2crSpec { } }
#[doc = "SFR (rw) register accessor: Secure flash start address register\n\nYou can [`read`](crate::Reg::read) this register and get [`sfr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sfr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sfr`] module"]
#[doc (alias = "SFR")] pub type Sfr = crate :: Reg < sfr :: SfrSpec > ;
#[doc = "Secure flash start address register"] pub mod sfr {
#[doc = "Register `SFR` reader"] pub type R = crate :: R < SfrSpec > ;
#[doc = "Register `SFR` writer"] pub type W = crate :: W < SfrSpec > ;
#[doc = "Field `SFSA` reader - Secure flash start address"] pub type SfsaR = crate :: FieldReader ;
#[doc = "Field `SFSA` writer - Secure flash start address"] pub type SfsaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `FSD` reader - Flash security disable"] pub type FsdR = crate :: BitReader ;
#[doc = "Field `FSD` writer - Flash security disable"] pub type FsdW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DDS` reader - Disable Cortex M0 debug access"] pub type DdsR = crate :: BitReader ;
#[doc = "Field `DDS` writer - Disable Cortex M0 debug access"] pub type DdsW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Secure flash start address"]
#[inline (always)] pub fn sfsa (& self) -> SfsaR { SfsaR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bit 8 - Flash security disable"]
#[inline (always)] pub fn fsd (& self) -> FsdR { FsdR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 12 - Disable Cortex M0 debug access"]
#[inline (always)] pub fn dds (& self) -> DdsR { DdsR :: new (((self . bits >> 12) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Secure flash start address"]
#[inline (always)] pub fn sfsa (& mut self) -> SfsaW < '_ , SfrSpec > { SfsaW :: new (self , 0) }
#[doc = "Bit 8 - Flash security disable"]
#[inline (always)] pub fn fsd (& mut self) -> FsdW < '_ , SfrSpec > { FsdW :: new (self , 8) }
#[doc = "Bit 12 - Disable Cortex M0 debug access"]
#[inline (always)] pub fn dds (& mut self) -> DdsW < '_ , SfrSpec > { DdsW :: new (self , 12) } }
#[doc = "Secure flash start address register\n\nYou can [`read`](crate::Reg::read) this register and get [`sfr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sfr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SfrSpec ; impl crate :: RegisterSpec for SfrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sfr::R`](R) reader structure"] impl crate :: Readable for SfrSpec { }
#[doc = "`write(|w| ..)` method takes [`sfr::W`](W) writer structure"] impl crate :: Writable for SfrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SFR to value 0xffff_ee00"] impl crate :: Resettable for SfrSpec { const RESET_VALUE : u32 = 0xffff_ee00 ; } }
#[doc = "SRRVR (rw) register accessor: Secure SRAM2 start address and cortex M0 reset vector register\n\nYou can [`read`](crate::Reg::read) this register and get [`srrvr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`srrvr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@srrvr`] module"]
#[doc (alias = "SRRVR")] pub type Srrvr = crate :: Reg < srrvr :: SrrvrSpec > ;
#[doc = "Secure SRAM2 start address and cortex M0 reset vector register"] pub mod srrvr {
#[doc = "Register `SRRVR` reader"] pub type R = crate :: R < SrrvrSpec > ;
#[doc = "Register `SRRVR` writer"] pub type W = crate :: W < SrrvrSpec > ;
#[doc = "Field `SBRV` reader - cortex M0 access control register"] pub type SbrvR = crate :: FieldReader < u32 > ;
#[doc = "Field `SBRV` writer - cortex M0 access control register"] pub type SbrvW < 'a , REG > = crate :: FieldWriter < 'a , REG , 18 , u32 > ;
#[doc = "Field `SBRSA` reader - Secure backup SRAM2a start address"] pub type SbrsaR = crate :: FieldReader ;
#[doc = "Field `SBRSA` writer - Secure backup SRAM2a start address"] pub type SbrsaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `BRSD` reader - backup SRAM2a security disable"] pub type BrsdR = crate :: BitReader ;
#[doc = "Field `BRSD` writer - backup SRAM2a security disable"] pub type BrsdW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SNBRSA` reader - Secure non backup SRAM2a start address"] pub type SnbrsaR = crate :: FieldReader ;
#[doc = "Field `SNBRSA` writer - Secure non backup SRAM2a start address"] pub type SnbrsaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `NBRSD` reader - non-backup SRAM2b security disable"] pub type NbrsdR = crate :: BitReader ;
#[doc = "Field `NBRSD` writer - non-backup SRAM2b security disable"] pub type NbrsdW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `C2OPT` reader - CPU2 cortex M0 boot reset vector memory selection"] pub type C2optR = crate :: BitReader ;
#[doc = "Field `C2OPT` writer - CPU2 cortex M0 boot reset vector memory selection"] pub type C2optW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:17 - cortex M0 access control register"]
#[inline (always)] pub fn sbrv (& self) -> SbrvR { SbrvR :: new (self . bits & 0x0003_ffff) }
#[doc = "Bits 18:22 - Secure backup SRAM2a start address"]
#[inline (always)] pub fn sbrsa (& self) -> SbrsaR { SbrsaR :: new (((self . bits >> 18) & 0x1f) as u8) }
#[doc = "Bit 23 - backup SRAM2a security disable"]
#[inline (always)] pub fn brsd (& self) -> BrsdR { BrsdR :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bits 25:29 - Secure non backup SRAM2a start address"]
#[inline (always)] pub fn snbrsa (& self) -> SnbrsaR { SnbrsaR :: new (((self . bits >> 25) & 0x1f) as u8) }
#[doc = "Bit 30 - non-backup SRAM2b security disable"]
#[inline (always)] pub fn nbrsd (& self) -> NbrsdR { NbrsdR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - CPU2 cortex M0 boot reset vector memory selection"]
#[inline (always)] pub fn c2opt (& self) -> C2optR { C2optR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:17 - cortex M0 access control register"]
#[inline (always)] pub fn sbrv (& mut self) -> SbrvW < '_ , SrrvrSpec > { SbrvW :: new (self , 0) }
#[doc = "Bits 18:22 - Secure backup SRAM2a start address"]
#[inline (always)] pub fn sbrsa (& mut self) -> SbrsaW < '_ , SrrvrSpec > { SbrsaW :: new (self , 18) }
#[doc = "Bit 23 - backup SRAM2a security disable"]
#[inline (always)] pub fn brsd (& mut self) -> BrsdW < '_ , SrrvrSpec > { BrsdW :: new (self , 23) }
#[doc = "Bits 25:29 - Secure non backup SRAM2a start address"]
#[inline (always)] pub fn snbrsa (& mut self) -> SnbrsaW < '_ , SrrvrSpec > { SnbrsaW :: new (self , 25) }
#[doc = "Bit 30 - non-backup SRAM2b security disable"]
#[inline (always)] pub fn nbrsd (& mut self) -> NbrsdW < '_ , SrrvrSpec > { NbrsdW :: new (self , 30) }
#[doc = "Bit 31 - CPU2 cortex M0 boot reset vector memory selection"]
#[inline (always)] pub fn c2opt (& mut self) -> C2optW < '_ , SrrvrSpec > { C2optW :: new (self , 31) } }
#[doc = "Secure SRAM2 start address and cortex M0 reset vector register\n\nYou can [`read`](crate::Reg::read) this register and get [`srrvr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`srrvr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrrvrSpec ; impl crate :: RegisterSpec for SrrvrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`srrvr::R`](R) reader structure"] impl crate :: Readable for SrrvrSpec { }
#[doc = "`write(|w| ..)` method takes [`srrvr::W`](W) writer structure"] impl crate :: Writable for SrrvrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SRRVR to value 0x0100_0000"] impl crate :: Resettable for SrrvrSpec { const RESET_VALUE : u32 = 0x0100_0000 ; } } }
#[doc = "QuadSPI interface"] pub type Quadspi = crate :: Periph < quadspi :: RegisterBlock , 0xa000_1000 > ; impl core :: fmt :: Debug for Quadspi { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Quadspi") . finish () } }
#[doc = "QuadSPI interface"] pub mod quadspi {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr : Cr , dcr : Dcr , sr : Sr , fcr : Fcr , dlr : Dlr , ccr : Ccr , ar : Ar , abr : Abr , dr : Dr , psmkr : Psmkr , psmar : Psmar , pir : Pir , lptr : Lptr , } impl RegisterBlock {
#[doc = "0x00 - control register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x04 - device configuration register"]
#[inline (always)] pub const fn dcr (& self) -> & Dcr { & self . dcr }
#[doc = "0x08 - status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x0c - flag clear register"]
#[inline (always)] pub const fn fcr (& self) -> & Fcr { & self . fcr }
#[doc = "0x10 - data length register"]
#[inline (always)] pub const fn dlr (& self) -> & Dlr { & self . dlr }
#[doc = "0x14 - communication configuration register"]
#[inline (always)] pub const fn ccr (& self) -> & Ccr { & self . ccr }
#[doc = "0x18 - address register"]
#[inline (always)] pub const fn ar (& self) -> & Ar { & self . ar }
#[doc = "0x1c - ABR"]
#[inline (always)] pub const fn abr (& self) -> & Abr { & self . abr }
#[doc = "0x20 - data register"]
#[inline (always)] pub const fn dr (& self) -> & Dr { & self . dr }
#[doc = "0x24 - polling status mask register"]
#[inline (always)] pub const fn psmkr (& self) -> & Psmkr { & self . psmkr }
#[doc = "0x28 - polling status match register"]
#[inline (always)] pub const fn psmar (& self) -> & Psmar { & self . psmar }
#[doc = "0x2c - polling interval register"]
#[inline (always)] pub const fn pir (& self) -> & Pir { & self . pir }
#[doc = "0x30 - low-power timeout register"]
#[inline (always)] pub const fn lptr (& self) -> & Lptr { & self . lptr } }
#[doc = "CR (rw) register accessor: control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "control register"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `EN` reader - Enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ABORT` reader - Abort request"] pub type AbortR = crate :: BitReader ;
#[doc = "Field `ABORT` writer - Abort request"] pub type AbortW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMAEN` reader - DMA enable"] pub type DmaenR = crate :: BitReader ;
#[doc = "Field `DMAEN` writer - DMA enable"] pub type DmaenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCEN` reader - Timeout counter enable"] pub type TcenR = crate :: BitReader ;
#[doc = "Field `TCEN` writer - Timeout counter enable"] pub type TcenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SSHIFT` reader - Sample shift"] pub type SshiftR = crate :: BitReader ;
#[doc = "Field `SSHIFT` writer - Sample shift"] pub type SshiftW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FTHRES` reader - FIFO threshold level"] pub type FthresR = crate :: FieldReader ;
#[doc = "Field `FTHRES` writer - FIFO threshold level"] pub type FthresW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FTIE` reader - FIFO threshold interrupt enable"] pub type FtieR = crate :: BitReader ;
#[doc = "Field `FTIE` writer - FIFO threshold interrupt enable"] pub type FtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SMIE` reader - Status match interrupt enable"] pub type SmieR = crate :: BitReader ;
#[doc = "Field `SMIE` writer - Status match interrupt enable"] pub type SmieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TOIE` reader - TimeOut interrupt enable"] pub type ToieR = crate :: BitReader ;
#[doc = "Field `TOIE` writer - TimeOut interrupt enable"] pub type ToieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `APMS` reader - Automatic poll mode stop"] pub type ApmsR = crate :: BitReader ;
#[doc = "Field `APMS` writer - Automatic poll mode stop"] pub type ApmsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PMM` reader - Polling match mode"] pub type PmmR = crate :: BitReader ;
#[doc = "Field `PMM` writer - Polling match mode"] pub type PmmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PRESCALER` reader - Clock prescaler"] pub type PrescalerR = crate :: FieldReader ;
#[doc = "Field `PRESCALER` writer - Clock prescaler"] pub type PrescalerW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bit 0 - Enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Abort request"]
#[inline (always)] pub fn abort (& self) -> AbortR { AbortR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - DMA enable"]
#[inline (always)] pub fn dmaen (& self) -> DmaenR { DmaenR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Timeout counter enable"]
#[inline (always)] pub fn tcen (& self) -> TcenR { TcenR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Sample shift"]
#[inline (always)] pub fn sshift (& self) -> SshiftR { SshiftR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bits 8:12 - FIFO threshold level"]
#[inline (always)] pub fn fthres (& self) -> FthresR { FthresR :: new (((self . bits >> 8) & 0x1f) as u8) }
#[doc = "Bit 16 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - FIFO threshold interrupt enable"]
#[inline (always)] pub fn ftie (& self) -> FtieR { FtieR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Status match interrupt enable"]
#[inline (always)] pub fn smie (& self) -> SmieR { SmieR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - TimeOut interrupt enable"]
#[inline (always)] pub fn toie (& self) -> ToieR { ToieR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 22 - Automatic poll mode stop"]
#[inline (always)] pub fn apms (& self) -> ApmsR { ApmsR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Polling match mode"]
#[inline (always)] pub fn pmm (& self) -> PmmR { PmmR :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bits 24:31 - Clock prescaler"]
#[inline (always)] pub fn prescaler (& self) -> PrescalerR { PrescalerR :: new (((self . bits >> 24) & 0xff) as u8) } } impl W {
#[doc = "Bit 0 - Enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , CrSpec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Abort request"]
#[inline (always)] pub fn abort (& mut self) -> AbortW < '_ , CrSpec > { AbortW :: new (self , 1) }
#[doc = "Bit 2 - DMA enable"]
#[inline (always)] pub fn dmaen (& mut self) -> DmaenW < '_ , CrSpec > { DmaenW :: new (self , 2) }
#[doc = "Bit 3 - Timeout counter enable"]
#[inline (always)] pub fn tcen (& mut self) -> TcenW < '_ , CrSpec > { TcenW :: new (self , 3) }
#[doc = "Bit 4 - Sample shift"]
#[inline (always)] pub fn sshift (& mut self) -> SshiftW < '_ , CrSpec > { SshiftW :: new (self , 4) }
#[doc = "Bits 8:12 - FIFO threshold level"]
#[inline (always)] pub fn fthres (& mut self) -> FthresW < '_ , CrSpec > { FthresW :: new (self , 8) }
#[doc = "Bit 16 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , CrSpec > { TeieW :: new (self , 16) }
#[doc = "Bit 17 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , CrSpec > { TcieW :: new (self , 17) }
#[doc = "Bit 18 - FIFO threshold interrupt enable"]
#[inline (always)] pub fn ftie (& mut self) -> FtieW < '_ , CrSpec > { FtieW :: new (self , 18) }
#[doc = "Bit 19 - Status match interrupt enable"]
#[inline (always)] pub fn smie (& mut self) -> SmieW < '_ , CrSpec > { SmieW :: new (self , 19) }
#[doc = "Bit 20 - TimeOut interrupt enable"]
#[inline (always)] pub fn toie (& mut self) -> ToieW < '_ , CrSpec > { ToieW :: new (self , 20) }
#[doc = "Bit 22 - Automatic poll mode stop"]
#[inline (always)] pub fn apms (& mut self) -> ApmsW < '_ , CrSpec > { ApmsW :: new (self , 22) }
#[doc = "Bit 23 - Polling match mode"]
#[inline (always)] pub fn pmm (& mut self) -> PmmW < '_ , CrSpec > { PmmW :: new (self , 23) }
#[doc = "Bits 24:31 - Clock prescaler"]
#[inline (always)] pub fn prescaler (& mut self) -> PrescalerW < '_ , CrSpec > { PrescalerW :: new (self , 24) } }
#[doc = "control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { } }
#[doc = "DCR (rw) register accessor: device configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`dcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dcr`] module"]
#[doc (alias = "DCR")] pub type Dcr = crate :: Reg < dcr :: DcrSpec > ;
#[doc = "device configuration register"] pub mod dcr {
#[doc = "Register `DCR` reader"] pub type R = crate :: R < DcrSpec > ;
#[doc = "Register `DCR` writer"] pub type W = crate :: W < DcrSpec > ;
#[doc = "Field `CKMODE` reader - Mode 0 / mode 3"] pub type CkmodeR = crate :: BitReader ;
#[doc = "Field `CKMODE` writer - Mode 0 / mode 3"] pub type CkmodeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CSHT` reader - Chip select high time"] pub type CshtR = crate :: FieldReader ;
#[doc = "Field `CSHT` writer - Chip select high time"] pub type CshtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `FSIZE` reader - FLASH memory size"] pub type FsizeR = crate :: FieldReader ;
#[doc = "Field `FSIZE` writer - FLASH memory size"] pub type FsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bit 0 - Mode 0 / mode 3"]
#[inline (always)] pub fn ckmode (& self) -> CkmodeR { CkmodeR :: new ((self . bits & 1) != 0) }
#[doc = "Bits 8:10 - Chip select high time"]
#[inline (always)] pub fn csht (& self) -> CshtR { CshtR :: new (((self . bits >> 8) & 7) as u8) }
#[doc = "Bits 16:20 - FLASH memory size"]
#[inline (always)] pub fn fsize (& self) -> FsizeR { FsizeR :: new (((self . bits >> 16) & 0x1f) as u8) } } impl W {
#[doc = "Bit 0 - Mode 0 / mode 3"]
#[inline (always)] pub fn ckmode (& mut self) -> CkmodeW < '_ , DcrSpec > { CkmodeW :: new (self , 0) }
#[doc = "Bits 8:10 - Chip select high time"]
#[inline (always)] pub fn csht (& mut self) -> CshtW < '_ , DcrSpec > { CshtW :: new (self , 8) }
#[doc = "Bits 16:20 - FLASH memory size"]
#[inline (always)] pub fn fsize (& mut self) -> FsizeW < '_ , DcrSpec > { FsizeW :: new (self , 16) } }
#[doc = "device configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`dcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DcrSpec ; impl crate :: RegisterSpec for DcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dcr::R`](R) reader structure"] impl crate :: Readable for DcrSpec { }
#[doc = "`write(|w| ..)` method takes [`dcr::W`](W) writer structure"] impl crate :: Writable for DcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DCR to value 0"] impl crate :: Resettable for DcrSpec { } }
#[doc = "SR (r) register accessor: status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Field `TEF` reader - Transfer error flag"] pub type TefR = crate :: BitReader ;
#[doc = "Field `TCF` reader - Transfer complete flag"] pub type TcfR = crate :: BitReader ;
#[doc = "Field `FTF` reader - FIFO threshold flag"] pub type FtfR = crate :: BitReader ;
#[doc = "Field `SMF` reader - Status match flag"] pub type SmfR = crate :: BitReader ;
#[doc = "Field `TOF` reader - Timeout flag"] pub type TofR = crate :: BitReader ;
#[doc = "Field `BUSY` reader - Busy"] pub type BusyR = crate :: BitReader ;
#[doc = "Field `FLEVEL` reader - FIFO level"] pub type FlevelR = crate :: FieldReader ; impl R {
#[doc = "Bit 0 - Transfer error flag"]
#[inline (always)] pub fn tef (& self) -> TefR { TefR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete flag"]
#[inline (always)] pub fn tcf (& self) -> TcfR { TcfR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - FIFO threshold flag"]
#[inline (always)] pub fn ftf (& self) -> FtfR { FtfR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Status match flag"]
#[inline (always)] pub fn smf (& self) -> SmfR { SmfR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Timeout flag"]
#[inline (always)] pub fn tof (& self) -> TofR { TofR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Busy"]
#[inline (always)] pub fn busy (& self) -> BusyR { BusyR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bits 8:13 - FIFO level"]
#[inline (always)] pub fn flevel (& self) -> FlevelR { FlevelR :: new (((self . bits >> 8) & 0x3f) as u8) } }
#[doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "FCR (rw) register accessor: flag clear register\n\nYou can [`read`](crate::Reg::read) this register and get [`fcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fcr`] module"]
#[doc (alias = "FCR")] pub type Fcr = crate :: Reg < fcr :: FcrSpec > ;
#[doc = "flag clear register"] pub mod fcr {
#[doc = "Register `FCR` reader"] pub type R = crate :: R < FcrSpec > ;
#[doc = "Register `FCR` writer"] pub type W = crate :: W < FcrSpec > ;
#[doc = "Field `CTEF` reader - Clear transfer error flag"] pub type CtefR = crate :: BitReader ;
#[doc = "Field `CTEF` writer - Clear transfer error flag"] pub type CtefW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCF` reader - Clear transfer complete flag"] pub type CtcfR = crate :: BitReader ;
#[doc = "Field `CTCF` writer - Clear transfer complete flag"] pub type CtcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CSMF` reader - Clear status match flag"] pub type CsmfR = crate :: BitReader ;
#[doc = "Field `CSMF` writer - Clear status match flag"] pub type CsmfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTOF` reader - Clear timeout flag"] pub type CtofR = crate :: BitReader ;
#[doc = "Field `CTOF` writer - Clear timeout flag"] pub type CtofW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Clear transfer error flag"]
#[inline (always)] pub fn ctef (& self) -> CtefR { CtefR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Clear transfer complete flag"]
#[inline (always)] pub fn ctcf (& self) -> CtcfR { CtcfR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - Clear status match flag"]
#[inline (always)] pub fn csmf (& self) -> CsmfR { CsmfR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Clear timeout flag"]
#[inline (always)] pub fn ctof (& self) -> CtofR { CtofR :: new (((self . bits >> 4) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Clear transfer error flag"]
#[inline (always)] pub fn ctef (& mut self) -> CtefW < '_ , FcrSpec > { CtefW :: new (self , 0) }
#[doc = "Bit 1 - Clear transfer complete flag"]
#[inline (always)] pub fn ctcf (& mut self) -> CtcfW < '_ , FcrSpec > { CtcfW :: new (self , 1) }
#[doc = "Bit 3 - Clear status match flag"]
#[inline (always)] pub fn csmf (& mut self) -> CsmfW < '_ , FcrSpec > { CsmfW :: new (self , 3) }
#[doc = "Bit 4 - Clear timeout flag"]
#[inline (always)] pub fn ctof (& mut self) -> CtofW < '_ , FcrSpec > { CtofW :: new (self , 4) } }
#[doc = "flag clear register\n\nYou can [`read`](crate::Reg::read) this register and get [`fcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FcrSpec ; impl crate :: RegisterSpec for FcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fcr::R`](R) reader structure"] impl crate :: Readable for FcrSpec { }
#[doc = "`write(|w| ..)` method takes [`fcr::W`](W) writer structure"] impl crate :: Writable for FcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FCR to value 0"] impl crate :: Resettable for FcrSpec { } }
#[doc = "DLR (rw) register accessor: data length register\n\nYou can [`read`](crate::Reg::read) this register and get [`dlr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dlr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dlr`] module"]
#[doc (alias = "DLR")] pub type Dlr = crate :: Reg < dlr :: DlrSpec > ;
#[doc = "data length register"] pub mod dlr {
#[doc = "Register `DLR` reader"] pub type R = crate :: R < DlrSpec > ;
#[doc = "Register `DLR` writer"] pub type W = crate :: W < DlrSpec > ;
#[doc = "Field `DL` reader - Data length"] pub type DlR = crate :: FieldReader < u32 > ;
#[doc = "Field `DL` writer - Data length"] pub type DlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Data length"]
#[inline (always)] pub fn dl (& self) -> DlR { DlR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Data length"]
#[inline (always)] pub fn dl (& mut self) -> DlW < '_ , DlrSpec > { DlW :: new (self , 0) } }
#[doc = "data length register\n\nYou can [`read`](crate::Reg::read) this register and get [`dlr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dlr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DlrSpec ; impl crate :: RegisterSpec for DlrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dlr::R`](R) reader structure"] impl crate :: Readable for DlrSpec { }
#[doc = "`write(|w| ..)` method takes [`dlr::W`](W) writer structure"] impl crate :: Writable for DlrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DLR to value 0"] impl crate :: Resettable for DlrSpec { } }
#[doc = "CCR (rw) register accessor: communication configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr`] module"]
#[doc (alias = "CCR")] pub type Ccr = crate :: Reg < ccr :: CcrSpec > ;
#[doc = "communication configuration register"] pub mod ccr {
#[doc = "Register `CCR` reader"] pub type R = crate :: R < CcrSpec > ;
#[doc = "Register `CCR` writer"] pub type W = crate :: W < CcrSpec > ;
#[doc = "Field `INSTRUCTION` reader - Instruction"] pub type InstructionR = crate :: FieldReader ;
#[doc = "Field `INSTRUCTION` writer - Instruction"] pub type InstructionW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `IMODE` reader - Instruction mode"] pub type ImodeR = crate :: FieldReader ;
#[doc = "Field `IMODE` writer - Instruction mode"] pub type ImodeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ADMODE` reader - Address mode"] pub type AdmodeR = crate :: FieldReader ;
#[doc = "Field `ADMODE` writer - Address mode"] pub type AdmodeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ADSIZE` reader - Address size"] pub type AdsizeR = crate :: FieldReader ;
#[doc = "Field `ADSIZE` writer - Address size"] pub type AdsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ABMODE` reader - Alternate bytes mode"] pub type AbmodeR = crate :: FieldReader ;
#[doc = "Field `ABMODE` writer - Alternate bytes mode"] pub type AbmodeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ABSIZE` reader - Alternate bytes size"] pub type AbsizeR = crate :: FieldReader ;
#[doc = "Field `ABSIZE` writer - Alternate bytes size"] pub type AbsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DCYC` reader - Number of dummy cycles"] pub type DcycR = crate :: FieldReader ;
#[doc = "Field `DCYC` writer - Number of dummy cycles"] pub type DcycW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `DMODE` reader - Data mode"] pub type DmodeR = crate :: FieldReader ;
#[doc = "Field `DMODE` writer - Data mode"] pub type DmodeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `FMODE` reader - Functional mode"] pub type FmodeR = crate :: FieldReader ;
#[doc = "Field `FMODE` writer - Functional mode"] pub type FmodeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SIOO` reader - Send instruction only once mode"] pub type SiooR = crate :: BitReader ;
#[doc = "Field `SIOO` writer - Send instruction only once mode"] pub type SiooW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DDRM` reader - Double data rate mode"] pub type DdrmR = crate :: BitReader ;
#[doc = "Field `DDRM` writer - Double data rate mode"] pub type DdrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Instruction"]
#[inline (always)] pub fn instruction (& self) -> InstructionR { InstructionR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:9 - Instruction mode"]
#[inline (always)] pub fn imode (& self) -> ImodeR { ImodeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Address mode"]
#[inline (always)] pub fn admode (& self) -> AdmodeR { AdmodeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Address size"]
#[inline (always)] pub fn adsize (& self) -> AdsizeR { AdsizeR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bits 14:15 - Alternate bytes mode"]
#[inline (always)] pub fn abmode (& self) -> AbmodeR { AbmodeR :: new (((self . bits >> 14) & 3) as u8) }
#[doc = "Bits 16:17 - Alternate bytes size"]
#[inline (always)] pub fn absize (& self) -> AbsizeR { AbsizeR :: new (((self . bits >> 16) & 3) as u8) }
#[doc = "Bits 18:22 - Number of dummy cycles"]
#[inline (always)] pub fn dcyc (& self) -> DcycR { DcycR :: new (((self . bits >> 18) & 0x1f) as u8) }
#[doc = "Bits 24:25 - Data mode"]
#[inline (always)] pub fn dmode (& self) -> DmodeR { DmodeR :: new (((self . bits >> 24) & 3) as u8) }
#[doc = "Bits 26:27 - Functional mode"]
#[inline (always)] pub fn fmode (& self) -> FmodeR { FmodeR :: new (((self . bits >> 26) & 3) as u8) }
#[doc = "Bit 28 - Send instruction only once mode"]
#[inline (always)] pub fn sioo (& self) -> SiooR { SiooR :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 31 - Double data rate mode"]
#[inline (always)] pub fn ddrm (& self) -> DdrmR { DdrmR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Instruction"]
#[inline (always)] pub fn instruction (& mut self) -> InstructionW < '_ , CcrSpec > { InstructionW :: new (self , 0) }
#[doc = "Bits 8:9 - Instruction mode"]
#[inline (always)] pub fn imode (& mut self) -> ImodeW < '_ , CcrSpec > { ImodeW :: new (self , 8) }
#[doc = "Bits 10:11 - Address mode"]
#[inline (always)] pub fn admode (& mut self) -> AdmodeW < '_ , CcrSpec > { AdmodeW :: new (self , 10) }
#[doc = "Bits 12:13 - Address size"]
#[inline (always)] pub fn adsize (& mut self) -> AdsizeW < '_ , CcrSpec > { AdsizeW :: new (self , 12) }
#[doc = "Bits 14:15 - Alternate bytes mode"]
#[inline (always)] pub fn abmode (& mut self) -> AbmodeW < '_ , CcrSpec > { AbmodeW :: new (self , 14) }
#[doc = "Bits 16:17 - Alternate bytes size"]
#[inline (always)] pub fn absize (& mut self) -> AbsizeW < '_ , CcrSpec > { AbsizeW :: new (self , 16) }
#[doc = "Bits 18:22 - Number of dummy cycles"]
#[inline (always)] pub fn dcyc (& mut self) -> DcycW < '_ , CcrSpec > { DcycW :: new (self , 18) }
#[doc = "Bits 24:25 - Data mode"]
#[inline (always)] pub fn dmode (& mut self) -> DmodeW < '_ , CcrSpec > { DmodeW :: new (self , 24) }
#[doc = "Bits 26:27 - Functional mode"]
#[inline (always)] pub fn fmode (& mut self) -> FmodeW < '_ , CcrSpec > { FmodeW :: new (self , 26) }
#[doc = "Bit 28 - Send instruction only once mode"]
#[inline (always)] pub fn sioo (& mut self) -> SiooW < '_ , CcrSpec > { SiooW :: new (self , 28) }
#[doc = "Bit 31 - Double data rate mode"]
#[inline (always)] pub fn ddrm (& mut self) -> DdrmW < '_ , CcrSpec > { DdrmW :: new (self , 31) } }
#[doc = "communication configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CcrSpec ; impl crate :: RegisterSpec for CcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr::R`](R) reader structure"] impl crate :: Readable for CcrSpec { }
#[doc = "`write(|w| ..)` method takes [`ccr::W`](W) writer structure"] impl crate :: Writable for CcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR to value 0"] impl crate :: Resettable for CcrSpec { } }
#[doc = "AR (rw) register accessor: address register\n\nYou can [`read`](crate::Reg::read) this register and get [`ar::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ar::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ar`] module"]
#[doc (alias = "AR")] pub type Ar = crate :: Reg < ar :: ArSpec > ;
#[doc = "address register"] pub mod ar {
#[doc = "Register `AR` reader"] pub type R = crate :: R < ArSpec > ;
#[doc = "Register `AR` writer"] pub type W = crate :: W < ArSpec > ;
#[doc = "Field `ADDRESS` reader - Address"] pub type AddressR = crate :: FieldReader < u32 > ;
#[doc = "Field `ADDRESS` writer - Address"] pub type AddressW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Address"]
#[inline (always)] pub fn address (& self) -> AddressR { AddressR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Address"]
#[inline (always)] pub fn address (& mut self) -> AddressW < '_ , ArSpec > { AddressW :: new (self , 0) } }
#[doc = "address register\n\nYou can [`read`](crate::Reg::read) this register and get [`ar::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ar::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ArSpec ; impl crate :: RegisterSpec for ArSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ar::R`](R) reader structure"] impl crate :: Readable for ArSpec { }
#[doc = "`write(|w| ..)` method takes [`ar::W`](W) writer structure"] impl crate :: Writable for ArSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AR to value 0"] impl crate :: Resettable for ArSpec { } }
#[doc = "ABR (rw) register accessor: ABR\n\nYou can [`read`](crate::Reg::read) this register and get [`abr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`abr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@abr`] module"]
#[doc (alias = "ABR")] pub type Abr = crate :: Reg < abr :: AbrSpec > ;
#[doc = "ABR"] pub mod abr {
#[doc = "Register `ABR` reader"] pub type R = crate :: R < AbrSpec > ;
#[doc = "Register `ABR` writer"] pub type W = crate :: W < AbrSpec > ;
#[doc = "Field `ALTERNATE` reader - ALTERNATE"] pub type AlternateR = crate :: FieldReader < u32 > ;
#[doc = "Field `ALTERNATE` writer - ALTERNATE"] pub type AlternateW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - ALTERNATE"]
#[inline (always)] pub fn alternate (& self) -> AlternateR { AlternateR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - ALTERNATE"]
#[inline (always)] pub fn alternate (& mut self) -> AlternateW < '_ , AbrSpec > { AlternateW :: new (self , 0) } }
#[doc = "ABR\n\nYou can [`read`](crate::Reg::read) this register and get [`abr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`abr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AbrSpec ; impl crate :: RegisterSpec for AbrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`abr::R`](R) reader structure"] impl crate :: Readable for AbrSpec { }
#[doc = "`write(|w| ..)` method takes [`abr::W`](W) writer structure"] impl crate :: Writable for AbrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ABR to value 0"] impl crate :: Resettable for AbrSpec { } }
#[doc = "DR (rw) register accessor: data register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr`] module"]
#[doc (alias = "DR")] pub type Dr = crate :: Reg < dr :: DrSpec > ;
#[doc = "data register"] pub mod dr {
#[doc = "Register `DR` reader"] pub type R = crate :: R < DrSpec > ;
#[doc = "Register `DR` writer"] pub type W = crate :: W < DrSpec > ;
#[doc = "Field `DATA` reader - Data"] pub type DataR = crate :: FieldReader < u32 > ;
#[doc = "Field `DATA` writer - Data"] pub type DataW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Data"]
#[inline (always)] pub fn data (& self) -> DataR { DataR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Data"]
#[inline (always)] pub fn data (& mut self) -> DataW < '_ , DrSpec > { DataW :: new (self , 0) } }
#[doc = "data register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DrSpec ; impl crate :: RegisterSpec for DrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr::R`](R) reader structure"] impl crate :: Readable for DrSpec { }
#[doc = "`write(|w| ..)` method takes [`dr::W`](W) writer structure"] impl crate :: Writable for DrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR to value 0"] impl crate :: Resettable for DrSpec { } }
#[doc = "PSMKR (rw) register accessor: polling status mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`psmkr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psmkr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@psmkr`] module"]
#[doc (alias = "PSMKR")] pub type Psmkr = crate :: Reg < psmkr :: PsmkrSpec > ;
#[doc = "polling status mask register"] pub mod psmkr {
#[doc = "Register `PSMKR` reader"] pub type R = crate :: R < PsmkrSpec > ;
#[doc = "Register `PSMKR` writer"] pub type W = crate :: W < PsmkrSpec > ;
#[doc = "Field `MASK` reader - Status mask"] pub type MaskR = crate :: FieldReader < u32 > ;
#[doc = "Field `MASK` writer - Status mask"] pub type MaskW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Status mask"]
#[inline (always)] pub fn mask (& self) -> MaskR { MaskR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Status mask"]
#[inline (always)] pub fn mask (& mut self) -> MaskW < '_ , PsmkrSpec > { MaskW :: new (self , 0) } }
#[doc = "polling status mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`psmkr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psmkr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PsmkrSpec ; impl crate :: RegisterSpec for PsmkrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`psmkr::R`](R) reader structure"] impl crate :: Readable for PsmkrSpec { }
#[doc = "`write(|w| ..)` method takes [`psmkr::W`](W) writer structure"] impl crate :: Writable for PsmkrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PSMKR to value 0"] impl crate :: Resettable for PsmkrSpec { } }
#[doc = "PSMAR (rw) register accessor: polling status match register\n\nYou can [`read`](crate::Reg::read) this register and get [`psmar::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psmar::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@psmar`] module"]
#[doc (alias = "PSMAR")] pub type Psmar = crate :: Reg < psmar :: PsmarSpec > ;
#[doc = "polling status match register"] pub mod psmar {
#[doc = "Register `PSMAR` reader"] pub type R = crate :: R < PsmarSpec > ;
#[doc = "Register `PSMAR` writer"] pub type W = crate :: W < PsmarSpec > ;
#[doc = "Field `MATCH` reader - Status match"] pub type MatchR = crate :: FieldReader < u32 > ;
#[doc = "Field `MATCH` writer - Status match"] pub type MatchW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Status match"]
#[inline (always)] pub fn match_ (& self) -> MatchR { MatchR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Status match"]
#[inline (always)] pub fn match_ (& mut self) -> MatchW < '_ , PsmarSpec > { MatchW :: new (self , 0) } }
#[doc = "polling status match register\n\nYou can [`read`](crate::Reg::read) this register and get [`psmar::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psmar::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PsmarSpec ; impl crate :: RegisterSpec for PsmarSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`psmar::R`](R) reader structure"] impl crate :: Readable for PsmarSpec { }
#[doc = "`write(|w| ..)` method takes [`psmar::W`](W) writer structure"] impl crate :: Writable for PsmarSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PSMAR to value 0"] impl crate :: Resettable for PsmarSpec { } }
#[doc = "PIR (rw) register accessor: polling interval register\n\nYou can [`read`](crate::Reg::read) this register and get [`pir::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pir::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pir`] module"]
#[doc (alias = "PIR")] pub type Pir = crate :: Reg < pir :: PirSpec > ;
#[doc = "polling interval register"] pub mod pir {
#[doc = "Register `PIR` reader"] pub type R = crate :: R < PirSpec > ;
#[doc = "Register `PIR` writer"] pub type W = crate :: W < PirSpec > ;
#[doc = "Field `INTERVAL` reader - Polling interval"] pub type IntervalR = crate :: FieldReader < u16 > ;
#[doc = "Field `INTERVAL` writer - Polling interval"] pub type IntervalW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Polling interval"]
#[inline (always)] pub fn interval (& self) -> IntervalR { IntervalR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Polling interval"]
#[inline (always)] pub fn interval (& mut self) -> IntervalW < '_ , PirSpec > { IntervalW :: new (self , 0) } }
#[doc = "polling interval register\n\nYou can [`read`](crate::Reg::read) this register and get [`pir::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pir::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PirSpec ; impl crate :: RegisterSpec for PirSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pir::R`](R) reader structure"] impl crate :: Readable for PirSpec { }
#[doc = "`write(|w| ..)` method takes [`pir::W`](W) writer structure"] impl crate :: Writable for PirSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PIR to value 0"] impl crate :: Resettable for PirSpec { } }
#[doc = "LPTR (rw) register accessor: low-power timeout register\n\nYou can [`read`](crate::Reg::read) this register and get [`lptr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lptr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lptr`] module"]
#[doc (alias = "LPTR")] pub type Lptr = crate :: Reg < lptr :: LptrSpec > ;
#[doc = "low-power timeout register"] pub mod lptr {
#[doc = "Register `LPTR` reader"] pub type R = crate :: R < LptrSpec > ;
#[doc = "Register `LPTR` writer"] pub type W = crate :: W < LptrSpec > ;
#[doc = "Field `TIMEOUT` reader - Timeout period"] pub type TimeoutR = crate :: FieldReader < u16 > ;
#[doc = "Field `TIMEOUT` writer - Timeout period"] pub type TimeoutW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Timeout period"]
#[inline (always)] pub fn timeout (& self) -> TimeoutR { TimeoutR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Timeout period"]
#[inline (always)] pub fn timeout (& mut self) -> TimeoutW < '_ , LptrSpec > { TimeoutW :: new (self , 0) } }
#[doc = "low-power timeout register\n\nYou can [`read`](crate::Reg::read) this register and get [`lptr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lptr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct LptrSpec ; impl crate :: RegisterSpec for LptrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`lptr::R`](R) reader structure"] impl crate :: Readable for LptrSpec { }
#[doc = "`write(|w| ..)` method takes [`lptr::W`](W) writer structure"] impl crate :: Writable for LptrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets LPTR to value 0"] impl crate :: Resettable for LptrSpec { } } }
#[doc = "Reset and clock control"] pub type Rcc = crate :: Periph < rcc :: RegisterBlock , 0x5800_0000 > ; impl core :: fmt :: Debug for Rcc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rcc") . finish () } }
#[doc = "Reset and clock control"] pub mod rcc {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr : Cr , icscr : Icscr , cfgr : Cfgr , pllcfgr : Pllcfgr , pllsai1cfgr : Pllsai1cfgr , _reserved5 : [u8 ; 0x04] , cier : Cier , cifr : Cifr , cicr : Cicr , smpscr : Smpscr , ahb1rstr : Ahb1rstr , ahb2rstr : Ahb2rstr , ahb3rstr : Ahb3rstr , _reserved12 : [u8 ; 0x04] , apb1rstr1 : Apb1rstr1 , apb1rstr2 : Apb1rstr2 , apb2rstr : Apb2rstr , apb3rstr : Apb3rstr , ahb1enr : Ahb1enr , ahb2enr : Ahb2enr , ahb3enr : Ahb3enr , _reserved19 : [u8 ; 0x04] , apb1enr1 : Apb1enr1 , apb1enr2 : Apb1enr2 , apb2enr : Apb2enr , _reserved22 : [u8 ; 0x04] , ahb1smenr : Ahb1smenr , ahb2smenr : Ahb2smenr , ahb3smenr : Ahb3smenr , _reserved25 : [u8 ; 0x04] , apb1smenr1 : Apb1smenr1 , apb1smenr2 : Apb1smenr2 , apb2smenr : Apb2smenr , _reserved28 : [u8 ; 0x04] , ccipr : Ccipr , _reserved29 : [u8 ; 0x04] , bdcr : Bdcr , csr : Csr , crrcr : Crrcr , hsecr : Hsecr , _reserved33 : [u8 ; 0x68] , extcfgr : Extcfgr , _reserved34 : [u8 ; 0x3c] , c2ahb1enr : C2ahb1enr , c2ahb2enr : C2ahb2enr , c2ahb3enr : C2ahb3enr , _reserved37 : [u8 ; 0x04] , c2apb1enr1 : C2apb1enr1 , c2apb1enr2 : C2apb1enr2 , c2apb2enr : C2apb2enr , c2apb3enr : C2apb3enr , c2ahb1smenr : C2ahb1smenr , c2ahb2smenr : C2ahb2smenr , c2ahb3smenr : C2ahb3smenr , _reserved44 : [u8 ; 0x04] , c2apb1smenr1 : C2apb1smenr1 , c2apb1smenr2 : C2apb1smenr2 , c2apb2smenr : C2apb2smenr , c2apb3smenr : C2apb3smenr , } impl RegisterBlock {
#[doc = "0x00 - Clock control register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x04 - Internal clock sources calibration register"]
#[inline (always)] pub const fn icscr (& self) -> & Icscr { & self . icscr }
#[doc = "0x08 - Clock configuration register"]
#[inline (always)] pub const fn cfgr (& self) -> & Cfgr { & self . cfgr }
#[doc = "0x0c - PLLSYS configuration register"]
#[inline (always)] pub const fn pllcfgr (& self) -> & Pllcfgr { & self . pllcfgr }
#[doc = "0x10 - PLLSAI1 configuration register"]
#[inline (always)] pub const fn pllsai1cfgr (& self) -> & Pllsai1cfgr { & self . pllsai1cfgr }
#[doc = "0x18 - Clock interrupt enable register"]
#[inline (always)] pub const fn cier (& self) -> & Cier { & self . cier }
#[doc = "0x1c - Clock interrupt flag register"]
#[inline (always)] pub const fn cifr (& self) -> & Cifr { & self . cifr }
#[doc = "0x20 - Clock interrupt clear register"]
#[inline (always)] pub const fn cicr (& self) -> & Cicr { & self . cicr }
#[doc = "0x24 - Step Down converter control register"]
#[inline (always)] pub const fn smpscr (& self) -> & Smpscr { & self . smpscr }
#[doc = "0x28 - AHB1 peripheral reset register"]
#[inline (always)] pub const fn ahb1rstr (& self) -> & Ahb1rstr { & self . ahb1rstr }
#[doc = "0x2c - AHB2 peripheral reset register"]
#[inline (always)] pub const fn ahb2rstr (& self) -> & Ahb2rstr { & self . ahb2rstr }
#[doc = "0x30 - AHB3 peripheral reset register"]
#[inline (always)] pub const fn ahb3rstr (& self) -> & Ahb3rstr { & self . ahb3rstr }
#[doc = "0x38 - APB1 peripheral reset register 1"]
#[inline (always)] pub const fn apb1rstr1 (& self) -> & Apb1rstr1 { & self . apb1rstr1 }
#[doc = "0x3c - APB1 peripheral reset register 2"]
#[inline (always)] pub const fn apb1rstr2 (& self) -> & Apb1rstr2 { & self . apb1rstr2 }
#[doc = "0x40 - APB2 peripheral reset register"]
#[inline (always)] pub const fn apb2rstr (& self) -> & Apb2rstr { & self . apb2rstr }
#[doc = "0x44 - APB3 peripheral reset register"]
#[inline (always)] pub const fn apb3rstr (& self) -> & Apb3rstr { & self . apb3rstr }
#[doc = "0x48 - AHB1 peripheral clock enable register"]
#[inline (always)] pub const fn ahb1enr (& self) -> & Ahb1enr { & self . ahb1enr }
#[doc = "0x4c - AHB2 peripheral clock enable register"]
#[inline (always)] pub const fn ahb2enr (& self) -> & Ahb2enr { & self . ahb2enr }
#[doc = "0x50 - AHB3 peripheral clock enable register"]
#[inline (always)] pub const fn ahb3enr (& self) -> & Ahb3enr { & self . ahb3enr }
#[doc = "0x58 - APB1ENR1"]
#[inline (always)] pub const fn apb1enr1 (& self) -> & Apb1enr1 { & self . apb1enr1 }
#[doc = "0x5c - APB1 peripheral clock enable register 2"]
#[inline (always)] pub const fn apb1enr2 (& self) -> & Apb1enr2 { & self . apb1enr2 }
#[doc = "0x60 - APB2ENR"]
#[inline (always)] pub const fn apb2enr (& self) -> & Apb2enr { & self . apb2enr }
#[doc = "0x68 - AHB1 peripheral clocks enable in Sleep and Stop modes register"]
#[inline (always)] pub const fn ahb1smenr (& self) -> & Ahb1smenr { & self . ahb1smenr }
#[doc = "0x6c - AHB2 peripheral clocks enable in Sleep and Stop modes register"]
#[inline (always)] pub const fn ahb2smenr (& self) -> & Ahb2smenr { & self . ahb2smenr }
#[doc = "0x70 - AHB3 peripheral clocks enable in Sleep and Stop modes register"]
#[inline (always)] pub const fn ahb3smenr (& self) -> & Ahb3smenr { & self . ahb3smenr }
#[doc = "0x78 - APB1SMENR1"]
#[inline (always)] pub const fn apb1smenr1 (& self) -> & Apb1smenr1 { & self . apb1smenr1 }
#[doc = "0x7c - APB1 peripheral clocks enable in Sleep and Stop modes register 2"]
#[inline (always)] pub const fn apb1smenr2 (& self) -> & Apb1smenr2 { & self . apb1smenr2 }
#[doc = "0x80 - APB2SMENR"]
#[inline (always)] pub const fn apb2smenr (& self) -> & Apb2smenr { & self . apb2smenr }
#[doc = "0x88 - CCIPR"]
#[inline (always)] pub const fn ccipr (& self) -> & Ccipr { & self . ccipr }
#[doc = "0x90 - BDCR"]
#[inline (always)] pub const fn bdcr (& self) -> & Bdcr { & self . bdcr }
#[doc = "0x94 - CSR"]
#[inline (always)] pub const fn csr (& self) -> & Csr { & self . csr }
#[doc = "0x98 - Clock recovery RC register"]
#[inline (always)] pub const fn crrcr (& self) -> & Crrcr { & self . crrcr }
#[doc = "0x9c - Clock HSE register"]
#[inline (always)] pub const fn hsecr (& self) -> & Hsecr { & self . hsecr }
#[doc = "0x108 - Extended clock recovery register"]
#[inline (always)] pub const fn extcfgr (& self) -> & Extcfgr { & self . extcfgr }
#[doc = "0x148 - CPU2 AHB1 peripheral clock enable register"]
#[inline (always)] pub const fn c2ahb1enr (& self) -> & C2ahb1enr { & self . c2ahb1enr }
#[doc = "0x14c - CPU2 AHB2 peripheral clock enable register"]
#[inline (always)] pub const fn c2ahb2enr (& self) -> & C2ahb2enr { & self . c2ahb2enr }
#[doc = "0x150 - CPU2 AHB3 peripheral clock enable register"]
#[inline (always)] pub const fn c2ahb3enr (& self) -> & C2ahb3enr { & self . c2ahb3enr }
#[doc = "0x158 - CPU2 APB1ENR1"]
#[inline (always)] pub const fn c2apb1enr1 (& self) -> & C2apb1enr1 { & self . c2apb1enr1 }
#[doc = "0x15c - CPU2 APB1 peripheral clock enable register 2"]
#[inline (always)] pub const fn c2apb1enr2 (& self) -> & C2apb1enr2 { & self . c2apb1enr2 }
#[doc = "0x160 - CPU2 APB2ENR"]
#[inline (always)] pub const fn c2apb2enr (& self) -> & C2apb2enr { & self . c2apb2enr }
#[doc = "0x164 - CPU2 APB3ENR"]
#[inline (always)] pub const fn c2apb3enr (& self) -> & C2apb3enr { & self . c2apb3enr }
#[doc = "0x168 - CPU2 AHB1 peripheral clocks enable in Sleep and Stop modes register"]
#[inline (always)] pub const fn c2ahb1smenr (& self) -> & C2ahb1smenr { & self . c2ahb1smenr }
#[doc = "0x16c - CPU2 AHB2 peripheral clocks enable in Sleep and Stop modes register"]
#[inline (always)] pub const fn c2ahb2smenr (& self) -> & C2ahb2smenr { & self . c2ahb2smenr }
#[doc = "0x170 - CPU2 AHB3 peripheral clocks enable in Sleep and Stop modes register"]
#[inline (always)] pub const fn c2ahb3smenr (& self) -> & C2ahb3smenr { & self . c2ahb3smenr }
#[doc = "0x178 - CPU2 APB1SMENR1"]
#[inline (always)] pub const fn c2apb1smenr1 (& self) -> & C2apb1smenr1 { & self . c2apb1smenr1 }
#[doc = "0x17c - CPU2 APB1 peripheral clocks enable in Sleep and Stop modes register 2"]
#[inline (always)] pub const fn c2apb1smenr2 (& self) -> & C2apb1smenr2 { & self . c2apb1smenr2 }
#[doc = "0x180 - CPU2 APB2SMENR"]
#[inline (always)] pub const fn c2apb2smenr (& self) -> & C2apb2smenr { & self . c2apb2smenr }
#[doc = "0x184 - CPU2 APB3SMENR"]
#[inline (always)] pub const fn c2apb3smenr (& self) -> & C2apb3smenr { & self . c2apb3smenr } }
#[doc = "CR (rw) register accessor: Clock control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "Clock control register"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `MSION` reader - MSI clock enable"] pub type MsionR = crate :: BitReader ;
#[doc = "Field `MSION` writer - MSI clock enable"] pub type MsionW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MSIRDY` reader - MSI clock ready flag"] pub type MsirdyR = crate :: BitReader ;
#[doc = "Field `MSIPLLEN` reader - MSI clock PLL enable"] pub type MsipllenR = crate :: BitReader ;
#[doc = "Field `MSIPLLEN` writer - MSI clock PLL enable"] pub type MsipllenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MSIRANGE` reader - MSI clock ranges"] pub type MsirangeR = crate :: FieldReader ;
#[doc = "Field `MSIRANGE` writer - MSI clock ranges"] pub type MsirangeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `HSION` reader - HSI clock enabled"] pub type HsionR = crate :: BitReader ;
#[doc = "Field `HSION` writer - HSI clock enabled"] pub type HsionW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSIKERON` reader - HSI always enable for peripheral kernels"] pub type HsikeronR = crate :: BitReader ;
#[doc = "Field `HSIKERON` writer - HSI always enable for peripheral kernels"] pub type HsikeronW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSIRDY` reader - HSI clock ready flag"] pub type HsirdyR = crate :: BitReader ;
#[doc = "Field `HSIASFS` reader - HSI automatic start from Stop"] pub type HsiasfsR = crate :: BitReader ;
#[doc = "Field `HSIASFS` writer - HSI automatic start from Stop"] pub type HsiasfsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSIKERDY` reader - HSI kernel clock ready flag for peripherals requests"] pub type HsikerdyR = crate :: BitReader ;
#[doc = "Field `HSEON` reader - HSE clock enabled"] pub type HseonR = crate :: BitReader ;
#[doc = "Field `HSEON` writer - HSE clock enabled"] pub type HseonW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSERDY` reader - HSE clock ready flag"] pub type HserdyR = crate :: BitReader ;
#[doc = "Field `HSEBYP` reader - HSE crystal oscillator bypass"] pub type HsebypR = crate :: BitReader ;
#[doc = "Field `HSEBYP` writer - HSE crystal oscillator bypass"] pub type HsebypW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CSSON` writer - HSE Clock security system enable"] pub type CssonW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSEPRE` reader - HSE sysclk and PLL M divider prescaler"] pub type HsepreR = crate :: BitReader ;
#[doc = "Field `HSEPRE` writer - HSE sysclk and PLL M divider prescaler"] pub type HsepreW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PLLON` reader - Main PLL enable"] pub type PllonR = crate :: BitReader ;
#[doc = "Field `PLLON` writer - Main PLL enable"] pub type PllonW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PLLRDY` reader - Main PLL clock ready flag"] pub type PllrdyR = crate :: BitReader ;
#[doc = "Field `PLLSAI1ON` reader - SAI1 PLL enable"] pub type Pllsai1onR = crate :: BitReader ;
#[doc = "Field `PLLSAI1ON` writer - SAI1 PLL enable"] pub type Pllsai1onW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PLLSAI1RDY` reader - SAI1 PLL clock ready flag"] pub type Pllsai1rdyR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - MSI clock enable"]
#[inline (always)] pub fn msion (& self) -> MsionR { MsionR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - MSI clock ready flag"]
#[inline (always)] pub fn msirdy (& self) -> MsirdyR { MsirdyR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - MSI clock PLL enable"]
#[inline (always)] pub fn msipllen (& self) -> MsipllenR { MsipllenR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 4:7 - MSI clock ranges"]
#[inline (always)] pub fn msirange (& self) -> MsirangeR { MsirangeR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bit 8 - HSI clock enabled"]
#[inline (always)] pub fn hsion (& self) -> HsionR { HsionR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - HSI always enable for peripheral kernels"]
#[inline (always)] pub fn hsikeron (& self) -> HsikeronR { HsikeronR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - HSI clock ready flag"]
#[inline (always)] pub fn hsirdy (& self) -> HsirdyR { HsirdyR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - HSI automatic start from Stop"]
#[inline (always)] pub fn hsiasfs (& self) -> HsiasfsR { HsiasfsR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - HSI kernel clock ready flag for peripherals requests"]
#[inline (always)] pub fn hsikerdy (& self) -> HsikerdyR { HsikerdyR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 16 - HSE clock enabled"]
#[inline (always)] pub fn hseon (& self) -> HseonR { HseonR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - HSE clock ready flag"]
#[inline (always)] pub fn hserdy (& self) -> HserdyR { HserdyR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - HSE crystal oscillator bypass"]
#[inline (always)] pub fn hsebyp (& self) -> HsebypR { HsebypR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 20 - HSE sysclk and PLL M divider prescaler"]
#[inline (always)] pub fn hsepre (& self) -> HsepreR { HsepreR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 24 - Main PLL enable"]
#[inline (always)] pub fn pllon (& self) -> PllonR { PllonR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Main PLL clock ready flag"]
#[inline (always)] pub fn pllrdy (& self) -> PllrdyR { PllrdyR :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - SAI1 PLL enable"]
#[inline (always)] pub fn pllsai1on (& self) -> Pllsai1onR { Pllsai1onR :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - SAI1 PLL clock ready flag"]
#[inline (always)] pub fn pllsai1rdy (& self) -> Pllsai1rdyR { Pllsai1rdyR :: new (((self . bits >> 27) & 1) != 0) } } impl W {
#[doc = "Bit 0 - MSI clock enable"]
#[inline (always)] pub fn msion (& mut self) -> MsionW < '_ , CrSpec > { MsionW :: new (self , 0) }
#[doc = "Bit 2 - MSI clock PLL enable"]
#[inline (always)] pub fn msipllen (& mut self) -> MsipllenW < '_ , CrSpec > { MsipllenW :: new (self , 2) }
#[doc = "Bits 4:7 - MSI clock ranges"]
#[inline (always)] pub fn msirange (& mut self) -> MsirangeW < '_ , CrSpec > { MsirangeW :: new (self , 4) }
#[doc = "Bit 8 - HSI clock enabled"]
#[inline (always)] pub fn hsion (& mut self) -> HsionW < '_ , CrSpec > { HsionW :: new (self , 8) }
#[doc = "Bit 9 - HSI always enable for peripheral kernels"]
#[inline (always)] pub fn hsikeron (& mut self) -> HsikeronW < '_ , CrSpec > { HsikeronW :: new (self , 9) }
#[doc = "Bit 11 - HSI automatic start from Stop"]
#[inline (always)] pub fn hsiasfs (& mut self) -> HsiasfsW < '_ , CrSpec > { HsiasfsW :: new (self , 11) }
#[doc = "Bit 16 - HSE clock enabled"]
#[inline (always)] pub fn hseon (& mut self) -> HseonW < '_ , CrSpec > { HseonW :: new (self , 16) }
#[doc = "Bit 18 - HSE crystal oscillator bypass"]
#[inline (always)] pub fn hsebyp (& mut self) -> HsebypW < '_ , CrSpec > { HsebypW :: new (self , 18) }
#[doc = "Bit 19 - HSE Clock security system enable"]
#[inline (always)] pub fn csson (& mut self) -> CssonW < '_ , CrSpec > { CssonW :: new (self , 19) }
#[doc = "Bit 20 - HSE sysclk and PLL M divider prescaler"]
#[inline (always)] pub fn hsepre (& mut self) -> HsepreW < '_ , CrSpec > { HsepreW :: new (self , 20) }
#[doc = "Bit 24 - Main PLL enable"]
#[inline (always)] pub fn pllon (& mut self) -> PllonW < '_ , CrSpec > { PllonW :: new (self , 24) }
#[doc = "Bit 26 - SAI1 PLL enable"]
#[inline (always)] pub fn pllsai1on (& mut self) -> Pllsai1onW < '_ , CrSpec > { Pllsai1onW :: new (self , 26) } }
#[doc = "Clock control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0x61"] impl crate :: Resettable for CrSpec { const RESET_VALUE : u32 = 0x61 ; } }
#[doc = "ICSCR (rw) register accessor: Internal clock sources calibration register\n\nYou can [`read`](crate::Reg::read) this register and get [`icscr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icscr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@icscr`] module"]
#[doc (alias = "ICSCR")] pub type Icscr = crate :: Reg < icscr :: IcscrSpec > ;
#[doc = "Internal clock sources calibration register"] pub mod icscr {
#[doc = "Register `ICSCR` reader"] pub type R = crate :: R < IcscrSpec > ;
#[doc = "Register `ICSCR` writer"] pub type W = crate :: W < IcscrSpec > ;
#[doc = "Field `MSICAL` reader - MSI clock calibration"] pub type MsicalR = crate :: FieldReader ;
#[doc = "Field `MSITRIM` reader - MSI clock trimming"] pub type MsitrimR = crate :: FieldReader ;
#[doc = "Field `MSITRIM` writer - MSI clock trimming"] pub type MsitrimW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `HSICAL` reader - HSI clock calibration"] pub type HsicalR = crate :: FieldReader ;
#[doc = "Field `HSITRIM` reader - HSI clock trimming"] pub type HsitrimR = crate :: FieldReader ;
#[doc = "Field `HSITRIM` writer - HSI clock trimming"] pub type HsitrimW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ; impl R {
#[doc = "Bits 0:7 - MSI clock calibration"]
#[inline (always)] pub fn msical (& self) -> MsicalR { MsicalR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - MSI clock trimming"]
#[inline (always)] pub fn msitrim (& self) -> MsitrimR { MsitrimR :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:23 - HSI clock calibration"]
#[inline (always)] pub fn hsical (& self) -> HsicalR { HsicalR :: new (((self . bits >> 16) & 0xff) as u8) }
#[doc = "Bits 24:30 - HSI clock trimming"]
#[inline (always)] pub fn hsitrim (& self) -> HsitrimR { HsitrimR :: new (((self . bits >> 24) & 0x7f) as u8) } } impl W {
#[doc = "Bits 8:15 - MSI clock trimming"]
#[inline (always)] pub fn msitrim (& mut self) -> MsitrimW < '_ , IcscrSpec > { MsitrimW :: new (self , 8) }
#[doc = "Bits 24:30 - HSI clock trimming"]
#[inline (always)] pub fn hsitrim (& mut self) -> HsitrimW < '_ , IcscrSpec > { HsitrimW :: new (self , 24) } }
#[doc = "Internal clock sources calibration register\n\nYou can [`read`](crate::Reg::read) this register and get [`icscr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icscr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IcscrSpec ; impl crate :: RegisterSpec for IcscrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`icscr::R`](R) reader structure"] impl crate :: Readable for IcscrSpec { }
#[doc = "`write(|w| ..)` method takes [`icscr::W`](W) writer structure"] impl crate :: Writable for IcscrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ICSCR to value 0x4000_0000"] impl crate :: Resettable for IcscrSpec { const RESET_VALUE : u32 = 0x4000_0000 ; } }
#[doc = "CFGR (rw) register accessor: Clock configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfgr`] module"]
#[doc (alias = "CFGR")] pub type Cfgr = crate :: Reg < cfgr :: CfgrSpec > ;
#[doc = "Clock configuration register"] pub mod cfgr {
#[doc = "Register `CFGR` reader"] pub type R = crate :: R < CfgrSpec > ;
#[doc = "Register `CFGR` writer"] pub type W = crate :: W < CfgrSpec > ;
#[doc = "Field `SW` reader - System clock switch"] pub type SwR = crate :: FieldReader ;
#[doc = "Field `SW` writer - System clock switch"] pub type SwW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SWS` reader - System clock switch status"] pub type SwsR = crate :: FieldReader ;
#[doc = "Field `HPRE` reader - AHB prescaler"] pub type HpreR = crate :: FieldReader ;
#[doc = "Field `HPRE` writer - AHB prescaler"] pub type HpreW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `PPRE1` reader - PB low-speed prescaler (APB1)"] pub type Ppre1R = crate :: FieldReader ;
#[doc = "Field `PPRE1` writer - PB low-speed prescaler (APB1)"] pub type Ppre1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `PPRE2` reader - APB high-speed prescaler (APB2)"] pub type Ppre2R = crate :: FieldReader ;
#[doc = "Field `PPRE2` writer - APB high-speed prescaler (APB2)"] pub type Ppre2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `STOPWUCK` reader - Wakeup from Stop and CSS backup clock selection"] pub type StopwuckR = crate :: BitReader ;
#[doc = "Field `STOPWUCK` writer - Wakeup from Stop and CSS backup clock selection"] pub type StopwuckW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HPREF` reader - AHB prescaler flag"] pub type HprefR = crate :: BitReader ;
#[doc = "Field `PPRE1F` reader - APB1 prescaler flag"] pub type Ppre1fR = crate :: BitReader ;
#[doc = "Field `PPRE2F` reader - APB2 prescaler flag"] pub type Ppre2fR = crate :: BitReader ;
#[doc = "Field `MCOSEL` reader - Microcontroller clock output"] pub type McoselR = crate :: FieldReader ;
#[doc = "Field `MCOSEL` writer - Microcontroller clock output"] pub type McoselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `MCOPRE` reader - Microcontroller clock output prescaler"] pub type McopreR = crate :: FieldReader ;
#[doc = "Field `MCOPRE` writer - Microcontroller clock output prescaler"] pub type McopreW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:1 - System clock switch"]
#[inline (always)] pub fn sw (& self) -> SwR { SwR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - System clock switch status"]
#[inline (always)] pub fn sws (& self) -> SwsR { SwsR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:7 - AHB prescaler"]
#[inline (always)] pub fn hpre (& self) -> HpreR { HpreR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:10 - PB low-speed prescaler (APB1)"]
#[inline (always)] pub fn ppre1 (& self) -> Ppre1R { Ppre1R :: new (((self . bits >> 8) & 7) as u8) }
#[doc = "Bits 11:13 - APB high-speed prescaler (APB2)"]
#[inline (always)] pub fn ppre2 (& self) -> Ppre2R { Ppre2R :: new (((self . bits >> 11) & 7) as u8) }
#[doc = "Bit 15 - Wakeup from Stop and CSS backup clock selection"]
#[inline (always)] pub fn stopwuck (& self) -> StopwuckR { StopwuckR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - AHB prescaler flag"]
#[inline (always)] pub fn hpref (& self) -> HprefR { HprefR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - APB1 prescaler flag"]
#[inline (always)] pub fn ppre1f (& self) -> Ppre1fR { Ppre1fR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - APB2 prescaler flag"]
#[inline (always)] pub fn ppre2f (& self) -> Ppre2fR { Ppre2fR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bits 24:27 - Microcontroller clock output"]
#[inline (always)] pub fn mcosel (& self) -> McoselR { McoselR :: new (((self . bits >> 24) & 0x0f) as u8) }
#[doc = "Bits 28:30 - Microcontroller clock output prescaler"]
#[inline (always)] pub fn mcopre (& self) -> McopreR { McopreR :: new (((self . bits >> 28) & 7) as u8) } } impl W {
#[doc = "Bits 0:1 - System clock switch"]
#[inline (always)] pub fn sw (& mut self) -> SwW < '_ , CfgrSpec > { SwW :: new (self , 0) }
#[doc = "Bits 4:7 - AHB prescaler"]
#[inline (always)] pub fn hpre (& mut self) -> HpreW < '_ , CfgrSpec > { HpreW :: new (self , 4) }
#[doc = "Bits 8:10 - PB low-speed prescaler (APB1)"]
#[inline (always)] pub fn ppre1 (& mut self) -> Ppre1W < '_ , CfgrSpec > { Ppre1W :: new (self , 8) }
#[doc = "Bits 11:13 - APB high-speed prescaler (APB2)"]
#[inline (always)] pub fn ppre2 (& mut self) -> Ppre2W < '_ , CfgrSpec > { Ppre2W :: new (self , 11) }
#[doc = "Bit 15 - Wakeup from Stop and CSS backup clock selection"]
#[inline (always)] pub fn stopwuck (& mut self) -> StopwuckW < '_ , CfgrSpec > { StopwuckW :: new (self , 15) }
#[doc = "Bits 24:27 - Microcontroller clock output"]
#[inline (always)] pub fn mcosel (& mut self) -> McoselW < '_ , CfgrSpec > { McoselW :: new (self , 24) }
#[doc = "Bits 28:30 - Microcontroller clock output prescaler"]
#[inline (always)] pub fn mcopre (& mut self) -> McopreW < '_ , CfgrSpec > { McopreW :: new (self , 28) } }
#[doc = "Clock configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CfgrSpec ; impl crate :: RegisterSpec for CfgrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cfgr::R`](R) reader structure"] impl crate :: Readable for CfgrSpec { }
#[doc = "`write(|w| ..)` method takes [`cfgr::W`](W) writer structure"] impl crate :: Writable for CfgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CFGR to value 0x0007_0000"] impl crate :: Resettable for CfgrSpec { const RESET_VALUE : u32 = 0x0007_0000 ; } }
#[doc = "PLLCFGR (rw) register accessor: PLLSYS configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`pllcfgr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pllcfgr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pllcfgr`] module"]
#[doc (alias = "PLLCFGR")] pub type Pllcfgr = crate :: Reg < pllcfgr :: PllcfgrSpec > ;
#[doc = "PLLSYS configuration register"] pub mod pllcfgr {
#[doc = "Register `PLLCFGR` reader"] pub type R = crate :: R < PllcfgrSpec > ;
#[doc = "Register `PLLCFGR` writer"] pub type W = crate :: W < PllcfgrSpec > ;
#[doc = "Field `PLLSRC` reader - Main PLL, PLLSAI1 and PLLSAI2 entry clock source"] pub type PllsrcR = crate :: FieldReader ;
#[doc = "Field `PLLSRC` writer - Main PLL, PLLSAI1 and PLLSAI2 entry clock source"] pub type PllsrcW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PLLM` reader - Division factor M for the main PLL and audio PLL (PLLSAI1 and PLLSAI2) input clock"] pub type PllmR = crate :: FieldReader ;
#[doc = "Field `PLLM` writer - Division factor M for the main PLL and audio PLL (PLLSAI1 and PLLSAI2) input clock"] pub type PllmW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `PLLN` reader - Main PLLSYS multiplication factor N"] pub type PllnR = crate :: FieldReader ;
#[doc = "Field `PLLN` writer - Main PLLSYS multiplication factor N"] pub type PllnW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `PLLPEN` reader - Main PLLSYSP output enable"] pub type PllpenR = crate :: BitReader ;
#[doc = "Field `PLLPEN` writer - Main PLLSYSP output enable"] pub type PllpenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PLLP` reader - Main PLL division factor P for PPLSYSSAICLK"] pub type PllpR = crate :: FieldReader ;
#[doc = "Field `PLLP` writer - Main PLL division factor P for PPLSYSSAICLK"] pub type PllpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `PLLQEN` reader - Main PLLSYSQ output enable"] pub type PllqenR = crate :: BitReader ;
#[doc = "Field `PLLQEN` writer - Main PLLSYSQ output enable"] pub type PllqenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PLLQ` reader - Main PLLSYS division factor Q for PLLSYSUSBCLK"] pub type PllqR = crate :: FieldReader ;
#[doc = "Field `PLLQ` writer - Main PLLSYS division factor Q for PLLSYSUSBCLK"] pub type PllqW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `PLLREN` reader - Main PLLSYSR PLLCLK output enable"] pub type PllrenR = crate :: BitReader ;
#[doc = "Field `PLLREN` writer - Main PLLSYSR PLLCLK output enable"] pub type PllrenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PLLR` reader - Main PLLSYS division factor R for SYSCLK (system clock)"] pub type PllrR = crate :: FieldReader ;
#[doc = "Field `PLLR` writer - Main PLLSYS division factor R for SYSCLK (system clock)"] pub type PllrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:1 - Main PLL, PLLSAI1 and PLLSAI2 entry clock source"]
#[inline (always)] pub fn pllsrc (& self) -> PllsrcR { PllsrcR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 4:6 - Division factor M for the main PLL and audio PLL (PLLSAI1 and PLLSAI2) input clock"]
#[inline (always)] pub fn pllm (& self) -> PllmR { PllmR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bits 8:14 - Main PLLSYS multiplication factor N"]
#[inline (always)] pub fn plln (& self) -> PllnR { PllnR :: new (((self . bits >> 8) & 0x7f) as u8) }
#[doc = "Bit 16 - Main PLLSYSP output enable"]
#[inline (always)] pub fn pllpen (& self) -> PllpenR { PllpenR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:21 - Main PLL division factor P for PPLSYSSAICLK"]
#[inline (always)] pub fn pllp (& self) -> PllpR { PllpR :: new (((self . bits >> 17) & 0x1f) as u8) }
#[doc = "Bit 24 - Main PLLSYSQ output enable"]
#[inline (always)] pub fn pllqen (& self) -> PllqenR { PllqenR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bits 25:27 - Main PLLSYS division factor Q for PLLSYSUSBCLK"]
#[inline (always)] pub fn pllq (& self) -> PllqR { PllqR :: new (((self . bits >> 25) & 7) as u8) }
#[doc = "Bit 28 - Main PLLSYSR PLLCLK output enable"]
#[inline (always)] pub fn pllren (& self) -> PllrenR { PllrenR :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bits 29:31 - Main PLLSYS division factor R for SYSCLK (system clock)"]
#[inline (always)] pub fn pllr (& self) -> PllrR { PllrR :: new (((self . bits >> 29) & 7) as u8) } } impl W {
#[doc = "Bits 0:1 - Main PLL, PLLSAI1 and PLLSAI2 entry clock source"]
#[inline (always)] pub fn pllsrc (& mut self) -> PllsrcW < '_ , PllcfgrSpec > { PllsrcW :: new (self , 0) }
#[doc = "Bits 4:6 - Division factor M for the main PLL and audio PLL (PLLSAI1 and PLLSAI2) input clock"]
#[inline (always)] pub fn pllm (& mut self) -> PllmW < '_ , PllcfgrSpec > { PllmW :: new (self , 4) }
#[doc = "Bits 8:14 - Main PLLSYS multiplication factor N"]
#[inline (always)] pub fn plln (& mut self) -> PllnW < '_ , PllcfgrSpec > { PllnW :: new (self , 8) }
#[doc = "Bit 16 - Main PLLSYSP output enable"]
#[inline (always)] pub fn pllpen (& mut self) -> PllpenW < '_ , PllcfgrSpec > { PllpenW :: new (self , 16) }
#[doc = "Bits 17:21 - Main PLL division factor P for PPLSYSSAICLK"]
#[inline (always)] pub fn pllp (& mut self) -> PllpW < '_ , PllcfgrSpec > { PllpW :: new (self , 17) }
#[doc = "Bit 24 - Main PLLSYSQ output enable"]
#[inline (always)] pub fn pllqen (& mut self) -> PllqenW < '_ , PllcfgrSpec > { PllqenW :: new (self , 24) }
#[doc = "Bits 25:27 - Main PLLSYS division factor Q for PLLSYSUSBCLK"]
#[inline (always)] pub fn pllq (& mut self) -> PllqW < '_ , PllcfgrSpec > { PllqW :: new (self , 25) }
#[doc = "Bit 28 - Main PLLSYSR PLLCLK output enable"]
#[inline (always)] pub fn pllren (& mut self) -> PllrenW < '_ , PllcfgrSpec > { PllrenW :: new (self , 28) }
#[doc = "Bits 29:31 - Main PLLSYS division factor R for SYSCLK (system clock)"]
#[inline (always)] pub fn pllr (& mut self) -> PllrW < '_ , PllcfgrSpec > { PllrW :: new (self , 29) } }
#[doc = "PLLSYS configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`pllcfgr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pllcfgr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PllcfgrSpec ; impl crate :: RegisterSpec for PllcfgrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pllcfgr::R`](R) reader structure"] impl crate :: Readable for PllcfgrSpec { }
#[doc = "`write(|w| ..)` method takes [`pllcfgr::W`](W) writer structure"] impl crate :: Writable for PllcfgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PLLCFGR to value 0x2204_0100"] impl crate :: Resettable for PllcfgrSpec { const RESET_VALUE : u32 = 0x2204_0100 ; } }
#[doc = "PLLSAI1CFGR (rw) register accessor: PLLSAI1 configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`pllsai1cfgr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pllsai1cfgr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pllsai1cfgr`] module"]
#[doc (alias = "PLLSAI1CFGR")] pub type Pllsai1cfgr = crate :: Reg < pllsai1cfgr :: Pllsai1cfgrSpec > ;
#[doc = "PLLSAI1 configuration register"] pub mod pllsai1cfgr {
#[doc = "Register `PLLSAI1CFGR` reader"] pub type R = crate :: R < Pllsai1cfgrSpec > ;
#[doc = "Register `PLLSAI1CFGR` writer"] pub type W = crate :: W < Pllsai1cfgrSpec > ;
#[doc = "Field `PLLN` reader - SAIPLL multiplication factor for VCO"] pub type PllnR = crate :: FieldReader ;
#[doc = "Field `PLLN` writer - SAIPLL multiplication factor for VCO"] pub type PllnW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `PLLPEN` reader - SAIPLL PLLSAI1CLK output enable"] pub type PllpenR = crate :: BitReader ;
#[doc = "Field `PLLPEN` writer - SAIPLL PLLSAI1CLK output enable"] pub type PllpenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PLLP` reader - SAI1PLL division factor P for PLLSAICLK (SAI1clock)"] pub type PllpR = crate :: FieldReader ;
#[doc = "Field `PLLP` writer - SAI1PLL division factor P for PLLSAICLK (SAI1clock)"] pub type PllpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `PLLQEN` reader - SAIPLL PLLSAIUSBCLK output enable"] pub type PllqenR = crate :: BitReader ;
#[doc = "Field `PLLQEN` writer - SAIPLL PLLSAIUSBCLK output enable"] pub type PllqenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PLLQ` reader - SAIPLL division factor Q for PLLSAIUSBCLK (48 MHz clock)"] pub type PllqR = crate :: FieldReader ;
#[doc = "Field `PLLQ` writer - SAIPLL division factor Q for PLLSAIUSBCLK (48 MHz clock)"] pub type PllqW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `PLLREN` reader - PLLSAI PLLADC1CLK output enable"] pub type PllrenR = crate :: BitReader ;
#[doc = "Field `PLLREN` writer - PLLSAI PLLADC1CLK output enable"] pub type PllrenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PLLR` reader - PLLSAI division factor R for PLLADC1CLK (ADC clock)"] pub type PllrR = crate :: FieldReader ;
#[doc = "Field `PLLR` writer - PLLSAI division factor R for PLLADC1CLK (ADC clock)"] pub type PllrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 8:14 - SAIPLL multiplication factor for VCO"]
#[inline (always)] pub fn plln (& self) -> PllnR { PllnR :: new (((self . bits >> 8) & 0x7f) as u8) }
#[doc = "Bit 16 - SAIPLL PLLSAI1CLK output enable"]
#[inline (always)] pub fn pllpen (& self) -> PllpenR { PllpenR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:21 - SAI1PLL division factor P for PLLSAICLK (SAI1clock)"]
#[inline (always)] pub fn pllp (& self) -> PllpR { PllpR :: new (((self . bits >> 17) & 0x1f) as u8) }
#[doc = "Bit 24 - SAIPLL PLLSAIUSBCLK output enable"]
#[inline (always)] pub fn pllqen (& self) -> PllqenR { PllqenR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bits 25:27 - SAIPLL division factor Q for PLLSAIUSBCLK (48 MHz clock)"]
#[inline (always)] pub fn pllq (& self) -> PllqR { PllqR :: new (((self . bits >> 25) & 7) as u8) }
#[doc = "Bit 28 - PLLSAI PLLADC1CLK output enable"]
#[inline (always)] pub fn pllren (& self) -> PllrenR { PllrenR :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bits 29:31 - PLLSAI division factor R for PLLADC1CLK (ADC clock)"]
#[inline (always)] pub fn pllr (& self) -> PllrR { PllrR :: new (((self . bits >> 29) & 7) as u8) } } impl W {
#[doc = "Bits 8:14 - SAIPLL multiplication factor for VCO"]
#[inline (always)] pub fn plln (& mut self) -> PllnW < '_ , Pllsai1cfgrSpec > { PllnW :: new (self , 8) }
#[doc = "Bit 16 - SAIPLL PLLSAI1CLK output enable"]
#[inline (always)] pub fn pllpen (& mut self) -> PllpenW < '_ , Pllsai1cfgrSpec > { PllpenW :: new (self , 16) }
#[doc = "Bits 17:21 - SAI1PLL division factor P for PLLSAICLK (SAI1clock)"]
#[inline (always)] pub fn pllp (& mut self) -> PllpW < '_ , Pllsai1cfgrSpec > { PllpW :: new (self , 17) }
#[doc = "Bit 24 - SAIPLL PLLSAIUSBCLK output enable"]
#[inline (always)] pub fn pllqen (& mut self) -> PllqenW < '_ , Pllsai1cfgrSpec > { PllqenW :: new (self , 24) }
#[doc = "Bits 25:27 - SAIPLL division factor Q for PLLSAIUSBCLK (48 MHz clock)"]
#[inline (always)] pub fn pllq (& mut self) -> PllqW < '_ , Pllsai1cfgrSpec > { PllqW :: new (self , 25) }
#[doc = "Bit 28 - PLLSAI PLLADC1CLK output enable"]
#[inline (always)] pub fn pllren (& mut self) -> PllrenW < '_ , Pllsai1cfgrSpec > { PllrenW :: new (self , 28) }
#[doc = "Bits 29:31 - PLLSAI division factor R for PLLADC1CLK (ADC clock)"]
#[inline (always)] pub fn pllr (& mut self) -> PllrW < '_ , Pllsai1cfgrSpec > { PllrW :: new (self , 29) } }
#[doc = "PLLSAI1 configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`pllsai1cfgr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pllsai1cfgr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Pllsai1cfgrSpec ; impl crate :: RegisterSpec for Pllsai1cfgrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pllsai1cfgr::R`](R) reader structure"] impl crate :: Readable for Pllsai1cfgrSpec { }
#[doc = "`write(|w| ..)` method takes [`pllsai1cfgr::W`](W) writer structure"] impl crate :: Writable for Pllsai1cfgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PLLSAI1CFGR to value 0x2204_0100"] impl crate :: Resettable for Pllsai1cfgrSpec { const RESET_VALUE : u32 = 0x2204_0100 ; } }
#[doc = "CIER (rw) register accessor: Clock interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`cier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cier`] module"]
#[doc (alias = "CIER")] pub type Cier = crate :: Reg < cier :: CierSpec > ;
#[doc = "Clock interrupt enable register"] pub mod cier {
#[doc = "Register `CIER` reader"] pub type R = crate :: R < CierSpec > ;
#[doc = "Register `CIER` writer"] pub type W = crate :: W < CierSpec > ;
#[doc = "Field `LSI1RDYIE` reader - LSI1 ready interrupt enable"] pub type Lsi1rdyieR = crate :: BitReader ;
#[doc = "Field `LSI1RDYIE` writer - LSI1 ready interrupt enable"] pub type Lsi1rdyieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSERDYIE` reader - LSE ready interrupt enable"] pub type LserdyieR = crate :: BitReader ;
#[doc = "Field `LSERDYIE` writer - LSE ready interrupt enable"] pub type LserdyieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MSIRDYIE` reader - MSI ready interrupt enable"] pub type MsirdyieR = crate :: BitReader ;
#[doc = "Field `MSIRDYIE` writer - MSI ready interrupt enable"] pub type MsirdyieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSIRDYIE` reader - HSI ready interrupt enable"] pub type HsirdyieR = crate :: BitReader ;
#[doc = "Field `HSIRDYIE` writer - HSI ready interrupt enable"] pub type HsirdyieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSERDYIE` reader - HSE ready interrupt enable"] pub type HserdyieR = crate :: BitReader ;
#[doc = "Field `HSERDYIE` writer - HSE ready interrupt enable"] pub type HserdyieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PLLRDYIE` reader - PLLSYS ready interrupt enable"] pub type PllrdyieR = crate :: BitReader ;
#[doc = "Field `PLLRDYIE` writer - PLLSYS ready interrupt enable"] pub type PllrdyieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PLLSAI1RDYIE` reader - PLLSAI1 ready interrupt enable"] pub type Pllsai1rdyieR = crate :: BitReader ;
#[doc = "Field `PLLSAI1RDYIE` writer - PLLSAI1 ready interrupt enable"] pub type Pllsai1rdyieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSECSSIE` reader - LSE clock security system interrupt enable"] pub type LsecssieR = crate :: BitReader ;
#[doc = "Field `LSECSSIE` writer - LSE clock security system interrupt enable"] pub type LsecssieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSI48RDYIE` reader - HSI48 ready interrupt enable"] pub type Hsi48rdyieR = crate :: BitReader ;
#[doc = "Field `HSI48RDYIE` writer - HSI48 ready interrupt enable"] pub type Hsi48rdyieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSI2RDYIE` reader - LSI2 ready interrupt enable"] pub type Lsi2rdyieR = crate :: BitReader ;
#[doc = "Field `LSI2RDYIE` writer - LSI2 ready interrupt enable"] pub type Lsi2rdyieW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - LSI1 ready interrupt enable"]
#[inline (always)] pub fn lsi1rdyie (& self) -> Lsi1rdyieR { Lsi1rdyieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - LSE ready interrupt enable"]
#[inline (always)] pub fn lserdyie (& self) -> LserdyieR { LserdyieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - MSI ready interrupt enable"]
#[inline (always)] pub fn msirdyie (& self) -> MsirdyieR { MsirdyieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - HSI ready interrupt enable"]
#[inline (always)] pub fn hsirdyie (& self) -> HsirdyieR { HsirdyieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - HSE ready interrupt enable"]
#[inline (always)] pub fn hserdyie (& self) -> HserdyieR { HserdyieR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - PLLSYS ready interrupt enable"]
#[inline (always)] pub fn pllrdyie (& self) -> PllrdyieR { PllrdyieR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - PLLSAI1 ready interrupt enable"]
#[inline (always)] pub fn pllsai1rdyie (& self) -> Pllsai1rdyieR { Pllsai1rdyieR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 9 - LSE clock security system interrupt enable"]
#[inline (always)] pub fn lsecssie (& self) -> LsecssieR { LsecssieR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - HSI48 ready interrupt enable"]
#[inline (always)] pub fn hsi48rdyie (& self) -> Hsi48rdyieR { Hsi48rdyieR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - LSI2 ready interrupt enable"]
#[inline (always)] pub fn lsi2rdyie (& self) -> Lsi2rdyieR { Lsi2rdyieR :: new (((self . bits >> 11) & 1) != 0) } } impl W {
#[doc = "Bit 0 - LSI1 ready interrupt enable"]
#[inline (always)] pub fn lsi1rdyie (& mut self) -> Lsi1rdyieW < '_ , CierSpec > { Lsi1rdyieW :: new (self , 0) }
#[doc = "Bit 1 - LSE ready interrupt enable"]
#[inline (always)] pub fn lserdyie (& mut self) -> LserdyieW < '_ , CierSpec > { LserdyieW :: new (self , 1) }
#[doc = "Bit 2 - MSI ready interrupt enable"]
#[inline (always)] pub fn msirdyie (& mut self) -> MsirdyieW < '_ , CierSpec > { MsirdyieW :: new (self , 2) }
#[doc = "Bit 3 - HSI ready interrupt enable"]
#[inline (always)] pub fn hsirdyie (& mut self) -> HsirdyieW < '_ , CierSpec > { HsirdyieW :: new (self , 3) }
#[doc = "Bit 4 - HSE ready interrupt enable"]
#[inline (always)] pub fn hserdyie (& mut self) -> HserdyieW < '_ , CierSpec > { HserdyieW :: new (self , 4) }
#[doc = "Bit 5 - PLLSYS ready interrupt enable"]
#[inline (always)] pub fn pllrdyie (& mut self) -> PllrdyieW < '_ , CierSpec > { PllrdyieW :: new (self , 5) }
#[doc = "Bit 6 - PLLSAI1 ready interrupt enable"]
#[inline (always)] pub fn pllsai1rdyie (& mut self) -> Pllsai1rdyieW < '_ , CierSpec > { Pllsai1rdyieW :: new (self , 6) }
#[doc = "Bit 9 - LSE clock security system interrupt enable"]
#[inline (always)] pub fn lsecssie (& mut self) -> LsecssieW < '_ , CierSpec > { LsecssieW :: new (self , 9) }
#[doc = "Bit 10 - HSI48 ready interrupt enable"]
#[inline (always)] pub fn hsi48rdyie (& mut self) -> Hsi48rdyieW < '_ , CierSpec > { Hsi48rdyieW :: new (self , 10) }
#[doc = "Bit 11 - LSI2 ready interrupt enable"]
#[inline (always)] pub fn lsi2rdyie (& mut self) -> Lsi2rdyieW < '_ , CierSpec > { Lsi2rdyieW :: new (self , 11) } }
#[doc = "Clock interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`cier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CierSpec ; impl crate :: RegisterSpec for CierSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cier::R`](R) reader structure"] impl crate :: Readable for CierSpec { }
#[doc = "`write(|w| ..)` method takes [`cier::W`](W) writer structure"] impl crate :: Writable for CierSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CIER to value 0"] impl crate :: Resettable for CierSpec { } }
#[doc = "CIFR (r) register accessor: Clock interrupt flag register\n\nYou can [`read`](crate::Reg::read) this register and get [`cifr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cifr`] module"]
#[doc (alias = "CIFR")] pub type Cifr = crate :: Reg < cifr :: CifrSpec > ;
#[doc = "Clock interrupt flag register"] pub mod cifr {
#[doc = "Register `CIFR` reader"] pub type R = crate :: R < CifrSpec > ;
#[doc = "Field `LSI1RDYF` reader - LSI1 ready interrupt flag"] pub type Lsi1rdyfR = crate :: BitReader ;
#[doc = "Field `LSERDYF` reader - LSE ready interrupt flag"] pub type LserdyfR = crate :: BitReader ;
#[doc = "Field `MSIRDYF` reader - MSI ready interrupt flag"] pub type MsirdyfR = crate :: BitReader ;
#[doc = "Field `HSIRDYF` reader - HSI ready interrupt flag"] pub type HsirdyfR = crate :: BitReader ;
#[doc = "Field `HSERDYF` reader - HSE ready interrupt flag"] pub type HserdyfR = crate :: BitReader ;
#[doc = "Field `PLLRDYF` reader - PLL ready interrupt flag"] pub type PllrdyfR = crate :: BitReader ;
#[doc = "Field `PLLSAI1RDYF` reader - PLLSAI1 ready interrupt flag"] pub type Pllsai1rdyfR = crate :: BitReader ;
#[doc = "Field `HSECSSF` reader - HSE Clock security system interrupt flag"] pub type HsecssfR = crate :: BitReader ;
#[doc = "Field `LSECSSF` reader - LSE Clock security system interrupt flag"] pub type LsecssfR = crate :: BitReader ;
#[doc = "Field `HSI48RDYF` reader - HSI48 ready interrupt flag"] pub type Hsi48rdyfR = crate :: BitReader ;
#[doc = "Field `LSI2RDYF` reader - LSI2 ready interrupt flag"] pub type Lsi2rdyfR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - LSI1 ready interrupt flag"]
#[inline (always)] pub fn lsi1rdyf (& self) -> Lsi1rdyfR { Lsi1rdyfR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - LSE ready interrupt flag"]
#[inline (always)] pub fn lserdyf (& self) -> LserdyfR { LserdyfR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - MSI ready interrupt flag"]
#[inline (always)] pub fn msirdyf (& self) -> MsirdyfR { MsirdyfR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - HSI ready interrupt flag"]
#[inline (always)] pub fn hsirdyf (& self) -> HsirdyfR { HsirdyfR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - HSE ready interrupt flag"]
#[inline (always)] pub fn hserdyf (& self) -> HserdyfR { HserdyfR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - PLL ready interrupt flag"]
#[inline (always)] pub fn pllrdyf (& self) -> PllrdyfR { PllrdyfR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - PLLSAI1 ready interrupt flag"]
#[inline (always)] pub fn pllsai1rdyf (& self) -> Pllsai1rdyfR { Pllsai1rdyfR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 8 - HSE Clock security system interrupt flag"]
#[inline (always)] pub fn hsecssf (& self) -> HsecssfR { HsecssfR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - LSE Clock security system interrupt flag"]
#[inline (always)] pub fn lsecssf (& self) -> LsecssfR { LsecssfR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - HSI48 ready interrupt flag"]
#[inline (always)] pub fn hsi48rdyf (& self) -> Hsi48rdyfR { Hsi48rdyfR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - LSI2 ready interrupt flag"]
#[inline (always)] pub fn lsi2rdyf (& self) -> Lsi2rdyfR { Lsi2rdyfR :: new (((self . bits >> 11) & 1) != 0) } }
#[doc = "Clock interrupt flag register\n\nYou can [`read`](crate::Reg::read) this register and get [`cifr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CifrSpec ; impl crate :: RegisterSpec for CifrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cifr::R`](R) reader structure"] impl crate :: Readable for CifrSpec { }
#[doc = "`reset()` method sets CIFR to value 0"] impl crate :: Resettable for CifrSpec { } }
#[doc = "CICR (w) register accessor: Clock interrupt clear register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cicr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cicr`] module"]
#[doc (alias = "CICR")] pub type Cicr = crate :: Reg < cicr :: CicrSpec > ;
#[doc = "Clock interrupt clear register"] pub mod cicr {
#[doc = "Register `CICR` writer"] pub type W = crate :: W < CicrSpec > ;
#[doc = "Field `LSI1RDYC` writer - LSI1 ready interrupt clear"] pub type Lsi1rdycW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSERDYC` writer - LSE ready interrupt clear"] pub type LserdycW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MSIRDYC` writer - MSI ready interrupt clear"] pub type MsirdycW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSIRDYC` writer - HSI ready interrupt clear"] pub type HsirdycW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSERDYC` writer - HSE ready interrupt clear"] pub type HserdycW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PLLRDYC` writer - PLL ready interrupt clear"] pub type PllrdycW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PLLSAI1RDYC` writer - PLLSAI1 ready interrupt clear"] pub type Pllsai1rdycW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSECSSC` writer - HSE Clock security system interrupt clear"] pub type HsecsscW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSECSSC` writer - LSE Clock security system interrupt clear"] pub type LsecsscW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSI48RDYC` writer - HSI48 ready interrupt clear"] pub type Hsi48rdycW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSI2RDYC` writer - LSI2 ready interrupt clear"] pub type Lsi2rdycW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - LSI1 ready interrupt clear"]
#[inline (always)] pub fn lsi1rdyc (& mut self) -> Lsi1rdycW < '_ , CicrSpec > { Lsi1rdycW :: new (self , 0) }
#[doc = "Bit 1 - LSE ready interrupt clear"]
#[inline (always)] pub fn lserdyc (& mut self) -> LserdycW < '_ , CicrSpec > { LserdycW :: new (self , 1) }
#[doc = "Bit 2 - MSI ready interrupt clear"]
#[inline (always)] pub fn msirdyc (& mut self) -> MsirdycW < '_ , CicrSpec > { MsirdycW :: new (self , 2) }
#[doc = "Bit 3 - HSI ready interrupt clear"]
#[inline (always)] pub fn hsirdyc (& mut self) -> HsirdycW < '_ , CicrSpec > { HsirdycW :: new (self , 3) }
#[doc = "Bit 4 - HSE ready interrupt clear"]
#[inline (always)] pub fn hserdyc (& mut self) -> HserdycW < '_ , CicrSpec > { HserdycW :: new (self , 4) }
#[doc = "Bit 5 - PLL ready interrupt clear"]
#[inline (always)] pub fn pllrdyc (& mut self) -> PllrdycW < '_ , CicrSpec > { PllrdycW :: new (self , 5) }
#[doc = "Bit 6 - PLLSAI1 ready interrupt clear"]
#[inline (always)] pub fn pllsai1rdyc (& mut self) -> Pllsai1rdycW < '_ , CicrSpec > { Pllsai1rdycW :: new (self , 6) }
#[doc = "Bit 8 - HSE Clock security system interrupt clear"]
#[inline (always)] pub fn hsecssc (& mut self) -> HsecsscW < '_ , CicrSpec > { HsecsscW :: new (self , 8) }
#[doc = "Bit 9 - LSE Clock security system interrupt clear"]
#[inline (always)] pub fn lsecssc (& mut self) -> LsecsscW < '_ , CicrSpec > { LsecsscW :: new (self , 9) }
#[doc = "Bit 10 - HSI48 ready interrupt clear"]
#[inline (always)] pub fn hsi48rdyc (& mut self) -> Hsi48rdycW < '_ , CicrSpec > { Hsi48rdycW :: new (self , 10) }
#[doc = "Bit 11 - LSI2 ready interrupt clear"]
#[inline (always)] pub fn lsi2rdyc (& mut self) -> Lsi2rdycW < '_ , CicrSpec > { Lsi2rdycW :: new (self , 11) } }
#[doc = "Clock interrupt clear register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cicr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CicrSpec ; impl crate :: RegisterSpec for CicrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`cicr::W`](W) writer structure"] impl crate :: Writable for CicrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CICR to value 0"] impl crate :: Resettable for CicrSpec { } }
#[doc = "SMPSCR (rw) register accessor: Step Down converter control register\n\nYou can [`read`](crate::Reg::read) this register and get [`smpscr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smpscr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@smpscr`] module"]
#[doc (alias = "SMPSCR")] pub type Smpscr = crate :: Reg < smpscr :: SmpscrSpec > ;
#[doc = "Step Down converter control register"] pub mod smpscr {
#[doc = "Register `SMPSCR` reader"] pub type R = crate :: R < SmpscrSpec > ;
#[doc = "Register `SMPSCR` writer"] pub type W = crate :: W < SmpscrSpec > ;
#[doc = "Field `SMPSSEL` reader - Step Down converter clock selection"] pub type SmpsselR = crate :: FieldReader ;
#[doc = "Field `SMPSSEL` writer - Step Down converter clock selection"] pub type SmpsselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SMPSDIV` reader - Step Down converter clock prescaler"] pub type SmpsdivR = crate :: FieldReader ;
#[doc = "Field `SMPSDIV` writer - Step Down converter clock prescaler"] pub type SmpsdivW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SMPSSWS` reader - Step Down converter clock switch status"] pub type SmpsswsR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:1 - Step Down converter clock selection"]
#[inline (always)] pub fn smpssel (& self) -> SmpsselR { SmpsselR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 4:5 - Step Down converter clock prescaler"]
#[inline (always)] pub fn smpsdiv (& self) -> SmpsdivR { SmpsdivR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bits 8:9 - Step Down converter clock switch status"]
#[inline (always)] pub fn smpssws (& self) -> SmpsswsR { SmpsswsR :: new (((self . bits >> 8) & 3) as u8) } } impl W {
#[doc = "Bits 0:1 - Step Down converter clock selection"]
#[inline (always)] pub fn smpssel (& mut self) -> SmpsselW < '_ , SmpscrSpec > { SmpsselW :: new (self , 0) }
#[doc = "Bits 4:5 - Step Down converter clock prescaler"]
#[inline (always)] pub fn smpsdiv (& mut self) -> SmpsdivW < '_ , SmpscrSpec > { SmpsdivW :: new (self , 4) } }
#[doc = "Step Down converter control register\n\nYou can [`read`](crate::Reg::read) this register and get [`smpscr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smpscr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SmpscrSpec ; impl crate :: RegisterSpec for SmpscrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`smpscr::R`](R) reader structure"] impl crate :: Readable for SmpscrSpec { }
#[doc = "`write(|w| ..)` method takes [`smpscr::W`](W) writer structure"] impl crate :: Writable for SmpscrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SMPSCR to value 0x0301"] impl crate :: Resettable for SmpscrSpec { const RESET_VALUE : u32 = 0x0301 ; } }
#[doc = "AHB1RSTR (rw) register accessor: AHB1 peripheral reset register\n\nYou can [`read`](crate::Reg::read) this register and get [`ahb1rstr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ahb1rstr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ahb1rstr`] module"]
#[doc (alias = "AHB1RSTR")] pub type Ahb1rstr = crate :: Reg < ahb1rstr :: Ahb1rstrSpec > ;
#[doc = "AHB1 peripheral reset register"] pub mod ahb1rstr {
#[doc = "Register `AHB1RSTR` reader"] pub type R = crate :: R < Ahb1rstrSpec > ;
#[doc = "Register `AHB1RSTR` writer"] pub type W = crate :: W < Ahb1rstrSpec > ;
#[doc = "Field `DMA1RST` reader - DMA1 reset"] pub type Dma1rstR = crate :: BitReader ;
#[doc = "Field `DMA1RST` writer - DMA1 reset"] pub type Dma1rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMA2RST` reader - DMA2 reset"] pub type Dma2rstR = crate :: BitReader ;
#[doc = "Field `DMA2RST` writer - DMA2 reset"] pub type Dma2rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMAMUXRST` reader - DMAMUX reset"] pub type DmamuxrstR = crate :: BitReader ;
#[doc = "Field `DMAMUXRST` writer - DMAMUX reset"] pub type DmamuxrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CRCRST` reader - CRC reset"] pub type CrcrstR = crate :: BitReader ;
#[doc = "Field `CRCRST` writer - CRC reset"] pub type CrcrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TSCRST` reader - Touch Sensing Controller reset"] pub type TscrstR = crate :: BitReader ;
#[doc = "Field `TSCRST` writer - Touch Sensing Controller reset"] pub type TscrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - DMA1 reset"]
#[inline (always)] pub fn dma1rst (& self) -> Dma1rstR { Dma1rstR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - DMA2 reset"]
#[inline (always)] pub fn dma2rst (& self) -> Dma2rstR { Dma2rstR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - DMAMUX reset"]
#[inline (always)] pub fn dmamuxrst (& self) -> DmamuxrstR { DmamuxrstR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 12 - CRC reset"]
#[inline (always)] pub fn crcrst (& self) -> CrcrstR { CrcrstR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 16 - Touch Sensing Controller reset"]
#[inline (always)] pub fn tscrst (& self) -> TscrstR { TscrstR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bit 0 - DMA1 reset"]
#[inline (always)] pub fn dma1rst (& mut self) -> Dma1rstW < '_ , Ahb1rstrSpec > { Dma1rstW :: new (self , 0) }
#[doc = "Bit 1 - DMA2 reset"]
#[inline (always)] pub fn dma2rst (& mut self) -> Dma2rstW < '_ , Ahb1rstrSpec > { Dma2rstW :: new (self , 1) }
#[doc = "Bit 2 - DMAMUX reset"]
#[inline (always)] pub fn dmamuxrst (& mut self) -> DmamuxrstW < '_ , Ahb1rstrSpec > { DmamuxrstW :: new (self , 2) }
#[doc = "Bit 12 - CRC reset"]
#[inline (always)] pub fn crcrst (& mut self) -> CrcrstW < '_ , Ahb1rstrSpec > { CrcrstW :: new (self , 12) }
#[doc = "Bit 16 - Touch Sensing Controller reset"]
#[inline (always)] pub fn tscrst (& mut self) -> TscrstW < '_ , Ahb1rstrSpec > { TscrstW :: new (self , 16) } }
#[doc = "AHB1 peripheral reset register\n\nYou can [`read`](crate::Reg::read) this register and get [`ahb1rstr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ahb1rstr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ahb1rstrSpec ; impl crate :: RegisterSpec for Ahb1rstrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ahb1rstr::R`](R) reader structure"] impl crate :: Readable for Ahb1rstrSpec { }
#[doc = "`write(|w| ..)` method takes [`ahb1rstr::W`](W) writer structure"] impl crate :: Writable for Ahb1rstrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AHB1RSTR to value 0"] impl crate :: Resettable for Ahb1rstrSpec { } }
#[doc = "AHB2RSTR (rw) register accessor: AHB2 peripheral reset register\n\nYou can [`read`](crate::Reg::read) this register and get [`ahb2rstr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ahb2rstr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ahb2rstr`] module"]
#[doc (alias = "AHB2RSTR")] pub type Ahb2rstr = crate :: Reg < ahb2rstr :: Ahb2rstrSpec > ;
#[doc = "AHB2 peripheral reset register"] pub mod ahb2rstr {
#[doc = "Register `AHB2RSTR` reader"] pub type R = crate :: R < Ahb2rstrSpec > ;
#[doc = "Register `AHB2RSTR` writer"] pub type W = crate :: W < Ahb2rstrSpec > ;
#[doc = "Field `GPIOARST` reader - IO port A reset"] pub type GpioarstR = crate :: BitReader ;
#[doc = "Field `GPIOARST` writer - IO port A reset"] pub type GpioarstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOBRST` reader - IO port B reset"] pub type GpiobrstR = crate :: BitReader ;
#[doc = "Field `GPIOBRST` writer - IO port B reset"] pub type GpiobrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOCRST` reader - IO port C reset"] pub type GpiocrstR = crate :: BitReader ;
#[doc = "Field `GPIOCRST` writer - IO port C reset"] pub type GpiocrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIODRST` reader - IO port D reset"] pub type GpiodrstR = crate :: BitReader ;
#[doc = "Field `GPIODRST` writer - IO port D reset"] pub type GpiodrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOERST` reader - IO port E reset"] pub type GpioerstR = crate :: BitReader ;
#[doc = "Field `GPIOERST` writer - IO port E reset"] pub type GpioerstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOHRST` reader - IO port H reset"] pub type GpiohrstR = crate :: BitReader ;
#[doc = "Field `GPIOHRST` writer - IO port H reset"] pub type GpiohrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADCRST` reader - ADC reset"] pub type AdcrstR = crate :: BitReader ;
#[doc = "Field `ADCRST` writer - ADC reset"] pub type AdcrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AES1RST` reader - AES1 hardware accelerator reset"] pub type Aes1rstR = crate :: BitReader ;
#[doc = "Field `AES1RST` writer - AES1 hardware accelerator reset"] pub type Aes1rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - IO port A reset"]
#[inline (always)] pub fn gpioarst (& self) -> GpioarstR { GpioarstR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - IO port B reset"]
#[inline (always)] pub fn gpiobrst (& self) -> GpiobrstR { GpiobrstR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - IO port C reset"]
#[inline (always)] pub fn gpiocrst (& self) -> GpiocrstR { GpiocrstR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - IO port D reset"]
#[inline (always)] pub fn gpiodrst (& self) -> GpiodrstR { GpiodrstR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - IO port E reset"]
#[inline (always)] pub fn gpioerst (& self) -> GpioerstR { GpioerstR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 7 - IO port H reset"]
#[inline (always)] pub fn gpiohrst (& self) -> GpiohrstR { GpiohrstR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 13 - ADC reset"]
#[inline (always)] pub fn adcrst (& self) -> AdcrstR { AdcrstR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 16 - AES1 hardware accelerator reset"]
#[inline (always)] pub fn aes1rst (& self) -> Aes1rstR { Aes1rstR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bit 0 - IO port A reset"]
#[inline (always)] pub fn gpioarst (& mut self) -> GpioarstW < '_ , Ahb2rstrSpec > { GpioarstW :: new (self , 0) }
#[doc = "Bit 1 - IO port B reset"]
#[inline (always)] pub fn gpiobrst (& mut self) -> GpiobrstW < '_ , Ahb2rstrSpec > { GpiobrstW :: new (self , 1) }
#[doc = "Bit 2 - IO port C reset"]
#[inline (always)] pub fn gpiocrst (& mut self) -> GpiocrstW < '_ , Ahb2rstrSpec > { GpiocrstW :: new (self , 2) }
#[doc = "Bit 3 - IO port D reset"]
#[inline (always)] pub fn gpiodrst (& mut self) -> GpiodrstW < '_ , Ahb2rstrSpec > { GpiodrstW :: new (self , 3) }
#[doc = "Bit 4 - IO port E reset"]
#[inline (always)] pub fn gpioerst (& mut self) -> GpioerstW < '_ , Ahb2rstrSpec > { GpioerstW :: new (self , 4) }
#[doc = "Bit 7 - IO port H reset"]
#[inline (always)] pub fn gpiohrst (& mut self) -> GpiohrstW < '_ , Ahb2rstrSpec > { GpiohrstW :: new (self , 7) }
#[doc = "Bit 13 - ADC reset"]
#[inline (always)] pub fn adcrst (& mut self) -> AdcrstW < '_ , Ahb2rstrSpec > { AdcrstW :: new (self , 13) }
#[doc = "Bit 16 - AES1 hardware accelerator reset"]
#[inline (always)] pub fn aes1rst (& mut self) -> Aes1rstW < '_ , Ahb2rstrSpec > { Aes1rstW :: new (self , 16) } }
#[doc = "AHB2 peripheral reset register\n\nYou can [`read`](crate::Reg::read) this register and get [`ahb2rstr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ahb2rstr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ahb2rstrSpec ; impl crate :: RegisterSpec for Ahb2rstrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ahb2rstr::R`](R) reader structure"] impl crate :: Readable for Ahb2rstrSpec { }
#[doc = "`write(|w| ..)` method takes [`ahb2rstr::W`](W) writer structure"] impl crate :: Writable for Ahb2rstrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AHB2RSTR to value 0"] impl crate :: Resettable for Ahb2rstrSpec { } }
#[doc = "AHB3RSTR (rw) register accessor: AHB3 peripheral reset register\n\nYou can [`read`](crate::Reg::read) this register and get [`ahb3rstr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ahb3rstr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ahb3rstr`] module"]
#[doc (alias = "AHB3RSTR")] pub type Ahb3rstr = crate :: Reg < ahb3rstr :: Ahb3rstrSpec > ;
#[doc = "AHB3 peripheral reset register"] pub mod ahb3rstr {
#[doc = "Register `AHB3RSTR` reader"] pub type R = crate :: R < Ahb3rstrSpec > ;
#[doc = "Register `AHB3RSTR` writer"] pub type W = crate :: W < Ahb3rstrSpec > ;
#[doc = "Field `QSPIRST` reader - Quad SPI memory interface reset"] pub type QspirstR = crate :: BitReader ;
#[doc = "Field `QSPIRST` writer - Quad SPI memory interface reset"] pub type QspirstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PKARST` reader - PKA interface reset"] pub type PkarstR = crate :: BitReader ;
#[doc = "Field `PKARST` writer - PKA interface reset"] pub type PkarstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AES2RST` reader - AES2 interface reset"] pub type Aes2rstR = crate :: BitReader ;
#[doc = "Field `AES2RST` writer - AES2 interface reset"] pub type Aes2rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RNGRST` reader - RNG interface reset"] pub type RngrstR = crate :: BitReader ;
#[doc = "Field `RNGRST` writer - RNG interface reset"] pub type RngrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSEMRST` reader - HSEM interface reset"] pub type HsemrstR = crate :: BitReader ;
#[doc = "Field `HSEMRST` writer - HSEM interface reset"] pub type HsemrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IPCCRST` reader - IPCC interface reset"] pub type IpccrstR = crate :: BitReader ;
#[doc = "Field `IPCCRST` writer - IPCC interface reset"] pub type IpccrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FLASHRST` reader - Flash interface reset"] pub type FlashrstR = crate :: BitReader ;
#[doc = "Field `FLASHRST` writer - Flash interface reset"] pub type FlashrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 8 - Quad SPI memory interface reset"]
#[inline (always)] pub fn qspirst (& self) -> QspirstR { QspirstR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 16 - PKA interface reset"]
#[inline (always)] pub fn pkarst (& self) -> PkarstR { PkarstR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - AES2 interface reset"]
#[inline (always)] pub fn aes2rst (& self) -> Aes2rstR { Aes2rstR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - RNG interface reset"]
#[inline (always)] pub fn rngrst (& self) -> RngrstR { RngrstR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - HSEM interface reset"]
#[inline (always)] pub fn hsemrst (& self) -> HsemrstR { HsemrstR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - IPCC interface reset"]
#[inline (always)] pub fn ipccrst (& self) -> IpccrstR { IpccrstR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 25 - Flash interface reset"]
#[inline (always)] pub fn flashrst (& self) -> FlashrstR { FlashrstR :: new (((self . bits >> 25) & 1) != 0) } } impl W {
#[doc = "Bit 8 - Quad SPI memory interface reset"]
#[inline (always)] pub fn qspirst (& mut self) -> QspirstW < '_ , Ahb3rstrSpec > { QspirstW :: new (self , 8) }
#[doc = "Bit 16 - PKA interface reset"]
#[inline (always)] pub fn pkarst (& mut self) -> PkarstW < '_ , Ahb3rstrSpec > { PkarstW :: new (self , 16) }
#[doc = "Bit 17 - AES2 interface reset"]
#[inline (always)] pub fn aes2rst (& mut self) -> Aes2rstW < '_ , Ahb3rstrSpec > { Aes2rstW :: new (self , 17) }
#[doc = "Bit 18 - RNG interface reset"]
#[inline (always)] pub fn rngrst (& mut self) -> RngrstW < '_ , Ahb3rstrSpec > { RngrstW :: new (self , 18) }
#[doc = "Bit 19 - HSEM interface reset"]
#[inline (always)] pub fn hsemrst (& mut self) -> HsemrstW < '_ , Ahb3rstrSpec > { HsemrstW :: new (self , 19) }
#[doc = "Bit 20 - IPCC interface reset"]
#[inline (always)] pub fn ipccrst (& mut self) -> IpccrstW < '_ , Ahb3rstrSpec > { IpccrstW :: new (self , 20) }
#[doc = "Bit 25 - Flash interface reset"]
#[inline (always)] pub fn flashrst (& mut self) -> FlashrstW < '_ , Ahb3rstrSpec > { FlashrstW :: new (self , 25) } }
#[doc = "AHB3 peripheral reset register\n\nYou can [`read`](crate::Reg::read) this register and get [`ahb3rstr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ahb3rstr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ahb3rstrSpec ; impl crate :: RegisterSpec for Ahb3rstrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ahb3rstr::R`](R) reader structure"] impl crate :: Readable for Ahb3rstrSpec { }
#[doc = "`write(|w| ..)` method takes [`ahb3rstr::W`](W) writer structure"] impl crate :: Writable for Ahb3rstrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AHB3RSTR to value 0"] impl crate :: Resettable for Ahb3rstrSpec { } }
#[doc = "APB1RSTR1 (rw) register accessor: APB1 peripheral reset register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`apb1rstr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb1rstr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@apb1rstr1`] module"]
#[doc (alias = "APB1RSTR1")] pub type Apb1rstr1 = crate :: Reg < apb1rstr1 :: Apb1rstr1Spec > ;
#[doc = "APB1 peripheral reset register 1"] pub mod apb1rstr1 {
#[doc = "Register `APB1RSTR1` reader"] pub type R = crate :: R < Apb1rstr1Spec > ;
#[doc = "Register `APB1RSTR1` writer"] pub type W = crate :: W < Apb1rstr1Spec > ;
#[doc = "Field `TIM2RST` reader - TIM2 timer reset"] pub type Tim2rstR = crate :: BitReader ;
#[doc = "Field `TIM2RST` writer - TIM2 timer reset"] pub type Tim2rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCDRST` reader - LCD interface reset"] pub type LcdrstR = crate :: BitReader ;
#[doc = "Field `LCDRST` writer - LCD interface reset"] pub type LcdrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPI2RST` reader - SPI2 reset"] pub type Spi2rstR = crate :: BitReader ;
#[doc = "Field `SPI2RST` writer - SPI2 reset"] pub type Spi2rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `I2C1RST` reader - I2C1 reset"] pub type I2c1rstR = crate :: BitReader ;
#[doc = "Field `I2C1RST` writer - I2C1 reset"] pub type I2c1rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `I2C3RST` reader - I2C3 reset"] pub type I2c3rstR = crate :: BitReader ;
#[doc = "Field `I2C3RST` writer - I2C3 reset"] pub type I2c3rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CRSRST` reader - CRS reset"] pub type CrsrstR = crate :: BitReader ;
#[doc = "Field `CRSRST` writer - CRS reset"] pub type CrsrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `USBFSRST` reader - USB FS reset"] pub type UsbfsrstR = crate :: BitReader ;
#[doc = "Field `USBFSRST` writer - USB FS reset"] pub type UsbfsrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LPTIM1RST` reader - Low Power Timer 1 reset"] pub type Lptim1rstR = crate :: BitReader ;
#[doc = "Field `LPTIM1RST` writer - Low Power Timer 1 reset"] pub type Lptim1rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - TIM2 timer reset"]
#[inline (always)] pub fn tim2rst (& self) -> Tim2rstR { Tim2rstR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 9 - LCD interface reset"]
#[inline (always)] pub fn lcdrst (& self) -> LcdrstR { LcdrstR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 14 - SPI2 reset"]
#[inline (always)] pub fn spi2rst (& self) -> Spi2rstR { Spi2rstR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 21 - I2C1 reset"]
#[inline (always)] pub fn i2c1rst (& self) -> I2c1rstR { I2c1rstR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 23 - I2C3 reset"]
#[inline (always)] pub fn i2c3rst (& self) -> I2c3rstR { I2c3rstR :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - CRS reset"]
#[inline (always)] pub fn crsrst (& self) -> CrsrstR { CrsrstR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 26 - USB FS reset"]
#[inline (always)] pub fn usbfsrst (& self) -> UsbfsrstR { UsbfsrstR :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 31 - Low Power Timer 1 reset"]
#[inline (always)] pub fn lptim1rst (& self) -> Lptim1rstR { Lptim1rstR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - TIM2 timer reset"]
#[inline (always)] pub fn tim2rst (& mut self) -> Tim2rstW < '_ , Apb1rstr1Spec > { Tim2rstW :: new (self , 0) }
#[doc = "Bit 9 - LCD interface reset"]
#[inline (always)] pub fn lcdrst (& mut self) -> LcdrstW < '_ , Apb1rstr1Spec > { LcdrstW :: new (self , 9) }
#[doc = "Bit 14 - SPI2 reset"]
#[inline (always)] pub fn spi2rst (& mut self) -> Spi2rstW < '_ , Apb1rstr1Spec > { Spi2rstW :: new (self , 14) }
#[doc = "Bit 21 - I2C1 reset"]
#[inline (always)] pub fn i2c1rst (& mut self) -> I2c1rstW < '_ , Apb1rstr1Spec > { I2c1rstW :: new (self , 21) }
#[doc = "Bit 23 - I2C3 reset"]
#[inline (always)] pub fn i2c3rst (& mut self) -> I2c3rstW < '_ , Apb1rstr1Spec > { I2c3rstW :: new (self , 23) }
#[doc = "Bit 24 - CRS reset"]
#[inline (always)] pub fn crsrst (& mut self) -> CrsrstW < '_ , Apb1rstr1Spec > { CrsrstW :: new (self , 24) }
#[doc = "Bit 26 - USB FS reset"]
#[inline (always)] pub fn usbfsrst (& mut self) -> UsbfsrstW < '_ , Apb1rstr1Spec > { UsbfsrstW :: new (self , 26) }
#[doc = "Bit 31 - Low Power Timer 1 reset"]
#[inline (always)] pub fn lptim1rst (& mut self) -> Lptim1rstW < '_ , Apb1rstr1Spec > { Lptim1rstW :: new (self , 31) } }
#[doc = "APB1 peripheral reset register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`apb1rstr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb1rstr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Apb1rstr1Spec ; impl crate :: RegisterSpec for Apb1rstr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`apb1rstr1::R`](R) reader structure"] impl crate :: Readable for Apb1rstr1Spec { }
#[doc = "`write(|w| ..)` method takes [`apb1rstr1::W`](W) writer structure"] impl crate :: Writable for Apb1rstr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets APB1RSTR1 to value 0"] impl crate :: Resettable for Apb1rstr1Spec { } }
#[doc = "APB1RSTR2 (rw) register accessor: APB1 peripheral reset register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`apb1rstr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb1rstr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@apb1rstr2`] module"]
#[doc (alias = "APB1RSTR2")] pub type Apb1rstr2 = crate :: Reg < apb1rstr2 :: Apb1rstr2Spec > ;
#[doc = "APB1 peripheral reset register 2"] pub mod apb1rstr2 {
#[doc = "Register `APB1RSTR2` reader"] pub type R = crate :: R < Apb1rstr2Spec > ;
#[doc = "Register `APB1RSTR2` writer"] pub type W = crate :: W < Apb1rstr2Spec > ;
#[doc = "Field `LPUART1RST` reader - Low-power UART 1 reset"] pub type Lpuart1rstR = crate :: BitReader ;
#[doc = "Field `LPUART1RST` writer - Low-power UART 1 reset"] pub type Lpuart1rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LPTIM2RST` reader - Low-power timer 2 reset"] pub type Lptim2rstR = crate :: BitReader ;
#[doc = "Field `LPTIM2RST` writer - Low-power timer 2 reset"] pub type Lptim2rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Low-power UART 1 reset"]
#[inline (always)] pub fn lpuart1rst (& self) -> Lpuart1rstR { Lpuart1rstR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 5 - Low-power timer 2 reset"]
#[inline (always)] pub fn lptim2rst (& self) -> Lptim2rstR { Lptim2rstR :: new (((self . bits >> 5) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Low-power UART 1 reset"]
#[inline (always)] pub fn lpuart1rst (& mut self) -> Lpuart1rstW < '_ , Apb1rstr2Spec > { Lpuart1rstW :: new (self , 0) }
#[doc = "Bit 5 - Low-power timer 2 reset"]
#[inline (always)] pub fn lptim2rst (& mut self) -> Lptim2rstW < '_ , Apb1rstr2Spec > { Lptim2rstW :: new (self , 5) } }
#[doc = "APB1 peripheral reset register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`apb1rstr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb1rstr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Apb1rstr2Spec ; impl crate :: RegisterSpec for Apb1rstr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`apb1rstr2::R`](R) reader structure"] impl crate :: Readable for Apb1rstr2Spec { }
#[doc = "`write(|w| ..)` method takes [`apb1rstr2::W`](W) writer structure"] impl crate :: Writable for Apb1rstr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets APB1RSTR2 to value 0"] impl crate :: Resettable for Apb1rstr2Spec { } }
#[doc = "APB2RSTR (rw) register accessor: APB2 peripheral reset register\n\nYou can [`read`](crate::Reg::read) this register and get [`apb2rstr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb2rstr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@apb2rstr`] module"]
#[doc (alias = "APB2RSTR")] pub type Apb2rstr = crate :: Reg < apb2rstr :: Apb2rstrSpec > ;
#[doc = "APB2 peripheral reset register"] pub mod apb2rstr {
#[doc = "Register `APB2RSTR` reader"] pub type R = crate :: R < Apb2rstrSpec > ;
#[doc = "Register `APB2RSTR` writer"] pub type W = crate :: W < Apb2rstrSpec > ;
#[doc = "Field `TIM1RST` reader - TIM1 timer reset"] pub type Tim1rstR = crate :: BitReader ;
#[doc = "Field `TIM1RST` writer - TIM1 timer reset"] pub type Tim1rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPI1RST` reader - SPI1 reset"] pub type Spi1rstR = crate :: BitReader ;
#[doc = "Field `SPI1RST` writer - SPI1 reset"] pub type Spi1rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `USART1RST` reader - USART1 reset"] pub type Usart1rstR = crate :: BitReader ;
#[doc = "Field `USART1RST` writer - USART1 reset"] pub type Usart1rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM16RST` reader - TIM16 timer reset"] pub type Tim16rstR = crate :: BitReader ;
#[doc = "Field `TIM16RST` writer - TIM16 timer reset"] pub type Tim16rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM17RST` reader - TIM17 timer reset"] pub type Tim17rstR = crate :: BitReader ;
#[doc = "Field `TIM17RST` writer - TIM17 timer reset"] pub type Tim17rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SAI1RST` reader - Serial audio interface 1 (SAI1) reset"] pub type Sai1rstR = crate :: BitReader ;
#[doc = "Field `SAI1RST` writer - Serial audio interface 1 (SAI1) reset"] pub type Sai1rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 11 - TIM1 timer reset"]
#[inline (always)] pub fn tim1rst (& self) -> Tim1rstR { Tim1rstR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - SPI1 reset"]
#[inline (always)] pub fn spi1rst (& self) -> Spi1rstR { Spi1rstR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 14 - USART1 reset"]
#[inline (always)] pub fn usart1rst (& self) -> Usart1rstR { Usart1rstR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 17 - TIM16 timer reset"]
#[inline (always)] pub fn tim16rst (& self) -> Tim16rstR { Tim16rstR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - TIM17 timer reset"]
#[inline (always)] pub fn tim17rst (& self) -> Tim17rstR { Tim17rstR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 21 - Serial audio interface 1 (SAI1) reset"]
#[inline (always)] pub fn sai1rst (& self) -> Sai1rstR { Sai1rstR :: new (((self . bits >> 21) & 1) != 0) } } impl W {
#[doc = "Bit 11 - TIM1 timer reset"]
#[inline (always)] pub fn tim1rst (& mut self) -> Tim1rstW < '_ , Apb2rstrSpec > { Tim1rstW :: new (self , 11) }
#[doc = "Bit 12 - SPI1 reset"]
#[inline (always)] pub fn spi1rst (& mut self) -> Spi1rstW < '_ , Apb2rstrSpec > { Spi1rstW :: new (self , 12) }
#[doc = "Bit 14 - USART1 reset"]
#[inline (always)] pub fn usart1rst (& mut self) -> Usart1rstW < '_ , Apb2rstrSpec > { Usart1rstW :: new (self , 14) }
#[doc = "Bit 17 - TIM16 timer reset"]
#[inline (always)] pub fn tim16rst (& mut self) -> Tim16rstW < '_ , Apb2rstrSpec > { Tim16rstW :: new (self , 17) }
#[doc = "Bit 18 - TIM17 timer reset"]
#[inline (always)] pub fn tim17rst (& mut self) -> Tim17rstW < '_ , Apb2rstrSpec > { Tim17rstW :: new (self , 18) }
#[doc = "Bit 21 - Serial audio interface 1 (SAI1) reset"]
#[inline (always)] pub fn sai1rst (& mut self) -> Sai1rstW < '_ , Apb2rstrSpec > { Sai1rstW :: new (self , 21) } }
#[doc = "APB2 peripheral reset register\n\nYou can [`read`](crate::Reg::read) this register and get [`apb2rstr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb2rstr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Apb2rstrSpec ; impl crate :: RegisterSpec for Apb2rstrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`apb2rstr::R`](R) reader structure"] impl crate :: Readable for Apb2rstrSpec { }
#[doc = "`write(|w| ..)` method takes [`apb2rstr::W`](W) writer structure"] impl crate :: Writable for Apb2rstrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets APB2RSTR to value 0"] impl crate :: Resettable for Apb2rstrSpec { } }
#[doc = "APB3RSTR (rw) register accessor: APB3 peripheral reset register\n\nYou can [`read`](crate::Reg::read) this register and get [`apb3rstr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb3rstr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@apb3rstr`] module"]
#[doc (alias = "APB3RSTR")] pub type Apb3rstr = crate :: Reg < apb3rstr :: Apb3rstrSpec > ;
#[doc = "APB3 peripheral reset register"] pub mod apb3rstr {
#[doc = "Register `APB3RSTR` reader"] pub type R = crate :: R < Apb3rstrSpec > ;
#[doc = "Register `APB3RSTR` writer"] pub type W = crate :: W < Apb3rstrSpec > ;
#[doc = "Field `RFRST` reader - Radio system BLE reset"] pub type RfrstR = crate :: BitReader ;
#[doc = "Field `RFRST` writer - Radio system BLE reset"] pub type RfrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Radio system BLE reset"]
#[inline (always)] pub fn rfrst (& self) -> RfrstR { RfrstR :: new ((self . bits & 1) != 0) } } impl W {
#[doc = "Bit 0 - Radio system BLE reset"]
#[inline (always)] pub fn rfrst (& mut self) -> RfrstW < '_ , Apb3rstrSpec > { RfrstW :: new (self , 0) } }
#[doc = "APB3 peripheral reset register\n\nYou can [`read`](crate::Reg::read) this register and get [`apb3rstr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb3rstr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Apb3rstrSpec ; impl crate :: RegisterSpec for Apb3rstrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`apb3rstr::R`](R) reader structure"] impl crate :: Readable for Apb3rstrSpec { }
#[doc = "`write(|w| ..)` method takes [`apb3rstr::W`](W) writer structure"] impl crate :: Writable for Apb3rstrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets APB3RSTR to value 0"] impl crate :: Resettable for Apb3rstrSpec { } }
#[doc = "AHB1ENR (rw) register accessor: AHB1 peripheral clock enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ahb1enr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ahb1enr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ahb1enr`] module"]
#[doc (alias = "AHB1ENR")] pub type Ahb1enr = crate :: Reg < ahb1enr :: Ahb1enrSpec > ;
#[doc = "AHB1 peripheral clock enable register"] pub mod ahb1enr {
#[doc = "Register `AHB1ENR` reader"] pub type R = crate :: R < Ahb1enrSpec > ;
#[doc = "Register `AHB1ENR` writer"] pub type W = crate :: W < Ahb1enrSpec > ;
#[doc = "Field `DMA1EN` reader - DMA1 clock enable"] pub type Dma1enR = crate :: BitReader ;
#[doc = "Field `DMA1EN` writer - DMA1 clock enable"] pub type Dma1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMA2EN` reader - DMA2 clock enable"] pub type Dma2enR = crate :: BitReader ;
#[doc = "Field `DMA2EN` writer - DMA2 clock enable"] pub type Dma2enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMAMUXEN` reader - DMAMUX clock enable"] pub type DmamuxenR = crate :: BitReader ;
#[doc = "Field `DMAMUXEN` writer - DMAMUX clock enable"] pub type DmamuxenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CRCEN` reader - CPU1 CRC clock enable"] pub type CrcenR = crate :: BitReader ;
#[doc = "Field `CRCEN` writer - CPU1 CRC clock enable"] pub type CrcenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TSCEN` reader - Touch Sensing Controller clock enable"] pub type TscenR = crate :: BitReader ;
#[doc = "Field `TSCEN` writer - Touch Sensing Controller clock enable"] pub type TscenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - DMA1 clock enable"]
#[inline (always)] pub fn dma1en (& self) -> Dma1enR { Dma1enR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - DMA2 clock enable"]
#[inline (always)] pub fn dma2en (& self) -> Dma2enR { Dma2enR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - DMAMUX clock enable"]
#[inline (always)] pub fn dmamuxen (& self) -> DmamuxenR { DmamuxenR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 12 - CPU1 CRC clock enable"]
#[inline (always)] pub fn crcen (& self) -> CrcenR { CrcenR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 16 - Touch Sensing Controller clock enable"]
#[inline (always)] pub fn tscen (& self) -> TscenR { TscenR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bit 0 - DMA1 clock enable"]
#[inline (always)] pub fn dma1en (& mut self) -> Dma1enW < '_ , Ahb1enrSpec > { Dma1enW :: new (self , 0) }
#[doc = "Bit 1 - DMA2 clock enable"]
#[inline (always)] pub fn dma2en (& mut self) -> Dma2enW < '_ , Ahb1enrSpec > { Dma2enW :: new (self , 1) }
#[doc = "Bit 2 - DMAMUX clock enable"]
#[inline (always)] pub fn dmamuxen (& mut self) -> DmamuxenW < '_ , Ahb1enrSpec > { DmamuxenW :: new (self , 2) }
#[doc = "Bit 12 - CPU1 CRC clock enable"]
#[inline (always)] pub fn crcen (& mut self) -> CrcenW < '_ , Ahb1enrSpec > { CrcenW :: new (self , 12) }
#[doc = "Bit 16 - Touch Sensing Controller clock enable"]
#[inline (always)] pub fn tscen (& mut self) -> TscenW < '_ , Ahb1enrSpec > { TscenW :: new (self , 16) } }
#[doc = "AHB1 peripheral clock enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ahb1enr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ahb1enr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ahb1enrSpec ; impl crate :: RegisterSpec for Ahb1enrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ahb1enr::R`](R) reader structure"] impl crate :: Readable for Ahb1enrSpec { }
#[doc = "`write(|w| ..)` method takes [`ahb1enr::W`](W) writer structure"] impl crate :: Writable for Ahb1enrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AHB1ENR to value 0x0100"] impl crate :: Resettable for Ahb1enrSpec { const RESET_VALUE : u32 = 0x0100 ; } }
#[doc = "AHB2ENR (rw) register accessor: AHB2 peripheral clock enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ahb2enr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ahb2enr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ahb2enr`] module"]
#[doc (alias = "AHB2ENR")] pub type Ahb2enr = crate :: Reg < ahb2enr :: Ahb2enrSpec > ;
#[doc = "AHB2 peripheral clock enable register"] pub mod ahb2enr {
#[doc = "Register `AHB2ENR` reader"] pub type R = crate :: R < Ahb2enrSpec > ;
#[doc = "Register `AHB2ENR` writer"] pub type W = crate :: W < Ahb2enrSpec > ;
#[doc = "Field `GPIOAEN` reader - IO port A clock enable"] pub type GpioaenR = crate :: BitReader ;
#[doc = "Field `GPIOAEN` writer - IO port A clock enable"] pub type GpioaenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOBEN` reader - IO port B clock enable"] pub type GpiobenR = crate :: BitReader ;
#[doc = "Field `GPIOBEN` writer - IO port B clock enable"] pub type GpiobenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOCEN` reader - IO port C clock enable"] pub type GpiocenR = crate :: BitReader ;
#[doc = "Field `GPIOCEN` writer - IO port C clock enable"] pub type GpiocenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIODEN` reader - IO port D clock enable"] pub type GpiodenR = crate :: BitReader ;
#[doc = "Field `GPIODEN` writer - IO port D clock enable"] pub type GpiodenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOEEN` reader - IO port E clock enable"] pub type GpioeenR = crate :: BitReader ;
#[doc = "Field `GPIOEEN` writer - IO port E clock enable"] pub type GpioeenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOHEN` reader - IO port H clock enable"] pub type GpiohenR = crate :: BitReader ;
#[doc = "Field `GPIOHEN` writer - IO port H clock enable"] pub type GpiohenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADCEN` reader - ADC clock enable"] pub type AdcenR = crate :: BitReader ;
#[doc = "Field `ADCEN` writer - ADC clock enable"] pub type AdcenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AES1EN` reader - AES1 accelerator clock enable"] pub type Aes1enR = crate :: BitReader ;
#[doc = "Field `AES1EN` writer - AES1 accelerator clock enable"] pub type Aes1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - IO port A clock enable"]
#[inline (always)] pub fn gpioaen (& self) -> GpioaenR { GpioaenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - IO port B clock enable"]
#[inline (always)] pub fn gpioben (& self) -> GpiobenR { GpiobenR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - IO port C clock enable"]
#[inline (always)] pub fn gpiocen (& self) -> GpiocenR { GpiocenR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - IO port D clock enable"]
#[inline (always)] pub fn gpioden (& self) -> GpiodenR { GpiodenR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - IO port E clock enable"]
#[inline (always)] pub fn gpioeen (& self) -> GpioeenR { GpioeenR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 7 - IO port H clock enable"]
#[inline (always)] pub fn gpiohen (& self) -> GpiohenR { GpiohenR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 13 - ADC clock enable"]
#[inline (always)] pub fn adcen (& self) -> AdcenR { AdcenR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 16 - AES1 accelerator clock enable"]
#[inline (always)] pub fn aes1en (& self) -> Aes1enR { Aes1enR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bit 0 - IO port A clock enable"]
#[inline (always)] pub fn gpioaen (& mut self) -> GpioaenW < '_ , Ahb2enrSpec > { GpioaenW :: new (self , 0) }
#[doc = "Bit 1 - IO port B clock enable"]
#[inline (always)] pub fn gpioben (& mut self) -> GpiobenW < '_ , Ahb2enrSpec > { GpiobenW :: new (self , 1) }
#[doc = "Bit 2 - IO port C clock enable"]
#[inline (always)] pub fn gpiocen (& mut self) -> GpiocenW < '_ , Ahb2enrSpec > { GpiocenW :: new (self , 2) }
#[doc = "Bit 3 - IO port D clock enable"]
#[inline (always)] pub fn gpioden (& mut self) -> GpiodenW < '_ , Ahb2enrSpec > { GpiodenW :: new (self , 3) }
#[doc = "Bit 4 - IO port E clock enable"]
#[inline (always)] pub fn gpioeen (& mut self) -> GpioeenW < '_ , Ahb2enrSpec > { GpioeenW :: new (self , 4) }
#[doc = "Bit 7 - IO port H clock enable"]
#[inline (always)] pub fn gpiohen (& mut self) -> GpiohenW < '_ , Ahb2enrSpec > { GpiohenW :: new (self , 7) }
#[doc = "Bit 13 - ADC clock enable"]
#[inline (always)] pub fn adcen (& mut self) -> AdcenW < '_ , Ahb2enrSpec > { AdcenW :: new (self , 13) }
#[doc = "Bit 16 - AES1 accelerator clock enable"]
#[inline (always)] pub fn aes1en (& mut self) -> Aes1enW < '_ , Ahb2enrSpec > { Aes1enW :: new (self , 16) } }
#[doc = "AHB2 peripheral clock enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ahb2enr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ahb2enr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ahb2enrSpec ; impl crate :: RegisterSpec for Ahb2enrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ahb2enr::R`](R) reader structure"] impl crate :: Readable for Ahb2enrSpec { }
#[doc = "`write(|w| ..)` method takes [`ahb2enr::W`](W) writer structure"] impl crate :: Writable for Ahb2enrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AHB2ENR to value 0"] impl crate :: Resettable for Ahb2enrSpec { } }
#[doc = "AHB3ENR (rw) register accessor: AHB3 peripheral clock enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ahb3enr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ahb3enr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ahb3enr`] module"]
#[doc (alias = "AHB3ENR")] pub type Ahb3enr = crate :: Reg < ahb3enr :: Ahb3enrSpec > ;
#[doc = "AHB3 peripheral clock enable register"] pub mod ahb3enr {
#[doc = "Register `AHB3ENR` reader"] pub type R = crate :: R < Ahb3enrSpec > ;
#[doc = "Register `AHB3ENR` writer"] pub type W = crate :: W < Ahb3enrSpec > ;
#[doc = "Field `QSPIEN` reader - QSPIEN"] pub type QspienR = crate :: BitReader ;
#[doc = "Field `QSPIEN` writer - QSPIEN"] pub type QspienW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PKAEN` reader - PKAEN"] pub type PkaenR = crate :: BitReader ;
#[doc = "Field `PKAEN` writer - PKAEN"] pub type PkaenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AES2EN` reader - AES2EN"] pub type Aes2enR = crate :: BitReader ;
#[doc = "Field `AES2EN` writer - AES2EN"] pub type Aes2enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RNGEN` reader - RNGEN"] pub type RngenR = crate :: BitReader ;
#[doc = "Field `RNGEN` writer - RNGEN"] pub type RngenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSEMEN` reader - HSEMEN"] pub type HsemenR = crate :: BitReader ;
#[doc = "Field `HSEMEN` writer - HSEMEN"] pub type HsemenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IPCCEN` reader - IPCCEN"] pub type IpccenR = crate :: BitReader ;
#[doc = "Field `IPCCEN` writer - IPCCEN"] pub type IpccenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FLASHEN` reader - FLASHEN"] pub type FlashenR = crate :: BitReader ;
#[doc = "Field `FLASHEN` writer - FLASHEN"] pub type FlashenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 8 - QSPIEN"]
#[inline (always)] pub fn qspien (& self) -> QspienR { QspienR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 16 - PKAEN"]
#[inline (always)] pub fn pkaen (& self) -> PkaenR { PkaenR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - AES2EN"]
#[inline (always)] pub fn aes2en (& self) -> Aes2enR { Aes2enR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - RNGEN"]
#[inline (always)] pub fn rngen (& self) -> RngenR { RngenR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - HSEMEN"]
#[inline (always)] pub fn hsemen (& self) -> HsemenR { HsemenR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - IPCCEN"]
#[inline (always)] pub fn ipccen (& self) -> IpccenR { IpccenR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 25 - FLASHEN"]
#[inline (always)] pub fn flashen (& self) -> FlashenR { FlashenR :: new (((self . bits >> 25) & 1) != 0) } } impl W {
#[doc = "Bit 8 - QSPIEN"]
#[inline (always)] pub fn qspien (& mut self) -> QspienW < '_ , Ahb3enrSpec > { QspienW :: new (self , 8) }
#[doc = "Bit 16 - PKAEN"]
#[inline (always)] pub fn pkaen (& mut self) -> PkaenW < '_ , Ahb3enrSpec > { PkaenW :: new (self , 16) }
#[doc = "Bit 17 - AES2EN"]
#[inline (always)] pub fn aes2en (& mut self) -> Aes2enW < '_ , Ahb3enrSpec > { Aes2enW :: new (self , 17) }
#[doc = "Bit 18 - RNGEN"]
#[inline (always)] pub fn rngen (& mut self) -> RngenW < '_ , Ahb3enrSpec > { RngenW :: new (self , 18) }
#[doc = "Bit 19 - HSEMEN"]
#[inline (always)] pub fn hsemen (& mut self) -> HsemenW < '_ , Ahb3enrSpec > { HsemenW :: new (self , 19) }
#[doc = "Bit 20 - IPCCEN"]
#[inline (always)] pub fn ipccen (& mut self) -> IpccenW < '_ , Ahb3enrSpec > { IpccenW :: new (self , 20) }
#[doc = "Bit 25 - FLASHEN"]
#[inline (always)] pub fn flashen (& mut self) -> FlashenW < '_ , Ahb3enrSpec > { FlashenW :: new (self , 25) } }
#[doc = "AHB3 peripheral clock enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ahb3enr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ahb3enr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ahb3enrSpec ; impl crate :: RegisterSpec for Ahb3enrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ahb3enr::R`](R) reader structure"] impl crate :: Readable for Ahb3enrSpec { }
#[doc = "`write(|w| ..)` method takes [`ahb3enr::W`](W) writer structure"] impl crate :: Writable for Ahb3enrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AHB3ENR to value 0x0208_0000"] impl crate :: Resettable for Ahb3enrSpec { const RESET_VALUE : u32 = 0x0208_0000 ; } }
#[doc = "APB1ENR1 (rw) register accessor: APB1ENR1\n\nYou can [`read`](crate::Reg::read) this register and get [`apb1enr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb1enr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@apb1enr1`] module"]
#[doc (alias = "APB1ENR1")] pub type Apb1enr1 = crate :: Reg < apb1enr1 :: Apb1enr1Spec > ;
#[doc = "APB1ENR1"] pub mod apb1enr1 {
#[doc = "Register `APB1ENR1` reader"] pub type R = crate :: R < Apb1enr1Spec > ;
#[doc = "Register `APB1ENR1` writer"] pub type W = crate :: W < Apb1enr1Spec > ;
#[doc = "Field `TIM2EN` reader - CPU1 TIM2 timer clock enable"] pub type Tim2enR = crate :: BitReader ;
#[doc = "Field `TIM2EN` writer - CPU1 TIM2 timer clock enable"] pub type Tim2enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCDEN` reader - CPU1 LCD clock enable"] pub type LcdenR = crate :: BitReader ;
#[doc = "Field `LCDEN` writer - CPU1 LCD clock enable"] pub type LcdenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RTCAPBEN` reader - CPU1 RTC APB clock enable"] pub type RtcapbenR = crate :: BitReader ;
#[doc = "Field `RTCAPBEN` writer - CPU1 RTC APB clock enable"] pub type RtcapbenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WWDGEN` reader - CPU1 Window watchdog clock enable"] pub type WwdgenR = crate :: BitReader ;
#[doc = "Field `WWDGEN` writer - CPU1 Window watchdog clock enable"] pub type WwdgenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPI2EN` reader - CPU1 SPI2 clock enable"] pub type Spi2enR = crate :: BitReader ;
#[doc = "Field `SPI2EN` writer - CPU1 SPI2 clock enable"] pub type Spi2enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `I2C1EN` reader - CPU1 I2C1 clock enable"] pub type I2c1enR = crate :: BitReader ;
#[doc = "Field `I2C1EN` writer - CPU1 I2C1 clock enable"] pub type I2c1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `I2C3EN` reader - CPU1 I2C3 clock enable"] pub type I2c3enR = crate :: BitReader ;
#[doc = "Field `I2C3EN` writer - CPU1 I2C3 clock enable"] pub type I2c3enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CRSEN` reader - CPU1 CRS clock enable"] pub type CrsenR = crate :: BitReader ;
#[doc = "Field `CRSEN` writer - CPU1 CRS clock enable"] pub type CrsenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `USBEN` reader - CPU1 USB clock enable"] pub type UsbenR = crate :: BitReader ;
#[doc = "Field `USBEN` writer - CPU1 USB clock enable"] pub type UsbenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LPTIM1EN` reader - CPU1 Low power timer 1 clock enable"] pub type Lptim1enR = crate :: BitReader ;
#[doc = "Field `LPTIM1EN` writer - CPU1 Low power timer 1 clock enable"] pub type Lptim1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - CPU1 TIM2 timer clock enable"]
#[inline (always)] pub fn tim2en (& self) -> Tim2enR { Tim2enR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 9 - CPU1 LCD clock enable"]
#[inline (always)] pub fn lcden (& self) -> LcdenR { LcdenR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - CPU1 RTC APB clock enable"]
#[inline (always)] pub fn rtcapben (& self) -> RtcapbenR { RtcapbenR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - CPU1 Window watchdog clock enable"]
#[inline (always)] pub fn wwdgen (& self) -> WwdgenR { WwdgenR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 14 - CPU1 SPI2 clock enable"]
#[inline (always)] pub fn spi2en (& self) -> Spi2enR { Spi2enR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 21 - CPU1 I2C1 clock enable"]
#[inline (always)] pub fn i2c1en (& self) -> I2c1enR { I2c1enR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 23 - CPU1 I2C3 clock enable"]
#[inline (always)] pub fn i2c3en (& self) -> I2c3enR { I2c3enR :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - CPU1 CRS clock enable"]
#[inline (always)] pub fn crsen (& self) -> CrsenR { CrsenR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 26 - CPU1 USB clock enable"]
#[inline (always)] pub fn usben (& self) -> UsbenR { UsbenR :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 31 - CPU1 Low power timer 1 clock enable"]
#[inline (always)] pub fn lptim1en (& self) -> Lptim1enR { Lptim1enR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - CPU1 TIM2 timer clock enable"]
#[inline (always)] pub fn tim2en (& mut self) -> Tim2enW < '_ , Apb1enr1Spec > { Tim2enW :: new (self , 0) }
#[doc = "Bit 9 - CPU1 LCD clock enable"]
#[inline (always)] pub fn lcden (& mut self) -> LcdenW < '_ , Apb1enr1Spec > { LcdenW :: new (self , 9) }
#[doc = "Bit 10 - CPU1 RTC APB clock enable"]
#[inline (always)] pub fn rtcapben (& mut self) -> RtcapbenW < '_ , Apb1enr1Spec > { RtcapbenW :: new (self , 10) }
#[doc = "Bit 11 - CPU1 Window watchdog clock enable"]
#[inline (always)] pub fn wwdgen (& mut self) -> WwdgenW < '_ , Apb1enr1Spec > { WwdgenW :: new (self , 11) }
#[doc = "Bit 14 - CPU1 SPI2 clock enable"]
#[inline (always)] pub fn spi2en (& mut self) -> Spi2enW < '_ , Apb1enr1Spec > { Spi2enW :: new (self , 14) }
#[doc = "Bit 21 - CPU1 I2C1 clock enable"]
#[inline (always)] pub fn i2c1en (& mut self) -> I2c1enW < '_ , Apb1enr1Spec > { I2c1enW :: new (self , 21) }
#[doc = "Bit 23 - CPU1 I2C3 clock enable"]
#[inline (always)] pub fn i2c3en (& mut self) -> I2c3enW < '_ , Apb1enr1Spec > { I2c3enW :: new (self , 23) }
#[doc = "Bit 24 - CPU1 CRS clock enable"]
#[inline (always)] pub fn crsen (& mut self) -> CrsenW < '_ , Apb1enr1Spec > { CrsenW :: new (self , 24) }
#[doc = "Bit 26 - CPU1 USB clock enable"]
#[inline (always)] pub fn usben (& mut self) -> UsbenW < '_ , Apb1enr1Spec > { UsbenW :: new (self , 26) }
#[doc = "Bit 31 - CPU1 Low power timer 1 clock enable"]
#[inline (always)] pub fn lptim1en (& mut self) -> Lptim1enW < '_ , Apb1enr1Spec > { Lptim1enW :: new (self , 31) } }
#[doc = "APB1ENR1\n\nYou can [`read`](crate::Reg::read) this register and get [`apb1enr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb1enr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Apb1enr1Spec ; impl crate :: RegisterSpec for Apb1enr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`apb1enr1::R`](R) reader structure"] impl crate :: Readable for Apb1enr1Spec { }
#[doc = "`write(|w| ..)` method takes [`apb1enr1::W`](W) writer structure"] impl crate :: Writable for Apb1enr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets APB1ENR1 to value 0x0400"] impl crate :: Resettable for Apb1enr1Spec { const RESET_VALUE : u32 = 0x0400 ; } }
#[doc = "APB1ENR2 (rw) register accessor: APB1 peripheral clock enable register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`apb1enr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb1enr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@apb1enr2`] module"]
#[doc (alias = "APB1ENR2")] pub type Apb1enr2 = crate :: Reg < apb1enr2 :: Apb1enr2Spec > ;
#[doc = "APB1 peripheral clock enable register 2"] pub mod apb1enr2 {
#[doc = "Register `APB1ENR2` reader"] pub type R = crate :: R < Apb1enr2Spec > ;
#[doc = "Register `APB1ENR2` writer"] pub type W = crate :: W < Apb1enr2Spec > ;
#[doc = "Field `LPUART1EN` reader - CPU1 Low power UART 1 clock enable"] pub type Lpuart1enR = crate :: BitReader ;
#[doc = "Field `LPUART1EN` writer - CPU1 Low power UART 1 clock enable"] pub type Lpuart1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LPTIM2EN` reader - CPU1 LPTIM2EN"] pub type Lptim2enR = crate :: BitReader ;
#[doc = "Field `LPTIM2EN` writer - CPU1 LPTIM2EN"] pub type Lptim2enW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - CPU1 Low power UART 1 clock enable"]
#[inline (always)] pub fn lpuart1en (& self) -> Lpuart1enR { Lpuart1enR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 5 - CPU1 LPTIM2EN"]
#[inline (always)] pub fn lptim2en (& self) -> Lptim2enR { Lptim2enR :: new (((self . bits >> 5) & 1) != 0) } } impl W {
#[doc = "Bit 0 - CPU1 Low power UART 1 clock enable"]
#[inline (always)] pub fn lpuart1en (& mut self) -> Lpuart1enW < '_ , Apb1enr2Spec > { Lpuart1enW :: new (self , 0) }
#[doc = "Bit 5 - CPU1 LPTIM2EN"]
#[inline (always)] pub fn lptim2en (& mut self) -> Lptim2enW < '_ , Apb1enr2Spec > { Lptim2enW :: new (self , 5) } }
#[doc = "APB1 peripheral clock enable register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`apb1enr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb1enr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Apb1enr2Spec ; impl crate :: RegisterSpec for Apb1enr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`apb1enr2::R`](R) reader structure"] impl crate :: Readable for Apb1enr2Spec { }
#[doc = "`write(|w| ..)` method takes [`apb1enr2::W`](W) writer structure"] impl crate :: Writable for Apb1enr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets APB1ENR2 to value 0"] impl crate :: Resettable for Apb1enr2Spec { } }
#[doc = "APB2ENR (rw) register accessor: APB2ENR\n\nYou can [`read`](crate::Reg::read) this register and get [`apb2enr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb2enr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@apb2enr`] module"]
#[doc (alias = "APB2ENR")] pub type Apb2enr = crate :: Reg < apb2enr :: Apb2enrSpec > ;
#[doc = "APB2ENR"] pub mod apb2enr {
#[doc = "Register `APB2ENR` reader"] pub type R = crate :: R < Apb2enrSpec > ;
#[doc = "Register `APB2ENR` writer"] pub type W = crate :: W < Apb2enrSpec > ;
#[doc = "Field `TIM1EN` reader - CPU1 TIM1 timer clock enable"] pub type Tim1enR = crate :: BitReader ;
#[doc = "Field `TIM1EN` writer - CPU1 TIM1 timer clock enable"] pub type Tim1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPI1EN` reader - CPU1 SPI1 clock enable"] pub type Spi1enR = crate :: BitReader ;
#[doc = "Field `SPI1EN` writer - CPU1 SPI1 clock enable"] pub type Spi1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `USART1EN` reader - CPU1 USART1clock enable"] pub type Usart1enR = crate :: BitReader ;
#[doc = "Field `USART1EN` writer - CPU1 USART1clock enable"] pub type Usart1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM16EN` reader - CPU1 TIM16 timer clock enable"] pub type Tim16enR = crate :: BitReader ;
#[doc = "Field `TIM16EN` writer - CPU1 TIM16 timer clock enable"] pub type Tim16enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM17EN` reader - CPU1 TIM17 timer clock enable"] pub type Tim17enR = crate :: BitReader ;
#[doc = "Field `TIM17EN` writer - CPU1 TIM17 timer clock enable"] pub type Tim17enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SAI1EN` reader - CPU1 SAI1 clock enable"] pub type Sai1enR = crate :: BitReader ;
#[doc = "Field `SAI1EN` writer - CPU1 SAI1 clock enable"] pub type Sai1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 11 - CPU1 TIM1 timer clock enable"]
#[inline (always)] pub fn tim1en (& self) -> Tim1enR { Tim1enR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - CPU1 SPI1 clock enable"]
#[inline (always)] pub fn spi1en (& self) -> Spi1enR { Spi1enR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 14 - CPU1 USART1clock enable"]
#[inline (always)] pub fn usart1en (& self) -> Usart1enR { Usart1enR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 17 - CPU1 TIM16 timer clock enable"]
#[inline (always)] pub fn tim16en (& self) -> Tim16enR { Tim16enR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - CPU1 TIM17 timer clock enable"]
#[inline (always)] pub fn tim17en (& self) -> Tim17enR { Tim17enR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 21 - CPU1 SAI1 clock enable"]
#[inline (always)] pub fn sai1en (& self) -> Sai1enR { Sai1enR :: new (((self . bits >> 21) & 1) != 0) } } impl W {
#[doc = "Bit 11 - CPU1 TIM1 timer clock enable"]
#[inline (always)] pub fn tim1en (& mut self) -> Tim1enW < '_ , Apb2enrSpec > { Tim1enW :: new (self , 11) }
#[doc = "Bit 12 - CPU1 SPI1 clock enable"]
#[inline (always)] pub fn spi1en (& mut self) -> Spi1enW < '_ , Apb2enrSpec > { Spi1enW :: new (self , 12) }
#[doc = "Bit 14 - CPU1 USART1clock enable"]
#[inline (always)] pub fn usart1en (& mut self) -> Usart1enW < '_ , Apb2enrSpec > { Usart1enW :: new (self , 14) }
#[doc = "Bit 17 - CPU1 TIM16 timer clock enable"]
#[inline (always)] pub fn tim16en (& mut self) -> Tim16enW < '_ , Apb2enrSpec > { Tim16enW :: new (self , 17) }
#[doc = "Bit 18 - CPU1 TIM17 timer clock enable"]
#[inline (always)] pub fn tim17en (& mut self) -> Tim17enW < '_ , Apb2enrSpec > { Tim17enW :: new (self , 18) }
#[doc = "Bit 21 - CPU1 SAI1 clock enable"]
#[inline (always)] pub fn sai1en (& mut self) -> Sai1enW < '_ , Apb2enrSpec > { Sai1enW :: new (self , 21) } }
#[doc = "APB2ENR\n\nYou can [`read`](crate::Reg::read) this register and get [`apb2enr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb2enr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Apb2enrSpec ; impl crate :: RegisterSpec for Apb2enrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`apb2enr::R`](R) reader structure"] impl crate :: Readable for Apb2enrSpec { }
#[doc = "`write(|w| ..)` method takes [`apb2enr::W`](W) writer structure"] impl crate :: Writable for Apb2enrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets APB2ENR to value 0"] impl crate :: Resettable for Apb2enrSpec { } }
#[doc = "AHB1SMENR (rw) register accessor: AHB1 peripheral clocks enable in Sleep and Stop modes register\n\nYou can [`read`](crate::Reg::read) this register and get [`ahb1smenr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ahb1smenr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ahb1smenr`] module"]
#[doc (alias = "AHB1SMENR")] pub type Ahb1smenr = crate :: Reg < ahb1smenr :: Ahb1smenrSpec > ;
#[doc = "AHB1 peripheral clocks enable in Sleep and Stop modes register"] pub mod ahb1smenr {
#[doc = "Register `AHB1SMENR` reader"] pub type R = crate :: R < Ahb1smenrSpec > ;
#[doc = "Register `AHB1SMENR` writer"] pub type W = crate :: W < Ahb1smenrSpec > ;
#[doc = "Field `DMA1SMEN` reader - CPU1 DMA1 clocks enable during Sleep and Stop modes"] pub type Dma1smenR = crate :: BitReader ;
#[doc = "Field `DMA1SMEN` writer - CPU1 DMA1 clocks enable during Sleep and Stop modes"] pub type Dma1smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMA2SMEN` reader - CPU1 DMA2 clocks enable during Sleep and Stop modes"] pub type Dma2smenR = crate :: BitReader ;
#[doc = "Field `DMA2SMEN` writer - CPU1 DMA2 clocks enable during Sleep and Stop modes"] pub type Dma2smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMAMUXSMEN` reader - CPU1 DMAMUX clocks enable during Sleep and Stop modes"] pub type DmamuxsmenR = crate :: BitReader ;
#[doc = "Field `DMAMUXSMEN` writer - CPU1 DMAMUX clocks enable during Sleep and Stop modes"] pub type DmamuxsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SRAM1SMEN` reader - CPU1 SRAM1 interface clocks enable during Sleep and Stop modes"] pub type Sram1smenR = crate :: BitReader ;
#[doc = "Field `SRAM1SMEN` writer - CPU1 SRAM1 interface clocks enable during Sleep and Stop modes"] pub type Sram1smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CRCSMEN` reader - CPU1 CRCSMEN"] pub type CrcsmenR = crate :: BitReader ;
#[doc = "Field `CRCSMEN` writer - CPU1 CRCSMEN"] pub type CrcsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TSCSMEN` reader - CPU1 Touch Sensing Controller clocks enable during Sleep and Stop modes"] pub type TscsmenR = crate :: BitReader ;
#[doc = "Field `TSCSMEN` writer - CPU1 Touch Sensing Controller clocks enable during Sleep and Stop modes"] pub type TscsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - CPU1 DMA1 clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn dma1smen (& self) -> Dma1smenR { Dma1smenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - CPU1 DMA2 clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn dma2smen (& self) -> Dma2smenR { Dma2smenR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - CPU1 DMAMUX clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn dmamuxsmen (& self) -> DmamuxsmenR { DmamuxsmenR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 9 - CPU1 SRAM1 interface clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn sram1smen (& self) -> Sram1smenR { Sram1smenR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 12 - CPU1 CRCSMEN"]
#[inline (always)] pub fn crcsmen (& self) -> CrcsmenR { CrcsmenR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 16 - CPU1 Touch Sensing Controller clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn tscsmen (& self) -> TscsmenR { TscsmenR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bit 0 - CPU1 DMA1 clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn dma1smen (& mut self) -> Dma1smenW < '_ , Ahb1smenrSpec > { Dma1smenW :: new (self , 0) }
#[doc = "Bit 1 - CPU1 DMA2 clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn dma2smen (& mut self) -> Dma2smenW < '_ , Ahb1smenrSpec > { Dma2smenW :: new (self , 1) }
#[doc = "Bit 2 - CPU1 DMAMUX clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn dmamuxsmen (& mut self) -> DmamuxsmenW < '_ , Ahb1smenrSpec > { DmamuxsmenW :: new (self , 2) }
#[doc = "Bit 9 - CPU1 SRAM1 interface clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn sram1smen (& mut self) -> Sram1smenW < '_ , Ahb1smenrSpec > { Sram1smenW :: new (self , 9) }
#[doc = "Bit 12 - CPU1 CRCSMEN"]
#[inline (always)] pub fn crcsmen (& mut self) -> CrcsmenW < '_ , Ahb1smenrSpec > { CrcsmenW :: new (self , 12) }
#[doc = "Bit 16 - CPU1 Touch Sensing Controller clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn tscsmen (& mut self) -> TscsmenW < '_ , Ahb1smenrSpec > { TscsmenW :: new (self , 16) } }
#[doc = "AHB1 peripheral clocks enable in Sleep and Stop modes register\n\nYou can [`read`](crate::Reg::read) this register and get [`ahb1smenr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ahb1smenr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ahb1smenrSpec ; impl crate :: RegisterSpec for Ahb1smenrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ahb1smenr::R`](R) reader structure"] impl crate :: Readable for Ahb1smenrSpec { }
#[doc = "`write(|w| ..)` method takes [`ahb1smenr::W`](W) writer structure"] impl crate :: Writable for Ahb1smenrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AHB1SMENR to value 0x0001_1207"] impl crate :: Resettable for Ahb1smenrSpec { const RESET_VALUE : u32 = 0x0001_1207 ; } }
#[doc = "AHB2SMENR (rw) register accessor: AHB2 peripheral clocks enable in Sleep and Stop modes register\n\nYou can [`read`](crate::Reg::read) this register and get [`ahb2smenr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ahb2smenr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ahb2smenr`] module"]
#[doc (alias = "AHB2SMENR")] pub type Ahb2smenr = crate :: Reg < ahb2smenr :: Ahb2smenrSpec > ;
#[doc = "AHB2 peripheral clocks enable in Sleep and Stop modes register"] pub mod ahb2smenr {
#[doc = "Register `AHB2SMENR` reader"] pub type R = crate :: R < Ahb2smenrSpec > ;
#[doc = "Register `AHB2SMENR` writer"] pub type W = crate :: W < Ahb2smenrSpec > ;
#[doc = "Field `GPIOASMEN` reader - CPU1 IO port A clocks enable during Sleep and Stop modes"] pub type GpioasmenR = crate :: BitReader ;
#[doc = "Field `GPIOASMEN` writer - CPU1 IO port A clocks enable during Sleep and Stop modes"] pub type GpioasmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOBSMEN` reader - CPU1 IO port B clocks enable during Sleep and Stop modes"] pub type GpiobsmenR = crate :: BitReader ;
#[doc = "Field `GPIOBSMEN` writer - CPU1 IO port B clocks enable during Sleep and Stop modes"] pub type GpiobsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOCSMEN` reader - CPU1 IO port C clocks enable during Sleep and Stop modes"] pub type GpiocsmenR = crate :: BitReader ;
#[doc = "Field `GPIOCSMEN` writer - CPU1 IO port C clocks enable during Sleep and Stop modes"] pub type GpiocsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIODSMEN` reader - CPU1 IO port D clocks enable during Sleep and Stop modes"] pub type GpiodsmenR = crate :: BitReader ;
#[doc = "Field `GPIODSMEN` writer - CPU1 IO port D clocks enable during Sleep and Stop modes"] pub type GpiodsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOESMEN` reader - CPU1 IO port E clocks enable during Sleep and Stop modes"] pub type GpioesmenR = crate :: BitReader ;
#[doc = "Field `GPIOESMEN` writer - CPU1 IO port E clocks enable during Sleep and Stop modes"] pub type GpioesmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOHSMEN` reader - CPU1 IO port H clocks enable during Sleep and Stop modes"] pub type GpiohsmenR = crate :: BitReader ;
#[doc = "Field `GPIOHSMEN` writer - CPU1 IO port H clocks enable during Sleep and Stop modes"] pub type GpiohsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADCFSSMEN` reader - CPU1 ADC clocks enable during Sleep and Stop modes"] pub type AdcfssmenR = crate :: BitReader ;
#[doc = "Field `ADCFSSMEN` writer - CPU1 ADC clocks enable during Sleep and Stop modes"] pub type AdcfssmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AES1SMEN` reader - CPU1 AES1 accelerator clocks enable during Sleep and Stop modes"] pub type Aes1smenR = crate :: BitReader ;
#[doc = "Field `AES1SMEN` writer - CPU1 AES1 accelerator clocks enable during Sleep and Stop modes"] pub type Aes1smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - CPU1 IO port A clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn gpioasmen (& self) -> GpioasmenR { GpioasmenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - CPU1 IO port B clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn gpiobsmen (& self) -> GpiobsmenR { GpiobsmenR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - CPU1 IO port C clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn gpiocsmen (& self) -> GpiocsmenR { GpiocsmenR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - CPU1 IO port D clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn gpiodsmen (& self) -> GpiodsmenR { GpiodsmenR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - CPU1 IO port E clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn gpioesmen (& self) -> GpioesmenR { GpioesmenR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 7 - CPU1 IO port H clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn gpiohsmen (& self) -> GpiohsmenR { GpiohsmenR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 13 - CPU1 ADC clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn adcfssmen (& self) -> AdcfssmenR { AdcfssmenR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 16 - CPU1 AES1 accelerator clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn aes1smen (& self) -> Aes1smenR { Aes1smenR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bit 0 - CPU1 IO port A clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn gpioasmen (& mut self) -> GpioasmenW < '_ , Ahb2smenrSpec > { GpioasmenW :: new (self , 0) }
#[doc = "Bit 1 - CPU1 IO port B clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn gpiobsmen (& mut self) -> GpiobsmenW < '_ , Ahb2smenrSpec > { GpiobsmenW :: new (self , 1) }
#[doc = "Bit 2 - CPU1 IO port C clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn gpiocsmen (& mut self) -> GpiocsmenW < '_ , Ahb2smenrSpec > { GpiocsmenW :: new (self , 2) }
#[doc = "Bit 3 - CPU1 IO port D clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn gpiodsmen (& mut self) -> GpiodsmenW < '_ , Ahb2smenrSpec > { GpiodsmenW :: new (self , 3) }
#[doc = "Bit 4 - CPU1 IO port E clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn gpioesmen (& mut self) -> GpioesmenW < '_ , Ahb2smenrSpec > { GpioesmenW :: new (self , 4) }
#[doc = "Bit 7 - CPU1 IO port H clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn gpiohsmen (& mut self) -> GpiohsmenW < '_ , Ahb2smenrSpec > { GpiohsmenW :: new (self , 7) }
#[doc = "Bit 13 - CPU1 ADC clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn adcfssmen (& mut self) -> AdcfssmenW < '_ , Ahb2smenrSpec > { AdcfssmenW :: new (self , 13) }
#[doc = "Bit 16 - CPU1 AES1 accelerator clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn aes1smen (& mut self) -> Aes1smenW < '_ , Ahb2smenrSpec > { Aes1smenW :: new (self , 16) } }
#[doc = "AHB2 peripheral clocks enable in Sleep and Stop modes register\n\nYou can [`read`](crate::Reg::read) this register and get [`ahb2smenr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ahb2smenr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ahb2smenrSpec ; impl crate :: RegisterSpec for Ahb2smenrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ahb2smenr::R`](R) reader structure"] impl crate :: Readable for Ahb2smenrSpec { }
#[doc = "`write(|w| ..)` method takes [`ahb2smenr::W`](W) writer structure"] impl crate :: Writable for Ahb2smenrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AHB2SMENR to value 0x0001_209f"] impl crate :: Resettable for Ahb2smenrSpec { const RESET_VALUE : u32 = 0x0001_209f ; } }
#[doc = "AHB3SMENR (rw) register accessor: AHB3 peripheral clocks enable in Sleep and Stop modes register\n\nYou can [`read`](crate::Reg::read) this register and get [`ahb3smenr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ahb3smenr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ahb3smenr`] module"]
#[doc (alias = "AHB3SMENR")] pub type Ahb3smenr = crate :: Reg < ahb3smenr :: Ahb3smenrSpec > ;
#[doc = "AHB3 peripheral clocks enable in Sleep and Stop modes register"] pub mod ahb3smenr {
#[doc = "Register `AHB3SMENR` reader"] pub type R = crate :: R < Ahb3smenrSpec > ;
#[doc = "Register `AHB3SMENR` writer"] pub type W = crate :: W < Ahb3smenrSpec > ;
#[doc = "Field `QSPISMEN` reader - QSPISMEN"] pub type QspismenR = crate :: BitReader ;
#[doc = "Field `QSPISMEN` writer - QSPISMEN"] pub type QspismenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PKASMEN` reader - PKA accelerator clocks enable during CPU1 sleep mode"] pub type PkasmenR = crate :: BitReader ;
#[doc = "Field `PKASMEN` writer - PKA accelerator clocks enable during CPU1 sleep mode"] pub type PkasmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AES2SMEN` reader - AES2 accelerator clocks enable during CPU1 sleep mode"] pub type Aes2smenR = crate :: BitReader ;
#[doc = "Field `AES2SMEN` writer - AES2 accelerator clocks enable during CPU1 sleep mode"] pub type Aes2smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RNGSMEN` reader - True RNG clocks enable during CPU1 sleep mode"] pub type RngsmenR = crate :: BitReader ;
#[doc = "Field `RNGSMEN` writer - True RNG clocks enable during CPU1 sleep mode"] pub type RngsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SRAM2SMEN` reader - SRAM2a and SRAM2b memory interface clocks enable during CPU1 sleep mode"] pub type Sram2smenR = crate :: BitReader ;
#[doc = "Field `SRAM2SMEN` writer - SRAM2a and SRAM2b memory interface clocks enable during CPU1 sleep mode"] pub type Sram2smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FLASHSMEN` reader - Flash interface clocks enable during CPU1 sleep mode"] pub type FlashsmenR = crate :: BitReader ;
#[doc = "Field `FLASHSMEN` writer - Flash interface clocks enable during CPU1 sleep mode"] pub type FlashsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 8 - QSPISMEN"]
#[inline (always)] pub fn qspismen (& self) -> QspismenR { QspismenR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 16 - PKA accelerator clocks enable during CPU1 sleep mode"]
#[inline (always)] pub fn pkasmen (& self) -> PkasmenR { PkasmenR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - AES2 accelerator clocks enable during CPU1 sleep mode"]
#[inline (always)] pub fn aes2smen (& self) -> Aes2smenR { Aes2smenR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - True RNG clocks enable during CPU1 sleep mode"]
#[inline (always)] pub fn rngsmen (& self) -> RngsmenR { RngsmenR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 24 - SRAM2a and SRAM2b memory interface clocks enable during CPU1 sleep mode"]
#[inline (always)] pub fn sram2smen (& self) -> Sram2smenR { Sram2smenR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Flash interface clocks enable during CPU1 sleep mode"]
#[inline (always)] pub fn flashsmen (& self) -> FlashsmenR { FlashsmenR :: new (((self . bits >> 25) & 1) != 0) } } impl W {
#[doc = "Bit 8 - QSPISMEN"]
#[inline (always)] pub fn qspismen (& mut self) -> QspismenW < '_ , Ahb3smenrSpec > { QspismenW :: new (self , 8) }
#[doc = "Bit 16 - PKA accelerator clocks enable during CPU1 sleep mode"]
#[inline (always)] pub fn pkasmen (& mut self) -> PkasmenW < '_ , Ahb3smenrSpec > { PkasmenW :: new (self , 16) }
#[doc = "Bit 17 - AES2 accelerator clocks enable during CPU1 sleep mode"]
#[inline (always)] pub fn aes2smen (& mut self) -> Aes2smenW < '_ , Ahb3smenrSpec > { Aes2smenW :: new (self , 17) }
#[doc = "Bit 18 - True RNG clocks enable during CPU1 sleep mode"]
#[inline (always)] pub fn rngsmen (& mut self) -> RngsmenW < '_ , Ahb3smenrSpec > { RngsmenW :: new (self , 18) }
#[doc = "Bit 24 - SRAM2a and SRAM2b memory interface clocks enable during CPU1 sleep mode"]
#[inline (always)] pub fn sram2smen (& mut self) -> Sram2smenW < '_ , Ahb3smenrSpec > { Sram2smenW :: new (self , 24) }
#[doc = "Bit 25 - Flash interface clocks enable during CPU1 sleep mode"]
#[inline (always)] pub fn flashsmen (& mut self) -> FlashsmenW < '_ , Ahb3smenrSpec > { FlashsmenW :: new (self , 25) } }
#[doc = "AHB3 peripheral clocks enable in Sleep and Stop modes register\n\nYou can [`read`](crate::Reg::read) this register and get [`ahb3smenr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ahb3smenr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ahb3smenrSpec ; impl crate :: RegisterSpec for Ahb3smenrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ahb3smenr::R`](R) reader structure"] impl crate :: Readable for Ahb3smenrSpec { }
#[doc = "`write(|w| ..)` method takes [`ahb3smenr::W`](W) writer structure"] impl crate :: Writable for Ahb3smenrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AHB3SMENR to value 0x0307_0100"] impl crate :: Resettable for Ahb3smenrSpec { const RESET_VALUE : u32 = 0x0307_0100 ; } }
#[doc = "APB1SMENR1 (rw) register accessor: APB1SMENR1\n\nYou can [`read`](crate::Reg::read) this register and get [`apb1smenr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb1smenr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@apb1smenr1`] module"]
#[doc (alias = "APB1SMENR1")] pub type Apb1smenr1 = crate :: Reg < apb1smenr1 :: Apb1smenr1Spec > ;
#[doc = "APB1SMENR1"] pub mod apb1smenr1 {
#[doc = "Register `APB1SMENR1` reader"] pub type R = crate :: R < Apb1smenr1Spec > ;
#[doc = "Register `APB1SMENR1` writer"] pub type W = crate :: W < Apb1smenr1Spec > ;
#[doc = "Field `TIM2SMEN` reader - TIM2 timer clocks enable during CPU1 Sleep mode"] pub type Tim2smenR = crate :: BitReader ;
#[doc = "Field `TIM2SMEN` writer - TIM2 timer clocks enable during CPU1 Sleep mode"] pub type Tim2smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCDSMEN` reader - LCD clocks enable during CPU1 Sleep mode"] pub type LcdsmenR = crate :: BitReader ;
#[doc = "Field `LCDSMEN` writer - LCD clocks enable during CPU1 Sleep mode"] pub type LcdsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RTCAPBSMEN` reader - RTC APB clocks enable during CPU1 Sleep mode"] pub type RtcapbsmenR = crate :: BitReader ;
#[doc = "Field `RTCAPBSMEN` writer - RTC APB clocks enable during CPU1 Sleep mode"] pub type RtcapbsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WWDGSMEN` reader - Window watchdog clocks enable during CPU1 Sleep mode"] pub type WwdgsmenR = crate :: BitReader ;
#[doc = "Field `WWDGSMEN` writer - Window watchdog clocks enable during CPU1 Sleep mode"] pub type WwdgsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPI2SMEN` reader - SPI2 clocks enable during CPU1 Sleep mode"] pub type Spi2smenR = crate :: BitReader ;
#[doc = "Field `SPI2SMEN` writer - SPI2 clocks enable during CPU1 Sleep mode"] pub type Spi2smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `I2C1SMEN` reader - I2C1 clocks enable during CPU1 Sleep mode"] pub type I2c1smenR = crate :: BitReader ;
#[doc = "Field `I2C1SMEN` writer - I2C1 clocks enable during CPU1 Sleep mode"] pub type I2c1smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `I2C3SMEN` reader - I2C3 clocks enable during CPU1 Sleep mode"] pub type I2c3smenR = crate :: BitReader ;
#[doc = "Field `I2C3SMEN` writer - I2C3 clocks enable during CPU1 Sleep mode"] pub type I2c3smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CRSMEN` reader - CRS clocks enable during CPU1 Sleep mode"] pub type CrsmenR = crate :: BitReader ;
#[doc = "Field `CRSMEN` writer - CRS clocks enable during CPU1 Sleep mode"] pub type CrsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `USBSMEN` reader - USB FS clocks enable during CPU1 Sleep mode"] pub type UsbsmenR = crate :: BitReader ;
#[doc = "Field `USBSMEN` writer - USB FS clocks enable during CPU1 Sleep mode"] pub type UsbsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LPTIM1SMEN` reader - Low power timer 1 clocks enable during CPU1 Sleep mode"] pub type Lptim1smenR = crate :: BitReader ;
#[doc = "Field `LPTIM1SMEN` writer - Low power timer 1 clocks enable during CPU1 Sleep mode"] pub type Lptim1smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - TIM2 timer clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn tim2smen (& self) -> Tim2smenR { Tim2smenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 9 - LCD clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn lcdsmen (& self) -> LcdsmenR { LcdsmenR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - RTC APB clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn rtcapbsmen (& self) -> RtcapbsmenR { RtcapbsmenR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Window watchdog clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn wwdgsmen (& self) -> WwdgsmenR { WwdgsmenR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 14 - SPI2 clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn spi2smen (& self) -> Spi2smenR { Spi2smenR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 21 - I2C1 clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn i2c1smen (& self) -> I2c1smenR { I2c1smenR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 23 - I2C3 clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn i2c3smen (& self) -> I2c3smenR { I2c3smenR :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - CRS clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn crsmen (& self) -> CrsmenR { CrsmenR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 26 - USB FS clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn usbsmen (& self) -> UsbsmenR { UsbsmenR :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 31 - Low power timer 1 clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn lptim1smen (& self) -> Lptim1smenR { Lptim1smenR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - TIM2 timer clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn tim2smen (& mut self) -> Tim2smenW < '_ , Apb1smenr1Spec > { Tim2smenW :: new (self , 0) }
#[doc = "Bit 9 - LCD clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn lcdsmen (& mut self) -> LcdsmenW < '_ , Apb1smenr1Spec > { LcdsmenW :: new (self , 9) }
#[doc = "Bit 10 - RTC APB clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn rtcapbsmen (& mut self) -> RtcapbsmenW < '_ , Apb1smenr1Spec > { RtcapbsmenW :: new (self , 10) }
#[doc = "Bit 11 - Window watchdog clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn wwdgsmen (& mut self) -> WwdgsmenW < '_ , Apb1smenr1Spec > { WwdgsmenW :: new (self , 11) }
#[doc = "Bit 14 - SPI2 clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn spi2smen (& mut self) -> Spi2smenW < '_ , Apb1smenr1Spec > { Spi2smenW :: new (self , 14) }
#[doc = "Bit 21 - I2C1 clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn i2c1smen (& mut self) -> I2c1smenW < '_ , Apb1smenr1Spec > { I2c1smenW :: new (self , 21) }
#[doc = "Bit 23 - I2C3 clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn i2c3smen (& mut self) -> I2c3smenW < '_ , Apb1smenr1Spec > { I2c3smenW :: new (self , 23) }
#[doc = "Bit 24 - CRS clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn crsmen (& mut self) -> CrsmenW < '_ , Apb1smenr1Spec > { CrsmenW :: new (self , 24) }
#[doc = "Bit 26 - USB FS clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn usbsmen (& mut self) -> UsbsmenW < '_ , Apb1smenr1Spec > { UsbsmenW :: new (self , 26) }
#[doc = "Bit 31 - Low power timer 1 clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn lptim1smen (& mut self) -> Lptim1smenW < '_ , Apb1smenr1Spec > { Lptim1smenW :: new (self , 31) } }
#[doc = "APB1SMENR1\n\nYou can [`read`](crate::Reg::read) this register and get [`apb1smenr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb1smenr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Apb1smenr1Spec ; impl crate :: RegisterSpec for Apb1smenr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`apb1smenr1::R`](R) reader structure"] impl crate :: Readable for Apb1smenr1Spec { }
#[doc = "`write(|w| ..)` method takes [`apb1smenr1::W`](W) writer structure"] impl crate :: Writable for Apb1smenr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets APB1SMENR1 to value 0x85a0_4e01"] impl crate :: Resettable for Apb1smenr1Spec { const RESET_VALUE : u32 = 0x85a0_4e01 ; } }
#[doc = "APB1SMENR2 (rw) register accessor: APB1 peripheral clocks enable in Sleep and Stop modes register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`apb1smenr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb1smenr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@apb1smenr2`] module"]
#[doc (alias = "APB1SMENR2")] pub type Apb1smenr2 = crate :: Reg < apb1smenr2 :: Apb1smenr2Spec > ;
#[doc = "APB1 peripheral clocks enable in Sleep and Stop modes register 2"] pub mod apb1smenr2 {
#[doc = "Register `APB1SMENR2` reader"] pub type R = crate :: R < Apb1smenr2Spec > ;
#[doc = "Register `APB1SMENR2` writer"] pub type W = crate :: W < Apb1smenr2Spec > ;
#[doc = "Field `LPUART1SMEN` reader - Low power UART 1 clocks enable during CPU1 Sleep mode"] pub type Lpuart1smenR = crate :: BitReader ;
#[doc = "Field `LPUART1SMEN` writer - Low power UART 1 clocks enable during CPU1 Sleep mode"] pub type Lpuart1smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LPTIM2SMEN` reader - Low power timer 2 clocks enable during CPU1 Sleep mode"] pub type Lptim2smenR = crate :: BitReader ;
#[doc = "Field `LPTIM2SMEN` writer - Low power timer 2 clocks enable during CPU1 Sleep mode"] pub type Lptim2smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Low power UART 1 clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn lpuart1smen (& self) -> Lpuart1smenR { Lpuart1smenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 5 - Low power timer 2 clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn lptim2smen (& self) -> Lptim2smenR { Lptim2smenR :: new (((self . bits >> 5) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Low power UART 1 clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn lpuart1smen (& mut self) -> Lpuart1smenW < '_ , Apb1smenr2Spec > { Lpuart1smenW :: new (self , 0) }
#[doc = "Bit 5 - Low power timer 2 clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn lptim2smen (& mut self) -> Lptim2smenW < '_ , Apb1smenr2Spec > { Lptim2smenW :: new (self , 5) } }
#[doc = "APB1 peripheral clocks enable in Sleep and Stop modes register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`apb1smenr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb1smenr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Apb1smenr2Spec ; impl crate :: RegisterSpec for Apb1smenr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`apb1smenr2::R`](R) reader structure"] impl crate :: Readable for Apb1smenr2Spec { }
#[doc = "`write(|w| ..)` method takes [`apb1smenr2::W`](W) writer structure"] impl crate :: Writable for Apb1smenr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets APB1SMENR2 to value 0x21"] impl crate :: Resettable for Apb1smenr2Spec { const RESET_VALUE : u32 = 0x21 ; } }
#[doc = "APB2SMENR (rw) register accessor: APB2SMENR\n\nYou can [`read`](crate::Reg::read) this register and get [`apb2smenr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb2smenr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@apb2smenr`] module"]
#[doc (alias = "APB2SMENR")] pub type Apb2smenr = crate :: Reg < apb2smenr :: Apb2smenrSpec > ;
#[doc = "APB2SMENR"] pub mod apb2smenr {
#[doc = "Register `APB2SMENR` reader"] pub type R = crate :: R < Apb2smenrSpec > ;
#[doc = "Register `APB2SMENR` writer"] pub type W = crate :: W < Apb2smenrSpec > ;
#[doc = "Field `TIM1SMEN` reader - TIM1 timer clocks enable during CPU1 Sleep mode"] pub type Tim1smenR = crate :: BitReader ;
#[doc = "Field `TIM1SMEN` writer - TIM1 timer clocks enable during CPU1 Sleep mode"] pub type Tim1smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPI1SMEN` reader - SPI1 clocks enable during CPU1 Sleep mode"] pub type Spi1smenR = crate :: BitReader ;
#[doc = "Field `SPI1SMEN` writer - SPI1 clocks enable during CPU1 Sleep mode"] pub type Spi1smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `USART1SMEN` reader - USART1clocks enable during CPU1 Sleep mode"] pub type Usart1smenR = crate :: BitReader ;
#[doc = "Field `USART1SMEN` writer - USART1clocks enable during CPU1 Sleep mode"] pub type Usart1smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM16SMEN` reader - TIM16 timer clocks enable during CPU1 Sleep mode"] pub type Tim16smenR = crate :: BitReader ;
#[doc = "Field `TIM16SMEN` writer - TIM16 timer clocks enable during CPU1 Sleep mode"] pub type Tim16smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM17SMEN` reader - TIM17 timer clocks enable during CPU1 Sleep mode"] pub type Tim17smenR = crate :: BitReader ;
#[doc = "Field `TIM17SMEN` writer - TIM17 timer clocks enable during CPU1 Sleep mode"] pub type Tim17smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SAI1SMEN` reader - SAI1 clocks enable during CPU1 Sleep mode"] pub type Sai1smenR = crate :: BitReader ;
#[doc = "Field `SAI1SMEN` writer - SAI1 clocks enable during CPU1 Sleep mode"] pub type Sai1smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 11 - TIM1 timer clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn tim1smen (& self) -> Tim1smenR { Tim1smenR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - SPI1 clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn spi1smen (& self) -> Spi1smenR { Spi1smenR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 14 - USART1clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn usart1smen (& self) -> Usart1smenR { Usart1smenR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 17 - TIM16 timer clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn tim16smen (& self) -> Tim16smenR { Tim16smenR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - TIM17 timer clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn tim17smen (& self) -> Tim17smenR { Tim17smenR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 21 - SAI1 clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn sai1smen (& self) -> Sai1smenR { Sai1smenR :: new (((self . bits >> 21) & 1) != 0) } } impl W {
#[doc = "Bit 11 - TIM1 timer clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn tim1smen (& mut self) -> Tim1smenW < '_ , Apb2smenrSpec > { Tim1smenW :: new (self , 11) }
#[doc = "Bit 12 - SPI1 clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn spi1smen (& mut self) -> Spi1smenW < '_ , Apb2smenrSpec > { Spi1smenW :: new (self , 12) }
#[doc = "Bit 14 - USART1clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn usart1smen (& mut self) -> Usart1smenW < '_ , Apb2smenrSpec > { Usart1smenW :: new (self , 14) }
#[doc = "Bit 17 - TIM16 timer clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn tim16smen (& mut self) -> Tim16smenW < '_ , Apb2smenrSpec > { Tim16smenW :: new (self , 17) }
#[doc = "Bit 18 - TIM17 timer clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn tim17smen (& mut self) -> Tim17smenW < '_ , Apb2smenrSpec > { Tim17smenW :: new (self , 18) }
#[doc = "Bit 21 - SAI1 clocks enable during CPU1 Sleep mode"]
#[inline (always)] pub fn sai1smen (& mut self) -> Sai1smenW < '_ , Apb2smenrSpec > { Sai1smenW :: new (self , 21) } }
#[doc = "APB2SMENR\n\nYou can [`read`](crate::Reg::read) this register and get [`apb2smenr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb2smenr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Apb2smenrSpec ; impl crate :: RegisterSpec for Apb2smenrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`apb2smenr::R`](R) reader structure"] impl crate :: Readable for Apb2smenrSpec { }
#[doc = "`write(|w| ..)` method takes [`apb2smenr::W`](W) writer structure"] impl crate :: Writable for Apb2smenrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets APB2SMENR to value 0x0026_5800"] impl crate :: Resettable for Apb2smenrSpec { const RESET_VALUE : u32 = 0x0026_5800 ; } }
#[doc = "CCIPR (rw) register accessor: CCIPR\n\nYou can [`read`](crate::Reg::read) this register and get [`ccipr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccipr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccipr`] module"]
#[doc (alias = "CCIPR")] pub type Ccipr = crate :: Reg < ccipr :: CciprSpec > ;
#[doc = "CCIPR"] pub mod ccipr {
#[doc = "Register `CCIPR` reader"] pub type R = crate :: R < CciprSpec > ;
#[doc = "Register `CCIPR` writer"] pub type W = crate :: W < CciprSpec > ;
#[doc = "Field `USART1SEL` reader - USART1 clock source selection"] pub type Usart1selR = crate :: FieldReader ;
#[doc = "Field `USART1SEL` writer - USART1 clock source selection"] pub type Usart1selW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `LPUART1SEL` reader - LPUART1 clock source selection"] pub type Lpuart1selR = crate :: FieldReader ;
#[doc = "Field `LPUART1SEL` writer - LPUART1 clock source selection"] pub type Lpuart1selW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `I2C1SEL` reader - I2C1 clock source selection"] pub type I2c1selR = crate :: FieldReader ;
#[doc = "Field `I2C1SEL` writer - I2C1 clock source selection"] pub type I2c1selW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `I2C3SEL` reader - I2C3 clock source selection"] pub type I2c3selR = crate :: FieldReader ;
#[doc = "Field `I2C3SEL` writer - I2C3 clock source selection"] pub type I2c3selW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `LPTIM1SEL` reader - Low power timer 1 clock source selection"] pub type Lptim1selR = crate :: FieldReader ;
#[doc = "Field `LPTIM1SEL` writer - Low power timer 1 clock source selection"] pub type Lptim1selW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `LPTIM2SEL` reader - Low power timer 2 clock source selection"] pub type Lptim2selR = crate :: FieldReader ;
#[doc = "Field `LPTIM2SEL` writer - Low power timer 2 clock source selection"] pub type Lptim2selW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SAI1SEL` reader - SAI1 clock source selection"] pub type Sai1selR = crate :: FieldReader ;
#[doc = "Field `SAI1SEL` writer - SAI1 clock source selection"] pub type Sai1selW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CLK48SEL` reader - 48 MHz clock source selection"] pub type Clk48selR = crate :: FieldReader ;
#[doc = "Field `CLK48SEL` writer - 48 MHz clock source selection"] pub type Clk48selW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ADCSEL` reader - ADCs clock source selection"] pub type AdcselR = crate :: FieldReader ;
#[doc = "Field `ADCSEL` writer - ADCs clock source selection"] pub type AdcselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `RNGSEL` reader - RNG clock source selection"] pub type RngselR = crate :: FieldReader ;
#[doc = "Field `RNGSEL` writer - RNG clock source selection"] pub type RngselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:1 - USART1 clock source selection"]
#[inline (always)] pub fn usart1sel (& self) -> Usart1selR { Usart1selR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 10:11 - LPUART1 clock source selection"]
#[inline (always)] pub fn lpuart1sel (& self) -> Lpuart1selR { Lpuart1selR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - I2C1 clock source selection"]
#[inline (always)] pub fn i2c1sel (& self) -> I2c1selR { I2c1selR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bits 16:17 - I2C3 clock source selection"]
#[inline (always)] pub fn i2c3sel (& self) -> I2c3selR { I2c3selR :: new (((self . bits >> 16) & 3) as u8) }
#[doc = "Bits 18:19 - Low power timer 1 clock source selection"]
#[inline (always)] pub fn lptim1sel (& self) -> Lptim1selR { Lptim1selR :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bits 20:21 - Low power timer 2 clock source selection"]
#[inline (always)] pub fn lptim2sel (& self) -> Lptim2selR { Lptim2selR :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bits 22:23 - SAI1 clock source selection"]
#[inline (always)] pub fn sai1sel (& self) -> Sai1selR { Sai1selR :: new (((self . bits >> 22) & 3) as u8) }
#[doc = "Bits 26:27 - 48 MHz clock source selection"]
#[inline (always)] pub fn clk48sel (& self) -> Clk48selR { Clk48selR :: new (((self . bits >> 26) & 3) as u8) }
#[doc = "Bits 28:29 - ADCs clock source selection"]
#[inline (always)] pub fn adcsel (& self) -> AdcselR { AdcselR :: new (((self . bits >> 28) & 3) as u8) }
#[doc = "Bits 30:31 - RNG clock source selection"]
#[inline (always)] pub fn rngsel (& self) -> RngselR { RngselR :: new (((self . bits >> 30) & 3) as u8) } } impl W {
#[doc = "Bits 0:1 - USART1 clock source selection"]
#[inline (always)] pub fn usart1sel (& mut self) -> Usart1selW < '_ , CciprSpec > { Usart1selW :: new (self , 0) }
#[doc = "Bits 10:11 - LPUART1 clock source selection"]
#[inline (always)] pub fn lpuart1sel (& mut self) -> Lpuart1selW < '_ , CciprSpec > { Lpuart1selW :: new (self , 10) }
#[doc = "Bits 12:13 - I2C1 clock source selection"]
#[inline (always)] pub fn i2c1sel (& mut self) -> I2c1selW < '_ , CciprSpec > { I2c1selW :: new (self , 12) }
#[doc = "Bits 16:17 - I2C3 clock source selection"]
#[inline (always)] pub fn i2c3sel (& mut self) -> I2c3selW < '_ , CciprSpec > { I2c3selW :: new (self , 16) }
#[doc = "Bits 18:19 - Low power timer 1 clock source selection"]
#[inline (always)] pub fn lptim1sel (& mut self) -> Lptim1selW < '_ , CciprSpec > { Lptim1selW :: new (self , 18) }
#[doc = "Bits 20:21 - Low power timer 2 clock source selection"]
#[inline (always)] pub fn lptim2sel (& mut self) -> Lptim2selW < '_ , CciprSpec > { Lptim2selW :: new (self , 20) }
#[doc = "Bits 22:23 - SAI1 clock source selection"]
#[inline (always)] pub fn sai1sel (& mut self) -> Sai1selW < '_ , CciprSpec > { Sai1selW :: new (self , 22) }
#[doc = "Bits 26:27 - 48 MHz clock source selection"]
#[inline (always)] pub fn clk48sel (& mut self) -> Clk48selW < '_ , CciprSpec > { Clk48selW :: new (self , 26) }
#[doc = "Bits 28:29 - ADCs clock source selection"]
#[inline (always)] pub fn adcsel (& mut self) -> AdcselW < '_ , CciprSpec > { AdcselW :: new (self , 28) }
#[doc = "Bits 30:31 - RNG clock source selection"]
#[inline (always)] pub fn rngsel (& mut self) -> RngselW < '_ , CciprSpec > { RngselW :: new (self , 30) } }
#[doc = "CCIPR\n\nYou can [`read`](crate::Reg::read) this register and get [`ccipr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccipr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CciprSpec ; impl crate :: RegisterSpec for CciprSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccipr::R`](R) reader structure"] impl crate :: Readable for CciprSpec { }
#[doc = "`write(|w| ..)` method takes [`ccipr::W`](W) writer structure"] impl crate :: Writable for CciprSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCIPR to value 0"] impl crate :: Resettable for CciprSpec { } }
#[doc = "BDCR (rw) register accessor: BDCR\n\nYou can [`read`](crate::Reg::read) this register and get [`bdcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bdcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bdcr`] module"]
#[doc (alias = "BDCR")] pub type Bdcr = crate :: Reg < bdcr :: BdcrSpec > ;
#[doc = "BDCR"] pub mod bdcr {
#[doc = "Register `BDCR` reader"] pub type R = crate :: R < BdcrSpec > ;
#[doc = "Register `BDCR` writer"] pub type W = crate :: W < BdcrSpec > ;
#[doc = "Field `LSEON` reader - LSE oscillator enable"] pub type LseonR = crate :: BitReader ;
#[doc = "Field `LSEON` writer - LSE oscillator enable"] pub type LseonW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSERDY` reader - LSE oscillator ready"] pub type LserdyR = crate :: BitReader ;
#[doc = "Field `LSEBYP` reader - LSE oscillator bypass"] pub type LsebypR = crate :: BitReader ;
#[doc = "Field `LSEBYP` writer - LSE oscillator bypass"] pub type LsebypW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSEDRV` reader - SE oscillator drive capability"] pub type LsedrvR = crate :: FieldReader ;
#[doc = "Field `LSEDRV` writer - SE oscillator drive capability"] pub type LsedrvW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `LSECSSON` reader - LSECSSON"] pub type LsecssonR = crate :: BitReader ;
#[doc = "Field `LSECSSON` writer - LSECSSON"] pub type LsecssonW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSECSSD_` reader - CSS on LSE failure detection"] pub type Lsecssd_R = crate :: BitReader ;
#[doc = "Field `RTCSEL` reader - RTC clock source selection"] pub type RtcselR = crate :: FieldReader ;
#[doc = "Field `RTCSEL` writer - RTC clock source selection"] pub type RtcselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `RTCEN` reader - RTC clock enable"] pub type RtcenR = crate :: BitReader ;
#[doc = "Field `RTCEN` writer - RTC clock enable"] pub type RtcenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BDRST` reader - Backup domain software reset"] pub type BdrstR = crate :: BitReader ;
#[doc = "Field `BDRST` writer - Backup domain software reset"] pub type BdrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSCOEN` reader - Low speed clock output enable"] pub type LscoenR = crate :: BitReader ;
#[doc = "Field `LSCOEN` writer - Low speed clock output enable"] pub type LscoenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSCOSEL` reader - Low speed clock output selection"] pub type LscoselR = crate :: BitReader ;
#[doc = "Field `LSCOSEL` writer - Low speed clock output selection"] pub type LscoselW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - LSE oscillator enable"]
#[inline (always)] pub fn lseon (& self) -> LseonR { LseonR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - LSE oscillator ready"]
#[inline (always)] pub fn lserdy (& self) -> LserdyR { LserdyR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - LSE oscillator bypass"]
#[inline (always)] pub fn lsebyp (& self) -> LsebypR { LsebypR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 3:4 - SE oscillator drive capability"]
#[inline (always)] pub fn lsedrv (& self) -> LsedrvR { LsedrvR :: new (((self . bits >> 3) & 3) as u8) }
#[doc = "Bit 5 - LSECSSON"]
#[inline (always)] pub fn lsecsson (& self) -> LsecssonR { LsecssonR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - CSS on LSE failure detection"]
#[inline (always)] pub fn lsecssd_ (& self) -> Lsecssd_R { Lsecssd_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bits 8:9 - RTC clock source selection"]
#[inline (always)] pub fn rtcsel (& self) -> RtcselR { RtcselR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 15 - RTC clock enable"]
#[inline (always)] pub fn rtcen (& self) -> RtcenR { RtcenR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Backup domain software reset"]
#[inline (always)] pub fn bdrst (& self) -> BdrstR { BdrstR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 24 - Low speed clock output enable"]
#[inline (always)] pub fn lscoen (& self) -> LscoenR { LscoenR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Low speed clock output selection"]
#[inline (always)] pub fn lscosel (& self) -> LscoselR { LscoselR :: new (((self . bits >> 25) & 1) != 0) } } impl W {
#[doc = "Bit 0 - LSE oscillator enable"]
#[inline (always)] pub fn lseon (& mut self) -> LseonW < '_ , BdcrSpec > { LseonW :: new (self , 0) }
#[doc = "Bit 2 - LSE oscillator bypass"]
#[inline (always)] pub fn lsebyp (& mut self) -> LsebypW < '_ , BdcrSpec > { LsebypW :: new (self , 2) }
#[doc = "Bits 3:4 - SE oscillator drive capability"]
#[inline (always)] pub fn lsedrv (& mut self) -> LsedrvW < '_ , BdcrSpec > { LsedrvW :: new (self , 3) }
#[doc = "Bit 5 - LSECSSON"]
#[inline (always)] pub fn lsecsson (& mut self) -> LsecssonW < '_ , BdcrSpec > { LsecssonW :: new (self , 5) }
#[doc = "Bits 8:9 - RTC clock source selection"]
#[inline (always)] pub fn rtcsel (& mut self) -> RtcselW < '_ , BdcrSpec > { RtcselW :: new (self , 8) }
#[doc = "Bit 15 - RTC clock enable"]
#[inline (always)] pub fn rtcen (& mut self) -> RtcenW < '_ , BdcrSpec > { RtcenW :: new (self , 15) }
#[doc = "Bit 16 - Backup domain software reset"]
#[inline (always)] pub fn bdrst (& mut self) -> BdrstW < '_ , BdcrSpec > { BdrstW :: new (self , 16) }
#[doc = "Bit 24 - Low speed clock output enable"]
#[inline (always)] pub fn lscoen (& mut self) -> LscoenW < '_ , BdcrSpec > { LscoenW :: new (self , 24) }
#[doc = "Bit 25 - Low speed clock output selection"]
#[inline (always)] pub fn lscosel (& mut self) -> LscoselW < '_ , BdcrSpec > { LscoselW :: new (self , 25) } }
#[doc = "BDCR\n\nYou can [`read`](crate::Reg::read) this register and get [`bdcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bdcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BdcrSpec ; impl crate :: RegisterSpec for BdcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bdcr::R`](R) reader structure"] impl crate :: Readable for BdcrSpec { }
#[doc = "`write(|w| ..)` method takes [`bdcr::W`](W) writer structure"] impl crate :: Writable for BdcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BDCR to value 0"] impl crate :: Resettable for BdcrSpec { } }
#[doc = "CSR (rw) register accessor: CSR\n\nYou can [`read`](crate::Reg::read) this register and get [`csr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`csr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@csr`] module"]
#[doc (alias = "CSR")] pub type Csr = crate :: Reg < csr :: CsrSpec > ;
#[doc = "CSR"] pub mod csr {
#[doc = "Register `CSR` reader"] pub type R = crate :: R < CsrSpec > ;
#[doc = "Register `CSR` writer"] pub type W = crate :: W < CsrSpec > ;
#[doc = "Field `LSI1ON` reader - LSI1 oscillator enabled"] pub type Lsi1onR = crate :: BitReader ;
#[doc = "Field `LSI1ON` writer - LSI1 oscillator enabled"] pub type Lsi1onW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSI1RDY` reader - LSI1 oscillator ready"] pub type Lsi1rdyR = crate :: BitReader ;
#[doc = "Field `LSI2ON` reader - LSI2 oscillator enabled"] pub type Lsi2onR = crate :: BitReader ;
#[doc = "Field `LSI2ON` writer - LSI2 oscillator enabled"] pub type Lsi2onW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSI2RDY` reader - LSI2 oscillator ready"] pub type Lsi2rdyR = crate :: BitReader ;
#[doc = "Field `LSI2TRIMEN` reader - LSI2 oscillator trimming enable"] pub type Lsi2trimenR = crate :: BitReader ;
#[doc = "Field `LSI2TRIMEN` writer - LSI2 oscillator trimming enable"] pub type Lsi2trimenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSI2TRIMOK` reader - LSI2 oscillator trim OK"] pub type Lsi2trimokR = crate :: BitReader ;
#[doc = "Field `LSI2BW` reader - LSI2 oscillator bias configuration"] pub type Lsi2bwR = crate :: FieldReader ;
#[doc = "Field `LSI2BW` writer - LSI2 oscillator bias configuration"] pub type Lsi2bwW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `RFWKPSEL` reader - RF system wakeup clock source selection"] pub type RfwkpselR = crate :: FieldReader ;
#[doc = "Field `RFWKPSEL` writer - RF system wakeup clock source selection"] pub type RfwkpselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `RFRSTS` reader - Radio system BLE and 802.15.4 reset status"] pub type RfrstsR = crate :: BitReader ;
#[doc = "Field `RMVF` reader - Remove reset flag"] pub type RmvfR = crate :: BitReader ;
#[doc = "Field `RMVF` writer - Remove reset flag"] pub type RmvfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OBLRSTF` reader - Option byte loader reset flag"] pub type OblrstfR = crate :: BitReader ;
#[doc = "Field `PINRSTF` reader - Pin reset flag"] pub type PinrstfR = crate :: BitReader ;
#[doc = "Field `BORRSTF` reader - BOR flag"] pub type BorrstfR = crate :: BitReader ;
#[doc = "Field `SFTRSTF` reader - Software reset flag"] pub type SftrstfR = crate :: BitReader ;
#[doc = "Field `IWDGRSTF` reader - Independent window watchdog reset flag"] pub type IwdgrstfR = crate :: BitReader ;
#[doc = "Field `WWDGRSTF` reader - Window watchdog reset flag"] pub type WwdgrstfR = crate :: BitReader ;
#[doc = "Field `LPWRRSTF` reader - Low-power reset flag"] pub type LpwrrstfR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - LSI1 oscillator enabled"]
#[inline (always)] pub fn lsi1on (& self) -> Lsi1onR { Lsi1onR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - LSI1 oscillator ready"]
#[inline (always)] pub fn lsi1rdy (& self) -> Lsi1rdyR { Lsi1rdyR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - LSI2 oscillator enabled"]
#[inline (always)] pub fn lsi2on (& self) -> Lsi2onR { Lsi2onR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - LSI2 oscillator ready"]
#[inline (always)] pub fn lsi2rdy (& self) -> Lsi2rdyR { Lsi2rdyR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - LSI2 oscillator trimming enable"]
#[inline (always)] pub fn lsi2trimen (& self) -> Lsi2trimenR { Lsi2trimenR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - LSI2 oscillator trim OK"]
#[inline (always)] pub fn lsi2trimok (& self) -> Lsi2trimokR { Lsi2trimokR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bits 8:11 - LSI2 oscillator bias configuration"]
#[inline (always)] pub fn lsi2bw (& self) -> Lsi2bwR { Lsi2bwR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 14:15 - RF system wakeup clock source selection"]
#[inline (always)] pub fn rfwkpsel (& self) -> RfwkpselR { RfwkpselR :: new (((self . bits >> 14) & 3) as u8) }
#[doc = "Bit 16 - Radio system BLE and 802.15.4 reset status"]
#[inline (always)] pub fn rfrsts (& self) -> RfrstsR { RfrstsR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 23 - Remove reset flag"]
#[inline (always)] pub fn rmvf (& self) -> RmvfR { RmvfR :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 25 - Option byte loader reset flag"]
#[inline (always)] pub fn oblrstf (& self) -> OblrstfR { OblrstfR :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Pin reset flag"]
#[inline (always)] pub fn pinrstf (& self) -> PinrstfR { PinrstfR :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - BOR flag"]
#[inline (always)] pub fn borrstf (& self) -> BorrstfR { BorrstfR :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Software reset flag"]
#[inline (always)] pub fn sftrstf (& self) -> SftrstfR { SftrstfR :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Independent window watchdog reset flag"]
#[inline (always)] pub fn iwdgrstf (& self) -> IwdgrstfR { IwdgrstfR :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Window watchdog reset flag"]
#[inline (always)] pub fn wwdgrstf (& self) -> WwdgrstfR { WwdgrstfR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Low-power reset flag"]
#[inline (always)] pub fn lpwrrstf (& self) -> LpwrrstfR { LpwrrstfR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - LSI1 oscillator enabled"]
#[inline (always)] pub fn lsi1on (& mut self) -> Lsi1onW < '_ , CsrSpec > { Lsi1onW :: new (self , 0) }
#[doc = "Bit 2 - LSI2 oscillator enabled"]
#[inline (always)] pub fn lsi2on (& mut self) -> Lsi2onW < '_ , CsrSpec > { Lsi2onW :: new (self , 2) }
#[doc = "Bit 4 - LSI2 oscillator trimming enable"]
#[inline (always)] pub fn lsi2trimen (& mut self) -> Lsi2trimenW < '_ , CsrSpec > { Lsi2trimenW :: new (self , 4) }
#[doc = "Bits 8:11 - LSI2 oscillator bias configuration"]
#[inline (always)] pub fn lsi2bw (& mut self) -> Lsi2bwW < '_ , CsrSpec > { Lsi2bwW :: new (self , 8) }
#[doc = "Bits 14:15 - RF system wakeup clock source selection"]
#[inline (always)] pub fn rfwkpsel (& mut self) -> RfwkpselW < '_ , CsrSpec > { RfwkpselW :: new (self , 14) }
#[doc = "Bit 23 - Remove reset flag"]
#[inline (always)] pub fn rmvf (& mut self) -> RmvfW < '_ , CsrSpec > { RmvfW :: new (self , 23) } }
#[doc = "CSR\n\nYou can [`read`](crate::Reg::read) this register and get [`csr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`csr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CsrSpec ; impl crate :: RegisterSpec for CsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`csr::R`](R) reader structure"] impl crate :: Readable for CsrSpec { }
#[doc = "`write(|w| ..)` method takes [`csr::W`](W) writer structure"] impl crate :: Writable for CsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CSR to value 0x0c00_0000"] impl crate :: Resettable for CsrSpec { const RESET_VALUE : u32 = 0x0c00_0000 ; } }
#[doc = "CRRCR (rw) register accessor: Clock recovery RC register\n\nYou can [`read`](crate::Reg::read) this register and get [`crrcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`crrcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@crrcr`] module"]
#[doc (alias = "CRRCR")] pub type Crrcr = crate :: Reg < crrcr :: CrrcrSpec > ;
#[doc = "Clock recovery RC register"] pub mod crrcr {
#[doc = "Register `CRRCR` reader"] pub type R = crate :: R < CrrcrSpec > ;
#[doc = "Register `CRRCR` writer"] pub type W = crate :: W < CrrcrSpec > ;
#[doc = "Field `HSI48ON` reader - HSI48 oscillator enabled"] pub type Hsi48onR = crate :: BitReader ;
#[doc = "Field `HSI48ON` writer - HSI48 oscillator enabled"] pub type Hsi48onW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSI48RDY` reader - HSI48 clock ready"] pub type Hsi48rdyR = crate :: BitReader ;
#[doc = "Field `HSI48CAL` reader - HSI48 clock calibration"] pub type Hsi48calR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bit 0 - HSI48 oscillator enabled"]
#[inline (always)] pub fn hsi48on (& self) -> Hsi48onR { Hsi48onR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - HSI48 clock ready"]
#[inline (always)] pub fn hsi48rdy (& self) -> Hsi48rdyR { Hsi48rdyR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bits 7:15 - HSI48 clock calibration"]
#[inline (always)] pub fn hsi48cal (& self) -> Hsi48calR { Hsi48calR :: new (((self . bits >> 7) & 0x01ff) as u16) } } impl W {
#[doc = "Bit 0 - HSI48 oscillator enabled"]
#[inline (always)] pub fn hsi48on (& mut self) -> Hsi48onW < '_ , CrrcrSpec > { Hsi48onW :: new (self , 0) } }
#[doc = "Clock recovery RC register\n\nYou can [`read`](crate::Reg::read) this register and get [`crrcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`crrcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrrcrSpec ; impl crate :: RegisterSpec for CrrcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`crrcr::R`](R) reader structure"] impl crate :: Readable for CrrcrSpec { }
#[doc = "`write(|w| ..)` method takes [`crrcr::W`](W) writer structure"] impl crate :: Writable for CrrcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CRRCR to value 0"] impl crate :: Resettable for CrrcrSpec { } }
#[doc = "HSECR (rw) register accessor: Clock HSE register\n\nYou can [`read`](crate::Reg::read) this register and get [`hsecr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`hsecr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hsecr`] module"]
#[doc (alias = "HSECR")] pub type Hsecr = crate :: Reg < hsecr :: HsecrSpec > ;
#[doc = "Clock HSE register"] pub mod hsecr {
#[doc = "Register `HSECR` reader"] pub type R = crate :: R < HsecrSpec > ;
#[doc = "Register `HSECR` writer"] pub type W = crate :: W < HsecrSpec > ;
#[doc = "Field `UNLOCKED` reader - Register lock system"] pub type UnlockedR = crate :: BitReader ;
#[doc = "Field `UNLOCKED` writer - Register lock system"] pub type UnlockedW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSES` reader - HSE Sense amplifier threshold"] pub type HsesR = crate :: BitReader ;
#[doc = "Field `HSES` writer - HSE Sense amplifier threshold"] pub type HsesW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSEGMC` reader - HSE current control"] pub type HsegmcR = crate :: FieldReader ;
#[doc = "Field `HSEGMC` writer - HSE current control"] pub type HsegmcW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `HSETUNE` reader - HSE capacitor tuning"] pub type HsetuneR = crate :: FieldReader ; impl R {
#[doc = "Bit 0 - Register lock system"]
#[inline (always)] pub fn unlocked (& self) -> UnlockedR { UnlockedR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 3 - HSE Sense amplifier threshold"]
#[inline (always)] pub fn hses (& self) -> HsesR { HsesR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - HSE current control"]
#[inline (always)] pub fn hsegmc (& self) -> HsegmcR { HsegmcR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bits 8:13 - HSE capacitor tuning"]
#[inline (always)] pub fn hsetune (& self) -> HsetuneR { HsetuneR :: new (((self . bits >> 8) & 0x3f) as u8) } } impl W {
#[doc = "Bit 0 - Register lock system"]
#[inline (always)] pub fn unlocked (& mut self) -> UnlockedW < '_ , HsecrSpec > { UnlockedW :: new (self , 0) }
#[doc = "Bit 3 - HSE Sense amplifier threshold"]
#[inline (always)] pub fn hses (& mut self) -> HsesW < '_ , HsecrSpec > { HsesW :: new (self , 3) }
#[doc = "Bits 4:6 - HSE current control"]
#[inline (always)] pub fn hsegmc (& mut self) -> HsegmcW < '_ , HsecrSpec > { HsegmcW :: new (self , 4) } }
#[doc = "Clock HSE register\n\nYou can [`read`](crate::Reg::read) this register and get [`hsecr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`hsecr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct HsecrSpec ; impl crate :: RegisterSpec for HsecrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`hsecr::R`](R) reader structure"] impl crate :: Readable for HsecrSpec { }
#[doc = "`write(|w| ..)` method takes [`hsecr::W`](W) writer structure"] impl crate :: Writable for HsecrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets HSECR to value 0x30"] impl crate :: Resettable for HsecrSpec { const RESET_VALUE : u32 = 0x30 ; } }
#[doc = "EXTCFGR (rw) register accessor: Extended clock recovery register\n\nYou can [`read`](crate::Reg::read) this register and get [`extcfgr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`extcfgr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@extcfgr`] module"]
#[doc (alias = "EXTCFGR")] pub type Extcfgr = crate :: Reg < extcfgr :: ExtcfgrSpec > ;
#[doc = "Extended clock recovery register"] pub mod extcfgr {
#[doc = "Register `EXTCFGR` reader"] pub type R = crate :: R < ExtcfgrSpec > ;
#[doc = "Register `EXTCFGR` writer"] pub type W = crate :: W < ExtcfgrSpec > ;
#[doc = "Field `SHDHPRE` reader - Shared AHB prescaler"] pub type ShdhpreR = crate :: FieldReader ;
#[doc = "Field `SHDHPRE` writer - Shared AHB prescaler"] pub type ShdhpreW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `C2HPRE` reader - CPU2 AHB prescaler"] pub type C2hpreR = crate :: FieldReader ;
#[doc = "Field `C2HPRE` writer - CPU2 AHB prescaler"] pub type C2hpreW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `SHDHPREF` reader - Shared AHB prescaler flag"] pub type ShdhprefR = crate :: BitReader ;
#[doc = "Field `C2HPREF` reader - CPU2 AHB prescaler flag"] pub type C2hprefR = crate :: BitReader ;
#[doc = "Field `RFCSS` reader - RF clock source selected"] pub type RfcssR = crate :: BitReader ; impl R {
#[doc = "Bits 0:3 - Shared AHB prescaler"]
#[inline (always)] pub fn shdhpre (& self) -> ShdhpreR { ShdhpreR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - CPU2 AHB prescaler"]
#[inline (always)] pub fn c2hpre (& self) -> C2hpreR { C2hpreR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bit 16 - Shared AHB prescaler flag"]
#[inline (always)] pub fn shdhpref (& self) -> ShdhprefR { ShdhprefR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - CPU2 AHB prescaler flag"]
#[inline (always)] pub fn c2hpref (& self) -> C2hprefR { C2hprefR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 20 - RF clock source selected"]
#[inline (always)] pub fn rfcss (& self) -> RfcssR { RfcssR :: new (((self . bits >> 20) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - Shared AHB prescaler"]
#[inline (always)] pub fn shdhpre (& mut self) -> ShdhpreW < '_ , ExtcfgrSpec > { ShdhpreW :: new (self , 0) }
#[doc = "Bits 4:7 - CPU2 AHB prescaler"]
#[inline (always)] pub fn c2hpre (& mut self) -> C2hpreW < '_ , ExtcfgrSpec > { C2hpreW :: new (self , 4) } }
#[doc = "Extended clock recovery register\n\nYou can [`read`](crate::Reg::read) this register and get [`extcfgr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`extcfgr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ExtcfgrSpec ; impl crate :: RegisterSpec for ExtcfgrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`extcfgr::R`](R) reader structure"] impl crate :: Readable for ExtcfgrSpec { }
#[doc = "`write(|w| ..)` method takes [`extcfgr::W`](W) writer structure"] impl crate :: Writable for ExtcfgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EXTCFGR to value 0x0003_0000"] impl crate :: Resettable for ExtcfgrSpec { const RESET_VALUE : u32 = 0x0003_0000 ; } }
#[doc = "C2AHB1ENR (rw) register accessor: CPU2 AHB1 peripheral clock enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2ahb1enr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2ahb1enr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2ahb1enr`] module"]
#[doc (alias = "C2AHB1ENR")] pub type C2ahb1enr = crate :: Reg < c2ahb1enr :: C2ahb1enrSpec > ;
#[doc = "CPU2 AHB1 peripheral clock enable register"] pub mod c2ahb1enr {
#[doc = "Register `C2AHB1ENR` reader"] pub type R = crate :: R < C2ahb1enrSpec > ;
#[doc = "Register `C2AHB1ENR` writer"] pub type W = crate :: W < C2ahb1enrSpec > ;
#[doc = "Field `DMA1EN` reader - CPU2 DMA1 clock enable"] pub type Dma1enR = crate :: BitReader ;
#[doc = "Field `DMA1EN` writer - CPU2 DMA1 clock enable"] pub type Dma1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMA2EN` reader - CPU2 DMA2 clock enable"] pub type Dma2enR = crate :: BitReader ;
#[doc = "Field `DMA2EN` writer - CPU2 DMA2 clock enable"] pub type Dma2enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMAMUXEN` reader - CPU2 DMAMUX clock enable"] pub type DmamuxenR = crate :: BitReader ;
#[doc = "Field `DMAMUXEN` writer - CPU2 DMAMUX clock enable"] pub type DmamuxenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SRAM1EN` reader - CPU2 SRAM1 clock enable"] pub type Sram1enR = crate :: BitReader ;
#[doc = "Field `SRAM1EN` writer - CPU2 SRAM1 clock enable"] pub type Sram1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CRCEN` reader - CPU2 CRC clock enable"] pub type CrcenR = crate :: BitReader ;
#[doc = "Field `CRCEN` writer - CPU2 CRC clock enable"] pub type CrcenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TSCEN` reader - CPU2 Touch Sensing Controller clock enable"] pub type TscenR = crate :: BitReader ;
#[doc = "Field `TSCEN` writer - CPU2 Touch Sensing Controller clock enable"] pub type TscenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - CPU2 DMA1 clock enable"]
#[inline (always)] pub fn dma1en (& self) -> Dma1enR { Dma1enR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - CPU2 DMA2 clock enable"]
#[inline (always)] pub fn dma2en (& self) -> Dma2enR { Dma2enR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - CPU2 DMAMUX clock enable"]
#[inline (always)] pub fn dmamuxen (& self) -> DmamuxenR { DmamuxenR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 9 - CPU2 SRAM1 clock enable"]
#[inline (always)] pub fn sram1en (& self) -> Sram1enR { Sram1enR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 12 - CPU2 CRC clock enable"]
#[inline (always)] pub fn crcen (& self) -> CrcenR { CrcenR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 16 - CPU2 Touch Sensing Controller clock enable"]
#[inline (always)] pub fn tscen (& self) -> TscenR { TscenR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bit 0 - CPU2 DMA1 clock enable"]
#[inline (always)] pub fn dma1en (& mut self) -> Dma1enW < '_ , C2ahb1enrSpec > { Dma1enW :: new (self , 0) }
#[doc = "Bit 1 - CPU2 DMA2 clock enable"]
#[inline (always)] pub fn dma2en (& mut self) -> Dma2enW < '_ , C2ahb1enrSpec > { Dma2enW :: new (self , 1) }
#[doc = "Bit 2 - CPU2 DMAMUX clock enable"]
#[inline (always)] pub fn dmamuxen (& mut self) -> DmamuxenW < '_ , C2ahb1enrSpec > { DmamuxenW :: new (self , 2) }
#[doc = "Bit 9 - CPU2 SRAM1 clock enable"]
#[inline (always)] pub fn sram1en (& mut self) -> Sram1enW < '_ , C2ahb1enrSpec > { Sram1enW :: new (self , 9) }
#[doc = "Bit 12 - CPU2 CRC clock enable"]
#[inline (always)] pub fn crcen (& mut self) -> CrcenW < '_ , C2ahb1enrSpec > { CrcenW :: new (self , 12) }
#[doc = "Bit 16 - CPU2 Touch Sensing Controller clock enable"]
#[inline (always)] pub fn tscen (& mut self) -> TscenW < '_ , C2ahb1enrSpec > { TscenW :: new (self , 16) } }
#[doc = "CPU2 AHB1 peripheral clock enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2ahb1enr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2ahb1enr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2ahb1enrSpec ; impl crate :: RegisterSpec for C2ahb1enrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2ahb1enr::R`](R) reader structure"] impl crate :: Readable for C2ahb1enrSpec { }
#[doc = "`write(|w| ..)` method takes [`c2ahb1enr::W`](W) writer structure"] impl crate :: Writable for C2ahb1enrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2AHB1ENR to value 0"] impl crate :: Resettable for C2ahb1enrSpec { } }
#[doc = "C2AHB2ENR (rw) register accessor: CPU2 AHB2 peripheral clock enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2ahb2enr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2ahb2enr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2ahb2enr`] module"]
#[doc (alias = "C2AHB2ENR")] pub type C2ahb2enr = crate :: Reg < c2ahb2enr :: C2ahb2enrSpec > ;
#[doc = "CPU2 AHB2 peripheral clock enable register"] pub mod c2ahb2enr {
#[doc = "Register `C2AHB2ENR` reader"] pub type R = crate :: R < C2ahb2enrSpec > ;
#[doc = "Register `C2AHB2ENR` writer"] pub type W = crate :: W < C2ahb2enrSpec > ;
#[doc = "Field `GPIOAEN` reader - CPU2 IO port A clock enable"] pub type GpioaenR = crate :: BitReader ;
#[doc = "Field `GPIOAEN` writer - CPU2 IO port A clock enable"] pub type GpioaenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOBEN` reader - CPU2 IO port B clock enable"] pub type GpiobenR = crate :: BitReader ;
#[doc = "Field `GPIOBEN` writer - CPU2 IO port B clock enable"] pub type GpiobenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOCEN` reader - CPU2 IO port C clock enable"] pub type GpiocenR = crate :: BitReader ;
#[doc = "Field `GPIOCEN` writer - CPU2 IO port C clock enable"] pub type GpiocenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIODEN` reader - CPU2 IO port D clock enable"] pub type GpiodenR = crate :: BitReader ;
#[doc = "Field `GPIODEN` writer - CPU2 IO port D clock enable"] pub type GpiodenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOEEN` reader - CPU2 IO port E clock enable"] pub type GpioeenR = crate :: BitReader ;
#[doc = "Field `GPIOEEN` writer - CPU2 IO port E clock enable"] pub type GpioeenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOHEN` reader - CPU2 IO port H clock enable"] pub type GpiohenR = crate :: BitReader ;
#[doc = "Field `GPIOHEN` writer - CPU2 IO port H clock enable"] pub type GpiohenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADCEN` reader - CPU2 ADC clock enable"] pub type AdcenR = crate :: BitReader ;
#[doc = "Field `ADCEN` writer - CPU2 ADC clock enable"] pub type AdcenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AES1EN` reader - CPU2 AES1 accelerator clock enable"] pub type Aes1enR = crate :: BitReader ;
#[doc = "Field `AES1EN` writer - CPU2 AES1 accelerator clock enable"] pub type Aes1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - CPU2 IO port A clock enable"]
#[inline (always)] pub fn gpioaen (& self) -> GpioaenR { GpioaenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - CPU2 IO port B clock enable"]
#[inline (always)] pub fn gpioben (& self) -> GpiobenR { GpiobenR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - CPU2 IO port C clock enable"]
#[inline (always)] pub fn gpiocen (& self) -> GpiocenR { GpiocenR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - CPU2 IO port D clock enable"]
#[inline (always)] pub fn gpioden (& self) -> GpiodenR { GpiodenR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - CPU2 IO port E clock enable"]
#[inline (always)] pub fn gpioeen (& self) -> GpioeenR { GpioeenR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 7 - CPU2 IO port H clock enable"]
#[inline (always)] pub fn gpiohen (& self) -> GpiohenR { GpiohenR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 13 - CPU2 ADC clock enable"]
#[inline (always)] pub fn adcen (& self) -> AdcenR { AdcenR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 16 - CPU2 AES1 accelerator clock enable"]
#[inline (always)] pub fn aes1en (& self) -> Aes1enR { Aes1enR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bit 0 - CPU2 IO port A clock enable"]
#[inline (always)] pub fn gpioaen (& mut self) -> GpioaenW < '_ , C2ahb2enrSpec > { GpioaenW :: new (self , 0) }
#[doc = "Bit 1 - CPU2 IO port B clock enable"]
#[inline (always)] pub fn gpioben (& mut self) -> GpiobenW < '_ , C2ahb2enrSpec > { GpiobenW :: new (self , 1) }
#[doc = "Bit 2 - CPU2 IO port C clock enable"]
#[inline (always)] pub fn gpiocen (& mut self) -> GpiocenW < '_ , C2ahb2enrSpec > { GpiocenW :: new (self , 2) }
#[doc = "Bit 3 - CPU2 IO port D clock enable"]
#[inline (always)] pub fn gpioden (& mut self) -> GpiodenW < '_ , C2ahb2enrSpec > { GpiodenW :: new (self , 3) }
#[doc = "Bit 4 - CPU2 IO port E clock enable"]
#[inline (always)] pub fn gpioeen (& mut self) -> GpioeenW < '_ , C2ahb2enrSpec > { GpioeenW :: new (self , 4) }
#[doc = "Bit 7 - CPU2 IO port H clock enable"]
#[inline (always)] pub fn gpiohen (& mut self) -> GpiohenW < '_ , C2ahb2enrSpec > { GpiohenW :: new (self , 7) }
#[doc = "Bit 13 - CPU2 ADC clock enable"]
#[inline (always)] pub fn adcen (& mut self) -> AdcenW < '_ , C2ahb2enrSpec > { AdcenW :: new (self , 13) }
#[doc = "Bit 16 - CPU2 AES1 accelerator clock enable"]
#[inline (always)] pub fn aes1en (& mut self) -> Aes1enW < '_ , C2ahb2enrSpec > { Aes1enW :: new (self , 16) } }
#[doc = "CPU2 AHB2 peripheral clock enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2ahb2enr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2ahb2enr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2ahb2enrSpec ; impl crate :: RegisterSpec for C2ahb2enrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2ahb2enr::R`](R) reader structure"] impl crate :: Readable for C2ahb2enrSpec { }
#[doc = "`write(|w| ..)` method takes [`c2ahb2enr::W`](W) writer structure"] impl crate :: Writable for C2ahb2enrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2AHB2ENR to value 0"] impl crate :: Resettable for C2ahb2enrSpec { } }
#[doc = "C2AHB3ENR (rw) register accessor: CPU2 AHB3 peripheral clock enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2ahb3enr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2ahb3enr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2ahb3enr`] module"]
#[doc (alias = "C2AHB3ENR")] pub type C2ahb3enr = crate :: Reg < c2ahb3enr :: C2ahb3enrSpec > ;
#[doc = "CPU2 AHB3 peripheral clock enable register"] pub mod c2ahb3enr {
#[doc = "Register `C2AHB3ENR` reader"] pub type R = crate :: R < C2ahb3enrSpec > ;
#[doc = "Register `C2AHB3ENR` writer"] pub type W = crate :: W < C2ahb3enrSpec > ;
#[doc = "Field `PKAEN` reader - CPU2 PKAEN"] pub type PkaenR = crate :: BitReader ;
#[doc = "Field `PKAEN` writer - CPU2 PKAEN"] pub type PkaenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AES2EN` reader - CPU2 AES2EN"] pub type Aes2enR = crate :: BitReader ;
#[doc = "Field `AES2EN` writer - CPU2 AES2EN"] pub type Aes2enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RNGEN` reader - CPU2 RNGEN"] pub type RngenR = crate :: BitReader ;
#[doc = "Field `RNGEN` writer - CPU2 RNGEN"] pub type RngenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSEMEN` reader - CPU2 HSEMEN"] pub type HsemenR = crate :: BitReader ;
#[doc = "Field `HSEMEN` writer - CPU2 HSEMEN"] pub type HsemenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IPCCEN` reader - CPU2 IPCCEN"] pub type IpccenR = crate :: BitReader ;
#[doc = "Field `IPCCEN` writer - CPU2 IPCCEN"] pub type IpccenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FLASHEN` reader - CPU2 FLASHEN"] pub type FlashenR = crate :: BitReader ;
#[doc = "Field `FLASHEN` writer - CPU2 FLASHEN"] pub type FlashenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 16 - CPU2 PKAEN"]
#[inline (always)] pub fn pkaen (& self) -> PkaenR { PkaenR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - CPU2 AES2EN"]
#[inline (always)] pub fn aes2en (& self) -> Aes2enR { Aes2enR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - CPU2 RNGEN"]
#[inline (always)] pub fn rngen (& self) -> RngenR { RngenR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - CPU2 HSEMEN"]
#[inline (always)] pub fn hsemen (& self) -> HsemenR { HsemenR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - CPU2 IPCCEN"]
#[inline (always)] pub fn ipccen (& self) -> IpccenR { IpccenR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 25 - CPU2 FLASHEN"]
#[inline (always)] pub fn flashen (& self) -> FlashenR { FlashenR :: new (((self . bits >> 25) & 1) != 0) } } impl W {
#[doc = "Bit 16 - CPU2 PKAEN"]
#[inline (always)] pub fn pkaen (& mut self) -> PkaenW < '_ , C2ahb3enrSpec > { PkaenW :: new (self , 16) }
#[doc = "Bit 17 - CPU2 AES2EN"]
#[inline (always)] pub fn aes2en (& mut self) -> Aes2enW < '_ , C2ahb3enrSpec > { Aes2enW :: new (self , 17) }
#[doc = "Bit 18 - CPU2 RNGEN"]
#[inline (always)] pub fn rngen (& mut self) -> RngenW < '_ , C2ahb3enrSpec > { RngenW :: new (self , 18) }
#[doc = "Bit 19 - CPU2 HSEMEN"]
#[inline (always)] pub fn hsemen (& mut self) -> HsemenW < '_ , C2ahb3enrSpec > { HsemenW :: new (self , 19) }
#[doc = "Bit 20 - CPU2 IPCCEN"]
#[inline (always)] pub fn ipccen (& mut self) -> IpccenW < '_ , C2ahb3enrSpec > { IpccenW :: new (self , 20) }
#[doc = "Bit 25 - CPU2 FLASHEN"]
#[inline (always)] pub fn flashen (& mut self) -> FlashenW < '_ , C2ahb3enrSpec > { FlashenW :: new (self , 25) } }
#[doc = "CPU2 AHB3 peripheral clock enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2ahb3enr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2ahb3enr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2ahb3enrSpec ; impl crate :: RegisterSpec for C2ahb3enrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2ahb3enr::R`](R) reader structure"] impl crate :: Readable for C2ahb3enrSpec { }
#[doc = "`write(|w| ..)` method takes [`c2ahb3enr::W`](W) writer structure"] impl crate :: Writable for C2ahb3enrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2AHB3ENR to value 0x0208_0000"] impl crate :: Resettable for C2ahb3enrSpec { const RESET_VALUE : u32 = 0x0208_0000 ; } }
#[doc = "C2APB1ENR1 (rw) register accessor: CPU2 APB1ENR1\n\nYou can [`read`](crate::Reg::read) this register and get [`c2apb1enr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2apb1enr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2apb1enr1`] module"]
#[doc (alias = "C2APB1ENR1")] pub type C2apb1enr1 = crate :: Reg < c2apb1enr1 :: C2apb1enr1Spec > ;
#[doc = "CPU2 APB1ENR1"] pub mod c2apb1enr1 {
#[doc = "Register `C2APB1ENR1` reader"] pub type R = crate :: R < C2apb1enr1Spec > ;
#[doc = "Register `C2APB1ENR1` writer"] pub type W = crate :: W < C2apb1enr1Spec > ;
#[doc = "Field `TIM2EN` reader - CPU2 TIM2 timer clock enable"] pub type Tim2enR = crate :: BitReader ;
#[doc = "Field `TIM2EN` writer - CPU2 TIM2 timer clock enable"] pub type Tim2enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCDEN` reader - CPU2 LCD clock enable"] pub type LcdenR = crate :: BitReader ;
#[doc = "Field `LCDEN` writer - CPU2 LCD clock enable"] pub type LcdenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RTCAPBEN` reader - CPU2 RTC APB clock enable"] pub type RtcapbenR = crate :: BitReader ;
#[doc = "Field `RTCAPBEN` writer - CPU2 RTC APB clock enable"] pub type RtcapbenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPI2EN` reader - CPU2 SPI2 clock enable"] pub type Spi2enR = crate :: BitReader ;
#[doc = "Field `SPI2EN` writer - CPU2 SPI2 clock enable"] pub type Spi2enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `I2C1EN` reader - CPU2 I2C1 clock enable"] pub type I2c1enR = crate :: BitReader ;
#[doc = "Field `I2C1EN` writer - CPU2 I2C1 clock enable"] pub type I2c1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `I2C3EN` reader - CPU2 I2C3 clock enable"] pub type I2c3enR = crate :: BitReader ;
#[doc = "Field `I2C3EN` writer - CPU2 I2C3 clock enable"] pub type I2c3enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CRSEN` reader - CPU2 CRS clock enable"] pub type CrsenR = crate :: BitReader ;
#[doc = "Field `CRSEN` writer - CPU2 CRS clock enable"] pub type CrsenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `USBEN` reader - CPU2 USB clock enable"] pub type UsbenR = crate :: BitReader ;
#[doc = "Field `USBEN` writer - CPU2 USB clock enable"] pub type UsbenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LPTIM1EN` reader - CPU2 Low power timer 1 clock enable"] pub type Lptim1enR = crate :: BitReader ;
#[doc = "Field `LPTIM1EN` writer - CPU2 Low power timer 1 clock enable"] pub type Lptim1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - CPU2 TIM2 timer clock enable"]
#[inline (always)] pub fn tim2en (& self) -> Tim2enR { Tim2enR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 9 - CPU2 LCD clock enable"]
#[inline (always)] pub fn lcden (& self) -> LcdenR { LcdenR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - CPU2 RTC APB clock enable"]
#[inline (always)] pub fn rtcapben (& self) -> RtcapbenR { RtcapbenR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 14 - CPU2 SPI2 clock enable"]
#[inline (always)] pub fn spi2en (& self) -> Spi2enR { Spi2enR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 21 - CPU2 I2C1 clock enable"]
#[inline (always)] pub fn i2c1en (& self) -> I2c1enR { I2c1enR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 23 - CPU2 I2C3 clock enable"]
#[inline (always)] pub fn i2c3en (& self) -> I2c3enR { I2c3enR :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - CPU2 CRS clock enable"]
#[inline (always)] pub fn crsen (& self) -> CrsenR { CrsenR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 26 - CPU2 USB clock enable"]
#[inline (always)] pub fn usben (& self) -> UsbenR { UsbenR :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 31 - CPU2 Low power timer 1 clock enable"]
#[inline (always)] pub fn lptim1en (& self) -> Lptim1enR { Lptim1enR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - CPU2 TIM2 timer clock enable"]
#[inline (always)] pub fn tim2en (& mut self) -> Tim2enW < '_ , C2apb1enr1Spec > { Tim2enW :: new (self , 0) }
#[doc = "Bit 9 - CPU2 LCD clock enable"]
#[inline (always)] pub fn lcden (& mut self) -> LcdenW < '_ , C2apb1enr1Spec > { LcdenW :: new (self , 9) }
#[doc = "Bit 10 - CPU2 RTC APB clock enable"]
#[inline (always)] pub fn rtcapben (& mut self) -> RtcapbenW < '_ , C2apb1enr1Spec > { RtcapbenW :: new (self , 10) }
#[doc = "Bit 14 - CPU2 SPI2 clock enable"]
#[inline (always)] pub fn spi2en (& mut self) -> Spi2enW < '_ , C2apb1enr1Spec > { Spi2enW :: new (self , 14) }
#[doc = "Bit 21 - CPU2 I2C1 clock enable"]
#[inline (always)] pub fn i2c1en (& mut self) -> I2c1enW < '_ , C2apb1enr1Spec > { I2c1enW :: new (self , 21) }
#[doc = "Bit 23 - CPU2 I2C3 clock enable"]
#[inline (always)] pub fn i2c3en (& mut self) -> I2c3enW < '_ , C2apb1enr1Spec > { I2c3enW :: new (self , 23) }
#[doc = "Bit 24 - CPU2 CRS clock enable"]
#[inline (always)] pub fn crsen (& mut self) -> CrsenW < '_ , C2apb1enr1Spec > { CrsenW :: new (self , 24) }
#[doc = "Bit 26 - CPU2 USB clock enable"]
#[inline (always)] pub fn usben (& mut self) -> UsbenW < '_ , C2apb1enr1Spec > { UsbenW :: new (self , 26) }
#[doc = "Bit 31 - CPU2 Low power timer 1 clock enable"]
#[inline (always)] pub fn lptim1en (& mut self) -> Lptim1enW < '_ , C2apb1enr1Spec > { Lptim1enW :: new (self , 31) } }
#[doc = "CPU2 APB1ENR1\n\nYou can [`read`](crate::Reg::read) this register and get [`c2apb1enr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2apb1enr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2apb1enr1Spec ; impl crate :: RegisterSpec for C2apb1enr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2apb1enr1::R`](R) reader structure"] impl crate :: Readable for C2apb1enr1Spec { }
#[doc = "`write(|w| ..)` method takes [`c2apb1enr1::W`](W) writer structure"] impl crate :: Writable for C2apb1enr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2APB1ENR1 to value 0x0400"] impl crate :: Resettable for C2apb1enr1Spec { const RESET_VALUE : u32 = 0x0400 ; } }
#[doc = "C2APB1ENR2 (rw) register accessor: CPU2 APB1 peripheral clock enable register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`c2apb1enr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2apb1enr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2apb1enr2`] module"]
#[doc (alias = "C2APB1ENR2")] pub type C2apb1enr2 = crate :: Reg < c2apb1enr2 :: C2apb1enr2Spec > ;
#[doc = "CPU2 APB1 peripheral clock enable register 2"] pub mod c2apb1enr2 {
#[doc = "Register `C2APB1ENR2` reader"] pub type R = crate :: R < C2apb1enr2Spec > ;
#[doc = "Register `C2APB1ENR2` writer"] pub type W = crate :: W < C2apb1enr2Spec > ;
#[doc = "Field `LPUART1EN` reader - CPU2 Low power UART 1 clock enable"] pub type Lpuart1enR = crate :: BitReader ;
#[doc = "Field `LPUART1EN` writer - CPU2 Low power UART 1 clock enable"] pub type Lpuart1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LPTIM2EN` reader - CPU2 LPTIM2EN"] pub type Lptim2enR = crate :: BitReader ;
#[doc = "Field `LPTIM2EN` writer - CPU2 LPTIM2EN"] pub type Lptim2enW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - CPU2 Low power UART 1 clock enable"]
#[inline (always)] pub fn lpuart1en (& self) -> Lpuart1enR { Lpuart1enR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 5 - CPU2 LPTIM2EN"]
#[inline (always)] pub fn lptim2en (& self) -> Lptim2enR { Lptim2enR :: new (((self . bits >> 5) & 1) != 0) } } impl W {
#[doc = "Bit 0 - CPU2 Low power UART 1 clock enable"]
#[inline (always)] pub fn lpuart1en (& mut self) -> Lpuart1enW < '_ , C2apb1enr2Spec > { Lpuart1enW :: new (self , 0) }
#[doc = "Bit 5 - CPU2 LPTIM2EN"]
#[inline (always)] pub fn lptim2en (& mut self) -> Lptim2enW < '_ , C2apb1enr2Spec > { Lptim2enW :: new (self , 5) } }
#[doc = "CPU2 APB1 peripheral clock enable register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`c2apb1enr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2apb1enr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2apb1enr2Spec ; impl crate :: RegisterSpec for C2apb1enr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2apb1enr2::R`](R) reader structure"] impl crate :: Readable for C2apb1enr2Spec { }
#[doc = "`write(|w| ..)` method takes [`c2apb1enr2::W`](W) writer structure"] impl crate :: Writable for C2apb1enr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2APB1ENR2 to value 0"] impl crate :: Resettable for C2apb1enr2Spec { } }
#[doc = "C2APB2ENR (rw) register accessor: CPU2 APB2ENR\n\nYou can [`read`](crate::Reg::read) this register and get [`c2apb2enr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2apb2enr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2apb2enr`] module"]
#[doc (alias = "C2APB2ENR")] pub type C2apb2enr = crate :: Reg < c2apb2enr :: C2apb2enrSpec > ;
#[doc = "CPU2 APB2ENR"] pub mod c2apb2enr {
#[doc = "Register `C2APB2ENR` reader"] pub type R = crate :: R < C2apb2enrSpec > ;
#[doc = "Register `C2APB2ENR` writer"] pub type W = crate :: W < C2apb2enrSpec > ;
#[doc = "Field `TIM1EN` reader - CPU2 TIM1 timer clock enable"] pub type Tim1enR = crate :: BitReader ;
#[doc = "Field `TIM1EN` writer - CPU2 TIM1 timer clock enable"] pub type Tim1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPI1EN` reader - CPU2 SPI1 clock enable"] pub type Spi1enR = crate :: BitReader ;
#[doc = "Field `SPI1EN` writer - CPU2 SPI1 clock enable"] pub type Spi1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `USART1EN` reader - CPU2 USART1clock enable"] pub type Usart1enR = crate :: BitReader ;
#[doc = "Field `USART1EN` writer - CPU2 USART1clock enable"] pub type Usart1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM16EN` reader - CPU2 TIM16 timer clock enable"] pub type Tim16enR = crate :: BitReader ;
#[doc = "Field `TIM16EN` writer - CPU2 TIM16 timer clock enable"] pub type Tim16enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM17EN` reader - CPU2 TIM17 timer clock enable"] pub type Tim17enR = crate :: BitReader ;
#[doc = "Field `TIM17EN` writer - CPU2 TIM17 timer clock enable"] pub type Tim17enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SAI1EN` reader - CPU2 SAI1 clock enable"] pub type Sai1enR = crate :: BitReader ;
#[doc = "Field `SAI1EN` writer - CPU2 SAI1 clock enable"] pub type Sai1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 11 - CPU2 TIM1 timer clock enable"]
#[inline (always)] pub fn tim1en (& self) -> Tim1enR { Tim1enR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - CPU2 SPI1 clock enable"]
#[inline (always)] pub fn spi1en (& self) -> Spi1enR { Spi1enR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 14 - CPU2 USART1clock enable"]
#[inline (always)] pub fn usart1en (& self) -> Usart1enR { Usart1enR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 17 - CPU2 TIM16 timer clock enable"]
#[inline (always)] pub fn tim16en (& self) -> Tim16enR { Tim16enR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - CPU2 TIM17 timer clock enable"]
#[inline (always)] pub fn tim17en (& self) -> Tim17enR { Tim17enR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 21 - CPU2 SAI1 clock enable"]
#[inline (always)] pub fn sai1en (& self) -> Sai1enR { Sai1enR :: new (((self . bits >> 21) & 1) != 0) } } impl W {
#[doc = "Bit 11 - CPU2 TIM1 timer clock enable"]
#[inline (always)] pub fn tim1en (& mut self) -> Tim1enW < '_ , C2apb2enrSpec > { Tim1enW :: new (self , 11) }
#[doc = "Bit 12 - CPU2 SPI1 clock enable"]
#[inline (always)] pub fn spi1en (& mut self) -> Spi1enW < '_ , C2apb2enrSpec > { Spi1enW :: new (self , 12) }
#[doc = "Bit 14 - CPU2 USART1clock enable"]
#[inline (always)] pub fn usart1en (& mut self) -> Usart1enW < '_ , C2apb2enrSpec > { Usart1enW :: new (self , 14) }
#[doc = "Bit 17 - CPU2 TIM16 timer clock enable"]
#[inline (always)] pub fn tim16en (& mut self) -> Tim16enW < '_ , C2apb2enrSpec > { Tim16enW :: new (self , 17) }
#[doc = "Bit 18 - CPU2 TIM17 timer clock enable"]
#[inline (always)] pub fn tim17en (& mut self) -> Tim17enW < '_ , C2apb2enrSpec > { Tim17enW :: new (self , 18) }
#[doc = "Bit 21 - CPU2 SAI1 clock enable"]
#[inline (always)] pub fn sai1en (& mut self) -> Sai1enW < '_ , C2apb2enrSpec > { Sai1enW :: new (self , 21) } }
#[doc = "CPU2 APB2ENR\n\nYou can [`read`](crate::Reg::read) this register and get [`c2apb2enr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2apb2enr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2apb2enrSpec ; impl crate :: RegisterSpec for C2apb2enrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2apb2enr::R`](R) reader structure"] impl crate :: Readable for C2apb2enrSpec { }
#[doc = "`write(|w| ..)` method takes [`c2apb2enr::W`](W) writer structure"] impl crate :: Writable for C2apb2enrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2APB2ENR to value 0"] impl crate :: Resettable for C2apb2enrSpec { } }
#[doc = "C2APB3ENR (rw) register accessor: CPU2 APB3ENR\n\nYou can [`read`](crate::Reg::read) this register and get [`c2apb3enr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2apb3enr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2apb3enr`] module"]
#[doc (alias = "C2APB3ENR")] pub type C2apb3enr = crate :: Reg < c2apb3enr :: C2apb3enrSpec > ;
#[doc = "CPU2 APB3ENR"] pub mod c2apb3enr {
#[doc = "Register `C2APB3ENR` reader"] pub type R = crate :: R < C2apb3enrSpec > ;
#[doc = "Register `C2APB3ENR` writer"] pub type W = crate :: W < C2apb3enrSpec > ;
#[doc = "Field `BLEEN` reader - CPU2 BLE interface clock enable"] pub type BleenR = crate :: BitReader ;
#[doc = "Field `BLEEN` writer - CPU2 BLE interface clock enable"] pub type BleenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EN802` reader - CPU2 802.15.4 interface clock enable"] pub type En802R = crate :: BitReader ;
#[doc = "Field `EN802` writer - CPU2 802.15.4 interface clock enable"] pub type En802W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - CPU2 BLE interface clock enable"]
#[inline (always)] pub fn bleen (& self) -> BleenR { BleenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - CPU2 802.15.4 interface clock enable"]
#[inline (always)] pub fn en802 (& self) -> En802R { En802R :: new (((self . bits >> 1) & 1) != 0) } } impl W {
#[doc = "Bit 0 - CPU2 BLE interface clock enable"]
#[inline (always)] pub fn bleen (& mut self) -> BleenW < '_ , C2apb3enrSpec > { BleenW :: new (self , 0) }
#[doc = "Bit 1 - CPU2 802.15.4 interface clock enable"]
#[inline (always)] pub fn en802 (& mut self) -> En802W < '_ , C2apb3enrSpec > { En802W :: new (self , 1) } }
#[doc = "CPU2 APB3ENR\n\nYou can [`read`](crate::Reg::read) this register and get [`c2apb3enr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2apb3enr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2apb3enrSpec ; impl crate :: RegisterSpec for C2apb3enrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2apb3enr::R`](R) reader structure"] impl crate :: Readable for C2apb3enrSpec { }
#[doc = "`write(|w| ..)` method takes [`c2apb3enr::W`](W) writer structure"] impl crate :: Writable for C2apb3enrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2APB3ENR to value 0"] impl crate :: Resettable for C2apb3enrSpec { } }
#[doc = "C2AHB1SMENR (rw) register accessor: CPU2 AHB1 peripheral clocks enable in Sleep and Stop modes register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2ahb1smenr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2ahb1smenr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2ahb1smenr`] module"]
#[doc (alias = "C2AHB1SMENR")] pub type C2ahb1smenr = crate :: Reg < c2ahb1smenr :: C2ahb1smenrSpec > ;
#[doc = "CPU2 AHB1 peripheral clocks enable in Sleep and Stop modes register"] pub mod c2ahb1smenr {
#[doc = "Register `C2AHB1SMENR` reader"] pub type R = crate :: R < C2ahb1smenrSpec > ;
#[doc = "Register `C2AHB1SMENR` writer"] pub type W = crate :: W < C2ahb1smenrSpec > ;
#[doc = "Field `DMA1SMEN` reader - CPU2 DMA1 clocks enable during Sleep and Stop modes"] pub type Dma1smenR = crate :: BitReader ;
#[doc = "Field `DMA1SMEN` writer - CPU2 DMA1 clocks enable during Sleep and Stop modes"] pub type Dma1smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMA2SMEN` reader - CPU2 DMA2 clocks enable during Sleep and Stop modes"] pub type Dma2smenR = crate :: BitReader ;
#[doc = "Field `DMA2SMEN` writer - CPU2 DMA2 clocks enable during Sleep and Stop modes"] pub type Dma2smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMAMUXSMEN` reader - CPU2 DMAMUX clocks enable during Sleep and Stop modes"] pub type DmamuxsmenR = crate :: BitReader ;
#[doc = "Field `DMAMUXSMEN` writer - CPU2 DMAMUX clocks enable during Sleep and Stop modes"] pub type DmamuxsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SRAM1SMEN` reader - SRAM1 interface clock enable during CPU1 CSleep mode"] pub type Sram1smenR = crate :: BitReader ;
#[doc = "Field `SRAM1SMEN` writer - SRAM1 interface clock enable during CPU1 CSleep mode"] pub type Sram1smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CRCSMEN` reader - CPU2 CRCSMEN"] pub type CrcsmenR = crate :: BitReader ;
#[doc = "Field `CRCSMEN` writer - CPU2 CRCSMEN"] pub type CrcsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TSCSMEN` reader - CPU2 Touch Sensing Controller clocks enable during Sleep and Stop modes"] pub type TscsmenR = crate :: BitReader ;
#[doc = "Field `TSCSMEN` writer - CPU2 Touch Sensing Controller clocks enable during Sleep and Stop modes"] pub type TscsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - CPU2 DMA1 clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn dma1smen (& self) -> Dma1smenR { Dma1smenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - CPU2 DMA2 clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn dma2smen (& self) -> Dma2smenR { Dma2smenR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - CPU2 DMAMUX clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn dmamuxsmen (& self) -> DmamuxsmenR { DmamuxsmenR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 9 - SRAM1 interface clock enable during CPU1 CSleep mode"]
#[inline (always)] pub fn sram1smen (& self) -> Sram1smenR { Sram1smenR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 12 - CPU2 CRCSMEN"]
#[inline (always)] pub fn crcsmen (& self) -> CrcsmenR { CrcsmenR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 16 - CPU2 Touch Sensing Controller clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn tscsmen (& self) -> TscsmenR { TscsmenR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bit 0 - CPU2 DMA1 clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn dma1smen (& mut self) -> Dma1smenW < '_ , C2ahb1smenrSpec > { Dma1smenW :: new (self , 0) }
#[doc = "Bit 1 - CPU2 DMA2 clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn dma2smen (& mut self) -> Dma2smenW < '_ , C2ahb1smenrSpec > { Dma2smenW :: new (self , 1) }
#[doc = "Bit 2 - CPU2 DMAMUX clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn dmamuxsmen (& mut self) -> DmamuxsmenW < '_ , C2ahb1smenrSpec > { DmamuxsmenW :: new (self , 2) }
#[doc = "Bit 9 - SRAM1 interface clock enable during CPU1 CSleep mode"]
#[inline (always)] pub fn sram1smen (& mut self) -> Sram1smenW < '_ , C2ahb1smenrSpec > { Sram1smenW :: new (self , 9) }
#[doc = "Bit 12 - CPU2 CRCSMEN"]
#[inline (always)] pub fn crcsmen (& mut self) -> CrcsmenW < '_ , C2ahb1smenrSpec > { CrcsmenW :: new (self , 12) }
#[doc = "Bit 16 - CPU2 Touch Sensing Controller clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn tscsmen (& mut self) -> TscsmenW < '_ , C2ahb1smenrSpec > { TscsmenW :: new (self , 16) } }
#[doc = "CPU2 AHB1 peripheral clocks enable in Sleep and Stop modes register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2ahb1smenr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2ahb1smenr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2ahb1smenrSpec ; impl crate :: RegisterSpec for C2ahb1smenrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2ahb1smenr::R`](R) reader structure"] impl crate :: Readable for C2ahb1smenrSpec { }
#[doc = "`write(|w| ..)` method takes [`c2ahb1smenr::W`](W) writer structure"] impl crate :: Writable for C2ahb1smenrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2AHB1SMENR to value 0x0001_1207"] impl crate :: Resettable for C2ahb1smenrSpec { const RESET_VALUE : u32 = 0x0001_1207 ; } }
#[doc = "C2AHB2SMENR (rw) register accessor: CPU2 AHB2 peripheral clocks enable in Sleep and Stop modes register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2ahb2smenr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2ahb2smenr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2ahb2smenr`] module"]
#[doc (alias = "C2AHB2SMENR")] pub type C2ahb2smenr = crate :: Reg < c2ahb2smenr :: C2ahb2smenrSpec > ;
#[doc = "CPU2 AHB2 peripheral clocks enable in Sleep and Stop modes register"] pub mod c2ahb2smenr {
#[doc = "Register `C2AHB2SMENR` reader"] pub type R = crate :: R < C2ahb2smenrSpec > ;
#[doc = "Register `C2AHB2SMENR` writer"] pub type W = crate :: W < C2ahb2smenrSpec > ;
#[doc = "Field `GPIOASMEN` reader - CPU2 IO port A clocks enable during Sleep and Stop modes"] pub type GpioasmenR = crate :: BitReader ;
#[doc = "Field `GPIOASMEN` writer - CPU2 IO port A clocks enable during Sleep and Stop modes"] pub type GpioasmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOBSMEN` reader - CPU2 IO port B clocks enable during Sleep and Stop modes"] pub type GpiobsmenR = crate :: BitReader ;
#[doc = "Field `GPIOBSMEN` writer - CPU2 IO port B clocks enable during Sleep and Stop modes"] pub type GpiobsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOCSMEN` reader - CPU2 IO port C clocks enable during Sleep and Stop modes"] pub type GpiocsmenR = crate :: BitReader ;
#[doc = "Field `GPIOCSMEN` writer - CPU2 IO port C clocks enable during Sleep and Stop modes"] pub type GpiocsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIODSMEN` reader - CPU2 IO port D clocks enable during Sleep and Stop modes"] pub type GpiodsmenR = crate :: BitReader ;
#[doc = "Field `GPIODSMEN` writer - CPU2 IO port D clocks enable during Sleep and Stop modes"] pub type GpiodsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOESMEN` reader - CPU2 IO port E clocks enable during Sleep and Stop modes"] pub type GpioesmenR = crate :: BitReader ;
#[doc = "Field `GPIOESMEN` writer - CPU2 IO port E clocks enable during Sleep and Stop modes"] pub type GpioesmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOHSMEN` reader - CPU2 IO port H clocks enable during Sleep and Stop modes"] pub type GpiohsmenR = crate :: BitReader ;
#[doc = "Field `GPIOHSMEN` writer - CPU2 IO port H clocks enable during Sleep and Stop modes"] pub type GpiohsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADCFSSMEN` reader - CPU2 ADC clocks enable during Sleep and Stop modes"] pub type AdcfssmenR = crate :: BitReader ;
#[doc = "Field `ADCFSSMEN` writer - CPU2 ADC clocks enable during Sleep and Stop modes"] pub type AdcfssmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AES1SMEN` reader - CPU2 AES1 accelerator clocks enable during Sleep and Stop modes"] pub type Aes1smenR = crate :: BitReader ;
#[doc = "Field `AES1SMEN` writer - CPU2 AES1 accelerator clocks enable during Sleep and Stop modes"] pub type Aes1smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - CPU2 IO port A clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn gpioasmen (& self) -> GpioasmenR { GpioasmenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - CPU2 IO port B clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn gpiobsmen (& self) -> GpiobsmenR { GpiobsmenR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - CPU2 IO port C clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn gpiocsmen (& self) -> GpiocsmenR { GpiocsmenR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - CPU2 IO port D clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn gpiodsmen (& self) -> GpiodsmenR { GpiodsmenR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - CPU2 IO port E clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn gpioesmen (& self) -> GpioesmenR { GpioesmenR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 7 - CPU2 IO port H clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn gpiohsmen (& self) -> GpiohsmenR { GpiohsmenR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 13 - CPU2 ADC clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn adcfssmen (& self) -> AdcfssmenR { AdcfssmenR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 16 - CPU2 AES1 accelerator clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn aes1smen (& self) -> Aes1smenR { Aes1smenR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bit 0 - CPU2 IO port A clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn gpioasmen (& mut self) -> GpioasmenW < '_ , C2ahb2smenrSpec > { GpioasmenW :: new (self , 0) }
#[doc = "Bit 1 - CPU2 IO port B clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn gpiobsmen (& mut self) -> GpiobsmenW < '_ , C2ahb2smenrSpec > { GpiobsmenW :: new (self , 1) }
#[doc = "Bit 2 - CPU2 IO port C clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn gpiocsmen (& mut self) -> GpiocsmenW < '_ , C2ahb2smenrSpec > { GpiocsmenW :: new (self , 2) }
#[doc = "Bit 3 - CPU2 IO port D clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn gpiodsmen (& mut self) -> GpiodsmenW < '_ , C2ahb2smenrSpec > { GpiodsmenW :: new (self , 3) }
#[doc = "Bit 4 - CPU2 IO port E clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn gpioesmen (& mut self) -> GpioesmenW < '_ , C2ahb2smenrSpec > { GpioesmenW :: new (self , 4) }
#[doc = "Bit 7 - CPU2 IO port H clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn gpiohsmen (& mut self) -> GpiohsmenW < '_ , C2ahb2smenrSpec > { GpiohsmenW :: new (self , 7) }
#[doc = "Bit 13 - CPU2 ADC clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn adcfssmen (& mut self) -> AdcfssmenW < '_ , C2ahb2smenrSpec > { AdcfssmenW :: new (self , 13) }
#[doc = "Bit 16 - CPU2 AES1 accelerator clocks enable during Sleep and Stop modes"]
#[inline (always)] pub fn aes1smen (& mut self) -> Aes1smenW < '_ , C2ahb2smenrSpec > { Aes1smenW :: new (self , 16) } }
#[doc = "CPU2 AHB2 peripheral clocks enable in Sleep and Stop modes register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2ahb2smenr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2ahb2smenr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2ahb2smenrSpec ; impl crate :: RegisterSpec for C2ahb2smenrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2ahb2smenr::R`](R) reader structure"] impl crate :: Readable for C2ahb2smenrSpec { }
#[doc = "`write(|w| ..)` method takes [`c2ahb2smenr::W`](W) writer structure"] impl crate :: Writable for C2ahb2smenrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2AHB2SMENR to value 0x0001_209f"] impl crate :: Resettable for C2ahb2smenrSpec { const RESET_VALUE : u32 = 0x0001_209f ; } }
#[doc = "C2AHB3SMENR (rw) register accessor: CPU2 AHB3 peripheral clocks enable in Sleep and Stop modes register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2ahb3smenr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2ahb3smenr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2ahb3smenr`] module"]
#[doc (alias = "C2AHB3SMENR")] pub type C2ahb3smenr = crate :: Reg < c2ahb3smenr :: C2ahb3smenrSpec > ;
#[doc = "CPU2 AHB3 peripheral clocks enable in Sleep and Stop modes register"] pub mod c2ahb3smenr {
#[doc = "Register `C2AHB3SMENR` reader"] pub type R = crate :: R < C2ahb3smenrSpec > ;
#[doc = "Register `C2AHB3SMENR` writer"] pub type W = crate :: W < C2ahb3smenrSpec > ;
#[doc = "Field `PKASMEN` reader - PKA accelerator clocks enable during CPU2 sleep modes"] pub type PkasmenR = crate :: BitReader ;
#[doc = "Field `PKASMEN` writer - PKA accelerator clocks enable during CPU2 sleep modes"] pub type PkasmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AES2SMEN` reader - AES2 accelerator clocks enable during CPU2 sleep modes"] pub type Aes2smenR = crate :: BitReader ;
#[doc = "Field `AES2SMEN` writer - AES2 accelerator clocks enable during CPU2 sleep modes"] pub type Aes2smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RNGSMEN` reader - True RNG clocks enable during CPU2 sleep modes"] pub type RngsmenR = crate :: BitReader ;
#[doc = "Field `RNGSMEN` writer - True RNG clocks enable during CPU2 sleep modes"] pub type RngsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SRAM2SMEN` reader - SRAM2a and SRAM2b memory interface clocks enable during CPU2 sleep modes"] pub type Sram2smenR = crate :: BitReader ;
#[doc = "Field `SRAM2SMEN` writer - SRAM2a and SRAM2b memory interface clocks enable during CPU2 sleep modes"] pub type Sram2smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FLASHSMEN` reader - Flash interface clocks enable during CPU2 sleep modes"] pub type FlashsmenR = crate :: BitReader ;
#[doc = "Field `FLASHSMEN` writer - Flash interface clocks enable during CPU2 sleep modes"] pub type FlashsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 16 - PKA accelerator clocks enable during CPU2 sleep modes"]
#[inline (always)] pub fn pkasmen (& self) -> PkasmenR { PkasmenR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - AES2 accelerator clocks enable during CPU2 sleep modes"]
#[inline (always)] pub fn aes2smen (& self) -> Aes2smenR { Aes2smenR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - True RNG clocks enable during CPU2 sleep modes"]
#[inline (always)] pub fn rngsmen (& self) -> RngsmenR { RngsmenR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 24 - SRAM2a and SRAM2b memory interface clocks enable during CPU2 sleep modes"]
#[inline (always)] pub fn sram2smen (& self) -> Sram2smenR { Sram2smenR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Flash interface clocks enable during CPU2 sleep modes"]
#[inline (always)] pub fn flashsmen (& self) -> FlashsmenR { FlashsmenR :: new (((self . bits >> 25) & 1) != 0) } } impl W {
#[doc = "Bit 16 - PKA accelerator clocks enable during CPU2 sleep modes"]
#[inline (always)] pub fn pkasmen (& mut self) -> PkasmenW < '_ , C2ahb3smenrSpec > { PkasmenW :: new (self , 16) }
#[doc = "Bit 17 - AES2 accelerator clocks enable during CPU2 sleep modes"]
#[inline (always)] pub fn aes2smen (& mut self) -> Aes2smenW < '_ , C2ahb3smenrSpec > { Aes2smenW :: new (self , 17) }
#[doc = "Bit 18 - True RNG clocks enable during CPU2 sleep modes"]
#[inline (always)] pub fn rngsmen (& mut self) -> RngsmenW < '_ , C2ahb3smenrSpec > { RngsmenW :: new (self , 18) }
#[doc = "Bit 24 - SRAM2a and SRAM2b memory interface clocks enable during CPU2 sleep modes"]
#[inline (always)] pub fn sram2smen (& mut self) -> Sram2smenW < '_ , C2ahb3smenrSpec > { Sram2smenW :: new (self , 24) }
#[doc = "Bit 25 - Flash interface clocks enable during CPU2 sleep modes"]
#[inline (always)] pub fn flashsmen (& mut self) -> FlashsmenW < '_ , C2ahb3smenrSpec > { FlashsmenW :: new (self , 25) } }
#[doc = "CPU2 AHB3 peripheral clocks enable in Sleep and Stop modes register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2ahb3smenr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2ahb3smenr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2ahb3smenrSpec ; impl crate :: RegisterSpec for C2ahb3smenrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2ahb3smenr::R`](R) reader structure"] impl crate :: Readable for C2ahb3smenrSpec { }
#[doc = "`write(|w| ..)` method takes [`c2ahb3smenr::W`](W) writer structure"] impl crate :: Writable for C2ahb3smenrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2AHB3SMENR to value 0x0307_0000"] impl crate :: Resettable for C2ahb3smenrSpec { const RESET_VALUE : u32 = 0x0307_0000 ; } }
#[doc = "C2APB1SMENR1 (rw) register accessor: CPU2 APB1SMENR1\n\nYou can [`read`](crate::Reg::read) this register and get [`c2apb1smenr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2apb1smenr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2apb1smenr1`] module"]
#[doc (alias = "C2APB1SMENR1")] pub type C2apb1smenr1 = crate :: Reg < c2apb1smenr1 :: C2apb1smenr1Spec > ;
#[doc = "CPU2 APB1SMENR1"] pub mod c2apb1smenr1 {
#[doc = "Register `C2APB1SMENR1` reader"] pub type R = crate :: R < C2apb1smenr1Spec > ;
#[doc = "Register `C2APB1SMENR1` writer"] pub type W = crate :: W < C2apb1smenr1Spec > ;
#[doc = "Field `TIM2SMEN` reader - TIM2 timer clocks enable during CPU2 Sleep mode"] pub type Tim2smenR = crate :: BitReader ;
#[doc = "Field `TIM2SMEN` writer - TIM2 timer clocks enable during CPU2 Sleep mode"] pub type Tim2smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCDSMEN` reader - LCD clocks enable during CPU2 Sleep mode"] pub type LcdsmenR = crate :: BitReader ;
#[doc = "Field `LCDSMEN` writer - LCD clocks enable during CPU2 Sleep mode"] pub type LcdsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RTCAPBSMEN` reader - RTC APB clocks enable during CPU2 Sleep mode"] pub type RtcapbsmenR = crate :: BitReader ;
#[doc = "Field `RTCAPBSMEN` writer - RTC APB clocks enable during CPU2 Sleep mode"] pub type RtcapbsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPI2SMEN` reader - SPI2 clocks enable during CPU2 Sleep mode"] pub type Spi2smenR = crate :: BitReader ;
#[doc = "Field `SPI2SMEN` writer - SPI2 clocks enable during CPU2 Sleep mode"] pub type Spi2smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `I2C1SMEN` reader - I2C1 clocks enable during CPU2 Sleep mode"] pub type I2c1smenR = crate :: BitReader ;
#[doc = "Field `I2C1SMEN` writer - I2C1 clocks enable during CPU2 Sleep mode"] pub type I2c1smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `I2C3SMEN` reader - I2C3 clocks enable during CPU2 Sleep mode"] pub type I2c3smenR = crate :: BitReader ;
#[doc = "Field `I2C3SMEN` writer - I2C3 clocks enable during CPU2 Sleep mode"] pub type I2c3smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CRSMEN` reader - CRS clocks enable during CPU2 Sleep mode"] pub type CrsmenR = crate :: BitReader ;
#[doc = "Field `CRSMEN` writer - CRS clocks enable during CPU2 Sleep mode"] pub type CrsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `USBSMEN` reader - USB FS clocks enable during CPU2 Sleep mode"] pub type UsbsmenR = crate :: BitReader ;
#[doc = "Field `USBSMEN` writer - USB FS clocks enable during CPU2 Sleep mode"] pub type UsbsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LPTIM1SMEN` reader - Low power timer 1 clocks enable during CPU2 Sleep mode"] pub type Lptim1smenR = crate :: BitReader ;
#[doc = "Field `LPTIM1SMEN` writer - Low power timer 1 clocks enable during CPU2 Sleep mode"] pub type Lptim1smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - TIM2 timer clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn tim2smen (& self) -> Tim2smenR { Tim2smenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 9 - LCD clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn lcdsmen (& self) -> LcdsmenR { LcdsmenR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - RTC APB clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn rtcapbsmen (& self) -> RtcapbsmenR { RtcapbsmenR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 14 - SPI2 clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn spi2smen (& self) -> Spi2smenR { Spi2smenR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 21 - I2C1 clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn i2c1smen (& self) -> I2c1smenR { I2c1smenR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 23 - I2C3 clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn i2c3smen (& self) -> I2c3smenR { I2c3smenR :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - CRS clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn crsmen (& self) -> CrsmenR { CrsmenR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 26 - USB FS clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn usbsmen (& self) -> UsbsmenR { UsbsmenR :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 31 - Low power timer 1 clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn lptim1smen (& self) -> Lptim1smenR { Lptim1smenR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - TIM2 timer clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn tim2smen (& mut self) -> Tim2smenW < '_ , C2apb1smenr1Spec > { Tim2smenW :: new (self , 0) }
#[doc = "Bit 9 - LCD clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn lcdsmen (& mut self) -> LcdsmenW < '_ , C2apb1smenr1Spec > { LcdsmenW :: new (self , 9) }
#[doc = "Bit 10 - RTC APB clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn rtcapbsmen (& mut self) -> RtcapbsmenW < '_ , C2apb1smenr1Spec > { RtcapbsmenW :: new (self , 10) }
#[doc = "Bit 14 - SPI2 clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn spi2smen (& mut self) -> Spi2smenW < '_ , C2apb1smenr1Spec > { Spi2smenW :: new (self , 14) }
#[doc = "Bit 21 - I2C1 clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn i2c1smen (& mut self) -> I2c1smenW < '_ , C2apb1smenr1Spec > { I2c1smenW :: new (self , 21) }
#[doc = "Bit 23 - I2C3 clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn i2c3smen (& mut self) -> I2c3smenW < '_ , C2apb1smenr1Spec > { I2c3smenW :: new (self , 23) }
#[doc = "Bit 24 - CRS clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn crsmen (& mut self) -> CrsmenW < '_ , C2apb1smenr1Spec > { CrsmenW :: new (self , 24) }
#[doc = "Bit 26 - USB FS clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn usbsmen (& mut self) -> UsbsmenW < '_ , C2apb1smenr1Spec > { UsbsmenW :: new (self , 26) }
#[doc = "Bit 31 - Low power timer 1 clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn lptim1smen (& mut self) -> Lptim1smenW < '_ , C2apb1smenr1Spec > { Lptim1smenW :: new (self , 31) } }
#[doc = "CPU2 APB1SMENR1\n\nYou can [`read`](crate::Reg::read) this register and get [`c2apb1smenr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2apb1smenr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2apb1smenr1Spec ; impl crate :: RegisterSpec for C2apb1smenr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2apb1smenr1::R`](R) reader structure"] impl crate :: Readable for C2apb1smenr1Spec { }
#[doc = "`write(|w| ..)` method takes [`c2apb1smenr1::W`](W) writer structure"] impl crate :: Writable for C2apb1smenr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2APB1SMENR1 to value 0x85a0_4601"] impl crate :: Resettable for C2apb1smenr1Spec { const RESET_VALUE : u32 = 0x85a0_4601 ; } }
#[doc = "C2APB1SMENR2 (rw) register accessor: CPU2 APB1 peripheral clocks enable in Sleep and Stop modes register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`c2apb1smenr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2apb1smenr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2apb1smenr2`] module"]
#[doc (alias = "C2APB1SMENR2")] pub type C2apb1smenr2 = crate :: Reg < c2apb1smenr2 :: C2apb1smenr2Spec > ;
#[doc = "CPU2 APB1 peripheral clocks enable in Sleep and Stop modes register 2"] pub mod c2apb1smenr2 {
#[doc = "Register `C2APB1SMENR2` reader"] pub type R = crate :: R < C2apb1smenr2Spec > ;
#[doc = "Register `C2APB1SMENR2` writer"] pub type W = crate :: W < C2apb1smenr2Spec > ;
#[doc = "Field `LPUART1SMEN` reader - Low power UART 1 clocks enable during CPU2 Sleep mode"] pub type Lpuart1smenR = crate :: BitReader ;
#[doc = "Field `LPUART1SMEN` writer - Low power UART 1 clocks enable during CPU2 Sleep mode"] pub type Lpuart1smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LPTIM2SMEN` reader - Low power timer 2 clocks enable during CPU2 Sleep mode"] pub type Lptim2smenR = crate :: BitReader ;
#[doc = "Field `LPTIM2SMEN` writer - Low power timer 2 clocks enable during CPU2 Sleep mode"] pub type Lptim2smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Low power UART 1 clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn lpuart1smen (& self) -> Lpuart1smenR { Lpuart1smenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 5 - Low power timer 2 clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn lptim2smen (& self) -> Lptim2smenR { Lptim2smenR :: new (((self . bits >> 5) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Low power UART 1 clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn lpuart1smen (& mut self) -> Lpuart1smenW < '_ , C2apb1smenr2Spec > { Lpuart1smenW :: new (self , 0) }
#[doc = "Bit 5 - Low power timer 2 clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn lptim2smen (& mut self) -> Lptim2smenW < '_ , C2apb1smenr2Spec > { Lptim2smenW :: new (self , 5) } }
#[doc = "CPU2 APB1 peripheral clocks enable in Sleep and Stop modes register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`c2apb1smenr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2apb1smenr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2apb1smenr2Spec ; impl crate :: RegisterSpec for C2apb1smenr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2apb1smenr2::R`](R) reader structure"] impl crate :: Readable for C2apb1smenr2Spec { }
#[doc = "`write(|w| ..)` method takes [`c2apb1smenr2::W`](W) writer structure"] impl crate :: Writable for C2apb1smenr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2APB1SMENR2 to value 0x21"] impl crate :: Resettable for C2apb1smenr2Spec { const RESET_VALUE : u32 = 0x21 ; } }
#[doc = "C2APB2SMENR (rw) register accessor: CPU2 APB2SMENR\n\nYou can [`read`](crate::Reg::read) this register and get [`c2apb2smenr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2apb2smenr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2apb2smenr`] module"]
#[doc (alias = "C2APB2SMENR")] pub type C2apb2smenr = crate :: Reg < c2apb2smenr :: C2apb2smenrSpec > ;
#[doc = "CPU2 APB2SMENR"] pub mod c2apb2smenr {
#[doc = "Register `C2APB2SMENR` reader"] pub type R = crate :: R < C2apb2smenrSpec > ;
#[doc = "Register `C2APB2SMENR` writer"] pub type W = crate :: W < C2apb2smenrSpec > ;
#[doc = "Field `TIM1SMEN` reader - TIM1 timer clocks enable during CPU2 Sleep mode"] pub type Tim1smenR = crate :: BitReader ;
#[doc = "Field `TIM1SMEN` writer - TIM1 timer clocks enable during CPU2 Sleep mode"] pub type Tim1smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPI1SMEN` reader - SPI1 clocks enable during CPU2 Sleep mode"] pub type Spi1smenR = crate :: BitReader ;
#[doc = "Field `SPI1SMEN` writer - SPI1 clocks enable during CPU2 Sleep mode"] pub type Spi1smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `USART1SMEN` reader - USART1clocks enable during CPU2 Sleep mode"] pub type Usart1smenR = crate :: BitReader ;
#[doc = "Field `USART1SMEN` writer - USART1clocks enable during CPU2 Sleep mode"] pub type Usart1smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM16SMEN` reader - TIM16 timer clocks enable during CPU2 Sleep mode"] pub type Tim16smenR = crate :: BitReader ;
#[doc = "Field `TIM16SMEN` writer - TIM16 timer clocks enable during CPU2 Sleep mode"] pub type Tim16smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM17SMEN` reader - TIM17 timer clocks enable during CPU2 Sleep mode"] pub type Tim17smenR = crate :: BitReader ;
#[doc = "Field `TIM17SMEN` writer - TIM17 timer clocks enable during CPU2 Sleep mode"] pub type Tim17smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SAI1SMEN` reader - SAI1 clocks enable during CPU2 Sleep mode"] pub type Sai1smenR = crate :: BitReader ;
#[doc = "Field `SAI1SMEN` writer - SAI1 clocks enable during CPU2 Sleep mode"] pub type Sai1smenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 11 - TIM1 timer clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn tim1smen (& self) -> Tim1smenR { Tim1smenR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - SPI1 clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn spi1smen (& self) -> Spi1smenR { Spi1smenR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 14 - USART1clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn usart1smen (& self) -> Usart1smenR { Usart1smenR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 17 - TIM16 timer clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn tim16smen (& self) -> Tim16smenR { Tim16smenR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - TIM17 timer clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn tim17smen (& self) -> Tim17smenR { Tim17smenR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 21 - SAI1 clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn sai1smen (& self) -> Sai1smenR { Sai1smenR :: new (((self . bits >> 21) & 1) != 0) } } impl W {
#[doc = "Bit 11 - TIM1 timer clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn tim1smen (& mut self) -> Tim1smenW < '_ , C2apb2smenrSpec > { Tim1smenW :: new (self , 11) }
#[doc = "Bit 12 - SPI1 clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn spi1smen (& mut self) -> Spi1smenW < '_ , C2apb2smenrSpec > { Spi1smenW :: new (self , 12) }
#[doc = "Bit 14 - USART1clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn usart1smen (& mut self) -> Usart1smenW < '_ , C2apb2smenrSpec > { Usart1smenW :: new (self , 14) }
#[doc = "Bit 17 - TIM16 timer clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn tim16smen (& mut self) -> Tim16smenW < '_ , C2apb2smenrSpec > { Tim16smenW :: new (self , 17) }
#[doc = "Bit 18 - TIM17 timer clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn tim17smen (& mut self) -> Tim17smenW < '_ , C2apb2smenrSpec > { Tim17smenW :: new (self , 18) }
#[doc = "Bit 21 - SAI1 clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn sai1smen (& mut self) -> Sai1smenW < '_ , C2apb2smenrSpec > { Sai1smenW :: new (self , 21) } }
#[doc = "CPU2 APB2SMENR\n\nYou can [`read`](crate::Reg::read) this register and get [`c2apb2smenr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2apb2smenr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2apb2smenrSpec ; impl crate :: RegisterSpec for C2apb2smenrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2apb2smenr::R`](R) reader structure"] impl crate :: Readable for C2apb2smenrSpec { }
#[doc = "`write(|w| ..)` method takes [`c2apb2smenr::W`](W) writer structure"] impl crate :: Writable for C2apb2smenrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2APB2SMENR to value 0x0026_5800"] impl crate :: Resettable for C2apb2smenrSpec { const RESET_VALUE : u32 = 0x0026_5800 ; } }
#[doc = "C2APB3SMENR (rw) register accessor: CPU2 APB3SMENR\n\nYou can [`read`](crate::Reg::read) this register and get [`c2apb3smenr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2apb3smenr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2apb3smenr`] module"]
#[doc (alias = "C2APB3SMENR")] pub type C2apb3smenr = crate :: Reg < c2apb3smenr :: C2apb3smenrSpec > ;
#[doc = "CPU2 APB3SMENR"] pub mod c2apb3smenr {
#[doc = "Register `C2APB3SMENR` reader"] pub type R = crate :: R < C2apb3smenrSpec > ;
#[doc = "Register `C2APB3SMENR` writer"] pub type W = crate :: W < C2apb3smenrSpec > ;
#[doc = "Field `BLESMEN` reader - BLE interface clocks enable during CPU2 Sleep mode"] pub type BlesmenR = crate :: BitReader ;
#[doc = "Field `BLESMEN` writer - BLE interface clocks enable during CPU2 Sleep mode"] pub type BlesmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SMEN802` reader - 802.15.4 interface clocks enable during CPU2 Sleep modes"] pub type Smen802R = crate :: BitReader ;
#[doc = "Field `SMEN802` writer - 802.15.4 interface clocks enable during CPU2 Sleep modes"] pub type Smen802W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - BLE interface clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn blesmen (& self) -> BlesmenR { BlesmenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - 802.15.4 interface clocks enable during CPU2 Sleep modes"]
#[inline (always)] pub fn smen802 (& self) -> Smen802R { Smen802R :: new (((self . bits >> 1) & 1) != 0) } } impl W {
#[doc = "Bit 0 - BLE interface clocks enable during CPU2 Sleep mode"]
#[inline (always)] pub fn blesmen (& mut self) -> BlesmenW < '_ , C2apb3smenrSpec > { BlesmenW :: new (self , 0) }
#[doc = "Bit 1 - 802.15.4 interface clocks enable during CPU2 Sleep modes"]
#[inline (always)] pub fn smen802 (& mut self) -> Smen802W < '_ , C2apb3smenrSpec > { Smen802W :: new (self , 1) } }
#[doc = "CPU2 APB3SMENR\n\nYou can [`read`](crate::Reg::read) this register and get [`c2apb3smenr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2apb3smenr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2apb3smenrSpec ; impl crate :: RegisterSpec for C2apb3smenrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2apb3smenr::R`](R) reader structure"] impl crate :: Readable for C2apb3smenrSpec { }
#[doc = "`write(|w| ..)` method takes [`c2apb3smenr::W`](W) writer structure"] impl crate :: Writable for C2apb3smenrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2APB3SMENR to value 0x03"] impl crate :: Resettable for C2apb3smenrSpec { const RESET_VALUE : u32 = 0x03 ; } } }
#[doc = "Power control"] pub type Pwr = crate :: Periph < pwr :: RegisterBlock , 0x5800_0400 > ; impl core :: fmt :: Debug for Pwr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Pwr") . finish () } }
#[doc = "Power control"] pub mod pwr {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr1 : Cr1 , cr2 : Cr2 , cr3 : Cr3 , cr4 : Cr4 , sr1 : Sr1 , sr2 : Sr2 , scr : Scr , cr5 : Cr5 , pucra : Pucra , pdcra : Pdcra , pucrb : Pucrb , pdcrb : Pdcrb , pucrc : Pucrc , pdcrc : Pdcrc , pucrd : Pucrd , pdcrd : Pdcrd , pucre : Pucre , pdcre : Pdcre , _reserved18 : [u8 ; 0x10] , pucrh : Pucrh , pdcrh : Pdcrh , _reserved20 : [u8 ; 0x20] , c2cr1 : C2cr1 , c2cr3 : C2cr3 , extscr : Extscr , } impl RegisterBlock {
#[doc = "0x00 - Power control register 1"]
#[inline (always)] pub const fn cr1 (& self) -> & Cr1 { & self . cr1 }
#[doc = "0x04 - Power control register 2"]
#[inline (always)] pub const fn cr2 (& self) -> & Cr2 { & self . cr2 }
#[doc = "0x08 - Power control register 3"]
#[inline (always)] pub const fn cr3 (& self) -> & Cr3 { & self . cr3 }
#[doc = "0x0c - Power control register 4"]
#[inline (always)] pub const fn cr4 (& self) -> & Cr4 { & self . cr4 }
#[doc = "0x10 - Power status register 1"]
#[inline (always)] pub const fn sr1 (& self) -> & Sr1 { & self . sr1 }
#[doc = "0x14 - Power status register 2"]
#[inline (always)] pub const fn sr2 (& self) -> & Sr2 { & self . sr2 }
#[doc = "0x18 - Power status clear register"]
#[inline (always)] pub const fn scr (& self) -> & Scr { & self . scr }
#[doc = "0x1c - Power control register 5"]
#[inline (always)] pub const fn cr5 (& self) -> & Cr5 { & self . cr5 }
#[doc = "0x20 - Power Port A pull-up control register"]
#[inline (always)] pub const fn pucra (& self) -> & Pucra { & self . pucra }
#[doc = "0x24 - Power Port A pull-down control register"]
#[inline (always)] pub const fn pdcra (& self) -> & Pdcra { & self . pdcra }
#[doc = "0x28 - Power Port B pull-up control register"]
#[inline (always)] pub const fn pucrb (& self) -> & Pucrb { & self . pucrb }
#[doc = "0x2c - Power Port B pull-down control register"]
#[inline (always)] pub const fn pdcrb (& self) -> & Pdcrb { & self . pdcrb }
#[doc = "0x30 - Power Port C pull-up control register"]
#[inline (always)] pub const fn pucrc (& self) -> & Pucrc { & self . pucrc }
#[doc = "0x34 - Power Port C pull-down control register"]
#[inline (always)] pub const fn pdcrc (& self) -> & Pdcrc { & self . pdcrc }
#[doc = "0x38 - Power Port D pull-up control register"]
#[inline (always)] pub const fn pucrd (& self) -> & Pucrd { & self . pucrd }
#[doc = "0x3c - Power Port D pull-down control register"]
#[inline (always)] pub const fn pdcrd (& self) -> & Pdcrd { & self . pdcrd }
#[doc = "0x40 - Power Port E pull-up control register"]
#[inline (always)] pub const fn pucre (& self) -> & Pucre { & self . pucre }
#[doc = "0x44 - Power Port E pull-down control register"]
#[inline (always)] pub const fn pdcre (& self) -> & Pdcre { & self . pdcre }
#[doc = "0x58 - Power Port H pull-up control register"]
#[inline (always)] pub const fn pucrh (& self) -> & Pucrh { & self . pucrh }
#[doc = "0x5c - Power Port H pull-down control register"]
#[inline (always)] pub const fn pdcrh (& self) -> & Pdcrh { & self . pdcrh }
#[doc = "0x80 - CPU2 Power control register 1"]
#[inline (always)] pub const fn c2cr1 (& self) -> & C2cr1 { & self . c2cr1 }
#[doc = "0x84 - CPU2 Power control register 3"]
#[inline (always)] pub const fn c2cr3 (& self) -> & C2cr3 { & self . c2cr3 }
#[doc = "0x88 - Power status clear register"]
#[inline (always)] pub const fn extscr (& self) -> & Extscr { & self . extscr } }
#[doc = "CR1 (rw) register accessor: Power control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
#[doc (alias = "CR1")] pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ;
#[doc = "Power control register 1"] pub mod cr1 {
#[doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ;
#[doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ;
#[doc = "Field `LPMS` reader - Low-power mode selection for CPU1"] pub type LpmsR = crate :: FieldReader ;
#[doc = "Field `LPMS` writer - Low-power mode selection for CPU1"] pub type LpmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `FPDR` reader - Flash power down mode during LPRun for CPU1"] pub type FpdrR = crate :: BitReader ;
#[doc = "Field `FPDR` writer - Flash power down mode during LPRun for CPU1"] pub type FpdrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FPDS` reader - Flash power down mode during LPsSleep for CPU1"] pub type FpdsR = crate :: BitReader ;
#[doc = "Field `FPDS` writer - Flash power down mode during LPsSleep for CPU1"] pub type FpdsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBP` reader - Disable backup domain write protection"] pub type DbpR = crate :: BitReader ;
#[doc = "Field `DBP` writer - Disable backup domain write protection"] pub type DbpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `VOS` reader - Voltage scaling range selection"] pub type VosR = crate :: FieldReader ;
#[doc = "Field `VOS` writer - Voltage scaling range selection"] pub type VosW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `LPR` reader - Low-power run"] pub type LprR = crate :: BitReader ;
#[doc = "Field `LPR` writer - Low-power run"] pub type LprW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:2 - Low-power mode selection for CPU1"]
#[inline (always)] pub fn lpms (& self) -> LpmsR { LpmsR :: new ((self . bits & 7) as u8) }
#[doc = "Bit 4 - Flash power down mode during LPRun for CPU1"]
#[inline (always)] pub fn fpdr (& self) -> FpdrR { FpdrR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Flash power down mode during LPsSleep for CPU1"]
#[inline (always)] pub fn fpds (& self) -> FpdsR { FpdsR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 8 - Disable backup domain write protection"]
#[inline (always)] pub fn dbp (& self) -> DbpR { DbpR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bits 9:10 - Voltage scaling range selection"]
#[inline (always)] pub fn vos (& self) -> VosR { VosR :: new (((self . bits >> 9) & 3) as u8) }
#[doc = "Bit 14 - Low-power run"]
#[inline (always)] pub fn lpr (& self) -> LprR { LprR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bits 0:2 - Low-power mode selection for CPU1"]
#[inline (always)] pub fn lpms (& mut self) -> LpmsW < '_ , Cr1Spec > { LpmsW :: new (self , 0) }
#[doc = "Bit 4 - Flash power down mode during LPRun for CPU1"]
#[inline (always)] pub fn fpdr (& mut self) -> FpdrW < '_ , Cr1Spec > { FpdrW :: new (self , 4) }
#[doc = "Bit 5 - Flash power down mode during LPsSleep for CPU1"]
#[inline (always)] pub fn fpds (& mut self) -> FpdsW < '_ , Cr1Spec > { FpdsW :: new (self , 5) }
#[doc = "Bit 8 - Disable backup domain write protection"]
#[inline (always)] pub fn dbp (& mut self) -> DbpW < '_ , Cr1Spec > { DbpW :: new (self , 8) }
#[doc = "Bits 9:10 - Voltage scaling range selection"]
#[inline (always)] pub fn vos (& mut self) -> VosW < '_ , Cr1Spec > { VosW :: new (self , 9) }
#[doc = "Bit 14 - Low-power run"]
#[inline (always)] pub fn lpr (& mut self) -> LprW < '_ , Cr1Spec > { LprW :: new (self , 14) } }
#[doc = "Power control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR1 to value 0x0200"] impl crate :: Resettable for Cr1Spec { const RESET_VALUE : u32 = 0x0200 ; } }
#[doc = "CR2 (rw) register accessor: Power control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`] module"]
#[doc (alias = "CR2")] pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ;
#[doc = "Power control register 2"] pub mod cr2 {
#[doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ;
#[doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ;
#[doc = "Field `PVDE` reader - Power voltage detector enable"] pub type PvdeR = crate :: BitReader ;
#[doc = "Field `PVDE` writer - Power voltage detector enable"] pub type PvdeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PLS` reader - Power voltage detector level selection"] pub type PlsR = crate :: FieldReader ;
#[doc = "Field `PLS` writer - Power voltage detector level selection"] pub type PlsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `PVME1` reader - Peripheral voltage monitoring 1 enable: VDDUSB vs. 1.2V"] pub type Pvme1R = crate :: BitReader ;
#[doc = "Field `PVME1` writer - Peripheral voltage monitoring 1 enable: VDDUSB vs. 1.2V"] pub type Pvme1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PVME3` reader - Peripheral voltage monitoring 3 enable: VDDA vs. 1.62V"] pub type Pvme3R = crate :: BitReader ;
#[doc = "Field `PVME3` writer - Peripheral voltage monitoring 3 enable: VDDA vs. 1.62V"] pub type Pvme3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `USV` reader - VDDUSB USB supply valid"] pub type UsvR = crate :: BitReader ;
#[doc = "Field `USV` writer - VDDUSB USB supply valid"] pub type UsvW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Power voltage detector enable"]
#[inline (always)] pub fn pvde (& self) -> PvdeR { PvdeR :: new ((self . bits & 1) != 0) }
#[doc = "Bits 1:3 - Power voltage detector level selection"]
#[inline (always)] pub fn pls (& self) -> PlsR { PlsR :: new (((self . bits >> 1) & 7) as u8) }
#[doc = "Bit 4 - Peripheral voltage monitoring 1 enable: VDDUSB vs. 1.2V"]
#[inline (always)] pub fn pvme1 (& self) -> Pvme1R { Pvme1R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - Peripheral voltage monitoring 3 enable: VDDA vs. 1.62V"]
#[inline (always)] pub fn pvme3 (& self) -> Pvme3R { Pvme3R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 10 - VDDUSB USB supply valid"]
#[inline (always)] pub fn usv (& self) -> UsvR { UsvR :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Power voltage detector enable"]
#[inline (always)] pub fn pvde (& mut self) -> PvdeW < '_ , Cr2Spec > { PvdeW :: new (self , 0) }
#[doc = "Bits 1:3 - Power voltage detector level selection"]
#[inline (always)] pub fn pls (& mut self) -> PlsW < '_ , Cr2Spec > { PlsW :: new (self , 1) }
#[doc = "Bit 4 - Peripheral voltage monitoring 1 enable: VDDUSB vs. 1.2V"]
#[inline (always)] pub fn pvme1 (& mut self) -> Pvme1W < '_ , Cr2Spec > { Pvme1W :: new (self , 4) }
#[doc = "Bit 6 - Peripheral voltage monitoring 3 enable: VDDA vs. 1.62V"]
#[inline (always)] pub fn pvme3 (& mut self) -> Pvme3W < '_ , Cr2Spec > { Pvme3W :: new (self , 6) }
#[doc = "Bit 10 - VDDUSB USB supply valid"]
#[inline (always)] pub fn usv (& mut self) -> UsvW < '_ , Cr2Spec > { UsvW :: new (self , 10) } }
#[doc = "Power control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR2 to value 0"] impl crate :: Resettable for Cr2Spec { } }
#[doc = "CR3 (rw) register accessor: Power control register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`cr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr3`] module"]
#[doc (alias = "CR3")] pub type Cr3 = crate :: Reg < cr3 :: Cr3Spec > ;
#[doc = "Power control register 3"] pub mod cr3 {
#[doc = "Register `CR3` reader"] pub type R = crate :: R < Cr3Spec > ;
#[doc = "Register `CR3` writer"] pub type W = crate :: W < Cr3Spec > ;
#[doc = "Field `EWUP1` reader - Enable Wakeup pin WKUP1"] pub type Ewup1R = crate :: BitReader ;
#[doc = "Field `EWUP1` writer - Enable Wakeup pin WKUP1"] pub type Ewup1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EWUP2` reader - Enable Wakeup pin WKUP2"] pub type Ewup2R = crate :: BitReader ;
#[doc = "Field `EWUP2` writer - Enable Wakeup pin WKUP2"] pub type Ewup2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EWUP3` reader - Enable Wakeup pin WKUP3"] pub type Ewup3R = crate :: BitReader ;
#[doc = "Field `EWUP3` writer - Enable Wakeup pin WKUP3"] pub type Ewup3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EWUP4` reader - Enable Wakeup pin WKUP4"] pub type Ewup4R = crate :: BitReader ;
#[doc = "Field `EWUP4` writer - Enable Wakeup pin WKUP4"] pub type Ewup4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EWUP5` reader - Enable Wakeup pin WKUP5"] pub type Ewup5R = crate :: BitReader ;
#[doc = "Field `EWUP5` writer - Enable Wakeup pin WKUP5"] pub type Ewup5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EBORHSDFB` reader - Enable BORH and Step Down counverter forced in Bypass interrups for CPU1"] pub type EborhsdfbR = crate :: BitReader ;
#[doc = "Field `EBORHSDFB` writer - Enable BORH and Step Down counverter forced in Bypass interrups for CPU1"] pub type EborhsdfbW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RRS` reader - SRAM2a retention in Standby mode"] pub type RrsR = crate :: BitReader ;
#[doc = "Field `RRS` writer - SRAM2a retention in Standby mode"] pub type RrsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `APC` reader - Apply pull-up and pull-down configuration"] pub type ApcR = crate :: BitReader ;
#[doc = "Field `APC` writer - Apply pull-up and pull-down configuration"] pub type ApcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EBLEA` reader - Enable BLE end of activity interrupt for CPU1"] pub type EbleaR = crate :: BitReader ;
#[doc = "Field `EBLEA` writer - Enable BLE end of activity interrupt for CPU1"] pub type EbleaW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ECRPE` reader - Enable critical radio phase end of activity interrupt for CPU1"] pub type EcrpeR = crate :: BitReader ;
#[doc = "Field `ECRPE` writer - Enable critical radio phase end of activity interrupt for CPU1"] pub type EcrpeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E802A` reader - Enable end of activity interrupt for CPU1"] pub type E802aR = crate :: BitReader ;
#[doc = "Field `E802A` writer - Enable end of activity interrupt for CPU1"] pub type E802aW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EC2H` reader - Enable CPU2 Hold interrupt for CPU1"] pub type Ec2hR = crate :: BitReader ;
#[doc = "Field `EC2H` writer - Enable CPU2 Hold interrupt for CPU1"] pub type Ec2hW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EIWUL` reader - Enable internal wakeup line for CPU1"] pub type EiwulR = crate :: BitReader ;
#[doc = "Field `EIWUL` writer - Enable internal wakeup line for CPU1"] pub type EiwulW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Enable Wakeup pin WKUP1"]
#[inline (always)] pub fn ewup1 (& self) -> Ewup1R { Ewup1R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Enable Wakeup pin WKUP2"]
#[inline (always)] pub fn ewup2 (& self) -> Ewup2R { Ewup2R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Enable Wakeup pin WKUP3"]
#[inline (always)] pub fn ewup3 (& self) -> Ewup3R { Ewup3R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Enable Wakeup pin WKUP4"]
#[inline (always)] pub fn ewup4 (& self) -> Ewup4R { Ewup4R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Enable Wakeup pin WKUP5"]
#[inline (always)] pub fn ewup5 (& self) -> Ewup5R { Ewup5R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 8 - Enable BORH and Step Down counverter forced in Bypass interrups for CPU1"]
#[inline (always)] pub fn eborhsdfb (& self) -> EborhsdfbR { EborhsdfbR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - SRAM2a retention in Standby mode"]
#[inline (always)] pub fn rrs (& self) -> RrsR { RrsR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Apply pull-up and pull-down configuration"]
#[inline (always)] pub fn apc (& self) -> ApcR { ApcR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Enable BLE end of activity interrupt for CPU1"]
#[inline (always)] pub fn eblea (& self) -> EbleaR { EbleaR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Enable critical radio phase end of activity interrupt for CPU1"]
#[inline (always)] pub fn ecrpe (& self) -> EcrpeR { EcrpeR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Enable end of activity interrupt for CPU1"]
#[inline (always)] pub fn e802a (& self) -> E802aR { E802aR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Enable CPU2 Hold interrupt for CPU1"]
#[inline (always)] pub fn ec2h (& self) -> Ec2hR { Ec2hR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Enable internal wakeup line for CPU1"]
#[inline (always)] pub fn eiwul (& self) -> EiwulR { EiwulR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Enable Wakeup pin WKUP1"]
#[inline (always)] pub fn ewup1 (& mut self) -> Ewup1W < '_ , Cr3Spec > { Ewup1W :: new (self , 0) }
#[doc = "Bit 1 - Enable Wakeup pin WKUP2"]
#[inline (always)] pub fn ewup2 (& mut self) -> Ewup2W < '_ , Cr3Spec > { Ewup2W :: new (self , 1) }
#[doc = "Bit 2 - Enable Wakeup pin WKUP3"]
#[inline (always)] pub fn ewup3 (& mut self) -> Ewup3W < '_ , Cr3Spec > { Ewup3W :: new (self , 2) }
#[doc = "Bit 3 - Enable Wakeup pin WKUP4"]
#[inline (always)] pub fn ewup4 (& mut self) -> Ewup4W < '_ , Cr3Spec > { Ewup4W :: new (self , 3) }
#[doc = "Bit 4 - Enable Wakeup pin WKUP5"]
#[inline (always)] pub fn ewup5 (& mut self) -> Ewup5W < '_ , Cr3Spec > { Ewup5W :: new (self , 4) }
#[doc = "Bit 8 - Enable BORH and Step Down counverter forced in Bypass interrups for CPU1"]
#[inline (always)] pub fn eborhsdfb (& mut self) -> EborhsdfbW < '_ , Cr3Spec > { EborhsdfbW :: new (self , 8) }
#[doc = "Bit 9 - SRAM2a retention in Standby mode"]
#[inline (always)] pub fn rrs (& mut self) -> RrsW < '_ , Cr3Spec > { RrsW :: new (self , 9) }
#[doc = "Bit 10 - Apply pull-up and pull-down configuration"]
#[inline (always)] pub fn apc (& mut self) -> ApcW < '_ , Cr3Spec > { ApcW :: new (self , 10) }
#[doc = "Bit 11 - Enable BLE end of activity interrupt for CPU1"]
#[inline (always)] pub fn eblea (& mut self) -> EbleaW < '_ , Cr3Spec > { EbleaW :: new (self , 11) }
#[doc = "Bit 12 - Enable critical radio phase end of activity interrupt for CPU1"]
#[inline (always)] pub fn ecrpe (& mut self) -> EcrpeW < '_ , Cr3Spec > { EcrpeW :: new (self , 12) }
#[doc = "Bit 13 - Enable end of activity interrupt for CPU1"]
#[inline (always)] pub fn e802a (& mut self) -> E802aW < '_ , Cr3Spec > { E802aW :: new (self , 13) }
#[doc = "Bit 14 - Enable CPU2 Hold interrupt for CPU1"]
#[inline (always)] pub fn ec2h (& mut self) -> Ec2hW < '_ , Cr3Spec > { Ec2hW :: new (self , 14) }
#[doc = "Bit 15 - Enable internal wakeup line for CPU1"]
#[inline (always)] pub fn eiwul (& mut self) -> EiwulW < '_ , Cr3Spec > { EiwulW :: new (self , 15) } }
#[doc = "Power control register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`cr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr3Spec ; impl crate :: RegisterSpec for Cr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr3::R`](R) reader structure"] impl crate :: Readable for Cr3Spec { }
#[doc = "`write(|w| ..)` method takes [`cr3::W`](W) writer structure"] impl crate :: Writable for Cr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR3 to value 0x8000"] impl crate :: Resettable for Cr3Spec { const RESET_VALUE : u32 = 0x8000 ; } }
#[doc = "CR4 (rw) register accessor: Power control register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`cr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr4`] module"]
#[doc (alias = "CR4")] pub type Cr4 = crate :: Reg < cr4 :: Cr4Spec > ;
#[doc = "Power control register 4"] pub mod cr4 {
#[doc = "Register `CR4` reader"] pub type R = crate :: R < Cr4Spec > ;
#[doc = "Register `CR4` writer"] pub type W = crate :: W < Cr4Spec > ;
#[doc = "Field `WP1` reader - Wakeup pin WKUP1 polarity"] pub type Wp1R = crate :: BitReader ;
#[doc = "Field `WP1` writer - Wakeup pin WKUP1 polarity"] pub type Wp1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WP2` reader - Wakeup pin WKUP2 polarity"] pub type Wp2R = crate :: BitReader ;
#[doc = "Field `WP2` writer - Wakeup pin WKUP2 polarity"] pub type Wp2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WP3` reader - Wakeup pin WKUP3 polarity"] pub type Wp3R = crate :: BitReader ;
#[doc = "Field `WP3` writer - Wakeup pin WKUP3 polarity"] pub type Wp3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WP4` reader - Wakeup pin WKUP4 polarity"] pub type Wp4R = crate :: BitReader ;
#[doc = "Field `WP4` writer - Wakeup pin WKUP4 polarity"] pub type Wp4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WP5` reader - Wakeup pin WKUP5 polarity"] pub type Wp5R = crate :: BitReader ;
#[doc = "Field `WP5` writer - Wakeup pin WKUP5 polarity"] pub type Wp5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `VBE` reader - VBAT battery charging enable"] pub type VbeR = crate :: BitReader ;
#[doc = "Field `VBE` writer - VBAT battery charging enable"] pub type VbeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `VBRS` reader - VBAT battery charging resistor selection"] pub type VbrsR = crate :: BitReader ;
#[doc = "Field `VBRS` writer - VBAT battery charging resistor selection"] pub type VbrsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `C2BOOT` reader - BOOT CPU2 after reset or wakeup from Stop or Standby modes"] pub type C2bootR = crate :: BitReader ;
#[doc = "Field `C2BOOT` writer - BOOT CPU2 after reset or wakeup from Stop or Standby modes"] pub type C2bootW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Wakeup pin WKUP1 polarity"]
#[inline (always)] pub fn wp1 (& self) -> Wp1R { Wp1R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Wakeup pin WKUP2 polarity"]
#[inline (always)] pub fn wp2 (& self) -> Wp2R { Wp2R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Wakeup pin WKUP3 polarity"]
#[inline (always)] pub fn wp3 (& self) -> Wp3R { Wp3R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Wakeup pin WKUP4 polarity"]
#[inline (always)] pub fn wp4 (& self) -> Wp4R { Wp4R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Wakeup pin WKUP5 polarity"]
#[inline (always)] pub fn wp5 (& self) -> Wp5R { Wp5R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 8 - VBAT battery charging enable"]
#[inline (always)] pub fn vbe (& self) -> VbeR { VbeR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - VBAT battery charging resistor selection"]
#[inline (always)] pub fn vbrs (& self) -> VbrsR { VbrsR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 15 - BOOT CPU2 after reset or wakeup from Stop or Standby modes"]
#[inline (always)] pub fn c2boot (& self) -> C2bootR { C2bootR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Wakeup pin WKUP1 polarity"]
#[inline (always)] pub fn wp1 (& mut self) -> Wp1W < '_ , Cr4Spec > { Wp1W :: new (self , 0) }
#[doc = "Bit 1 - Wakeup pin WKUP2 polarity"]
#[inline (always)] pub fn wp2 (& mut self) -> Wp2W < '_ , Cr4Spec > { Wp2W :: new (self , 1) }
#[doc = "Bit 2 - Wakeup pin WKUP3 polarity"]
#[inline (always)] pub fn wp3 (& mut self) -> Wp3W < '_ , Cr4Spec > { Wp3W :: new (self , 2) }
#[doc = "Bit 3 - Wakeup pin WKUP4 polarity"]
#[inline (always)] pub fn wp4 (& mut self) -> Wp4W < '_ , Cr4Spec > { Wp4W :: new (self , 3) }
#[doc = "Bit 4 - Wakeup pin WKUP5 polarity"]
#[inline (always)] pub fn wp5 (& mut self) -> Wp5W < '_ , Cr4Spec > { Wp5W :: new (self , 4) }
#[doc = "Bit 8 - VBAT battery charging enable"]
#[inline (always)] pub fn vbe (& mut self) -> VbeW < '_ , Cr4Spec > { VbeW :: new (self , 8) }
#[doc = "Bit 9 - VBAT battery charging resistor selection"]
#[inline (always)] pub fn vbrs (& mut self) -> VbrsW < '_ , Cr4Spec > { VbrsW :: new (self , 9) }
#[doc = "Bit 15 - BOOT CPU2 after reset or wakeup from Stop or Standby modes"]
#[inline (always)] pub fn c2boot (& mut self) -> C2bootW < '_ , Cr4Spec > { C2bootW :: new (self , 15) } }
#[doc = "Power control register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`cr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr4Spec ; impl crate :: RegisterSpec for Cr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr4::R`](R) reader structure"] impl crate :: Readable for Cr4Spec { }
#[doc = "`write(|w| ..)` method takes [`cr4::W`](W) writer structure"] impl crate :: Writable for Cr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR4 to value 0"] impl crate :: Resettable for Cr4Spec { } }
#[doc = "SR1 (r) register accessor: Power status register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`sr1::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr1`] module"]
#[doc (alias = "SR1")] pub type Sr1 = crate :: Reg < sr1 :: Sr1Spec > ;
#[doc = "Power status register 1"] pub mod sr1 {
#[doc = "Register `SR1` reader"] pub type R = crate :: R < Sr1Spec > ;
#[doc = "Field `CWUF1` reader - Wakeup flag 1"] pub type Cwuf1R = crate :: BitReader ;
#[doc = "Field `CWUF2` reader - Wakeup flag 2"] pub type Cwuf2R = crate :: BitReader ;
#[doc = "Field `CWUF3` reader - Wakeup flag 3"] pub type Cwuf3R = crate :: BitReader ;
#[doc = "Field `CWUF4` reader - Wakeup flag 4"] pub type Cwuf4R = crate :: BitReader ;
#[doc = "Field `CWUF5` reader - Wakeup flag 5"] pub type Cwuf5R = crate :: BitReader ;
#[doc = "Field `SDFBF` reader - Step Down converter forced in Bypass interrupt flag"] pub type SdfbfR = crate :: BitReader ;
#[doc = "Field `BORHF` reader - BORH interrupt flag"] pub type BorhfR = crate :: BitReader ;
#[doc = "Field `BLEWUF` reader - BLE wakeup interrupt flag"] pub type BlewufR = crate :: BitReader ;
#[doc = "Field `WUF802` reader - 802.15.4 wakeup interrupt flag"] pub type Wuf802R = crate :: BitReader ;
#[doc = "Field `CRPEF` reader - Enable critical radio phase end of activity interrupt flag"] pub type CrpefR = crate :: BitReader ;
#[doc = "Field `BLEAF` reader - BLE end of activity interrupt flag"] pub type BleafR = crate :: BitReader ;
#[doc = "Field `AF802` reader - 802.15.4 end of activity interrupt flag"] pub type Af802R = crate :: BitReader ;
#[doc = "Field `C2HF` reader - CPU2 Hold interrupt flag"] pub type C2hfR = crate :: BitReader ;
#[doc = "Field `WUFI` reader - Internal Wakeup interrupt flag"] pub type WufiR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Wakeup flag 1"]
#[inline (always)] pub fn cwuf1 (& self) -> Cwuf1R { Cwuf1R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Wakeup flag 2"]
#[inline (always)] pub fn cwuf2 (& self) -> Cwuf2R { Cwuf2R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Wakeup flag 3"]
#[inline (always)] pub fn cwuf3 (& self) -> Cwuf3R { Cwuf3R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Wakeup flag 4"]
#[inline (always)] pub fn cwuf4 (& self) -> Cwuf4R { Cwuf4R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Wakeup flag 5"]
#[inline (always)] pub fn cwuf5 (& self) -> Cwuf5R { Cwuf5R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 7 - Step Down converter forced in Bypass interrupt flag"]
#[inline (always)] pub fn sdfbf (& self) -> SdfbfR { SdfbfR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - BORH interrupt flag"]
#[inline (always)] pub fn borhf (& self) -> BorhfR { BorhfR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - BLE wakeup interrupt flag"]
#[inline (always)] pub fn blewuf (& self) -> BlewufR { BlewufR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - 802.15.4 wakeup interrupt flag"]
#[inline (always)] pub fn wuf802 (& self) -> Wuf802R { Wuf802R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Enable critical radio phase end of activity interrupt flag"]
#[inline (always)] pub fn crpef (& self) -> CrpefR { CrpefR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - BLE end of activity interrupt flag"]
#[inline (always)] pub fn bleaf (& self) -> BleafR { BleafR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - 802.15.4 end of activity interrupt flag"]
#[inline (always)] pub fn af802 (& self) -> Af802R { Af802R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - CPU2 Hold interrupt flag"]
#[inline (always)] pub fn c2hf (& self) -> C2hfR { C2hfR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Internal Wakeup interrupt flag"]
#[inline (always)] pub fn wufi (& self) -> WufiR { WufiR :: new (((self . bits >> 15) & 1) != 0) } }
#[doc = "Power status register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`sr1::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Sr1Spec ; impl crate :: RegisterSpec for Sr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr1::R`](R) reader structure"] impl crate :: Readable for Sr1Spec { }
#[doc = "`reset()` method sets SR1 to value 0"] impl crate :: Resettable for Sr1Spec { } }
#[doc = "SR2 (r) register accessor: Power status register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`sr2::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr2`] module"]
#[doc (alias = "SR2")] pub type Sr2 = crate :: Reg < sr2 :: Sr2Spec > ;
#[doc = "Power status register 2"] pub mod sr2 {
#[doc = "Register `SR2` reader"] pub type R = crate :: R < Sr2Spec > ;
#[doc = "Field `SDBF` reader - Step Down converter Bypass mode flag"] pub type SdbfR = crate :: BitReader ;
#[doc = "Field `SDSMPSF` reader - Step Down converter SMPS mode flag"] pub type SdsmpsfR = crate :: BitReader ;
#[doc = "Field `REGLPS` reader - Low-power regulator started"] pub type ReglpsR = crate :: BitReader ;
#[doc = "Field `REGLPF` reader - Low-power regulator flag"] pub type ReglpfR = crate :: BitReader ;
#[doc = "Field `VOSF` reader - Voltage scaling flag"] pub type VosfR = crate :: BitReader ;
#[doc = "Field `PVDO` reader - Power voltage detector output"] pub type PvdoR = crate :: BitReader ;
#[doc = "Field `PVMO1` reader - Peripheral voltage monitoring output: VDDUSB vs. 1.2 V"] pub type Pvmo1R = crate :: BitReader ;
#[doc = "Field `PVMO3` reader - Peripheral voltage monitoring output: VDDA vs. 1.62 V"] pub type Pvmo3R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Step Down converter Bypass mode flag"]
#[inline (always)] pub fn sdbf (& self) -> SdbfR { SdbfR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Step Down converter SMPS mode flag"]
#[inline (always)] pub fn sdsmpsf (& self) -> SdsmpsfR { SdsmpsfR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 8 - Low-power regulator started"]
#[inline (always)] pub fn reglps (& self) -> ReglpsR { ReglpsR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Low-power regulator flag"]
#[inline (always)] pub fn reglpf (& self) -> ReglpfR { ReglpfR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Voltage scaling flag"]
#[inline (always)] pub fn vosf (& self) -> VosfR { VosfR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Power voltage detector output"]
#[inline (always)] pub fn pvdo (& self) -> PvdoR { PvdoR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Peripheral voltage monitoring output: VDDUSB vs. 1.2 V"]
#[inline (always)] pub fn pvmo1 (& self) -> Pvmo1R { Pvmo1R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 14 - Peripheral voltage monitoring output: VDDA vs. 1.62 V"]
#[inline (always)] pub fn pvmo3 (& self) -> Pvmo3R { Pvmo3R :: new (((self . bits >> 14) & 1) != 0) } }
#[doc = "Power status register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`sr2::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Sr2Spec ; impl crate :: RegisterSpec for Sr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr2::R`](R) reader structure"] impl crate :: Readable for Sr2Spec { }
#[doc = "`reset()` method sets SR2 to value 0x02"] impl crate :: Resettable for Sr2Spec { const RESET_VALUE : u32 = 0x02 ; } }
#[doc = "SCR (w) register accessor: Power status clear register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`scr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@scr`] module"]
#[doc (alias = "SCR")] pub type Scr = crate :: Reg < scr :: ScrSpec > ;
#[doc = "Power status clear register"] pub mod scr {
#[doc = "Register `SCR` writer"] pub type W = crate :: W < ScrSpec > ;
#[doc = "Field `CWUF1` writer - Clear wakeup flag 1"] pub type Cwuf1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CWUF2` writer - Clear wakeup flag 2"] pub type Cwuf2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CWUF3` writer - Clear wakeup flag 3"] pub type Cwuf3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CWUF4` writer - Clear wakeup flag 4"] pub type Cwuf4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CWUF5` writer - Clear wakeup flag 5"] pub type Cwuf5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CSMPSFBF` writer - Clear SMPS Step Down converter forced in Bypass interrupt flag"] pub type CsmpsfbfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CBORHF` writer - Clear BORH interrupt flag"] pub type CborhfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CBLEWUF` writer - Clear BLE wakeup interrupt flag"] pub type CblewufW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `C802WUF` writer - Clear 802.15.4 wakeup interrupt flag"] pub type C802wufW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CCRPEF` writer - Clear critical radio phase end of activity interrupt flag"] pub type CcrpefW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CBLEAF` writer - Clear BLE end of activity interrupt flag"] pub type CbleafW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `C802AF` writer - Clear 802.15.4 end of activity interrupt flag"] pub type C802afW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2HF` writer - Clear CPU2 Hold interrupt flag"] pub type Cc2hfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Clear wakeup flag 1"]
#[inline (always)] pub fn cwuf1 (& mut self) -> Cwuf1W < '_ , ScrSpec > { Cwuf1W :: new (self , 0) }
#[doc = "Bit 1 - Clear wakeup flag 2"]
#[inline (always)] pub fn cwuf2 (& mut self) -> Cwuf2W < '_ , ScrSpec > { Cwuf2W :: new (self , 1) }
#[doc = "Bit 2 - Clear wakeup flag 3"]
#[inline (always)] pub fn cwuf3 (& mut self) -> Cwuf3W < '_ , ScrSpec > { Cwuf3W :: new (self , 2) }
#[doc = "Bit 3 - Clear wakeup flag 4"]
#[inline (always)] pub fn cwuf4 (& mut self) -> Cwuf4W < '_ , ScrSpec > { Cwuf4W :: new (self , 3) }
#[doc = "Bit 4 - Clear wakeup flag 5"]
#[inline (always)] pub fn cwuf5 (& mut self) -> Cwuf5W < '_ , ScrSpec > { Cwuf5W :: new (self , 4) }
#[doc = "Bit 7 - Clear SMPS Step Down converter forced in Bypass interrupt flag"]
#[inline (always)] pub fn csmpsfbf (& mut self) -> CsmpsfbfW < '_ , ScrSpec > { CsmpsfbfW :: new (self , 7) }
#[doc = "Bit 8 - Clear BORH interrupt flag"]
#[inline (always)] pub fn cborhf (& mut self) -> CborhfW < '_ , ScrSpec > { CborhfW :: new (self , 8) }
#[doc = "Bit 9 - Clear BLE wakeup interrupt flag"]
#[inline (always)] pub fn cblewuf (& mut self) -> CblewufW < '_ , ScrSpec > { CblewufW :: new (self , 9) }
#[doc = "Bit 10 - Clear 802.15.4 wakeup interrupt flag"]
#[inline (always)] pub fn c802wuf (& mut self) -> C802wufW < '_ , ScrSpec > { C802wufW :: new (self , 10) }
#[doc = "Bit 11 - Clear critical radio phase end of activity interrupt flag"]
#[inline (always)] pub fn ccrpef (& mut self) -> CcrpefW < '_ , ScrSpec > { CcrpefW :: new (self , 11) }
#[doc = "Bit 12 - Clear BLE end of activity interrupt flag"]
#[inline (always)] pub fn cbleaf (& mut self) -> CbleafW < '_ , ScrSpec > { CbleafW :: new (self , 12) }
#[doc = "Bit 13 - Clear 802.15.4 end of activity interrupt flag"]
#[inline (always)] pub fn c802af (& mut self) -> C802afW < '_ , ScrSpec > { C802afW :: new (self , 13) }
#[doc = "Bit 14 - Clear CPU2 Hold interrupt flag"]
#[inline (always)] pub fn cc2hf (& mut self) -> Cc2hfW < '_ , ScrSpec > { Cc2hfW :: new (self , 14) } }
#[doc = "Power status clear register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`scr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ScrSpec ; impl crate :: RegisterSpec for ScrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`scr::W`](W) writer structure"] impl crate :: Writable for ScrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SCR to value 0"] impl crate :: Resettable for ScrSpec { } }
#[doc = "CR5 (rw) register accessor: Power control register 5\n\nYou can [`read`](crate::Reg::read) this register and get [`cr5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr5`] module"]
#[doc (alias = "CR5")] pub type Cr5 = crate :: Reg < cr5 :: Cr5Spec > ;
#[doc = "Power control register 5"] pub mod cr5 {
#[doc = "Register `CR5` reader"] pub type R = crate :: R < Cr5Spec > ;
#[doc = "Register `CR5` writer"] pub type W = crate :: W < Cr5Spec > ;
#[doc = "Field `SMPSVOS` reader - SMPS step-down converter voltage output scaling"] pub type SmpsvosR = crate :: FieldReader ;
#[doc = "Field `SMPSVOS` writer - SMPS step-down converter voltage output scaling"] pub type SmpsvosW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `SMPSSC` reader - SMPS step-down converter supply startup current selection"] pub type SmpsscR = crate :: FieldReader ;
#[doc = "Field `SMPSSC` writer - SMPS step-down converter supply startup current selection"] pub type SmpsscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `BORHC` reader - BORH configuration selection"] pub type BorhcR = crate :: BitReader ;
#[doc = "Field `BORHC` writer - BORH configuration selection"] pub type BorhcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SMPSEN` reader - Enable SMPS step-down converter SMPS mode enabled"] pub type SmpsenR = crate :: BitReader ;
#[doc = "Field `SMPSEN` writer - Enable SMPS step-down converter SMPS mode enabled"] pub type SmpsenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:3 - SMPS step-down converter voltage output scaling"]
#[inline (always)] pub fn smpsvos (& self) -> SmpsvosR { SmpsvosR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:6 - SMPS step-down converter supply startup current selection"]
#[inline (always)] pub fn smpssc (& self) -> SmpsscR { SmpsscR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 8 - BORH configuration selection"]
#[inline (always)] pub fn borhc (& self) -> BorhcR { BorhcR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 15 - Enable SMPS step-down converter SMPS mode enabled"]
#[inline (always)] pub fn smpsen (& self) -> SmpsenR { SmpsenR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - SMPS step-down converter voltage output scaling"]
#[inline (always)] pub fn smpsvos (& mut self) -> SmpsvosW < '_ , Cr5Spec > { SmpsvosW :: new (self , 0) }
#[doc = "Bits 4:6 - SMPS step-down converter supply startup current selection"]
#[inline (always)] pub fn smpssc (& mut self) -> SmpsscW < '_ , Cr5Spec > { SmpsscW :: new (self , 4) }
#[doc = "Bit 8 - BORH configuration selection"]
#[inline (always)] pub fn borhc (& mut self) -> BorhcW < '_ , Cr5Spec > { BorhcW :: new (self , 8) }
#[doc = "Bit 15 - Enable SMPS step-down converter SMPS mode enabled"]
#[inline (always)] pub fn smpsen (& mut self) -> SmpsenW < '_ , Cr5Spec > { SmpsenW :: new (self , 15) } }
#[doc = "Power control register 5\n\nYou can [`read`](crate::Reg::read) this register and get [`cr5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr5Spec ; impl crate :: RegisterSpec for Cr5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr5::R`](R) reader structure"] impl crate :: Readable for Cr5Spec { }
#[doc = "`write(|w| ..)` method takes [`cr5::W`](W) writer structure"] impl crate :: Writable for Cr5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR5 to value 0x4270"] impl crate :: Resettable for Cr5Spec { const RESET_VALUE : u32 = 0x4270 ; } }
#[doc = "PUCRA (rw) register accessor: Power Port A pull-up control register\n\nYou can [`read`](crate::Reg::read) this register and get [`pucra::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pucra::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pucra`] module"]
#[doc (alias = "PUCRA")] pub type Pucra = crate :: Reg < pucra :: PucraSpec > ;
#[doc = "Power Port A pull-up control register"] pub mod pucra {
#[doc = "Register `PUCRA` reader"] pub type R = crate :: R < PucraSpec > ;
#[doc = "Register `PUCRA` writer"] pub type W = crate :: W < PucraSpec > ;
#[doc = "Field `PU0` reader - Port A pull-up bit y (y=0..15)"] pub type Pu0R = crate :: BitReader ;
#[doc = "Field `PU0` writer - Port A pull-up bit y (y=0..15)"] pub type Pu0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU1` reader - Port A pull-up bit y (y=0..15)"] pub type Pu1R = crate :: BitReader ;
#[doc = "Field `PU1` writer - Port A pull-up bit y (y=0..15)"] pub type Pu1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU2` reader - Port A pull-up bit y (y=0..15)"] pub type Pu2R = crate :: BitReader ;
#[doc = "Field `PU2` writer - Port A pull-up bit y (y=0..15)"] pub type Pu2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU3` reader - Port A pull-up bit y (y=0..15)"] pub type Pu3R = crate :: BitReader ;
#[doc = "Field `PU3` writer - Port A pull-up bit y (y=0..15)"] pub type Pu3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU4` reader - Port A pull-up bit y (y=0..15)"] pub type Pu4R = crate :: BitReader ;
#[doc = "Field `PU4` writer - Port A pull-up bit y (y=0..15)"] pub type Pu4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU5` reader - Port A pull-up bit y (y=0..15)"] pub type Pu5R = crate :: BitReader ;
#[doc = "Field `PU5` writer - Port A pull-up bit y (y=0..15)"] pub type Pu5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU6` reader - Port A pull-up bit y (y=0..15)"] pub type Pu6R = crate :: BitReader ;
#[doc = "Field `PU6` writer - Port A pull-up bit y (y=0..15)"] pub type Pu6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU7` reader - Port A pull-up bit y (y=0..15)"] pub type Pu7R = crate :: BitReader ;
#[doc = "Field `PU7` writer - Port A pull-up bit y (y=0..15)"] pub type Pu7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU8` reader - Port A pull-up bit y (y=0..15)"] pub type Pu8R = crate :: BitReader ;
#[doc = "Field `PU8` writer - Port A pull-up bit y (y=0..15)"] pub type Pu8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU9` reader - Port A pull-up bit y (y=0..15)"] pub type Pu9R = crate :: BitReader ;
#[doc = "Field `PU9` writer - Port A pull-up bit y (y=0..15)"] pub type Pu9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU10` reader - Port A pull-up bit y (y=0..15)"] pub type Pu10R = crate :: BitReader ;
#[doc = "Field `PU10` writer - Port A pull-up bit y (y=0..15)"] pub type Pu10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU11` reader - Port A pull-up bit y (y=0..15)"] pub type Pu11R = crate :: BitReader ;
#[doc = "Field `PU11` writer - Port A pull-up bit y (y=0..15)"] pub type Pu11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU12` reader - Port A pull-up bit y (y=0..15)"] pub type Pu12R = crate :: BitReader ;
#[doc = "Field `PU12` writer - Port A pull-up bit y (y=0..15)"] pub type Pu12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU13` reader - Port A pull-up bit y (y=0..15)"] pub type Pu13R = crate :: BitReader ;
#[doc = "Field `PU13` writer - Port A pull-up bit y (y=0..15)"] pub type Pu13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU15` reader - Port A pull-up bit y (y=0..15)"] pub type Pu15R = crate :: BitReader ;
#[doc = "Field `PU15` writer - Port A pull-up bit y (y=0..15)"] pub type Pu15W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu0 (& self) -> Pu0R { Pu0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu1 (& self) -> Pu1R { Pu1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu2 (& self) -> Pu2R { Pu2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu3 (& self) -> Pu3R { Pu3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu4 (& self) -> Pu4R { Pu4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu5 (& self) -> Pu5R { Pu5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu6 (& self) -> Pu6R { Pu6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu7 (& self) -> Pu7R { Pu7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu8 (& self) -> Pu8R { Pu8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu9 (& self) -> Pu9R { Pu9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu10 (& self) -> Pu10R { Pu10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu11 (& self) -> Pu11R { Pu11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu12 (& self) -> Pu12R { Pu12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu13 (& self) -> Pu13R { Pu13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 15 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu15 (& self) -> Pu15R { Pu15R :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu0 (& mut self) -> Pu0W < '_ , PucraSpec > { Pu0W :: new (self , 0) }
#[doc = "Bit 1 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu1 (& mut self) -> Pu1W < '_ , PucraSpec > { Pu1W :: new (self , 1) }
#[doc = "Bit 2 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu2 (& mut self) -> Pu2W < '_ , PucraSpec > { Pu2W :: new (self , 2) }
#[doc = "Bit 3 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu3 (& mut self) -> Pu3W < '_ , PucraSpec > { Pu3W :: new (self , 3) }
#[doc = "Bit 4 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu4 (& mut self) -> Pu4W < '_ , PucraSpec > { Pu4W :: new (self , 4) }
#[doc = "Bit 5 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu5 (& mut self) -> Pu5W < '_ , PucraSpec > { Pu5W :: new (self , 5) }
#[doc = "Bit 6 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu6 (& mut self) -> Pu6W < '_ , PucraSpec > { Pu6W :: new (self , 6) }
#[doc = "Bit 7 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu7 (& mut self) -> Pu7W < '_ , PucraSpec > { Pu7W :: new (self , 7) }
#[doc = "Bit 8 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu8 (& mut self) -> Pu8W < '_ , PucraSpec > { Pu8W :: new (self , 8) }
#[doc = "Bit 9 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu9 (& mut self) -> Pu9W < '_ , PucraSpec > { Pu9W :: new (self , 9) }
#[doc = "Bit 10 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu10 (& mut self) -> Pu10W < '_ , PucraSpec > { Pu10W :: new (self , 10) }
#[doc = "Bit 11 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu11 (& mut self) -> Pu11W < '_ , PucraSpec > { Pu11W :: new (self , 11) }
#[doc = "Bit 12 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu12 (& mut self) -> Pu12W < '_ , PucraSpec > { Pu12W :: new (self , 12) }
#[doc = "Bit 13 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu13 (& mut self) -> Pu13W < '_ , PucraSpec > { Pu13W :: new (self , 13) }
#[doc = "Bit 15 - Port A pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu15 (& mut self) -> Pu15W < '_ , PucraSpec > { Pu15W :: new (self , 15) } }
#[doc = "Power Port A pull-up control register\n\nYou can [`read`](crate::Reg::read) this register and get [`pucra::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pucra::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PucraSpec ; impl crate :: RegisterSpec for PucraSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pucra::R`](R) reader structure"] impl crate :: Readable for PucraSpec { }
#[doc = "`write(|w| ..)` method takes [`pucra::W`](W) writer structure"] impl crate :: Writable for PucraSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PUCRA to value 0"] impl crate :: Resettable for PucraSpec { } }
#[doc = "PDCRA (rw) register accessor: Power Port A pull-down control register\n\nYou can [`read`](crate::Reg::read) this register and get [`pdcra::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pdcra::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pdcra`] module"]
#[doc (alias = "PDCRA")] pub type Pdcra = crate :: Reg < pdcra :: PdcraSpec > ;
#[doc = "Power Port A pull-down control register"] pub mod pdcra {
#[doc = "Register `PDCRA` reader"] pub type R = crate :: R < PdcraSpec > ;
#[doc = "Register `PDCRA` writer"] pub type W = crate :: W < PdcraSpec > ;
#[doc = "Field `PD0` reader - Port A pull-down bit y (y=0..15)"] pub type Pd0R = crate :: BitReader ;
#[doc = "Field `PD0` writer - Port A pull-down bit y (y=0..15)"] pub type Pd0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD1` reader - Port A pull-down bit y (y=0..15)"] pub type Pd1R = crate :: BitReader ;
#[doc = "Field `PD1` writer - Port A pull-down bit y (y=0..15)"] pub type Pd1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD2` reader - Port A pull-down bit y (y=0..15)"] pub type Pd2R = crate :: BitReader ;
#[doc = "Field `PD2` writer - Port A pull-down bit y (y=0..15)"] pub type Pd2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD3` reader - Port A pull-down bit y (y=0..15)"] pub type Pd3R = crate :: BitReader ;
#[doc = "Field `PD3` writer - Port A pull-down bit y (y=0..15)"] pub type Pd3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD4` reader - Port A pull-down bit y (y=0..15)"] pub type Pd4R = crate :: BitReader ;
#[doc = "Field `PD4` writer - Port A pull-down bit y (y=0..15)"] pub type Pd4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD5` reader - Port A pull-down bit y (y=0..15)"] pub type Pd5R = crate :: BitReader ;
#[doc = "Field `PD5` writer - Port A pull-down bit y (y=0..15)"] pub type Pd5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD6` reader - Port A pull-down bit y (y=0..15)"] pub type Pd6R = crate :: BitReader ;
#[doc = "Field `PD6` writer - Port A pull-down bit y (y=0..15)"] pub type Pd6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD7` reader - Port A pull-down bit y (y=0..15)"] pub type Pd7R = crate :: BitReader ;
#[doc = "Field `PD7` writer - Port A pull-down bit y (y=0..15)"] pub type Pd7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD8` reader - Port A pull-down bit y (y=0..15)"] pub type Pd8R = crate :: BitReader ;
#[doc = "Field `PD8` writer - Port A pull-down bit y (y=0..15)"] pub type Pd8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD9` reader - Port A pull-down bit y (y=0..15)"] pub type Pd9R = crate :: BitReader ;
#[doc = "Field `PD9` writer - Port A pull-down bit y (y=0..15)"] pub type Pd9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD10` reader - Port A pull-down bit y (y=0..15)"] pub type Pd10R = crate :: BitReader ;
#[doc = "Field `PD10` writer - Port A pull-down bit y (y=0..15)"] pub type Pd10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD11` reader - Port A pull-down bit y (y=0..15)"] pub type Pd11R = crate :: BitReader ;
#[doc = "Field `PD11` writer - Port A pull-down bit y (y=0..15)"] pub type Pd11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD12` reader - Port A pull-down bit y (y=0..15)"] pub type Pd12R = crate :: BitReader ;
#[doc = "Field `PD12` writer - Port A pull-down bit y (y=0..15)"] pub type Pd12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD14` reader - Port A pull-down bit y (y=0..15)"] pub type Pd14R = crate :: BitReader ;
#[doc = "Field `PD14` writer - Port A pull-down bit y (y=0..15)"] pub type Pd14W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd0 (& self) -> Pd0R { Pd0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd1 (& self) -> Pd1R { Pd1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd2 (& self) -> Pd2R { Pd2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd3 (& self) -> Pd3R { Pd3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd4 (& self) -> Pd4R { Pd4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd5 (& self) -> Pd5R { Pd5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd6 (& self) -> Pd6R { Pd6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd7 (& self) -> Pd7R { Pd7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd8 (& self) -> Pd8R { Pd8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd9 (& self) -> Pd9R { Pd9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd10 (& self) -> Pd10R { Pd10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd11 (& self) -> Pd11R { Pd11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd12 (& self) -> Pd12R { Pd12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 14 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd14 (& self) -> Pd14R { Pd14R :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd0 (& mut self) -> Pd0W < '_ , PdcraSpec > { Pd0W :: new (self , 0) }
#[doc = "Bit 1 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd1 (& mut self) -> Pd1W < '_ , PdcraSpec > { Pd1W :: new (self , 1) }
#[doc = "Bit 2 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd2 (& mut self) -> Pd2W < '_ , PdcraSpec > { Pd2W :: new (self , 2) }
#[doc = "Bit 3 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd3 (& mut self) -> Pd3W < '_ , PdcraSpec > { Pd3W :: new (self , 3) }
#[doc = "Bit 4 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd4 (& mut self) -> Pd4W < '_ , PdcraSpec > { Pd4W :: new (self , 4) }
#[doc = "Bit 5 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd5 (& mut self) -> Pd5W < '_ , PdcraSpec > { Pd5W :: new (self , 5) }
#[doc = "Bit 6 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd6 (& mut self) -> Pd6W < '_ , PdcraSpec > { Pd6W :: new (self , 6) }
#[doc = "Bit 7 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd7 (& mut self) -> Pd7W < '_ , PdcraSpec > { Pd7W :: new (self , 7) }
#[doc = "Bit 8 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd8 (& mut self) -> Pd8W < '_ , PdcraSpec > { Pd8W :: new (self , 8) }
#[doc = "Bit 9 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd9 (& mut self) -> Pd9W < '_ , PdcraSpec > { Pd9W :: new (self , 9) }
#[doc = "Bit 10 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd10 (& mut self) -> Pd10W < '_ , PdcraSpec > { Pd10W :: new (self , 10) }
#[doc = "Bit 11 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd11 (& mut self) -> Pd11W < '_ , PdcraSpec > { Pd11W :: new (self , 11) }
#[doc = "Bit 12 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd12 (& mut self) -> Pd12W < '_ , PdcraSpec > { Pd12W :: new (self , 12) }
#[doc = "Bit 14 - Port A pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd14 (& mut self) -> Pd14W < '_ , PdcraSpec > { Pd14W :: new (self , 14) } }
#[doc = "Power Port A pull-down control register\n\nYou can [`read`](crate::Reg::read) this register and get [`pdcra::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pdcra::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PdcraSpec ; impl crate :: RegisterSpec for PdcraSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pdcra::R`](R) reader structure"] impl crate :: Readable for PdcraSpec { }
#[doc = "`write(|w| ..)` method takes [`pdcra::W`](W) writer structure"] impl crate :: Writable for PdcraSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PDCRA to value 0"] impl crate :: Resettable for PdcraSpec { } }
#[doc = "PUCRB (rw) register accessor: Power Port B pull-up control register\n\nYou can [`read`](crate::Reg::read) this register and get [`pucrb::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pucrb::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pucrb`] module"]
#[doc (alias = "PUCRB")] pub type Pucrb = crate :: Reg < pucrb :: PucrbSpec > ;
#[doc = "Power Port B pull-up control register"] pub mod pucrb {
#[doc = "Register `PUCRB` reader"] pub type R = crate :: R < PucrbSpec > ;
#[doc = "Register `PUCRB` writer"] pub type W = crate :: W < PucrbSpec > ;
#[doc = "Field `PU0` reader - Port B pull-up bit y (y=0..15)"] pub type Pu0R = crate :: BitReader ;
#[doc = "Field `PU0` writer - Port B pull-up bit y (y=0..15)"] pub type Pu0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU1` reader - Port B pull-up bit y (y=0..15)"] pub type Pu1R = crate :: BitReader ;
#[doc = "Field `PU1` writer - Port B pull-up bit y (y=0..15)"] pub type Pu1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU2` reader - Port B pull-up bit y (y=0..15)"] pub type Pu2R = crate :: BitReader ;
#[doc = "Field `PU2` writer - Port B pull-up bit y (y=0..15)"] pub type Pu2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU3` reader - Port B pull-up bit y (y=0..15)"] pub type Pu3R = crate :: BitReader ;
#[doc = "Field `PU3` writer - Port B pull-up bit y (y=0..15)"] pub type Pu3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU4` reader - Port B pull-up bit y (y=0..15)"] pub type Pu4R = crate :: BitReader ;
#[doc = "Field `PU4` writer - Port B pull-up bit y (y=0..15)"] pub type Pu4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU5` reader - Port B pull-up bit y (y=0..15)"] pub type Pu5R = crate :: BitReader ;
#[doc = "Field `PU5` writer - Port B pull-up bit y (y=0..15)"] pub type Pu5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU6` reader - Port B pull-up bit y (y=0..15)"] pub type Pu6R = crate :: BitReader ;
#[doc = "Field `PU6` writer - Port B pull-up bit y (y=0..15)"] pub type Pu6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU7` reader - Port B pull-up bit y (y=0..15)"] pub type Pu7R = crate :: BitReader ;
#[doc = "Field `PU7` writer - Port B pull-up bit y (y=0..15)"] pub type Pu7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU8` reader - Port B pull-up bit y (y=0..15)"] pub type Pu8R = crate :: BitReader ;
#[doc = "Field `PU8` writer - Port B pull-up bit y (y=0..15)"] pub type Pu8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU9` reader - Port B pull-up bit y (y=0..15)"] pub type Pu9R = crate :: BitReader ;
#[doc = "Field `PU9` writer - Port B pull-up bit y (y=0..15)"] pub type Pu9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU10` reader - Port B pull-up bit y (y=0..15)"] pub type Pu10R = crate :: BitReader ;
#[doc = "Field `PU10` writer - Port B pull-up bit y (y=0..15)"] pub type Pu10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU11` reader - Port B pull-up bit y (y=0..15)"] pub type Pu11R = crate :: BitReader ;
#[doc = "Field `PU11` writer - Port B pull-up bit y (y=0..15)"] pub type Pu11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU12` reader - Port B pull-up bit y (y=0..15)"] pub type Pu12R = crate :: BitReader ;
#[doc = "Field `PU12` writer - Port B pull-up bit y (y=0..15)"] pub type Pu12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU13` reader - Port B pull-up bit y (y=0..15)"] pub type Pu13R = crate :: BitReader ;
#[doc = "Field `PU13` writer - Port B pull-up bit y (y=0..15)"] pub type Pu13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU14` reader - Port B pull-up bit y (y=0..15)"] pub type Pu14R = crate :: BitReader ;
#[doc = "Field `PU14` writer - Port B pull-up bit y (y=0..15)"] pub type Pu14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU15` reader - Port B pull-up bit y (y=0..15)"] pub type Pu15R = crate :: BitReader ;
#[doc = "Field `PU15` writer - Port B pull-up bit y (y=0..15)"] pub type Pu15W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu0 (& self) -> Pu0R { Pu0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu1 (& self) -> Pu1R { Pu1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu2 (& self) -> Pu2R { Pu2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu3 (& self) -> Pu3R { Pu3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu4 (& self) -> Pu4R { Pu4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu5 (& self) -> Pu5R { Pu5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu6 (& self) -> Pu6R { Pu6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu7 (& self) -> Pu7R { Pu7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu8 (& self) -> Pu8R { Pu8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu9 (& self) -> Pu9R { Pu9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu10 (& self) -> Pu10R { Pu10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu11 (& self) -> Pu11R { Pu11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu12 (& self) -> Pu12R { Pu12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu13 (& self) -> Pu13R { Pu13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu14 (& self) -> Pu14R { Pu14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu15 (& self) -> Pu15R { Pu15R :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu0 (& mut self) -> Pu0W < '_ , PucrbSpec > { Pu0W :: new (self , 0) }
#[doc = "Bit 1 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu1 (& mut self) -> Pu1W < '_ , PucrbSpec > { Pu1W :: new (self , 1) }
#[doc = "Bit 2 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu2 (& mut self) -> Pu2W < '_ , PucrbSpec > { Pu2W :: new (self , 2) }
#[doc = "Bit 3 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu3 (& mut self) -> Pu3W < '_ , PucrbSpec > { Pu3W :: new (self , 3) }
#[doc = "Bit 4 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu4 (& mut self) -> Pu4W < '_ , PucrbSpec > { Pu4W :: new (self , 4) }
#[doc = "Bit 5 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu5 (& mut self) -> Pu5W < '_ , PucrbSpec > { Pu5W :: new (self , 5) }
#[doc = "Bit 6 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu6 (& mut self) -> Pu6W < '_ , PucrbSpec > { Pu6W :: new (self , 6) }
#[doc = "Bit 7 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu7 (& mut self) -> Pu7W < '_ , PucrbSpec > { Pu7W :: new (self , 7) }
#[doc = "Bit 8 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu8 (& mut self) -> Pu8W < '_ , PucrbSpec > { Pu8W :: new (self , 8) }
#[doc = "Bit 9 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu9 (& mut self) -> Pu9W < '_ , PucrbSpec > { Pu9W :: new (self , 9) }
#[doc = "Bit 10 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu10 (& mut self) -> Pu10W < '_ , PucrbSpec > { Pu10W :: new (self , 10) }
#[doc = "Bit 11 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu11 (& mut self) -> Pu11W < '_ , PucrbSpec > { Pu11W :: new (self , 11) }
#[doc = "Bit 12 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu12 (& mut self) -> Pu12W < '_ , PucrbSpec > { Pu12W :: new (self , 12) }
#[doc = "Bit 13 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu13 (& mut self) -> Pu13W < '_ , PucrbSpec > { Pu13W :: new (self , 13) }
#[doc = "Bit 14 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu14 (& mut self) -> Pu14W < '_ , PucrbSpec > { Pu14W :: new (self , 14) }
#[doc = "Bit 15 - Port B pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu15 (& mut self) -> Pu15W < '_ , PucrbSpec > { Pu15W :: new (self , 15) } }
#[doc = "Power Port B pull-up control register\n\nYou can [`read`](crate::Reg::read) this register and get [`pucrb::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pucrb::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PucrbSpec ; impl crate :: RegisterSpec for PucrbSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pucrb::R`](R) reader structure"] impl crate :: Readable for PucrbSpec { }
#[doc = "`write(|w| ..)` method takes [`pucrb::W`](W) writer structure"] impl crate :: Writable for PucrbSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PUCRB to value 0"] impl crate :: Resettable for PucrbSpec { } }
#[doc = "PDCRB (rw) register accessor: Power Port B pull-down control register\n\nYou can [`read`](crate::Reg::read) this register and get [`pdcrb::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pdcrb::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pdcrb`] module"]
#[doc (alias = "PDCRB")] pub type Pdcrb = crate :: Reg < pdcrb :: PdcrbSpec > ;
#[doc = "Power Port B pull-down control register"] pub mod pdcrb {
#[doc = "Register `PDCRB` reader"] pub type R = crate :: R < PdcrbSpec > ;
#[doc = "Register `PDCRB` writer"] pub type W = crate :: W < PdcrbSpec > ;
#[doc = "Field `PD0` reader - Port B pull-down bit y (y=0..15)"] pub type Pd0R = crate :: BitReader ;
#[doc = "Field `PD0` writer - Port B pull-down bit y (y=0..15)"] pub type Pd0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD1` reader - Port B pull-down bit y (y=0..15)"] pub type Pd1R = crate :: BitReader ;
#[doc = "Field `PD1` writer - Port B pull-down bit y (y=0..15)"] pub type Pd1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD2` reader - Port B pull-down bit y (y=0..15)"] pub type Pd2R = crate :: BitReader ;
#[doc = "Field `PD2` writer - Port B pull-down bit y (y=0..15)"] pub type Pd2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD3` reader - Port B pull-down bit y (y=0..15)"] pub type Pd3R = crate :: BitReader ;
#[doc = "Field `PD3` writer - Port B pull-down bit y (y=0..15)"] pub type Pd3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD5` reader - Port B pull-down bit y (y=0..15)"] pub type Pd5R = crate :: BitReader ;
#[doc = "Field `PD5` writer - Port B pull-down bit y (y=0..15)"] pub type Pd5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD6` reader - Port B pull-down bit y (y=0..15)"] pub type Pd6R = crate :: BitReader ;
#[doc = "Field `PD6` writer - Port B pull-down bit y (y=0..15)"] pub type Pd6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD7` reader - Port B pull-down bit y (y=0..15)"] pub type Pd7R = crate :: BitReader ;
#[doc = "Field `PD7` writer - Port B pull-down bit y (y=0..15)"] pub type Pd7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD8` reader - Port B pull-down bit y (y=0..15)"] pub type Pd8R = crate :: BitReader ;
#[doc = "Field `PD8` writer - Port B pull-down bit y (y=0..15)"] pub type Pd8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD9` reader - Port B pull-down bit y (y=0..15)"] pub type Pd9R = crate :: BitReader ;
#[doc = "Field `PD9` writer - Port B pull-down bit y (y=0..15)"] pub type Pd9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD10` reader - Port B pull-down bit y (y=0..15)"] pub type Pd10R = crate :: BitReader ;
#[doc = "Field `PD10` writer - Port B pull-down bit y (y=0..15)"] pub type Pd10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD11` reader - Port B pull-down bit y (y=0..15)"] pub type Pd11R = crate :: BitReader ;
#[doc = "Field `PD11` writer - Port B pull-down bit y (y=0..15)"] pub type Pd11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD12` reader - Port B pull-down bit y (y=0..15)"] pub type Pd12R = crate :: BitReader ;
#[doc = "Field `PD12` writer - Port B pull-down bit y (y=0..15)"] pub type Pd12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD13` reader - Port B pull-down bit y (y=0..15)"] pub type Pd13R = crate :: BitReader ;
#[doc = "Field `PD13` writer - Port B pull-down bit y (y=0..15)"] pub type Pd13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD14` reader - Port B pull-down bit y (y=0..15)"] pub type Pd14R = crate :: BitReader ;
#[doc = "Field `PD14` writer - Port B pull-down bit y (y=0..15)"] pub type Pd14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD15` reader - Port B pull-down bit y (y=0..15)"] pub type Pd15R = crate :: BitReader ;
#[doc = "Field `PD15` writer - Port B pull-down bit y (y=0..15)"] pub type Pd15W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd0 (& self) -> Pd0R { Pd0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd1 (& self) -> Pd1R { Pd1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd2 (& self) -> Pd2R { Pd2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd3 (& self) -> Pd3R { Pd3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 5 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd5 (& self) -> Pd5R { Pd5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd6 (& self) -> Pd6R { Pd6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd7 (& self) -> Pd7R { Pd7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd8 (& self) -> Pd8R { Pd8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd9 (& self) -> Pd9R { Pd9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd10 (& self) -> Pd10R { Pd10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd11 (& self) -> Pd11R { Pd11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd12 (& self) -> Pd12R { Pd12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd13 (& self) -> Pd13R { Pd13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd14 (& self) -> Pd14R { Pd14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd15 (& self) -> Pd15R { Pd15R :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd0 (& mut self) -> Pd0W < '_ , PdcrbSpec > { Pd0W :: new (self , 0) }
#[doc = "Bit 1 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd1 (& mut self) -> Pd1W < '_ , PdcrbSpec > { Pd1W :: new (self , 1) }
#[doc = "Bit 2 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd2 (& mut self) -> Pd2W < '_ , PdcrbSpec > { Pd2W :: new (self , 2) }
#[doc = "Bit 3 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd3 (& mut self) -> Pd3W < '_ , PdcrbSpec > { Pd3W :: new (self , 3) }
#[doc = "Bit 5 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd5 (& mut self) -> Pd5W < '_ , PdcrbSpec > { Pd5W :: new (self , 5) }
#[doc = "Bit 6 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd6 (& mut self) -> Pd6W < '_ , PdcrbSpec > { Pd6W :: new (self , 6) }
#[doc = "Bit 7 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd7 (& mut self) -> Pd7W < '_ , PdcrbSpec > { Pd7W :: new (self , 7) }
#[doc = "Bit 8 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd8 (& mut self) -> Pd8W < '_ , PdcrbSpec > { Pd8W :: new (self , 8) }
#[doc = "Bit 9 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd9 (& mut self) -> Pd9W < '_ , PdcrbSpec > { Pd9W :: new (self , 9) }
#[doc = "Bit 10 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd10 (& mut self) -> Pd10W < '_ , PdcrbSpec > { Pd10W :: new (self , 10) }
#[doc = "Bit 11 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd11 (& mut self) -> Pd11W < '_ , PdcrbSpec > { Pd11W :: new (self , 11) }
#[doc = "Bit 12 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd12 (& mut self) -> Pd12W < '_ , PdcrbSpec > { Pd12W :: new (self , 12) }
#[doc = "Bit 13 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd13 (& mut self) -> Pd13W < '_ , PdcrbSpec > { Pd13W :: new (self , 13) }
#[doc = "Bit 14 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd14 (& mut self) -> Pd14W < '_ , PdcrbSpec > { Pd14W :: new (self , 14) }
#[doc = "Bit 15 - Port B pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd15 (& mut self) -> Pd15W < '_ , PdcrbSpec > { Pd15W :: new (self , 15) } }
#[doc = "Power Port B pull-down control register\n\nYou can [`read`](crate::Reg::read) this register and get [`pdcrb::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pdcrb::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PdcrbSpec ; impl crate :: RegisterSpec for PdcrbSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pdcrb::R`](R) reader structure"] impl crate :: Readable for PdcrbSpec { }
#[doc = "`write(|w| ..)` method takes [`pdcrb::W`](W) writer structure"] impl crate :: Writable for PdcrbSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PDCRB to value 0"] impl crate :: Resettable for PdcrbSpec { } }
#[doc = "PUCRC (rw) register accessor: Power Port C pull-up control register\n\nYou can [`read`](crate::Reg::read) this register and get [`pucrc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pucrc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pucrc`] module"]
#[doc (alias = "PUCRC")] pub type Pucrc = crate :: Reg < pucrc :: PucrcSpec > ;
#[doc = "Power Port C pull-up control register"] pub mod pucrc {
#[doc = "Register `PUCRC` reader"] pub type R = crate :: R < PucrcSpec > ;
#[doc = "Register `PUCRC` writer"] pub type W = crate :: W < PucrcSpec > ;
#[doc = "Field `PU0` reader - Port C pull-up bit y (y=0..15)"] pub type Pu0R = crate :: BitReader ;
#[doc = "Field `PU0` writer - Port C pull-up bit y (y=0..15)"] pub type Pu0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU1` reader - Port C pull-up bit y (y=0..15)"] pub type Pu1R = crate :: BitReader ;
#[doc = "Field `PU1` writer - Port C pull-up bit y (y=0..15)"] pub type Pu1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU2` reader - Port C pull-up bit y (y=0..15)"] pub type Pu2R = crate :: BitReader ;
#[doc = "Field `PU2` writer - Port C pull-up bit y (y=0..15)"] pub type Pu2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU3` reader - Port C pull-up bit y (y=0..15)"] pub type Pu3R = crate :: BitReader ;
#[doc = "Field `PU3` writer - Port C pull-up bit y (y=0..15)"] pub type Pu3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU4` reader - Port C pull-up bit y (y=0..15)"] pub type Pu4R = crate :: BitReader ;
#[doc = "Field `PU4` writer - Port C pull-up bit y (y=0..15)"] pub type Pu4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU5` reader - Port C pull-up bit y (y=0..15)"] pub type Pu5R = crate :: BitReader ;
#[doc = "Field `PU5` writer - Port C pull-up bit y (y=0..15)"] pub type Pu5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU6` reader - Port C pull-up bit y (y=0..15)"] pub type Pu6R = crate :: BitReader ;
#[doc = "Field `PU6` writer - Port C pull-up bit y (y=0..15)"] pub type Pu6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU7` reader - Port C pull-up bit y (y=0..15)"] pub type Pu7R = crate :: BitReader ;
#[doc = "Field `PU7` writer - Port C pull-up bit y (y=0..15)"] pub type Pu7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU8` reader - Port C pull-up bit y (y=0..15)"] pub type Pu8R = crate :: BitReader ;
#[doc = "Field `PU8` writer - Port C pull-up bit y (y=0..15)"] pub type Pu8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU9` reader - Port C pull-up bit y (y=0..15)"] pub type Pu9R = crate :: BitReader ;
#[doc = "Field `PU9` writer - Port C pull-up bit y (y=0..15)"] pub type Pu9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU10` reader - Port C pull-up bit y (y=0..15)"] pub type Pu10R = crate :: BitReader ;
#[doc = "Field `PU10` writer - Port C pull-up bit y (y=0..15)"] pub type Pu10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU11` reader - Port C pull-up bit y (y=0..15)"] pub type Pu11R = crate :: BitReader ;
#[doc = "Field `PU11` writer - Port C pull-up bit y (y=0..15)"] pub type Pu11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU12` reader - Port C pull-up bit y (y=0..15)"] pub type Pu12R = crate :: BitReader ;
#[doc = "Field `PU12` writer - Port C pull-up bit y (y=0..15)"] pub type Pu12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU13` reader - Port C pull-up bit y (y=0..15)"] pub type Pu13R = crate :: BitReader ;
#[doc = "Field `PU13` writer - Port C pull-up bit y (y=0..15)"] pub type Pu13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU14` reader - Port C pull-up bit y (y=0..15)"] pub type Pu14R = crate :: BitReader ;
#[doc = "Field `PU14` writer - Port C pull-up bit y (y=0..15)"] pub type Pu14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU15` reader - Port C pull-up bit y (y=0..15)"] pub type Pu15R = crate :: BitReader ;
#[doc = "Field `PU15` writer - Port C pull-up bit y (y=0..15)"] pub type Pu15W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu0 (& self) -> Pu0R { Pu0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu1 (& self) -> Pu1R { Pu1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu2 (& self) -> Pu2R { Pu2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu3 (& self) -> Pu3R { Pu3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu4 (& self) -> Pu4R { Pu4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu5 (& self) -> Pu5R { Pu5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu6 (& self) -> Pu6R { Pu6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu7 (& self) -> Pu7R { Pu7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu8 (& self) -> Pu8R { Pu8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu9 (& self) -> Pu9R { Pu9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu10 (& self) -> Pu10R { Pu10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu11 (& self) -> Pu11R { Pu11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu12 (& self) -> Pu12R { Pu12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu13 (& self) -> Pu13R { Pu13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu14 (& self) -> Pu14R { Pu14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu15 (& self) -> Pu15R { Pu15R :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu0 (& mut self) -> Pu0W < '_ , PucrcSpec > { Pu0W :: new (self , 0) }
#[doc = "Bit 1 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu1 (& mut self) -> Pu1W < '_ , PucrcSpec > { Pu1W :: new (self , 1) }
#[doc = "Bit 2 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu2 (& mut self) -> Pu2W < '_ , PucrcSpec > { Pu2W :: new (self , 2) }
#[doc = "Bit 3 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu3 (& mut self) -> Pu3W < '_ , PucrcSpec > { Pu3W :: new (self , 3) }
#[doc = "Bit 4 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu4 (& mut self) -> Pu4W < '_ , PucrcSpec > { Pu4W :: new (self , 4) }
#[doc = "Bit 5 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu5 (& mut self) -> Pu5W < '_ , PucrcSpec > { Pu5W :: new (self , 5) }
#[doc = "Bit 6 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu6 (& mut self) -> Pu6W < '_ , PucrcSpec > { Pu6W :: new (self , 6) }
#[doc = "Bit 7 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu7 (& mut self) -> Pu7W < '_ , PucrcSpec > { Pu7W :: new (self , 7) }
#[doc = "Bit 8 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu8 (& mut self) -> Pu8W < '_ , PucrcSpec > { Pu8W :: new (self , 8) }
#[doc = "Bit 9 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu9 (& mut self) -> Pu9W < '_ , PucrcSpec > { Pu9W :: new (self , 9) }
#[doc = "Bit 10 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu10 (& mut self) -> Pu10W < '_ , PucrcSpec > { Pu10W :: new (self , 10) }
#[doc = "Bit 11 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu11 (& mut self) -> Pu11W < '_ , PucrcSpec > { Pu11W :: new (self , 11) }
#[doc = "Bit 12 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu12 (& mut self) -> Pu12W < '_ , PucrcSpec > { Pu12W :: new (self , 12) }
#[doc = "Bit 13 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu13 (& mut self) -> Pu13W < '_ , PucrcSpec > { Pu13W :: new (self , 13) }
#[doc = "Bit 14 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu14 (& mut self) -> Pu14W < '_ , PucrcSpec > { Pu14W :: new (self , 14) }
#[doc = "Bit 15 - Port C pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu15 (& mut self) -> Pu15W < '_ , PucrcSpec > { Pu15W :: new (self , 15) } }
#[doc = "Power Port C pull-up control register\n\nYou can [`read`](crate::Reg::read) this register and get [`pucrc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pucrc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PucrcSpec ; impl crate :: RegisterSpec for PucrcSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pucrc::R`](R) reader structure"] impl crate :: Readable for PucrcSpec { }
#[doc = "`write(|w| ..)` method takes [`pucrc::W`](W) writer structure"] impl crate :: Writable for PucrcSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PUCRC to value 0"] impl crate :: Resettable for PucrcSpec { } }
#[doc = "PDCRC (rw) register accessor: Power Port C pull-down control register\n\nYou can [`read`](crate::Reg::read) this register and get [`pdcrc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pdcrc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pdcrc`] module"]
#[doc (alias = "PDCRC")] pub type Pdcrc = crate :: Reg < pdcrc :: PdcrcSpec > ;
#[doc = "Power Port C pull-down control register"] pub mod pdcrc {
#[doc = "Register `PDCRC` reader"] pub type R = crate :: R < PdcrcSpec > ;
#[doc = "Register `PDCRC` writer"] pub type W = crate :: W < PdcrcSpec > ;
#[doc = "Field `PD0` reader - Port C pull-down bit y (y=0..15)"] pub type Pd0R = crate :: BitReader ;
#[doc = "Field `PD0` writer - Port C pull-down bit y (y=0..15)"] pub type Pd0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD1` reader - Port C pull-down bit y (y=0..15)"] pub type Pd1R = crate :: BitReader ;
#[doc = "Field `PD1` writer - Port C pull-down bit y (y=0..15)"] pub type Pd1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD2` reader - Port C pull-down bit y (y=0..15)"] pub type Pd2R = crate :: BitReader ;
#[doc = "Field `PD2` writer - Port C pull-down bit y (y=0..15)"] pub type Pd2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD3` reader - Port C pull-down bit y (y=0..15)"] pub type Pd3R = crate :: BitReader ;
#[doc = "Field `PD3` writer - Port C pull-down bit y (y=0..15)"] pub type Pd3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD4` reader - Port C pull-down bit y (y=0..15)"] pub type Pd4R = crate :: BitReader ;
#[doc = "Field `PD4` writer - Port C pull-down bit y (y=0..15)"] pub type Pd4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD5` reader - Port C pull-down bit y (y=0..15)"] pub type Pd5R = crate :: BitReader ;
#[doc = "Field `PD5` writer - Port C pull-down bit y (y=0..15)"] pub type Pd5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD6` reader - Port C pull-down bit y (y=0..15)"] pub type Pd6R = crate :: BitReader ;
#[doc = "Field `PD6` writer - Port C pull-down bit y (y=0..15)"] pub type Pd6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD7` reader - Port C pull-down bit y (y=0..15)"] pub type Pd7R = crate :: BitReader ;
#[doc = "Field `PD7` writer - Port C pull-down bit y (y=0..15)"] pub type Pd7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD8` reader - Port C pull-down bit y (y=0..15)"] pub type Pd8R = crate :: BitReader ;
#[doc = "Field `PD8` writer - Port C pull-down bit y (y=0..15)"] pub type Pd8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD9` reader - Port C pull-down bit y (y=0..15)"] pub type Pd9R = crate :: BitReader ;
#[doc = "Field `PD9` writer - Port C pull-down bit y (y=0..15)"] pub type Pd9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD10` reader - Port C pull-down bit y (y=0..15)"] pub type Pd10R = crate :: BitReader ;
#[doc = "Field `PD10` writer - Port C pull-down bit y (y=0..15)"] pub type Pd10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD11` reader - Port C pull-down bit y (y=0..15)"] pub type Pd11R = crate :: BitReader ;
#[doc = "Field `PD11` writer - Port C pull-down bit y (y=0..15)"] pub type Pd11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD12` reader - Port C pull-down bit y (y=0..15)"] pub type Pd12R = crate :: BitReader ;
#[doc = "Field `PD12` writer - Port C pull-down bit y (y=0..15)"] pub type Pd12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD13` reader - Port C pull-down bit y (y=0..15)"] pub type Pd13R = crate :: BitReader ;
#[doc = "Field `PD13` writer - Port C pull-down bit y (y=0..15)"] pub type Pd13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD14` reader - Port C pull-down bit y (y=0..15)"] pub type Pd14R = crate :: BitReader ;
#[doc = "Field `PD14` writer - Port C pull-down bit y (y=0..15)"] pub type Pd14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD15` reader - Port C pull-down bit y (y=0..15)"] pub type Pd15R = crate :: BitReader ;
#[doc = "Field `PD15` writer - Port C pull-down bit y (y=0..15)"] pub type Pd15W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd0 (& self) -> Pd0R { Pd0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd1 (& self) -> Pd1R { Pd1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd2 (& self) -> Pd2R { Pd2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd3 (& self) -> Pd3R { Pd3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd4 (& self) -> Pd4R { Pd4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd5 (& self) -> Pd5R { Pd5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd6 (& self) -> Pd6R { Pd6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd7 (& self) -> Pd7R { Pd7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd8 (& self) -> Pd8R { Pd8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd9 (& self) -> Pd9R { Pd9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd10 (& self) -> Pd10R { Pd10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd11 (& self) -> Pd11R { Pd11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd12 (& self) -> Pd12R { Pd12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd13 (& self) -> Pd13R { Pd13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd14 (& self) -> Pd14R { Pd14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd15 (& self) -> Pd15R { Pd15R :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd0 (& mut self) -> Pd0W < '_ , PdcrcSpec > { Pd0W :: new (self , 0) }
#[doc = "Bit 1 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd1 (& mut self) -> Pd1W < '_ , PdcrcSpec > { Pd1W :: new (self , 1) }
#[doc = "Bit 2 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd2 (& mut self) -> Pd2W < '_ , PdcrcSpec > { Pd2W :: new (self , 2) }
#[doc = "Bit 3 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd3 (& mut self) -> Pd3W < '_ , PdcrcSpec > { Pd3W :: new (self , 3) }
#[doc = "Bit 4 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd4 (& mut self) -> Pd4W < '_ , PdcrcSpec > { Pd4W :: new (self , 4) }
#[doc = "Bit 5 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd5 (& mut self) -> Pd5W < '_ , PdcrcSpec > { Pd5W :: new (self , 5) }
#[doc = "Bit 6 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd6 (& mut self) -> Pd6W < '_ , PdcrcSpec > { Pd6W :: new (self , 6) }
#[doc = "Bit 7 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd7 (& mut self) -> Pd7W < '_ , PdcrcSpec > { Pd7W :: new (self , 7) }
#[doc = "Bit 8 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd8 (& mut self) -> Pd8W < '_ , PdcrcSpec > { Pd8W :: new (self , 8) }
#[doc = "Bit 9 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd9 (& mut self) -> Pd9W < '_ , PdcrcSpec > { Pd9W :: new (self , 9) }
#[doc = "Bit 10 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd10 (& mut self) -> Pd10W < '_ , PdcrcSpec > { Pd10W :: new (self , 10) }
#[doc = "Bit 11 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd11 (& mut self) -> Pd11W < '_ , PdcrcSpec > { Pd11W :: new (self , 11) }
#[doc = "Bit 12 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd12 (& mut self) -> Pd12W < '_ , PdcrcSpec > { Pd12W :: new (self , 12) }
#[doc = "Bit 13 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd13 (& mut self) -> Pd13W < '_ , PdcrcSpec > { Pd13W :: new (self , 13) }
#[doc = "Bit 14 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd14 (& mut self) -> Pd14W < '_ , PdcrcSpec > { Pd14W :: new (self , 14) }
#[doc = "Bit 15 - Port C pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd15 (& mut self) -> Pd15W < '_ , PdcrcSpec > { Pd15W :: new (self , 15) } }
#[doc = "Power Port C pull-down control register\n\nYou can [`read`](crate::Reg::read) this register and get [`pdcrc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pdcrc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PdcrcSpec ; impl crate :: RegisterSpec for PdcrcSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pdcrc::R`](R) reader structure"] impl crate :: Readable for PdcrcSpec { }
#[doc = "`write(|w| ..)` method takes [`pdcrc::W`](W) writer structure"] impl crate :: Writable for PdcrcSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PDCRC to value 0"] impl crate :: Resettable for PdcrcSpec { } }
#[doc = "PUCRD (rw) register accessor: Power Port D pull-up control register\n\nYou can [`read`](crate::Reg::read) this register and get [`pucrd::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pucrd::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pucrd`] module"]
#[doc (alias = "PUCRD")] pub type Pucrd = crate :: Reg < pucrd :: PucrdSpec > ;
#[doc = "Power Port D pull-up control register"] pub mod pucrd {
#[doc = "Register `PUCRD` reader"] pub type R = crate :: R < PucrdSpec > ;
#[doc = "Register `PUCRD` writer"] pub type W = crate :: W < PucrdSpec > ;
#[doc = "Field `PU0` reader - Port D pull-up bit y (y=0..15)"] pub type Pu0R = crate :: BitReader ;
#[doc = "Field `PU0` writer - Port D pull-up bit y (y=0..15)"] pub type Pu0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU1` reader - Port D pull-up bit y (y=0..15)"] pub type Pu1R = crate :: BitReader ;
#[doc = "Field `PU1` writer - Port D pull-up bit y (y=0..15)"] pub type Pu1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU2` reader - Port D pull-up bit y (y=0..15)"] pub type Pu2R = crate :: BitReader ;
#[doc = "Field `PU2` writer - Port D pull-up bit y (y=0..15)"] pub type Pu2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU3` reader - Port D pull-up bit y (y=0..15)"] pub type Pu3R = crate :: BitReader ;
#[doc = "Field `PU3` writer - Port D pull-up bit y (y=0..15)"] pub type Pu3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU4` reader - Port D pull-up bit y (y=0..15)"] pub type Pu4R = crate :: BitReader ;
#[doc = "Field `PU4` writer - Port D pull-up bit y (y=0..15)"] pub type Pu4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU5` reader - Port D pull-up bit y (y=0..15)"] pub type Pu5R = crate :: BitReader ;
#[doc = "Field `PU5` writer - Port D pull-up bit y (y=0..15)"] pub type Pu5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU6` reader - Port D pull-up bit y (y=0..15)"] pub type Pu6R = crate :: BitReader ;
#[doc = "Field `PU6` writer - Port D pull-up bit y (y=0..15)"] pub type Pu6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU7` reader - Port D pull-up bit y (y=0..15)"] pub type Pu7R = crate :: BitReader ;
#[doc = "Field `PU7` writer - Port D pull-up bit y (y=0..15)"] pub type Pu7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU8` reader - Port D pull-up bit y (y=0..15)"] pub type Pu8R = crate :: BitReader ;
#[doc = "Field `PU8` writer - Port D pull-up bit y (y=0..15)"] pub type Pu8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU9` reader - Port D pull-up bit y (y=0..15)"] pub type Pu9R = crate :: BitReader ;
#[doc = "Field `PU9` writer - Port D pull-up bit y (y=0..15)"] pub type Pu9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU10` reader - Port D pull-up bit y (y=0..15)"] pub type Pu10R = crate :: BitReader ;
#[doc = "Field `PU10` writer - Port D pull-up bit y (y=0..15)"] pub type Pu10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU11` reader - Port D pull-up bit y (y=0..15)"] pub type Pu11R = crate :: BitReader ;
#[doc = "Field `PU11` writer - Port D pull-up bit y (y=0..15)"] pub type Pu11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU12` reader - Port D pull-up bit y (y=0..15)"] pub type Pu12R = crate :: BitReader ;
#[doc = "Field `PU12` writer - Port D pull-up bit y (y=0..15)"] pub type Pu12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU13` reader - Port D pull-up bit y (y=0..15)"] pub type Pu13R = crate :: BitReader ;
#[doc = "Field `PU13` writer - Port D pull-up bit y (y=0..15)"] pub type Pu13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU14` reader - Port D pull-up bit y (y=0..15)"] pub type Pu14R = crate :: BitReader ;
#[doc = "Field `PU14` writer - Port D pull-up bit y (y=0..15)"] pub type Pu14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU15` reader - Port D pull-up bit y (y=0..15)"] pub type Pu15R = crate :: BitReader ;
#[doc = "Field `PU15` writer - Port D pull-up bit y (y=0..15)"] pub type Pu15W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu0 (& self) -> Pu0R { Pu0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu1 (& self) -> Pu1R { Pu1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu2 (& self) -> Pu2R { Pu2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu3 (& self) -> Pu3R { Pu3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu4 (& self) -> Pu4R { Pu4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu5 (& self) -> Pu5R { Pu5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu6 (& self) -> Pu6R { Pu6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu7 (& self) -> Pu7R { Pu7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu8 (& self) -> Pu8R { Pu8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu9 (& self) -> Pu9R { Pu9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu10 (& self) -> Pu10R { Pu10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu11 (& self) -> Pu11R { Pu11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu12 (& self) -> Pu12R { Pu12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu13 (& self) -> Pu13R { Pu13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu14 (& self) -> Pu14R { Pu14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu15 (& self) -> Pu15R { Pu15R :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu0 (& mut self) -> Pu0W < '_ , PucrdSpec > { Pu0W :: new (self , 0) }
#[doc = "Bit 1 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu1 (& mut self) -> Pu1W < '_ , PucrdSpec > { Pu1W :: new (self , 1) }
#[doc = "Bit 2 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu2 (& mut self) -> Pu2W < '_ , PucrdSpec > { Pu2W :: new (self , 2) }
#[doc = "Bit 3 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu3 (& mut self) -> Pu3W < '_ , PucrdSpec > { Pu3W :: new (self , 3) }
#[doc = "Bit 4 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu4 (& mut self) -> Pu4W < '_ , PucrdSpec > { Pu4W :: new (self , 4) }
#[doc = "Bit 5 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu5 (& mut self) -> Pu5W < '_ , PucrdSpec > { Pu5W :: new (self , 5) }
#[doc = "Bit 6 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu6 (& mut self) -> Pu6W < '_ , PucrdSpec > { Pu6W :: new (self , 6) }
#[doc = "Bit 7 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu7 (& mut self) -> Pu7W < '_ , PucrdSpec > { Pu7W :: new (self , 7) }
#[doc = "Bit 8 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu8 (& mut self) -> Pu8W < '_ , PucrdSpec > { Pu8W :: new (self , 8) }
#[doc = "Bit 9 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu9 (& mut self) -> Pu9W < '_ , PucrdSpec > { Pu9W :: new (self , 9) }
#[doc = "Bit 10 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu10 (& mut self) -> Pu10W < '_ , PucrdSpec > { Pu10W :: new (self , 10) }
#[doc = "Bit 11 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu11 (& mut self) -> Pu11W < '_ , PucrdSpec > { Pu11W :: new (self , 11) }
#[doc = "Bit 12 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu12 (& mut self) -> Pu12W < '_ , PucrdSpec > { Pu12W :: new (self , 12) }
#[doc = "Bit 13 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu13 (& mut self) -> Pu13W < '_ , PucrdSpec > { Pu13W :: new (self , 13) }
#[doc = "Bit 14 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu14 (& mut self) -> Pu14W < '_ , PucrdSpec > { Pu14W :: new (self , 14) }
#[doc = "Bit 15 - Port D pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu15 (& mut self) -> Pu15W < '_ , PucrdSpec > { Pu15W :: new (self , 15) } }
#[doc = "Power Port D pull-up control register\n\nYou can [`read`](crate::Reg::read) this register and get [`pucrd::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pucrd::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PucrdSpec ; impl crate :: RegisterSpec for PucrdSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pucrd::R`](R) reader structure"] impl crate :: Readable for PucrdSpec { }
#[doc = "`write(|w| ..)` method takes [`pucrd::W`](W) writer structure"] impl crate :: Writable for PucrdSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PUCRD to value 0"] impl crate :: Resettable for PucrdSpec { } }
#[doc = "PDCRD (rw) register accessor: Power Port D pull-down control register\n\nYou can [`read`](crate::Reg::read) this register and get [`pdcrd::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pdcrd::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pdcrd`] module"]
#[doc (alias = "PDCRD")] pub type Pdcrd = crate :: Reg < pdcrd :: PdcrdSpec > ;
#[doc = "Power Port D pull-down control register"] pub mod pdcrd {
#[doc = "Register `PDCRD` reader"] pub type R = crate :: R < PdcrdSpec > ;
#[doc = "Register `PDCRD` writer"] pub type W = crate :: W < PdcrdSpec > ;
#[doc = "Field `PD0` reader - Port D pull-down bit y (y=0..15)"] pub type Pd0R = crate :: BitReader ;
#[doc = "Field `PD0` writer - Port D pull-down bit y (y=0..15)"] pub type Pd0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD1` reader - Port D pull-down bit y (y=0..15)"] pub type Pd1R = crate :: BitReader ;
#[doc = "Field `PD1` writer - Port D pull-down bit y (y=0..15)"] pub type Pd1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD2` reader - Port D pull-down bit y (y=0..15)"] pub type Pd2R = crate :: BitReader ;
#[doc = "Field `PD2` writer - Port D pull-down bit y (y=0..15)"] pub type Pd2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD3` reader - Port D pull-down bit y (y=0..15)"] pub type Pd3R = crate :: BitReader ;
#[doc = "Field `PD3` writer - Port D pull-down bit y (y=0..15)"] pub type Pd3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD4` reader - Port D pull-down bit y (y=0..15)"] pub type Pd4R = crate :: BitReader ;
#[doc = "Field `PD4` writer - Port D pull-down bit y (y=0..15)"] pub type Pd4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD5` reader - Port D pull-down bit y (y=0..15)"] pub type Pd5R = crate :: BitReader ;
#[doc = "Field `PD5` writer - Port D pull-down bit y (y=0..15)"] pub type Pd5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD6` reader - Port D pull-down bit y (y=0..15)"] pub type Pd6R = crate :: BitReader ;
#[doc = "Field `PD6` writer - Port D pull-down bit y (y=0..15)"] pub type Pd6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD7` reader - Port D pull-down bit y (y=0..15)"] pub type Pd7R = crate :: BitReader ;
#[doc = "Field `PD7` writer - Port D pull-down bit y (y=0..15)"] pub type Pd7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD8` reader - Port D pull-down bit y (y=0..15)"] pub type Pd8R = crate :: BitReader ;
#[doc = "Field `PD8` writer - Port D pull-down bit y (y=0..15)"] pub type Pd8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD9` reader - Port D pull-down bit y (y=0..15)"] pub type Pd9R = crate :: BitReader ;
#[doc = "Field `PD9` writer - Port D pull-down bit y (y=0..15)"] pub type Pd9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD10` reader - Port D pull-down bit y (y=0..15)"] pub type Pd10R = crate :: BitReader ;
#[doc = "Field `PD10` writer - Port D pull-down bit y (y=0..15)"] pub type Pd10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD11` reader - Port D pull-down bit y (y=0..15)"] pub type Pd11R = crate :: BitReader ;
#[doc = "Field `PD11` writer - Port D pull-down bit y (y=0..15)"] pub type Pd11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD12` reader - Port D pull-down bit y (y=0..15)"] pub type Pd12R = crate :: BitReader ;
#[doc = "Field `PD12` writer - Port D pull-down bit y (y=0..15)"] pub type Pd12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD13` reader - Port D pull-down bit y (y=0..15)"] pub type Pd13R = crate :: BitReader ;
#[doc = "Field `PD13` writer - Port D pull-down bit y (y=0..15)"] pub type Pd13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD14` reader - Port D pull-down bit y (y=0..15)"] pub type Pd14R = crate :: BitReader ;
#[doc = "Field `PD14` writer - Port D pull-down bit y (y=0..15)"] pub type Pd14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD15` reader - Port D pull-down bit y (y=0..15)"] pub type Pd15R = crate :: BitReader ;
#[doc = "Field `PD15` writer - Port D pull-down bit y (y=0..15)"] pub type Pd15W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd0 (& self) -> Pd0R { Pd0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd1 (& self) -> Pd1R { Pd1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd2 (& self) -> Pd2R { Pd2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd3 (& self) -> Pd3R { Pd3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd4 (& self) -> Pd4R { Pd4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd5 (& self) -> Pd5R { Pd5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd6 (& self) -> Pd6R { Pd6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd7 (& self) -> Pd7R { Pd7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd8 (& self) -> Pd8R { Pd8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd9 (& self) -> Pd9R { Pd9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd10 (& self) -> Pd10R { Pd10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd11 (& self) -> Pd11R { Pd11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd12 (& self) -> Pd12R { Pd12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd13 (& self) -> Pd13R { Pd13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd14 (& self) -> Pd14R { Pd14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd15 (& self) -> Pd15R { Pd15R :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd0 (& mut self) -> Pd0W < '_ , PdcrdSpec > { Pd0W :: new (self , 0) }
#[doc = "Bit 1 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd1 (& mut self) -> Pd1W < '_ , PdcrdSpec > { Pd1W :: new (self , 1) }
#[doc = "Bit 2 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd2 (& mut self) -> Pd2W < '_ , PdcrdSpec > { Pd2W :: new (self , 2) }
#[doc = "Bit 3 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd3 (& mut self) -> Pd3W < '_ , PdcrdSpec > { Pd3W :: new (self , 3) }
#[doc = "Bit 4 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd4 (& mut self) -> Pd4W < '_ , PdcrdSpec > { Pd4W :: new (self , 4) }
#[doc = "Bit 5 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd5 (& mut self) -> Pd5W < '_ , PdcrdSpec > { Pd5W :: new (self , 5) }
#[doc = "Bit 6 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd6 (& mut self) -> Pd6W < '_ , PdcrdSpec > { Pd6W :: new (self , 6) }
#[doc = "Bit 7 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd7 (& mut self) -> Pd7W < '_ , PdcrdSpec > { Pd7W :: new (self , 7) }
#[doc = "Bit 8 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd8 (& mut self) -> Pd8W < '_ , PdcrdSpec > { Pd8W :: new (self , 8) }
#[doc = "Bit 9 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd9 (& mut self) -> Pd9W < '_ , PdcrdSpec > { Pd9W :: new (self , 9) }
#[doc = "Bit 10 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd10 (& mut self) -> Pd10W < '_ , PdcrdSpec > { Pd10W :: new (self , 10) }
#[doc = "Bit 11 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd11 (& mut self) -> Pd11W < '_ , PdcrdSpec > { Pd11W :: new (self , 11) }
#[doc = "Bit 12 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd12 (& mut self) -> Pd12W < '_ , PdcrdSpec > { Pd12W :: new (self , 12) }
#[doc = "Bit 13 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd13 (& mut self) -> Pd13W < '_ , PdcrdSpec > { Pd13W :: new (self , 13) }
#[doc = "Bit 14 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd14 (& mut self) -> Pd14W < '_ , PdcrdSpec > { Pd14W :: new (self , 14) }
#[doc = "Bit 15 - Port D pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd15 (& mut self) -> Pd15W < '_ , PdcrdSpec > { Pd15W :: new (self , 15) } }
#[doc = "Power Port D pull-down control register\n\nYou can [`read`](crate::Reg::read) this register and get [`pdcrd::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pdcrd::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PdcrdSpec ; impl crate :: RegisterSpec for PdcrdSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pdcrd::R`](R) reader structure"] impl crate :: Readable for PdcrdSpec { }
#[doc = "`write(|w| ..)` method takes [`pdcrd::W`](W) writer structure"] impl crate :: Writable for PdcrdSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PDCRD to value 0"] impl crate :: Resettable for PdcrdSpec { } }
#[doc = "PUCRE (rw) register accessor: Power Port E pull-up control register\n\nYou can [`read`](crate::Reg::read) this register and get [`pucre::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pucre::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pucre`] module"]
#[doc (alias = "PUCRE")] pub type Pucre = crate :: Reg < pucre :: PucreSpec > ;
#[doc = "Power Port E pull-up control register"] pub mod pucre {
#[doc = "Register `PUCRE` reader"] pub type R = crate :: R < PucreSpec > ;
#[doc = "Register `PUCRE` writer"] pub type W = crate :: W < PucreSpec > ;
#[doc = "Field `PU0` reader - Port E pull-up bit y (y=0..15)"] pub type Pu0R = crate :: BitReader ;
#[doc = "Field `PU0` writer - Port E pull-up bit y (y=0..15)"] pub type Pu0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU1` reader - Port E pull-up bit y (y=0..15)"] pub type Pu1R = crate :: BitReader ;
#[doc = "Field `PU1` writer - Port E pull-up bit y (y=0..15)"] pub type Pu1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU2` reader - Port E pull-up bit y (y=0..15)"] pub type Pu2R = crate :: BitReader ;
#[doc = "Field `PU2` writer - Port E pull-up bit y (y=0..15)"] pub type Pu2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU3` reader - Port E pull-up bit y (y=0..15)"] pub type Pu3R = crate :: BitReader ;
#[doc = "Field `PU3` writer - Port E pull-up bit y (y=0..15)"] pub type Pu3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU4` reader - Port E pull-up bit y (y=0..15)"] pub type Pu4R = crate :: BitReader ;
#[doc = "Field `PU4` writer - Port E pull-up bit y (y=0..15)"] pub type Pu4W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port E pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu0 (& self) -> Pu0R { Pu0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port E pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu1 (& self) -> Pu1R { Pu1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port E pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu2 (& self) -> Pu2R { Pu2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port E pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu3 (& self) -> Pu3R { Pu3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port E pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu4 (& self) -> Pu4R { Pu4R :: new (((self . bits >> 4) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port E pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu0 (& mut self) -> Pu0W < '_ , PucreSpec > { Pu0W :: new (self , 0) }
#[doc = "Bit 1 - Port E pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu1 (& mut self) -> Pu1W < '_ , PucreSpec > { Pu1W :: new (self , 1) }
#[doc = "Bit 2 - Port E pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu2 (& mut self) -> Pu2W < '_ , PucreSpec > { Pu2W :: new (self , 2) }
#[doc = "Bit 3 - Port E pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu3 (& mut self) -> Pu3W < '_ , PucreSpec > { Pu3W :: new (self , 3) }
#[doc = "Bit 4 - Port E pull-up bit y (y=0..15)"]
#[inline (always)] pub fn pu4 (& mut self) -> Pu4W < '_ , PucreSpec > { Pu4W :: new (self , 4) } }
#[doc = "Power Port E pull-up control register\n\nYou can [`read`](crate::Reg::read) this register and get [`pucre::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pucre::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PucreSpec ; impl crate :: RegisterSpec for PucreSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pucre::R`](R) reader structure"] impl crate :: Readable for PucreSpec { }
#[doc = "`write(|w| ..)` method takes [`pucre::W`](W) writer structure"] impl crate :: Writable for PucreSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PUCRE to value 0"] impl crate :: Resettable for PucreSpec { } }
#[doc = "PDCRE (rw) register accessor: Power Port E pull-down control register\n\nYou can [`read`](crate::Reg::read) this register and get [`pdcre::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pdcre::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pdcre`] module"]
#[doc (alias = "PDCRE")] pub type Pdcre = crate :: Reg < pdcre :: PdcreSpec > ;
#[doc = "Power Port E pull-down control register"] pub mod pdcre {
#[doc = "Register `PDCRE` reader"] pub type R = crate :: R < PdcreSpec > ;
#[doc = "Register `PDCRE` writer"] pub type W = crate :: W < PdcreSpec > ;
#[doc = "Field `PD0` reader - Port E pull-down bit y (y=0..15)"] pub type Pd0R = crate :: BitReader ;
#[doc = "Field `PD0` writer - Port E pull-down bit y (y=0..15)"] pub type Pd0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD1` reader - Port E pull-down bit y (y=0..15)"] pub type Pd1R = crate :: BitReader ;
#[doc = "Field `PD1` writer - Port E pull-down bit y (y=0..15)"] pub type Pd1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD2` reader - Port E pull-down bit y (y=0..15)"] pub type Pd2R = crate :: BitReader ;
#[doc = "Field `PD2` writer - Port E pull-down bit y (y=0..15)"] pub type Pd2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD3` reader - Port E pull-down bit y (y=0..15)"] pub type Pd3R = crate :: BitReader ;
#[doc = "Field `PD3` writer - Port E pull-down bit y (y=0..15)"] pub type Pd3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD4` reader - Port E pull-down bit y (y=0..15)"] pub type Pd4R = crate :: BitReader ;
#[doc = "Field `PD4` writer - Port E pull-down bit y (y=0..15)"] pub type Pd4W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port E pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd0 (& self) -> Pd0R { Pd0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port E pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd1 (& self) -> Pd1R { Pd1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port E pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd2 (& self) -> Pd2R { Pd2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port E pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd3 (& self) -> Pd3R { Pd3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port E pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd4 (& self) -> Pd4R { Pd4R :: new (((self . bits >> 4) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port E pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd0 (& mut self) -> Pd0W < '_ , PdcreSpec > { Pd0W :: new (self , 0) }
#[doc = "Bit 1 - Port E pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd1 (& mut self) -> Pd1W < '_ , PdcreSpec > { Pd1W :: new (self , 1) }
#[doc = "Bit 2 - Port E pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd2 (& mut self) -> Pd2W < '_ , PdcreSpec > { Pd2W :: new (self , 2) }
#[doc = "Bit 3 - Port E pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd3 (& mut self) -> Pd3W < '_ , PdcreSpec > { Pd3W :: new (self , 3) }
#[doc = "Bit 4 - Port E pull-down bit y (y=0..15)"]
#[inline (always)] pub fn pd4 (& mut self) -> Pd4W < '_ , PdcreSpec > { Pd4W :: new (self , 4) } }
#[doc = "Power Port E pull-down control register\n\nYou can [`read`](crate::Reg::read) this register and get [`pdcre::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pdcre::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PdcreSpec ; impl crate :: RegisterSpec for PdcreSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pdcre::R`](R) reader structure"] impl crate :: Readable for PdcreSpec { }
#[doc = "`write(|w| ..)` method takes [`pdcre::W`](W) writer structure"] impl crate :: Writable for PdcreSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PDCRE to value 0"] impl crate :: Resettable for PdcreSpec { } }
#[doc = "PUCRH (rw) register accessor: Power Port H pull-up control register\n\nYou can [`read`](crate::Reg::read) this register and get [`pucrh::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pucrh::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pucrh`] module"]
#[doc (alias = "PUCRH")] pub type Pucrh = crate :: Reg < pucrh :: PucrhSpec > ;
#[doc = "Power Port H pull-up control register"] pub mod pucrh {
#[doc = "Register `PUCRH` reader"] pub type R = crate :: R < PucrhSpec > ;
#[doc = "Register `PUCRH` writer"] pub type W = crate :: W < PucrhSpec > ;
#[doc = "Field `PU0` reader - Port H pull-up bit y (y=0..1)"] pub type Pu0R = crate :: BitReader ;
#[doc = "Field `PU0` writer - Port H pull-up bit y (y=0..1)"] pub type Pu0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU1` reader - Port H pull-up bit y (y=0..1)"] pub type Pu1R = crate :: BitReader ;
#[doc = "Field `PU1` writer - Port H pull-up bit y (y=0..1)"] pub type Pu1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PU3` reader - Port H pull-up bit y (y=0..1)"] pub type Pu3R = crate :: BitReader ;
#[doc = "Field `PU3` writer - Port H pull-up bit y (y=0..1)"] pub type Pu3W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port H pull-up bit y (y=0..1)"]
#[inline (always)] pub fn pu0 (& self) -> Pu0R { Pu0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port H pull-up bit y (y=0..1)"]
#[inline (always)] pub fn pu1 (& self) -> Pu1R { Pu1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - Port H pull-up bit y (y=0..1)"]
#[inline (always)] pub fn pu3 (& self) -> Pu3R { Pu3R :: new (((self . bits >> 3) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port H pull-up bit y (y=0..1)"]
#[inline (always)] pub fn pu0 (& mut self) -> Pu0W < '_ , PucrhSpec > { Pu0W :: new (self , 0) }
#[doc = "Bit 1 - Port H pull-up bit y (y=0..1)"]
#[inline (always)] pub fn pu1 (& mut self) -> Pu1W < '_ , PucrhSpec > { Pu1W :: new (self , 1) }
#[doc = "Bit 3 - Port H pull-up bit y (y=0..1)"]
#[inline (always)] pub fn pu3 (& mut self) -> Pu3W < '_ , PucrhSpec > { Pu3W :: new (self , 3) } }
#[doc = "Power Port H pull-up control register\n\nYou can [`read`](crate::Reg::read) this register and get [`pucrh::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pucrh::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PucrhSpec ; impl crate :: RegisterSpec for PucrhSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pucrh::R`](R) reader structure"] impl crate :: Readable for PucrhSpec { }
#[doc = "`write(|w| ..)` method takes [`pucrh::W`](W) writer structure"] impl crate :: Writable for PucrhSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PUCRH to value 0"] impl crate :: Resettable for PucrhSpec { } }
#[doc = "PDCRH (rw) register accessor: Power Port H pull-down control register\n\nYou can [`read`](crate::Reg::read) this register and get [`pdcrh::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pdcrh::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pdcrh`] module"]
#[doc (alias = "PDCRH")] pub type Pdcrh = crate :: Reg < pdcrh :: PdcrhSpec > ;
#[doc = "Power Port H pull-down control register"] pub mod pdcrh {
#[doc = "Register `PDCRH` reader"] pub type R = crate :: R < PdcrhSpec > ;
#[doc = "Register `PDCRH` writer"] pub type W = crate :: W < PdcrhSpec > ;
#[doc = "Field `PD0` reader - Port H pull-down bit y (y=0..1)"] pub type Pd0R = crate :: BitReader ;
#[doc = "Field `PD0` writer - Port H pull-down bit y (y=0..1)"] pub type Pd0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD1` reader - Port H pull-down bit y (y=0..1)"] pub type Pd1R = crate :: BitReader ;
#[doc = "Field `PD1` writer - Port H pull-down bit y (y=0..1)"] pub type Pd1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PD3` reader - Port H pull-down bit y (y=0..1)"] pub type Pd3R = crate :: BitReader ;
#[doc = "Field `PD3` writer - Port H pull-down bit y (y=0..1)"] pub type Pd3W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port H pull-down bit y (y=0..1)"]
#[inline (always)] pub fn pd0 (& self) -> Pd0R { Pd0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port H pull-down bit y (y=0..1)"]
#[inline (always)] pub fn pd1 (& self) -> Pd1R { Pd1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - Port H pull-down bit y (y=0..1)"]
#[inline (always)] pub fn pd3 (& self) -> Pd3R { Pd3R :: new (((self . bits >> 3) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port H pull-down bit y (y=0..1)"]
#[inline (always)] pub fn pd0 (& mut self) -> Pd0W < '_ , PdcrhSpec > { Pd0W :: new (self , 0) }
#[doc = "Bit 1 - Port H pull-down bit y (y=0..1)"]
#[inline (always)] pub fn pd1 (& mut self) -> Pd1W < '_ , PdcrhSpec > { Pd1W :: new (self , 1) }
#[doc = "Bit 3 - Port H pull-down bit y (y=0..1)"]
#[inline (always)] pub fn pd3 (& mut self) -> Pd3W < '_ , PdcrhSpec > { Pd3W :: new (self , 3) } }
#[doc = "Power Port H pull-down control register\n\nYou can [`read`](crate::Reg::read) this register and get [`pdcrh::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pdcrh::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PdcrhSpec ; impl crate :: RegisterSpec for PdcrhSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pdcrh::R`](R) reader structure"] impl crate :: Readable for PdcrhSpec { }
#[doc = "`write(|w| ..)` method takes [`pdcrh::W`](W) writer structure"] impl crate :: Writable for PdcrhSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PDCRH to value 0"] impl crate :: Resettable for PdcrhSpec { } }
#[doc = "C2CR1 (rw) register accessor: CPU2 Power control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`c2cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2cr1`] module"]
#[doc (alias = "C2CR1")] pub type C2cr1 = crate :: Reg < c2cr1 :: C2cr1Spec > ;
#[doc = "CPU2 Power control register 1"] pub mod c2cr1 {
#[doc = "Register `C2CR1` reader"] pub type R = crate :: R < C2cr1Spec > ;
#[doc = "Register `C2CR1` writer"] pub type W = crate :: W < C2cr1Spec > ;
#[doc = "Field `LPMS` reader - Low-power mode selection for CPU2"] pub type LpmsR = crate :: FieldReader ;
#[doc = "Field `LPMS` writer - Low-power mode selection for CPU2"] pub type LpmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `FPDR` reader - Flash power down mode during LPRun for CPU2"] pub type FpdrR = crate :: BitReader ;
#[doc = "Field `FPDR` writer - Flash power down mode during LPRun for CPU2"] pub type FpdrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FPDS` reader - Flash power down mode during LPSleep for CPU2"] pub type FpdsR = crate :: BitReader ;
#[doc = "Field `FPDS` writer - Flash power down mode during LPSleep for CPU2"] pub type FpdsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BLEEWKUP` reader - BLE external wakeup signal"] pub type BleewkupR = crate :: BitReader ;
#[doc = "Field `BLEEWKUP` writer - BLE external wakeup signal"] pub type BleewkupW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EWKUP802` reader - 802.15.4 external wakeup signal"] pub type Ewkup802R = crate :: BitReader ;
#[doc = "Field `EWKUP802` writer - 802.15.4 external wakeup signal"] pub type Ewkup802W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:2 - Low-power mode selection for CPU2"]
#[inline (always)] pub fn lpms (& self) -> LpmsR { LpmsR :: new ((self . bits & 7) as u8) }
#[doc = "Bit 4 - Flash power down mode during LPRun for CPU2"]
#[inline (always)] pub fn fpdr (& self) -> FpdrR { FpdrR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Flash power down mode during LPSleep for CPU2"]
#[inline (always)] pub fn fpds (& self) -> FpdsR { FpdsR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 14 - BLE external wakeup signal"]
#[inline (always)] pub fn bleewkup (& self) -> BleewkupR { BleewkupR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - 802.15.4 external wakeup signal"]
#[inline (always)] pub fn ewkup802 (& self) -> Ewkup802R { Ewkup802R :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:2 - Low-power mode selection for CPU2"]
#[inline (always)] pub fn lpms (& mut self) -> LpmsW < '_ , C2cr1Spec > { LpmsW :: new (self , 0) }
#[doc = "Bit 4 - Flash power down mode during LPRun for CPU2"]
#[inline (always)] pub fn fpdr (& mut self) -> FpdrW < '_ , C2cr1Spec > { FpdrW :: new (self , 4) }
#[doc = "Bit 5 - Flash power down mode during LPSleep for CPU2"]
#[inline (always)] pub fn fpds (& mut self) -> FpdsW < '_ , C2cr1Spec > { FpdsW :: new (self , 5) }
#[doc = "Bit 14 - BLE external wakeup signal"]
#[inline (always)] pub fn bleewkup (& mut self) -> BleewkupW < '_ , C2cr1Spec > { BleewkupW :: new (self , 14) }
#[doc = "Bit 15 - 802.15.4 external wakeup signal"]
#[inline (always)] pub fn ewkup802 (& mut self) -> Ewkup802W < '_ , C2cr1Spec > { Ewkup802W :: new (self , 15) } }
#[doc = "CPU2 Power control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`c2cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2cr1Spec ; impl crate :: RegisterSpec for C2cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2cr1::R`](R) reader structure"] impl crate :: Readable for C2cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`c2cr1::W`](W) writer structure"] impl crate :: Writable for C2cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2CR1 to value 0"] impl crate :: Resettable for C2cr1Spec { } }
#[doc = "C2CR3 (rw) register accessor: CPU2 Power control register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`c2cr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2cr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2cr3`] module"]
#[doc (alias = "C2CR3")] pub type C2cr3 = crate :: Reg < c2cr3 :: C2cr3Spec > ;
#[doc = "CPU2 Power control register 3"] pub mod c2cr3 {
#[doc = "Register `C2CR3` reader"] pub type R = crate :: R < C2cr3Spec > ;
#[doc = "Register `C2CR3` writer"] pub type W = crate :: W < C2cr3Spec > ;
#[doc = "Field `EWUP1` reader - Enable Wakeup pin WKUP1 for CPU2"] pub type Ewup1R = crate :: BitReader ;
#[doc = "Field `EWUP1` writer - Enable Wakeup pin WKUP1 for CPU2"] pub type Ewup1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EWUP2` reader - Enable Wakeup pin WKUP2 for CPU2"] pub type Ewup2R = crate :: BitReader ;
#[doc = "Field `EWUP2` writer - Enable Wakeup pin WKUP2 for CPU2"] pub type Ewup2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EWUP3` reader - Enable Wakeup pin WKUP3 for CPU2"] pub type Ewup3R = crate :: BitReader ;
#[doc = "Field `EWUP3` writer - Enable Wakeup pin WKUP3 for CPU2"] pub type Ewup3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EWUP4` reader - Enable Wakeup pin WKUP4 for CPU2"] pub type Ewup4R = crate :: BitReader ;
#[doc = "Field `EWUP4` writer - Enable Wakeup pin WKUP4 for CPU2"] pub type Ewup4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EWUP5` reader - Enable Wakeup pin WKUP5 for CPU2"] pub type Ewup5R = crate :: BitReader ;
#[doc = "Field `EWUP5` writer - Enable Wakeup pin WKUP5 for CPU2"] pub type Ewup5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EBLEWUP` reader - Enable BLE host wakeup interrupt for CPU2"] pub type EblewupR = crate :: BitReader ;
#[doc = "Field `EBLEWUP` writer - Enable BLE host wakeup interrupt for CPU2"] pub type EblewupW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E802WUP` reader - Enable 802.15.4 host wakeup interrupt for CPU2"] pub type E802wupR = crate :: BitReader ;
#[doc = "Field `E802WUP` writer - Enable 802.15.4 host wakeup interrupt for CPU2"] pub type E802wupW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `APC` reader - Apply pull-up and pull-down configuration for CPU2"] pub type ApcR = crate :: BitReader ;
#[doc = "Field `APC` writer - Apply pull-up and pull-down configuration for CPU2"] pub type ApcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EIWUL` reader - Enable internal wakeup line for CPU2"] pub type EiwulR = crate :: BitReader ;
#[doc = "Field `EIWUL` writer - Enable internal wakeup line for CPU2"] pub type EiwulW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Enable Wakeup pin WKUP1 for CPU2"]
#[inline (always)] pub fn ewup1 (& self) -> Ewup1R { Ewup1R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Enable Wakeup pin WKUP2 for CPU2"]
#[inline (always)] pub fn ewup2 (& self) -> Ewup2R { Ewup2R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Enable Wakeup pin WKUP3 for CPU2"]
#[inline (always)] pub fn ewup3 (& self) -> Ewup3R { Ewup3R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Enable Wakeup pin WKUP4 for CPU2"]
#[inline (always)] pub fn ewup4 (& self) -> Ewup4R { Ewup4R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Enable Wakeup pin WKUP5 for CPU2"]
#[inline (always)] pub fn ewup5 (& self) -> Ewup5R { Ewup5R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 9 - Enable BLE host wakeup interrupt for CPU2"]
#[inline (always)] pub fn eblewup (& self) -> EblewupR { EblewupR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Enable 802.15.4 host wakeup interrupt for CPU2"]
#[inline (always)] pub fn e802wup (& self) -> E802wupR { E802wupR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 12 - Apply pull-up and pull-down configuration for CPU2"]
#[inline (always)] pub fn apc (& self) -> ApcR { ApcR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 15 - Enable internal wakeup line for CPU2"]
#[inline (always)] pub fn eiwul (& self) -> EiwulR { EiwulR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Enable Wakeup pin WKUP1 for CPU2"]
#[inline (always)] pub fn ewup1 (& mut self) -> Ewup1W < '_ , C2cr3Spec > { Ewup1W :: new (self , 0) }
#[doc = "Bit 1 - Enable Wakeup pin WKUP2 for CPU2"]
#[inline (always)] pub fn ewup2 (& mut self) -> Ewup2W < '_ , C2cr3Spec > { Ewup2W :: new (self , 1) }
#[doc = "Bit 2 - Enable Wakeup pin WKUP3 for CPU2"]
#[inline (always)] pub fn ewup3 (& mut self) -> Ewup3W < '_ , C2cr3Spec > { Ewup3W :: new (self , 2) }
#[doc = "Bit 3 - Enable Wakeup pin WKUP4 for CPU2"]
#[inline (always)] pub fn ewup4 (& mut self) -> Ewup4W < '_ , C2cr3Spec > { Ewup4W :: new (self , 3) }
#[doc = "Bit 4 - Enable Wakeup pin WKUP5 for CPU2"]
#[inline (always)] pub fn ewup5 (& mut self) -> Ewup5W < '_ , C2cr3Spec > { Ewup5W :: new (self , 4) }
#[doc = "Bit 9 - Enable BLE host wakeup interrupt for CPU2"]
#[inline (always)] pub fn eblewup (& mut self) -> EblewupW < '_ , C2cr3Spec > { EblewupW :: new (self , 9) }
#[doc = "Bit 10 - Enable 802.15.4 host wakeup interrupt for CPU2"]
#[inline (always)] pub fn e802wup (& mut self) -> E802wupW < '_ , C2cr3Spec > { E802wupW :: new (self , 10) }
#[doc = "Bit 12 - Apply pull-up and pull-down configuration for CPU2"]
#[inline (always)] pub fn apc (& mut self) -> ApcW < '_ , C2cr3Spec > { ApcW :: new (self , 12) }
#[doc = "Bit 15 - Enable internal wakeup line for CPU2"]
#[inline (always)] pub fn eiwul (& mut self) -> EiwulW < '_ , C2cr3Spec > { EiwulW :: new (self , 15) } }
#[doc = "CPU2 Power control register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`c2cr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2cr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2cr3Spec ; impl crate :: RegisterSpec for C2cr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2cr3::R`](R) reader structure"] impl crate :: Readable for C2cr3Spec { }
#[doc = "`write(|w| ..)` method takes [`c2cr3::W`](W) writer structure"] impl crate :: Writable for C2cr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2CR3 to value 0x8000"] impl crate :: Resettable for C2cr3Spec { const RESET_VALUE : u32 = 0x8000 ; } }
#[doc = "EXTSCR (rw) register accessor: Power status clear register\n\nYou can [`read`](crate::Reg::read) this register and get [`extscr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`extscr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@extscr`] module"]
#[doc (alias = "EXTSCR")] pub type Extscr = crate :: Reg < extscr :: ExtscrSpec > ;
#[doc = "Power status clear register"] pub mod extscr {
#[doc = "Register `EXTSCR` reader"] pub type R = crate :: R < ExtscrSpec > ;
#[doc = "Register `EXTSCR` writer"] pub type W = crate :: W < ExtscrSpec > ;
#[doc = "Field `C1CSSF` writer - Clear CPU1 Stop Standby flags"] pub type C1cssfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `C2CSSF` writer - Clear CPU2 Stop Standby flags"] pub type C2cssfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CCRPF` writer - Clear Critical Radio system phase"] pub type CcrpfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `C1SBF` reader - System Standby flag for CPU1"] pub type C1sbfR = crate :: BitReader ;
#[doc = "Field `C1STOPF` reader - System Stop flag for CPU1"] pub type C1stopfR = crate :: BitReader ;
#[doc = "Field `C2SBF` reader - System Standby flag for CPU2"] pub type C2sbfR = crate :: BitReader ;
#[doc = "Field `C2STOPF` reader - System Stop flag for CPU2"] pub type C2stopfR = crate :: BitReader ;
#[doc = "Field `CRPF` reader - Critical Radio system phase"] pub type CrpfR = crate :: BitReader ;
#[doc = "Field `C1DS` reader - CPU1 deepsleep mode"] pub type C1dsR = crate :: BitReader ;
#[doc = "Field `C2DS` reader - CPU2 deepsleep mode"] pub type C2dsR = crate :: BitReader ; impl R {
#[doc = "Bit 8 - System Standby flag for CPU1"]
#[inline (always)] pub fn c1sbf (& self) -> C1sbfR { C1sbfR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - System Stop flag for CPU1"]
#[inline (always)] pub fn c1stopf (& self) -> C1stopfR { C1stopfR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - System Standby flag for CPU2"]
#[inline (always)] pub fn c2sbf (& self) -> C2sbfR { C2sbfR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - System Stop flag for CPU2"]
#[inline (always)] pub fn c2stopf (& self) -> C2stopfR { C2stopfR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 13 - Critical Radio system phase"]
#[inline (always)] pub fn crpf (& self) -> CrpfR { CrpfR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - CPU1 deepsleep mode"]
#[inline (always)] pub fn c1ds (& self) -> C1dsR { C1dsR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - CPU2 deepsleep mode"]
#[inline (always)] pub fn c2ds (& self) -> C2dsR { C2dsR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Clear CPU1 Stop Standby flags"]
#[inline (always)] pub fn c1cssf (& mut self) -> C1cssfW < '_ , ExtscrSpec > { C1cssfW :: new (self , 0) }
#[doc = "Bit 1 - Clear CPU2 Stop Standby flags"]
#[inline (always)] pub fn c2cssf (& mut self) -> C2cssfW < '_ , ExtscrSpec > { C2cssfW :: new (self , 1) }
#[doc = "Bit 2 - Clear Critical Radio system phase"]
#[inline (always)] pub fn ccrpf (& mut self) -> CcrpfW < '_ , ExtscrSpec > { CcrpfW :: new (self , 2) } }
#[doc = "Power status clear register\n\nYou can [`read`](crate::Reg::read) this register and get [`extscr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`extscr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ExtscrSpec ; impl crate :: RegisterSpec for ExtscrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`extscr::R`](R) reader structure"] impl crate :: Readable for ExtscrSpec { }
#[doc = "`write(|w| ..)` method takes [`extscr::W`](W) writer structure"] impl crate :: Writable for ExtscrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EXTSCR to value 0"] impl crate :: Resettable for ExtscrSpec { } } }
#[doc = "SYSCFG_VREFBUF"] pub type SyscfgVrefbuf = crate :: Periph < syscfg_vrefbuf :: RegisterBlock , 0x4001_0000 > ; impl core :: fmt :: Debug for SyscfgVrefbuf { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SyscfgVrefbuf") . finish () } }
#[doc = "SYSCFG_VREFBUF"] pub mod syscfg_vrefbuf {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { syscfg_memrmp : SyscfgMemrmp , syscfg_cfgr1 : SyscfgCfgr1 , syscfg_exticr1 : SyscfgExticr1 , syscfg_exticr2 : SyscfgExticr2 , syscfg_exticr3 : SyscfgExticr3 , syscfg_exticr4 : SyscfgExticr4 , syscfg_scsr : SyscfgScsr , syscfg_cfgr2 : SyscfgCfgr2 , syscfg_swpr : SyscfgSwpr , syscfg_skr : SyscfgSkr , syscfg_swpr2 : SyscfgSwpr2 , _reserved11 : [u8 ; 0x04] , vrefbuf_csr : VrefbufCsr , vrefbuf_ccr : VrefbufCcr , _reserved13 : [u8 ; 0xc8] , syscfg_imr1 : SyscfgImr1 , syscfg_imr2 : SyscfgImr2 , syscfg_c2imr1 : SyscfgC2imr1 , syscfg_c2imr2 : SyscfgC2imr2 , syscfg_sipcr : SyscfgSipcr , } impl RegisterBlock {
#[doc = "0x00 - memory remap register"]
#[inline (always)] pub const fn syscfg_memrmp (& self) -> & SyscfgMemrmp { & self . syscfg_memrmp }
#[doc = "0x04 - configuration register 1"]
#[inline (always)] pub const fn syscfg_cfgr1 (& self) -> & SyscfgCfgr1 { & self . syscfg_cfgr1 }
#[doc = "0x08 - external interrupt configuration register 1"]
#[inline (always)] pub const fn syscfg_exticr1 (& self) -> & SyscfgExticr1 { & self . syscfg_exticr1 }
#[doc = "0x0c - external interrupt configuration register 2"]
#[inline (always)] pub const fn syscfg_exticr2 (& self) -> & SyscfgExticr2 { & self . syscfg_exticr2 }
#[doc = "0x10 - external interrupt configuration register 3"]
#[inline (always)] pub const fn syscfg_exticr3 (& self) -> & SyscfgExticr3 { & self . syscfg_exticr3 }
#[doc = "0x14 - external interrupt configuration register 4"]
#[inline (always)] pub const fn syscfg_exticr4 (& self) -> & SyscfgExticr4 { & self . syscfg_exticr4 }
#[doc = "0x18 - SCSR"]
#[inline (always)] pub const fn syscfg_scsr (& self) -> & SyscfgScsr { & self . syscfg_scsr }
#[doc = "0x1c - CFGR2"]
#[inline (always)] pub const fn syscfg_cfgr2 (& self) -> & SyscfgCfgr2 { & self . syscfg_cfgr2 }
#[doc = "0x20 - SRAM2 write protection register"]
#[inline (always)] pub const fn syscfg_swpr (& self) -> & SyscfgSwpr { & self . syscfg_swpr }
#[doc = "0x24 - SKR"]
#[inline (always)] pub const fn syscfg_skr (& self) -> & SyscfgSkr { & self . syscfg_skr }
#[doc = "0x28 - SRAM2 write protection register 2"]
#[inline (always)] pub const fn syscfg_swpr2 (& self) -> & SyscfgSwpr2 { & self . syscfg_swpr2 }
#[doc = "0x30 - VREF control and status register"]
#[inline (always)] pub const fn vrefbuf_csr (& self) -> & VrefbufCsr { & self . vrefbuf_csr }
#[doc = "0x34 - calibration control register"]
#[inline (always)] pub const fn vrefbuf_ccr (& self) -> & VrefbufCcr { & self . vrefbuf_ccr }
#[doc = "0x100 - CPU1 interrupt mask register 1"]
#[inline (always)] pub const fn syscfg_imr1 (& self) -> & SyscfgImr1 { & self . syscfg_imr1 }
#[doc = "0x104 - CPU1 interrupt mask register 2"]
#[inline (always)] pub const fn syscfg_imr2 (& self) -> & SyscfgImr2 { & self . syscfg_imr2 }
#[doc = "0x108 - CPU2 interrupt mask register 1"]
#[inline (always)] pub const fn syscfg_c2imr1 (& self) -> & SyscfgC2imr1 { & self . syscfg_c2imr1 }
#[doc = "0x10c - CPU2 interrupt mask register 1"]
#[inline (always)] pub const fn syscfg_c2imr2 (& self) -> & SyscfgC2imr2 { & self . syscfg_c2imr2 }
#[doc = "0x110 - secure IP control register"]
#[inline (always)] pub const fn syscfg_sipcr (& self) -> & SyscfgSipcr { & self . syscfg_sipcr } }
#[doc = "SYSCFG_MEMRMP (rw) register accessor: memory remap register\n\nYou can [`read`](crate::Reg::read) this register and get [`syscfg_memrmp::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_memrmp::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@syscfg_memrmp`] module"]
#[doc (alias = "SYSCFG_MEMRMP")] pub type SyscfgMemrmp = crate :: Reg < syscfg_memrmp :: SyscfgMemrmpSpec > ;
#[doc = "memory remap register"] pub mod syscfg_memrmp {
#[doc = "Register `SYSCFG_MEMRMP` reader"] pub type R = crate :: R < SyscfgMemrmpSpec > ;
#[doc = "Register `SYSCFG_MEMRMP` writer"] pub type W = crate :: W < SyscfgMemrmpSpec > ;
#[doc = "Field `MEM_MODE` reader - Memory mapping selection"] pub type MemModeR = crate :: FieldReader ;
#[doc = "Field `MEM_MODE` writer - Memory mapping selection"] pub type MemModeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:2 - Memory mapping selection"]
#[inline (always)] pub fn mem_mode (& self) -> MemModeR { MemModeR :: new ((self . bits & 7) as u8) } } impl W {
#[doc = "Bits 0:2 - Memory mapping selection"]
#[inline (always)] pub fn mem_mode (& mut self) -> MemModeW < '_ , SyscfgMemrmpSpec > { MemModeW :: new (self , 0) } }
#[doc = "memory remap register\n\nYou can [`read`](crate::Reg::read) this register and get [`syscfg_memrmp::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_memrmp::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SyscfgMemrmpSpec ; impl crate :: RegisterSpec for SyscfgMemrmpSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`syscfg_memrmp::R`](R) reader structure"] impl crate :: Readable for SyscfgMemrmpSpec { }
#[doc = "`write(|w| ..)` method takes [`syscfg_memrmp::W`](W) writer structure"] impl crate :: Writable for SyscfgMemrmpSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SYSCFG_MEMRMP to value 0"] impl crate :: Resettable for SyscfgMemrmpSpec { } }
#[doc = "SYSCFG_CFGR1 (rw) register accessor: configuration register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`syscfg_cfgr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_cfgr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@syscfg_cfgr1`] module"]
#[doc (alias = "SYSCFG_CFGR1")] pub type SyscfgCfgr1 = crate :: Reg < syscfg_cfgr1 :: SyscfgCfgr1Spec > ;
#[doc = "configuration register 1"] pub mod syscfg_cfgr1 {
#[doc = "Register `SYSCFG_CFGR1` reader"] pub type R = crate :: R < SyscfgCfgr1Spec > ;
#[doc = "Register `SYSCFG_CFGR1` writer"] pub type W = crate :: W < SyscfgCfgr1Spec > ;
#[doc = "Field `BOOSTEN` reader - I/O analog switch voltage booster enable"] pub type BoostenR = crate :: BitReader ;
#[doc = "Field `BOOSTEN` writer - I/O analog switch voltage booster enable"] pub type BoostenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `I2C_PB6_FMP` reader - Fast-mode Plus (Fm+) driving capability activation on PB6"] pub type I2cPb6FmpR = crate :: BitReader ;
#[doc = "Field `I2C_PB6_FMP` writer - Fast-mode Plus (Fm+) driving capability activation on PB6"] pub type I2cPb6FmpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `I2C_PB7_FMP` reader - Fast-mode Plus (Fm+) driving capability activation on PB7"] pub type I2cPb7FmpR = crate :: BitReader ;
#[doc = "Field `I2C_PB7_FMP` writer - Fast-mode Plus (Fm+) driving capability activation on PB7"] pub type I2cPb7FmpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `I2C_PB8_FMP` reader - Fast-mode Plus (Fm+) driving capability activation on PB8"] pub type I2cPb8FmpR = crate :: BitReader ;
#[doc = "Field `I2C_PB8_FMP` writer - Fast-mode Plus (Fm+) driving capability activation on PB8"] pub type I2cPb8FmpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `I2C_PB9_FMP` reader - Fast-mode Plus (Fm+) driving capability activation on PB9"] pub type I2cPb9FmpR = crate :: BitReader ;
#[doc = "Field `I2C_PB9_FMP` writer - Fast-mode Plus (Fm+) driving capability activation on PB9"] pub type I2cPb9FmpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `I2C1_FMP` reader - I2C1 Fast-mode Plus driving capability activation"] pub type I2c1FmpR = crate :: BitReader ;
#[doc = "Field `I2C1_FMP` writer - I2C1 Fast-mode Plus driving capability activation"] pub type I2c1FmpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `I2C3_FMP` reader - I2C3 Fast-mode Plus driving capability activation"] pub type I2c3FmpR = crate :: BitReader ;
#[doc = "Field `I2C3_FMP` writer - I2C3 Fast-mode Plus driving capability activation"] pub type I2c3FmpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FPU_IE` reader - Floating Point Unit interrupts enable bits"] pub type FpuIeR = crate :: FieldReader ;
#[doc = "Field `FPU_IE` writer - Floating Point Unit interrupts enable bits"] pub type FpuIeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 > ; impl R {
#[doc = "Bit 8 - I/O analog switch voltage booster enable"]
#[inline (always)] pub fn boosten (& self) -> BoostenR { BoostenR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 16 - Fast-mode Plus (Fm+) driving capability activation on PB6"]
#[inline (always)] pub fn i2c_pb6_fmp (& self) -> I2cPb6FmpR { I2cPb6FmpR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Fast-mode Plus (Fm+) driving capability activation on PB7"]
#[inline (always)] pub fn i2c_pb7_fmp (& self) -> I2cPb7FmpR { I2cPb7FmpR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Fast-mode Plus (Fm+) driving capability activation on PB8"]
#[inline (always)] pub fn i2c_pb8_fmp (& self) -> I2cPb8FmpR { I2cPb8FmpR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Fast-mode Plus (Fm+) driving capability activation on PB9"]
#[inline (always)] pub fn i2c_pb9_fmp (& self) -> I2cPb9FmpR { I2cPb9FmpR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - I2C1 Fast-mode Plus driving capability activation"]
#[inline (always)] pub fn i2c1_fmp (& self) -> I2c1FmpR { I2c1FmpR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 22 - I2C3 Fast-mode Plus driving capability activation"]
#[inline (always)] pub fn i2c3_fmp (& self) -> I2c3FmpR { I2c3FmpR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bits 26:31 - Floating Point Unit interrupts enable bits"]
#[inline (always)] pub fn fpu_ie (& self) -> FpuIeR { FpuIeR :: new (((self . bits >> 26) & 0x3f) as u8) } } impl W {
#[doc = "Bit 8 - I/O analog switch voltage booster enable"]
#[inline (always)] pub fn boosten (& mut self) -> BoostenW < '_ , SyscfgCfgr1Spec > { BoostenW :: new (self , 8) }
#[doc = "Bit 16 - Fast-mode Plus (Fm+) driving capability activation on PB6"]
#[inline (always)] pub fn i2c_pb6_fmp (& mut self) -> I2cPb6FmpW < '_ , SyscfgCfgr1Spec > { I2cPb6FmpW :: new (self , 16) }
#[doc = "Bit 17 - Fast-mode Plus (Fm+) driving capability activation on PB7"]
#[inline (always)] pub fn i2c_pb7_fmp (& mut self) -> I2cPb7FmpW < '_ , SyscfgCfgr1Spec > { I2cPb7FmpW :: new (self , 17) }
#[doc = "Bit 18 - Fast-mode Plus (Fm+) driving capability activation on PB8"]
#[inline (always)] pub fn i2c_pb8_fmp (& mut self) -> I2cPb8FmpW < '_ , SyscfgCfgr1Spec > { I2cPb8FmpW :: new (self , 18) }
#[doc = "Bit 19 - Fast-mode Plus (Fm+) driving capability activation on PB9"]
#[inline (always)] pub fn i2c_pb9_fmp (& mut self) -> I2cPb9FmpW < '_ , SyscfgCfgr1Spec > { I2cPb9FmpW :: new (self , 19) }
#[doc = "Bit 20 - I2C1 Fast-mode Plus driving capability activation"]
#[inline (always)] pub fn i2c1_fmp (& mut self) -> I2c1FmpW < '_ , SyscfgCfgr1Spec > { I2c1FmpW :: new (self , 20) }
#[doc = "Bit 22 - I2C3 Fast-mode Plus driving capability activation"]
#[inline (always)] pub fn i2c3_fmp (& mut self) -> I2c3FmpW < '_ , SyscfgCfgr1Spec > { I2c3FmpW :: new (self , 22) }
#[doc = "Bits 26:31 - Floating Point Unit interrupts enable bits"]
#[inline (always)] pub fn fpu_ie (& mut self) -> FpuIeW < '_ , SyscfgCfgr1Spec > { FpuIeW :: new (self , 26) } }
#[doc = "configuration register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`syscfg_cfgr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_cfgr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SyscfgCfgr1Spec ; impl crate :: RegisterSpec for SyscfgCfgr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`syscfg_cfgr1::R`](R) reader structure"] impl crate :: Readable for SyscfgCfgr1Spec { }
#[doc = "`write(|w| ..)` method takes [`syscfg_cfgr1::W`](W) writer structure"] impl crate :: Writable for SyscfgCfgr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SYSCFG_CFGR1 to value 0x7c00_0001"] impl crate :: Resettable for SyscfgCfgr1Spec { const RESET_VALUE : u32 = 0x7c00_0001 ; } }
#[doc = "SYSCFG_EXTICR1 (rw) register accessor: external interrupt configuration register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`syscfg_exticr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_exticr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@syscfg_exticr1`] module"]
#[doc (alias = "SYSCFG_EXTICR1")] pub type SyscfgExticr1 = crate :: Reg < syscfg_exticr1 :: SyscfgExticr1Spec > ;
#[doc = "external interrupt configuration register 1"] pub mod syscfg_exticr1 {
#[doc = "Register `SYSCFG_EXTICR1` reader"] pub type R = crate :: R < SyscfgExticr1Spec > ;
#[doc = "Register `SYSCFG_EXTICR1` writer"] pub type W = crate :: W < SyscfgExticr1Spec > ;
#[doc = "Field `EXTI0` reader - EXTI 0 configuration bits"] pub type Exti0R = crate :: FieldReader ;
#[doc = "Field `EXTI0` writer - EXTI 0 configuration bits"] pub type Exti0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `EXTI1` reader - EXTI 1 configuration bits"] pub type Exti1R = crate :: FieldReader ;
#[doc = "Field `EXTI1` writer - EXTI 1 configuration bits"] pub type Exti1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `EXTI2` reader - EXTI 2 configuration bits"] pub type Exti2R = crate :: FieldReader ;
#[doc = "Field `EXTI2` writer - EXTI 2 configuration bits"] pub type Exti2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `EXTI3` reader - EXTI 3 configuration bits"] pub type Exti3R = crate :: FieldReader ;
#[doc = "Field `EXTI3` writer - EXTI 3 configuration bits"] pub type Exti3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:2 - EXTI 0 configuration bits"]
#[inline (always)] pub fn exti0 (& self) -> Exti0R { Exti0R :: new ((self . bits & 7) as u8) }
#[doc = "Bits 4:6 - EXTI 1 configuration bits"]
#[inline (always)] pub fn exti1 (& self) -> Exti1R { Exti1R :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bits 8:10 - EXTI 2 configuration bits"]
#[inline (always)] pub fn exti2 (& self) -> Exti2R { Exti2R :: new (((self . bits >> 8) & 7) as u8) }
#[doc = "Bits 12:14 - EXTI 3 configuration bits"]
#[inline (always)] pub fn exti3 (& self) -> Exti3R { Exti3R :: new (((self . bits >> 12) & 7) as u8) } } impl W {
#[doc = "Bits 0:2 - EXTI 0 configuration bits"]
#[inline (always)] pub fn exti0 (& mut self) -> Exti0W < '_ , SyscfgExticr1Spec > { Exti0W :: new (self , 0) }
#[doc = "Bits 4:6 - EXTI 1 configuration bits"]
#[inline (always)] pub fn exti1 (& mut self) -> Exti1W < '_ , SyscfgExticr1Spec > { Exti1W :: new (self , 4) }
#[doc = "Bits 8:10 - EXTI 2 configuration bits"]
#[inline (always)] pub fn exti2 (& mut self) -> Exti2W < '_ , SyscfgExticr1Spec > { Exti2W :: new (self , 8) }
#[doc = "Bits 12:14 - EXTI 3 configuration bits"]
#[inline (always)] pub fn exti3 (& mut self) -> Exti3W < '_ , SyscfgExticr1Spec > { Exti3W :: new (self , 12) } }
#[doc = "external interrupt configuration register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`syscfg_exticr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_exticr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SyscfgExticr1Spec ; impl crate :: RegisterSpec for SyscfgExticr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`syscfg_exticr1::R`](R) reader structure"] impl crate :: Readable for SyscfgExticr1Spec { }
#[doc = "`write(|w| ..)` method takes [`syscfg_exticr1::W`](W) writer structure"] impl crate :: Writable for SyscfgExticr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SYSCFG_EXTICR1 to value 0"] impl crate :: Resettable for SyscfgExticr1Spec { } }
#[doc = "SYSCFG_EXTICR2 (rw) register accessor: external interrupt configuration register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`syscfg_exticr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_exticr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@syscfg_exticr2`] module"]
#[doc (alias = "SYSCFG_EXTICR2")] pub type SyscfgExticr2 = crate :: Reg < syscfg_exticr2 :: SyscfgExticr2Spec > ;
#[doc = "external interrupt configuration register 2"] pub mod syscfg_exticr2 {
#[doc = "Register `SYSCFG_EXTICR2` reader"] pub type R = crate :: R < SyscfgExticr2Spec > ;
#[doc = "Register `SYSCFG_EXTICR2` writer"] pub type W = crate :: W < SyscfgExticr2Spec > ;
#[doc = "Field `EXTI4` reader - EXTI 4 configuration bits"] pub type Exti4R = crate :: FieldReader ;
#[doc = "Field `EXTI4` writer - EXTI 4 configuration bits"] pub type Exti4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `EXTI5` reader - EXTI 5 configuration bits"] pub type Exti5R = crate :: FieldReader ;
#[doc = "Field `EXTI5` writer - EXTI 5 configuration bits"] pub type Exti5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `EXTI6` reader - EXTI 6 configuration bits"] pub type Exti6R = crate :: FieldReader ;
#[doc = "Field `EXTI6` writer - EXTI 6 configuration bits"] pub type Exti6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `EXTI7` reader - EXTI 7 configuration bits"] pub type Exti7R = crate :: FieldReader ;
#[doc = "Field `EXTI7` writer - EXTI 7 configuration bits"] pub type Exti7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:2 - EXTI 4 configuration bits"]
#[inline (always)] pub fn exti4 (& self) -> Exti4R { Exti4R :: new ((self . bits & 7) as u8) }
#[doc = "Bits 4:6 - EXTI 5 configuration bits"]
#[inline (always)] pub fn exti5 (& self) -> Exti5R { Exti5R :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bits 8:10 - EXTI 6 configuration bits"]
#[inline (always)] pub fn exti6 (& self) -> Exti6R { Exti6R :: new (((self . bits >> 8) & 7) as u8) }
#[doc = "Bits 12:14 - EXTI 7 configuration bits"]
#[inline (always)] pub fn exti7 (& self) -> Exti7R { Exti7R :: new (((self . bits >> 12) & 7) as u8) } } impl W {
#[doc = "Bits 0:2 - EXTI 4 configuration bits"]
#[inline (always)] pub fn exti4 (& mut self) -> Exti4W < '_ , SyscfgExticr2Spec > { Exti4W :: new (self , 0) }
#[doc = "Bits 4:6 - EXTI 5 configuration bits"]
#[inline (always)] pub fn exti5 (& mut self) -> Exti5W < '_ , SyscfgExticr2Spec > { Exti5W :: new (self , 4) }
#[doc = "Bits 8:10 - EXTI 6 configuration bits"]
#[inline (always)] pub fn exti6 (& mut self) -> Exti6W < '_ , SyscfgExticr2Spec > { Exti6W :: new (self , 8) }
#[doc = "Bits 12:14 - EXTI 7 configuration bits"]
#[inline (always)] pub fn exti7 (& mut self) -> Exti7W < '_ , SyscfgExticr2Spec > { Exti7W :: new (self , 12) } }
#[doc = "external interrupt configuration register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`syscfg_exticr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_exticr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SyscfgExticr2Spec ; impl crate :: RegisterSpec for SyscfgExticr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`syscfg_exticr2::R`](R) reader structure"] impl crate :: Readable for SyscfgExticr2Spec { }
#[doc = "`write(|w| ..)` method takes [`syscfg_exticr2::W`](W) writer structure"] impl crate :: Writable for SyscfgExticr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SYSCFG_EXTICR2 to value 0"] impl crate :: Resettable for SyscfgExticr2Spec { } }
#[doc = "SYSCFG_EXTICR3 (rw) register accessor: external interrupt configuration register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`syscfg_exticr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_exticr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@syscfg_exticr3`] module"]
#[doc (alias = "SYSCFG_EXTICR3")] pub type SyscfgExticr3 = crate :: Reg < syscfg_exticr3 :: SyscfgExticr3Spec > ;
#[doc = "external interrupt configuration register 3"] pub mod syscfg_exticr3 {
#[doc = "Register `SYSCFG_EXTICR3` reader"] pub type R = crate :: R < SyscfgExticr3Spec > ;
#[doc = "Register `SYSCFG_EXTICR3` writer"] pub type W = crate :: W < SyscfgExticr3Spec > ;
#[doc = "Field `EXTI8` reader - EXTI 8 configuration bits"] pub type Exti8R = crate :: FieldReader ;
#[doc = "Field `EXTI8` writer - EXTI 8 configuration bits"] pub type Exti8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `EXTI9` reader - EXTI 9 configuration bits"] pub type Exti9R = crate :: FieldReader ;
#[doc = "Field `EXTI9` writer - EXTI 9 configuration bits"] pub type Exti9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `EXTI10` reader - EXTI 10 configuration bits"] pub type Exti10R = crate :: FieldReader ;
#[doc = "Field `EXTI10` writer - EXTI 10 configuration bits"] pub type Exti10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `EXTI11` reader - EXTI 11 configuration bits"] pub type Exti11R = crate :: FieldReader ;
#[doc = "Field `EXTI11` writer - EXTI 11 configuration bits"] pub type Exti11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:2 - EXTI 8 configuration bits"]
#[inline (always)] pub fn exti8 (& self) -> Exti8R { Exti8R :: new ((self . bits & 7) as u8) }
#[doc = "Bits 4:6 - EXTI 9 configuration bits"]
#[inline (always)] pub fn exti9 (& self) -> Exti9R { Exti9R :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bits 8:10 - EXTI 10 configuration bits"]
#[inline (always)] pub fn exti10 (& self) -> Exti10R { Exti10R :: new (((self . bits >> 8) & 7) as u8) }
#[doc = "Bits 12:14 - EXTI 11 configuration bits"]
#[inline (always)] pub fn exti11 (& self) -> Exti11R { Exti11R :: new (((self . bits >> 12) & 7) as u8) } } impl W {
#[doc = "Bits 0:2 - EXTI 8 configuration bits"]
#[inline (always)] pub fn exti8 (& mut self) -> Exti8W < '_ , SyscfgExticr3Spec > { Exti8W :: new (self , 0) }
#[doc = "Bits 4:6 - EXTI 9 configuration bits"]
#[inline (always)] pub fn exti9 (& mut self) -> Exti9W < '_ , SyscfgExticr3Spec > { Exti9W :: new (self , 4) }
#[doc = "Bits 8:10 - EXTI 10 configuration bits"]
#[inline (always)] pub fn exti10 (& mut self) -> Exti10W < '_ , SyscfgExticr3Spec > { Exti10W :: new (self , 8) }
#[doc = "Bits 12:14 - EXTI 11 configuration bits"]
#[inline (always)] pub fn exti11 (& mut self) -> Exti11W < '_ , SyscfgExticr3Spec > { Exti11W :: new (self , 12) } }
#[doc = "external interrupt configuration register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`syscfg_exticr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_exticr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SyscfgExticr3Spec ; impl crate :: RegisterSpec for SyscfgExticr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`syscfg_exticr3::R`](R) reader structure"] impl crate :: Readable for SyscfgExticr3Spec { }
#[doc = "`write(|w| ..)` method takes [`syscfg_exticr3::W`](W) writer structure"] impl crate :: Writable for SyscfgExticr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SYSCFG_EXTICR3 to value 0"] impl crate :: Resettable for SyscfgExticr3Spec { } }
#[doc = "SYSCFG_EXTICR4 (rw) register accessor: external interrupt configuration register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`syscfg_exticr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_exticr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@syscfg_exticr4`] module"]
#[doc (alias = "SYSCFG_EXTICR4")] pub type SyscfgExticr4 = crate :: Reg < syscfg_exticr4 :: SyscfgExticr4Spec > ;
#[doc = "external interrupt configuration register 4"] pub mod syscfg_exticr4 {
#[doc = "Register `SYSCFG_EXTICR4` reader"] pub type R = crate :: R < SyscfgExticr4Spec > ;
#[doc = "Register `SYSCFG_EXTICR4` writer"] pub type W = crate :: W < SyscfgExticr4Spec > ;
#[doc = "Field `EXTI12` reader - EXTI12 configuration bits"] pub type Exti12R = crate :: FieldReader ;
#[doc = "Field `EXTI12` writer - EXTI12 configuration bits"] pub type Exti12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `EXTI13` reader - EXTI13 configuration bits"] pub type Exti13R = crate :: FieldReader ;
#[doc = "Field `EXTI13` writer - EXTI13 configuration bits"] pub type Exti13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `EXTI14` reader - EXTI14 configuration bits"] pub type Exti14R = crate :: FieldReader ;
#[doc = "Field `EXTI14` writer - EXTI14 configuration bits"] pub type Exti14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `EXTI15` reader - EXTI15 configuration bits"] pub type Exti15R = crate :: FieldReader ;
#[doc = "Field `EXTI15` writer - EXTI15 configuration bits"] pub type Exti15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:2 - EXTI12 configuration bits"]
#[inline (always)] pub fn exti12 (& self) -> Exti12R { Exti12R :: new ((self . bits & 7) as u8) }
#[doc = "Bits 4:6 - EXTI13 configuration bits"]
#[inline (always)] pub fn exti13 (& self) -> Exti13R { Exti13R :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bits 8:10 - EXTI14 configuration bits"]
#[inline (always)] pub fn exti14 (& self) -> Exti14R { Exti14R :: new (((self . bits >> 8) & 7) as u8) }
#[doc = "Bits 12:14 - EXTI15 configuration bits"]
#[inline (always)] pub fn exti15 (& self) -> Exti15R { Exti15R :: new (((self . bits >> 12) & 7) as u8) } } impl W {
#[doc = "Bits 0:2 - EXTI12 configuration bits"]
#[inline (always)] pub fn exti12 (& mut self) -> Exti12W < '_ , SyscfgExticr4Spec > { Exti12W :: new (self , 0) }
#[doc = "Bits 4:6 - EXTI13 configuration bits"]
#[inline (always)] pub fn exti13 (& mut self) -> Exti13W < '_ , SyscfgExticr4Spec > { Exti13W :: new (self , 4) }
#[doc = "Bits 8:10 - EXTI14 configuration bits"]
#[inline (always)] pub fn exti14 (& mut self) -> Exti14W < '_ , SyscfgExticr4Spec > { Exti14W :: new (self , 8) }
#[doc = "Bits 12:14 - EXTI15 configuration bits"]
#[inline (always)] pub fn exti15 (& mut self) -> Exti15W < '_ , SyscfgExticr4Spec > { Exti15W :: new (self , 12) } }
#[doc = "external interrupt configuration register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`syscfg_exticr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_exticr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SyscfgExticr4Spec ; impl crate :: RegisterSpec for SyscfgExticr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`syscfg_exticr4::R`](R) reader structure"] impl crate :: Readable for SyscfgExticr4Spec { }
#[doc = "`write(|w| ..)` method takes [`syscfg_exticr4::W`](W) writer structure"] impl crate :: Writable for SyscfgExticr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SYSCFG_EXTICR4 to value 0"] impl crate :: Resettable for SyscfgExticr4Spec { } }
#[doc = "SYSCFG_SCSR (rw) register accessor: SCSR\n\nYou can [`read`](crate::Reg::read) this register and get [`syscfg_scsr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_scsr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@syscfg_scsr`] module"]
#[doc (alias = "SYSCFG_SCSR")] pub type SyscfgScsr = crate :: Reg < syscfg_scsr :: SyscfgScsrSpec > ;
#[doc = "SCSR"] pub mod syscfg_scsr {
#[doc = "Register `SYSCFG_SCSR` reader"] pub type R = crate :: R < SyscfgScsrSpec > ;
#[doc = "Register `SYSCFG_SCSR` writer"] pub type W = crate :: W < SyscfgScsrSpec > ;
#[doc = "Field `SRAM2ER` reader - SRAM2 Erase"] pub type Sram2erR = crate :: BitReader ;
#[doc = "Field `SRAM2ER` writer - SRAM2 Erase"] pub type Sram2erW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SRAM2BSY` reader - SRAM2 busy by erase operation"] pub type Sram2bsyR = crate :: BitReader ;
#[doc = "Field `C2RFD` reader - CPU2 SRAM fetch (execution) disable."] pub type C2rfdR = crate :: BitReader ;
#[doc = "Field `C2RFD` writer - CPU2 SRAM fetch (execution) disable."] pub type C2rfdW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - SRAM2 Erase"]
#[inline (always)] pub fn sram2er (& self) -> Sram2erR { Sram2erR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - SRAM2 busy by erase operation"]
#[inline (always)] pub fn sram2bsy (& self) -> Sram2bsyR { Sram2bsyR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 31 - CPU2 SRAM fetch (execution) disable."]
#[inline (always)] pub fn c2rfd (& self) -> C2rfdR { C2rfdR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - SRAM2 Erase"]
#[inline (always)] pub fn sram2er (& mut self) -> Sram2erW < '_ , SyscfgScsrSpec > { Sram2erW :: new (self , 0) }
#[doc = "Bit 31 - CPU2 SRAM fetch (execution) disable."]
#[inline (always)] pub fn c2rfd (& mut self) -> C2rfdW < '_ , SyscfgScsrSpec > { C2rfdW :: new (self , 31) } }
#[doc = "SCSR\n\nYou can [`read`](crate::Reg::read) this register and get [`syscfg_scsr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_scsr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SyscfgScsrSpec ; impl crate :: RegisterSpec for SyscfgScsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`syscfg_scsr::R`](R) reader structure"] impl crate :: Readable for SyscfgScsrSpec { }
#[doc = "`write(|w| ..)` method takes [`syscfg_scsr::W`](W) writer structure"] impl crate :: Writable for SyscfgScsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SYSCFG_SCSR to value 0"] impl crate :: Resettable for SyscfgScsrSpec { } }
#[doc = "SYSCFG_CFGR2 (rw) register accessor: CFGR2\n\nYou can [`read`](crate::Reg::read) this register and get [`syscfg_cfgr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_cfgr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@syscfg_cfgr2`] module"]
#[doc (alias = "SYSCFG_CFGR2")] pub type SyscfgCfgr2 = crate :: Reg < syscfg_cfgr2 :: SyscfgCfgr2Spec > ;
#[doc = "CFGR2"] pub mod syscfg_cfgr2 {
#[doc = "Register `SYSCFG_CFGR2` reader"] pub type R = crate :: R < SyscfgCfgr2Spec > ;
#[doc = "Register `SYSCFG_CFGR2` writer"] pub type W = crate :: W < SyscfgCfgr2Spec > ;
#[doc = "Field `CLL` writer - Cortex-M4 LOCKUP (Hardfault) output enable bit"] pub type CllW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPL` writer - SRAM2 parity lock bit"] pub type SplW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PVDL` writer - PVD lock enable bit"] pub type PvdlW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ECCL` writer - ECC Lock"] pub type EcclW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPF` reader - SRAM2 parity error flag"] pub type SpfR = crate :: BitReader ;
#[doc = "Field `SPF` writer - SRAM2 parity error flag"] pub type SpfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 8 - SRAM2 parity error flag"]
#[inline (always)] pub fn spf (& self) -> SpfR { SpfR :: new (((self . bits >> 8) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Cortex-M4 LOCKUP (Hardfault) output enable bit"]
#[inline (always)] pub fn cll (& mut self) -> CllW < '_ , SyscfgCfgr2Spec > { CllW :: new (self , 0) }
#[doc = "Bit 1 - SRAM2 parity lock bit"]
#[inline (always)] pub fn spl (& mut self) -> SplW < '_ , SyscfgCfgr2Spec > { SplW :: new (self , 1) }
#[doc = "Bit 2 - PVD lock enable bit"]
#[inline (always)] pub fn pvdl (& mut self) -> PvdlW < '_ , SyscfgCfgr2Spec > { PvdlW :: new (self , 2) }
#[doc = "Bit 3 - ECC Lock"]
#[inline (always)] pub fn eccl (& mut self) -> EcclW < '_ , SyscfgCfgr2Spec > { EcclW :: new (self , 3) }
#[doc = "Bit 8 - SRAM2 parity error flag"]
#[inline (always)] pub fn spf (& mut self) -> SpfW < '_ , SyscfgCfgr2Spec > { SpfW :: new (self , 8) } }
#[doc = "CFGR2\n\nYou can [`read`](crate::Reg::read) this register and get [`syscfg_cfgr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_cfgr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SyscfgCfgr2Spec ; impl crate :: RegisterSpec for SyscfgCfgr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`syscfg_cfgr2::R`](R) reader structure"] impl crate :: Readable for SyscfgCfgr2Spec { }
#[doc = "`write(|w| ..)` method takes [`syscfg_cfgr2::W`](W) writer structure"] impl crate :: Writable for SyscfgCfgr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SYSCFG_CFGR2 to value 0"] impl crate :: Resettable for SyscfgCfgr2Spec { } }
#[doc = "SYSCFG_SWPR (w) register accessor: SRAM2 write protection register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_swpr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@syscfg_swpr`] module"]
#[doc (alias = "SYSCFG_SWPR")] pub type SyscfgSwpr = crate :: Reg < syscfg_swpr :: SyscfgSwprSpec > ;
#[doc = "SRAM2 write protection register"] pub mod syscfg_swpr {
#[doc = "Register `SYSCFG_SWPR` writer"] pub type W = crate :: W < SyscfgSwprSpec > ;
#[doc = "Field `P0WP` writer - P0WP"] pub type P0wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P1WP` writer - P1WP"] pub type P1wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P2WP` writer - P2WP"] pub type P2wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P3WP` writer - P3WP"] pub type P3wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P4WP` writer - P4WP"] pub type P4wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P5WP` writer - P5WP"] pub type P5wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P6WP` writer - P6WP"] pub type P6wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P7WP` writer - P7WP"] pub type P7wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P8WP` writer - P8WP"] pub type P8wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P9WP` writer - P9WP"] pub type P9wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P10WP` writer - P10WP"] pub type P10wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P11WP` writer - P11WP"] pub type P11wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P12WP` writer - P12WP"] pub type P12wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P13WP` writer - P13WP"] pub type P13wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P14WP` writer - P14WP"] pub type P14wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P15WP` writer - P15WP"] pub type P15wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P16WP` writer - P16WP"] pub type P16wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P17WP` writer - P17WP"] pub type P17wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P18WP` writer - P18WP"] pub type P18wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P19WP` writer - P19WP"] pub type P19wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P20WP` writer - P20WP"] pub type P20wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P21WP` writer - P21WP"] pub type P21wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P22WP` writer - P22WP"] pub type P22wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P23WP` writer - P23WP"] pub type P23wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P24WP` writer - P24WP"] pub type P24wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P25WP` writer - P25WP"] pub type P25wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P26WP` writer - P26WP"] pub type P26wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P27WP` writer - P27WP"] pub type P27wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P28WP` writer - P28WP"] pub type P28wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P29WP` writer - P29WP"] pub type P29wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P30WP` writer - P30WP"] pub type P30wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P31WP` writer - SRAM2 page 31 write protection"] pub type P31wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - P0WP"]
#[inline (always)] pub fn p0wp (& mut self) -> P0wpW < '_ , SyscfgSwprSpec > { P0wpW :: new (self , 0) }
#[doc = "Bit 1 - P1WP"]
#[inline (always)] pub fn p1wp (& mut self) -> P1wpW < '_ , SyscfgSwprSpec > { P1wpW :: new (self , 1) }
#[doc = "Bit 2 - P2WP"]
#[inline (always)] pub fn p2wp (& mut self) -> P2wpW < '_ , SyscfgSwprSpec > { P2wpW :: new (self , 2) }
#[doc = "Bit 3 - P3WP"]
#[inline (always)] pub fn p3wp (& mut self) -> P3wpW < '_ , SyscfgSwprSpec > { P3wpW :: new (self , 3) }
#[doc = "Bit 4 - P4WP"]
#[inline (always)] pub fn p4wp (& mut self) -> P4wpW < '_ , SyscfgSwprSpec > { P4wpW :: new (self , 4) }
#[doc = "Bit 5 - P5WP"]
#[inline (always)] pub fn p5wp (& mut self) -> P5wpW < '_ , SyscfgSwprSpec > { P5wpW :: new (self , 5) }
#[doc = "Bit 6 - P6WP"]
#[inline (always)] pub fn p6wp (& mut self) -> P6wpW < '_ , SyscfgSwprSpec > { P6wpW :: new (self , 6) }
#[doc = "Bit 7 - P7WP"]
#[inline (always)] pub fn p7wp (& mut self) -> P7wpW < '_ , SyscfgSwprSpec > { P7wpW :: new (self , 7) }
#[doc = "Bit 8 - P8WP"]
#[inline (always)] pub fn p8wp (& mut self) -> P8wpW < '_ , SyscfgSwprSpec > { P8wpW :: new (self , 8) }
#[doc = "Bit 9 - P9WP"]
#[inline (always)] pub fn p9wp (& mut self) -> P9wpW < '_ , SyscfgSwprSpec > { P9wpW :: new (self , 9) }
#[doc = "Bit 10 - P10WP"]
#[inline (always)] pub fn p10wp (& mut self) -> P10wpW < '_ , SyscfgSwprSpec > { P10wpW :: new (self , 10) }
#[doc = "Bit 11 - P11WP"]
#[inline (always)] pub fn p11wp (& mut self) -> P11wpW < '_ , SyscfgSwprSpec > { P11wpW :: new (self , 11) }
#[doc = "Bit 12 - P12WP"]
#[inline (always)] pub fn p12wp (& mut self) -> P12wpW < '_ , SyscfgSwprSpec > { P12wpW :: new (self , 12) }
#[doc = "Bit 13 - P13WP"]
#[inline (always)] pub fn p13wp (& mut self) -> P13wpW < '_ , SyscfgSwprSpec > { P13wpW :: new (self , 13) }
#[doc = "Bit 14 - P14WP"]
#[inline (always)] pub fn p14wp (& mut self) -> P14wpW < '_ , SyscfgSwprSpec > { P14wpW :: new (self , 14) }
#[doc = "Bit 15 - P15WP"]
#[inline (always)] pub fn p15wp (& mut self) -> P15wpW < '_ , SyscfgSwprSpec > { P15wpW :: new (self , 15) }
#[doc = "Bit 16 - P16WP"]
#[inline (always)] pub fn p16wp (& mut self) -> P16wpW < '_ , SyscfgSwprSpec > { P16wpW :: new (self , 16) }
#[doc = "Bit 17 - P17WP"]
#[inline (always)] pub fn p17wp (& mut self) -> P17wpW < '_ , SyscfgSwprSpec > { P17wpW :: new (self , 17) }
#[doc = "Bit 18 - P18WP"]
#[inline (always)] pub fn p18wp (& mut self) -> P18wpW < '_ , SyscfgSwprSpec > { P18wpW :: new (self , 18) }
#[doc = "Bit 19 - P19WP"]
#[inline (always)] pub fn p19wp (& mut self) -> P19wpW < '_ , SyscfgSwprSpec > { P19wpW :: new (self , 19) }
#[doc = "Bit 20 - P20WP"]
#[inline (always)] pub fn p20wp (& mut self) -> P20wpW < '_ , SyscfgSwprSpec > { P20wpW :: new (self , 20) }
#[doc = "Bit 21 - P21WP"]
#[inline (always)] pub fn p21wp (& mut self) -> P21wpW < '_ , SyscfgSwprSpec > { P21wpW :: new (self , 21) }
#[doc = "Bit 22 - P22WP"]
#[inline (always)] pub fn p22wp (& mut self) -> P22wpW < '_ , SyscfgSwprSpec > { P22wpW :: new (self , 22) }
#[doc = "Bit 23 - P23WP"]
#[inline (always)] pub fn p23wp (& mut self) -> P23wpW < '_ , SyscfgSwprSpec > { P23wpW :: new (self , 23) }
#[doc = "Bit 24 - P24WP"]
#[inline (always)] pub fn p24wp (& mut self) -> P24wpW < '_ , SyscfgSwprSpec > { P24wpW :: new (self , 24) }
#[doc = "Bit 25 - P25WP"]
#[inline (always)] pub fn p25wp (& mut self) -> P25wpW < '_ , SyscfgSwprSpec > { P25wpW :: new (self , 25) }
#[doc = "Bit 26 - P26WP"]
#[inline (always)] pub fn p26wp (& mut self) -> P26wpW < '_ , SyscfgSwprSpec > { P26wpW :: new (self , 26) }
#[doc = "Bit 27 - P27WP"]
#[inline (always)] pub fn p27wp (& mut self) -> P27wpW < '_ , SyscfgSwprSpec > { P27wpW :: new (self , 27) }
#[doc = "Bit 28 - P28WP"]
#[inline (always)] pub fn p28wp (& mut self) -> P28wpW < '_ , SyscfgSwprSpec > { P28wpW :: new (self , 28) }
#[doc = "Bit 29 - P29WP"]
#[inline (always)] pub fn p29wp (& mut self) -> P29wpW < '_ , SyscfgSwprSpec > { P29wpW :: new (self , 29) }
#[doc = "Bit 30 - P30WP"]
#[inline (always)] pub fn p30wp (& mut self) -> P30wpW < '_ , SyscfgSwprSpec > { P30wpW :: new (self , 30) }
#[doc = "Bit 31 - SRAM2 page 31 write protection"]
#[inline (always)] pub fn p31wp (& mut self) -> P31wpW < '_ , SyscfgSwprSpec > { P31wpW :: new (self , 31) } }
#[doc = "SRAM2 write protection register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_swpr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SyscfgSwprSpec ; impl crate :: RegisterSpec for SyscfgSwprSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`syscfg_swpr::W`](W) writer structure"] impl crate :: Writable for SyscfgSwprSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SYSCFG_SWPR to value 0"] impl crate :: Resettable for SyscfgSwprSpec { } }
#[doc = "SYSCFG_SKR (w) register accessor: SKR\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_skr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@syscfg_skr`] module"]
#[doc (alias = "SYSCFG_SKR")] pub type SyscfgSkr = crate :: Reg < syscfg_skr :: SyscfgSkrSpec > ;
#[doc = "SKR"] pub mod syscfg_skr {
#[doc = "Register `SYSCFG_SKR` writer"] pub type W = crate :: W < SyscfgSkrSpec > ;
#[doc = "Field `KEY` writer - SRAM2 write protection key for software erase"] pub type KeyW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl W {
#[doc = "Bits 0:7 - SRAM2 write protection key for software erase"]
#[inline (always)] pub fn key (& mut self) -> KeyW < '_ , SyscfgSkrSpec > { KeyW :: new (self , 0) } }
#[doc = "SKR\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_skr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SyscfgSkrSpec ; impl crate :: RegisterSpec for SyscfgSkrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`syscfg_skr::W`](W) writer structure"] impl crate :: Writable for SyscfgSkrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SYSCFG_SKR to value 0"] impl crate :: Resettable for SyscfgSkrSpec { } }
#[doc = "SYSCFG_SWPR2 (w) register accessor: SRAM2 write protection register 2\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_swpr2::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@syscfg_swpr2`] module"]
#[doc (alias = "SYSCFG_SWPR2")] pub type SyscfgSwpr2 = crate :: Reg < syscfg_swpr2 :: SyscfgSwpr2Spec > ;
#[doc = "SRAM2 write protection register 2"] pub mod syscfg_swpr2 {
#[doc = "Register `SYSCFG_SWPR2` writer"] pub type W = crate :: W < SyscfgSwpr2Spec > ;
#[doc = "Field `P32WP` writer - P32WP"] pub type P32wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P33WP` writer - P33WP"] pub type P33wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P34WP` writer - P34WP"] pub type P34wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P35WP` writer - P35WP"] pub type P35wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P36WP` writer - P36WP"] pub type P36wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P37WP` writer - P37WP"] pub type P37wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P38WP` writer - P38WP"] pub type P38wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P39WP` writer - P39WP"] pub type P39wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P40WP` writer - P40WP"] pub type P40wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P41WP` writer - P41WP"] pub type P41wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P42WP` writer - P42WP"] pub type P42wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P43WP` writer - P43WP"] pub type P43wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P44WP` writer - P44WP"] pub type P44wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P45WP` writer - P45WP"] pub type P45wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P46WP` writer - P46WP"] pub type P46wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P47WP` writer - P47WP"] pub type P47wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P48WP` writer - P48WP"] pub type P48wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P49WP` writer - P49WP"] pub type P49wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P50WP` writer - P50WP"] pub type P50wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P51WP` writer - P51WP"] pub type P51wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P52WP` writer - P52WP"] pub type P52wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P53WP` writer - P53WP"] pub type P53wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P54WP` writer - P54WP"] pub type P54wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P55WP` writer - P55WP"] pub type P55wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P56WP` writer - P56WP"] pub type P56wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P57WP` writer - P57WP"] pub type P57wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P58WP` writer - P58WP"] pub type P58wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P59WP` writer - P59WP"] pub type P59wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P60WP` writer - P60WP"] pub type P60wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P61WP` writer - P61WP"] pub type P61wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P62WP` writer - P62WP"] pub type P62wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `P63WP` writer - SRAM2 page 63 write protection"] pub type P63wpW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - P32WP"]
#[inline (always)] pub fn p32wp (& mut self) -> P32wpW < '_ , SyscfgSwpr2Spec > { P32wpW :: new (self , 0) }
#[doc = "Bit 1 - P33WP"]
#[inline (always)] pub fn p33wp (& mut self) -> P33wpW < '_ , SyscfgSwpr2Spec > { P33wpW :: new (self , 1) }
#[doc = "Bit 2 - P34WP"]
#[inline (always)] pub fn p34wp (& mut self) -> P34wpW < '_ , SyscfgSwpr2Spec > { P34wpW :: new (self , 2) }
#[doc = "Bit 3 - P35WP"]
#[inline (always)] pub fn p35wp (& mut self) -> P35wpW < '_ , SyscfgSwpr2Spec > { P35wpW :: new (self , 3) }
#[doc = "Bit 4 - P36WP"]
#[inline (always)] pub fn p36wp (& mut self) -> P36wpW < '_ , SyscfgSwpr2Spec > { P36wpW :: new (self , 4) }
#[doc = "Bit 5 - P37WP"]
#[inline (always)] pub fn p37wp (& mut self) -> P37wpW < '_ , SyscfgSwpr2Spec > { P37wpW :: new (self , 5) }
#[doc = "Bit 6 - P38WP"]
#[inline (always)] pub fn p38wp (& mut self) -> P38wpW < '_ , SyscfgSwpr2Spec > { P38wpW :: new (self , 6) }
#[doc = "Bit 7 - P39WP"]
#[inline (always)] pub fn p39wp (& mut self) -> P39wpW < '_ , SyscfgSwpr2Spec > { P39wpW :: new (self , 7) }
#[doc = "Bit 8 - P40WP"]
#[inline (always)] pub fn p40wp (& mut self) -> P40wpW < '_ , SyscfgSwpr2Spec > { P40wpW :: new (self , 8) }
#[doc = "Bit 9 - P41WP"]
#[inline (always)] pub fn p41wp (& mut self) -> P41wpW < '_ , SyscfgSwpr2Spec > { P41wpW :: new (self , 9) }
#[doc = "Bit 10 - P42WP"]
#[inline (always)] pub fn p42wp (& mut self) -> P42wpW < '_ , SyscfgSwpr2Spec > { P42wpW :: new (self , 10) }
#[doc = "Bit 11 - P43WP"]
#[inline (always)] pub fn p43wp (& mut self) -> P43wpW < '_ , SyscfgSwpr2Spec > { P43wpW :: new (self , 11) }
#[doc = "Bit 12 - P44WP"]
#[inline (always)] pub fn p44wp (& mut self) -> P44wpW < '_ , SyscfgSwpr2Spec > { P44wpW :: new (self , 12) }
#[doc = "Bit 13 - P45WP"]
#[inline (always)] pub fn p45wp (& mut self) -> P45wpW < '_ , SyscfgSwpr2Spec > { P45wpW :: new (self , 13) }
#[doc = "Bit 14 - P46WP"]
#[inline (always)] pub fn p46wp (& mut self) -> P46wpW < '_ , SyscfgSwpr2Spec > { P46wpW :: new (self , 14) }
#[doc = "Bit 15 - P47WP"]
#[inline (always)] pub fn p47wp (& mut self) -> P47wpW < '_ , SyscfgSwpr2Spec > { P47wpW :: new (self , 15) }
#[doc = "Bit 16 - P48WP"]
#[inline (always)] pub fn p48wp (& mut self) -> P48wpW < '_ , SyscfgSwpr2Spec > { P48wpW :: new (self , 16) }
#[doc = "Bit 17 - P49WP"]
#[inline (always)] pub fn p49wp (& mut self) -> P49wpW < '_ , SyscfgSwpr2Spec > { P49wpW :: new (self , 17) }
#[doc = "Bit 18 - P50WP"]
#[inline (always)] pub fn p50wp (& mut self) -> P50wpW < '_ , SyscfgSwpr2Spec > { P50wpW :: new (self , 18) }
#[doc = "Bit 19 - P51WP"]
#[inline (always)] pub fn p51wp (& mut self) -> P51wpW < '_ , SyscfgSwpr2Spec > { P51wpW :: new (self , 19) }
#[doc = "Bit 20 - P52WP"]
#[inline (always)] pub fn p52wp (& mut self) -> P52wpW < '_ , SyscfgSwpr2Spec > { P52wpW :: new (self , 20) }
#[doc = "Bit 21 - P53WP"]
#[inline (always)] pub fn p53wp (& mut self) -> P53wpW < '_ , SyscfgSwpr2Spec > { P53wpW :: new (self , 21) }
#[doc = "Bit 22 - P54WP"]
#[inline (always)] pub fn p54wp (& mut self) -> P54wpW < '_ , SyscfgSwpr2Spec > { P54wpW :: new (self , 22) }
#[doc = "Bit 23 - P55WP"]
#[inline (always)] pub fn p55wp (& mut self) -> P55wpW < '_ , SyscfgSwpr2Spec > { P55wpW :: new (self , 23) }
#[doc = "Bit 24 - P56WP"]
#[inline (always)] pub fn p56wp (& mut self) -> P56wpW < '_ , SyscfgSwpr2Spec > { P56wpW :: new (self , 24) }
#[doc = "Bit 25 - P57WP"]
#[inline (always)] pub fn p57wp (& mut self) -> P57wpW < '_ , SyscfgSwpr2Spec > { P57wpW :: new (self , 25) }
#[doc = "Bit 26 - P58WP"]
#[inline (always)] pub fn p58wp (& mut self) -> P58wpW < '_ , SyscfgSwpr2Spec > { P58wpW :: new (self , 26) }
#[doc = "Bit 27 - P59WP"]
#[inline (always)] pub fn p59wp (& mut self) -> P59wpW < '_ , SyscfgSwpr2Spec > { P59wpW :: new (self , 27) }
#[doc = "Bit 28 - P60WP"]
#[inline (always)] pub fn p60wp (& mut self) -> P60wpW < '_ , SyscfgSwpr2Spec > { P60wpW :: new (self , 28) }
#[doc = "Bit 29 - P61WP"]
#[inline (always)] pub fn p61wp (& mut self) -> P61wpW < '_ , SyscfgSwpr2Spec > { P61wpW :: new (self , 29) }
#[doc = "Bit 30 - P62WP"]
#[inline (always)] pub fn p62wp (& mut self) -> P62wpW < '_ , SyscfgSwpr2Spec > { P62wpW :: new (self , 30) }
#[doc = "Bit 31 - SRAM2 page 63 write protection"]
#[inline (always)] pub fn p63wp (& mut self) -> P63wpW < '_ , SyscfgSwpr2Spec > { P63wpW :: new (self , 31) } }
#[doc = "SRAM2 write protection register 2\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_swpr2::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SyscfgSwpr2Spec ; impl crate :: RegisterSpec for SyscfgSwpr2Spec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`syscfg_swpr2::W`](W) writer structure"] impl crate :: Writable for SyscfgSwpr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SYSCFG_SWPR2 to value 0"] impl crate :: Resettable for SyscfgSwpr2Spec { } }
#[doc = "VREFBUF_CSR (rw) register accessor: VREF control and status register\n\nYou can [`read`](crate::Reg::read) this register and get [`vrefbuf_csr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`vrefbuf_csr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@vrefbuf_csr`] module"]
#[doc (alias = "VREFBUF_CSR")] pub type VrefbufCsr = crate :: Reg < vrefbuf_csr :: VrefbufCsrSpec > ;
#[doc = "VREF control and status register"] pub mod vrefbuf_csr {
#[doc = "Register `VREFBUF_CSR` reader"] pub type R = crate :: R < VrefbufCsrSpec > ;
#[doc = "Register `VREFBUF_CSR` writer"] pub type W = crate :: W < VrefbufCsrSpec > ;
#[doc = "Field `ENVR` reader - Voltage reference buffer enable"] pub type EnvrR = crate :: BitReader ;
#[doc = "Field `ENVR` writer - Voltage reference buffer enable"] pub type EnvrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HIZ` reader - High impedance mode"] pub type HizR = crate :: BitReader ;
#[doc = "Field `HIZ` writer - High impedance mode"] pub type HizW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `VRS` reader - Voltage reference scale"] pub type VrsR = crate :: BitReader ;
#[doc = "Field `VRS` writer - Voltage reference scale"] pub type VrsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `VRR` reader - Voltage reference buffer ready"] pub type VrrR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Voltage reference buffer enable"]
#[inline (always)] pub fn envr (& self) -> EnvrR { EnvrR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - High impedance mode"]
#[inline (always)] pub fn hiz (& self) -> HizR { HizR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Voltage reference scale"]
#[inline (always)] pub fn vrs (& self) -> VrsR { VrsR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Voltage reference buffer ready"]
#[inline (always)] pub fn vrr (& self) -> VrrR { VrrR :: new (((self . bits >> 3) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Voltage reference buffer enable"]
#[inline (always)] pub fn envr (& mut self) -> EnvrW < '_ , VrefbufCsrSpec > { EnvrW :: new (self , 0) }
#[doc = "Bit 1 - High impedance mode"]
#[inline (always)] pub fn hiz (& mut self) -> HizW < '_ , VrefbufCsrSpec > { HizW :: new (self , 1) }
#[doc = "Bit 2 - Voltage reference scale"]
#[inline (always)] pub fn vrs (& mut self) -> VrsW < '_ , VrefbufCsrSpec > { VrsW :: new (self , 2) } }
#[doc = "VREF control and status register\n\nYou can [`read`](crate::Reg::read) this register and get [`vrefbuf_csr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`vrefbuf_csr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct VrefbufCsrSpec ; impl crate :: RegisterSpec for VrefbufCsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`vrefbuf_csr::R`](R) reader structure"] impl crate :: Readable for VrefbufCsrSpec { }
#[doc = "`write(|w| ..)` method takes [`vrefbuf_csr::W`](W) writer structure"] impl crate :: Writable for VrefbufCsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets VREFBUF_CSR to value 0x02"] impl crate :: Resettable for VrefbufCsrSpec { const RESET_VALUE : u32 = 0x02 ; } }
#[doc = "VREFBUF_CCR (rw) register accessor: calibration control register\n\nYou can [`read`](crate::Reg::read) this register and get [`vrefbuf_ccr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`vrefbuf_ccr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@vrefbuf_ccr`] module"]
#[doc (alias = "VREFBUF_CCR")] pub type VrefbufCcr = crate :: Reg < vrefbuf_ccr :: VrefbufCcrSpec > ;
#[doc = "calibration control register"] pub mod vrefbuf_ccr {
#[doc = "Register `VREFBUF_CCR` reader"] pub type R = crate :: R < VrefbufCcrSpec > ;
#[doc = "Register `VREFBUF_CCR` writer"] pub type W = crate :: W < VrefbufCcrSpec > ;
#[doc = "Field `TRIM` reader - Trimming code"] pub type TrimR = crate :: FieldReader ;
#[doc = "Field `TRIM` writer - Trimming code"] pub type TrimW < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 > ; impl R {
#[doc = "Bits 0:5 - Trimming code"]
#[inline (always)] pub fn trim (& self) -> TrimR { TrimR :: new ((self . bits & 0x3f) as u8) } } impl W {
#[doc = "Bits 0:5 - Trimming code"]
#[inline (always)] pub fn trim (& mut self) -> TrimW < '_ , VrefbufCcrSpec > { TrimW :: new (self , 0) } }
#[doc = "calibration control register\n\nYou can [`read`](crate::Reg::read) this register and get [`vrefbuf_ccr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`vrefbuf_ccr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct VrefbufCcrSpec ; impl crate :: RegisterSpec for VrefbufCcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`vrefbuf_ccr::R`](R) reader structure"] impl crate :: Readable for VrefbufCcrSpec { }
#[doc = "`write(|w| ..)` method takes [`vrefbuf_ccr::W`](W) writer structure"] impl crate :: Writable for VrefbufCcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets VREFBUF_CCR to value 0"] impl crate :: Resettable for VrefbufCcrSpec { } }
#[doc = "SYSCFG_IMR1 (rw) register accessor: CPU1 interrupt mask register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`syscfg_imr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_imr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@syscfg_imr1`] module"]
#[doc (alias = "SYSCFG_IMR1")] pub type SyscfgImr1 = crate :: Reg < syscfg_imr1 :: SyscfgImr1Spec > ;
#[doc = "CPU1 interrupt mask register 1"] pub mod syscfg_imr1 {
#[doc = "Register `SYSCFG_IMR1` reader"] pub type R = crate :: R < SyscfgImr1Spec > ;
#[doc = "Register `SYSCFG_IMR1` writer"] pub type W = crate :: W < SyscfgImr1Spec > ;
#[doc = "Field `TIM1IM` reader - Peripheral TIM1 interrupt mask to CPU1"] pub type Tim1imR = crate :: BitReader ;
#[doc = "Field `TIM1IM` writer - Peripheral TIM1 interrupt mask to CPU1"] pub type Tim1imW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM16IM` reader - Peripheral TIM16 interrupt mask to CPU1"] pub type Tim16imR = crate :: BitReader ;
#[doc = "Field `TIM16IM` writer - Peripheral TIM16 interrupt mask to CPU1"] pub type Tim16imW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM17IM` reader - Peripheral TIM17 interrupt mask to CPU1"] pub type Tim17imR = crate :: BitReader ;
#[doc = "Field `TIM17IM` writer - Peripheral TIM17 interrupt mask to CPU1"] pub type Tim17imW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EXIT5IM` reader - Peripheral EXIT5 interrupt mask to CPU1"] pub type Exit5imR = crate :: BitReader ;
#[doc = "Field `EXIT5IM` writer - Peripheral EXIT5 interrupt mask to CPU1"] pub type Exit5imW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EXIT6IM` reader - Peripheral EXIT6 interrupt mask to CPU1"] pub type Exit6imR = crate :: BitReader ;
#[doc = "Field `EXIT6IM` writer - Peripheral EXIT6 interrupt mask to CPU1"] pub type Exit6imW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EXIT7IM` reader - Peripheral EXIT7 interrupt mask to CPU1"] pub type Exit7imR = crate :: BitReader ;
#[doc = "Field `EXIT7IM` writer - Peripheral EXIT7 interrupt mask to CPU1"] pub type Exit7imW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EXIT8IM` reader - Peripheral EXIT8 interrupt mask to CPU1"] pub type Exit8imR = crate :: BitReader ;
#[doc = "Field `EXIT8IM` writer - Peripheral EXIT8 interrupt mask to CPU1"] pub type Exit8imW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EXIT9IM` reader - Peripheral EXIT9 interrupt mask to CPU1"] pub type Exit9imR = crate :: BitReader ;
#[doc = "Field `EXIT9IM` writer - Peripheral EXIT9 interrupt mask to CPU1"] pub type Exit9imW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EXIT10IM` reader - Peripheral EXIT10 interrupt mask to CPU1"] pub type Exit10imR = crate :: BitReader ;
#[doc = "Field `EXIT10IM` writer - Peripheral EXIT10 interrupt mask to CPU1"] pub type Exit10imW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EXIT11IM` reader - Peripheral EXIT11 interrupt mask to CPU1"] pub type Exit11imR = crate :: BitReader ;
#[doc = "Field `EXIT11IM` writer - Peripheral EXIT11 interrupt mask to CPU1"] pub type Exit11imW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EXIT12IM` reader - Peripheral EXIT12 interrupt mask to CPU1"] pub type Exit12imR = crate :: BitReader ;
#[doc = "Field `EXIT12IM` writer - Peripheral EXIT12 interrupt mask to CPU1"] pub type Exit12imW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EXIT13IM` reader - Peripheral EXIT13 interrupt mask to CPU1"] pub type Exit13imR = crate :: BitReader ;
#[doc = "Field `EXIT13IM` writer - Peripheral EXIT13 interrupt mask to CPU1"] pub type Exit13imW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EXIT14IM` reader - Peripheral EXIT14 interrupt mask to CPU1"] pub type Exit14imR = crate :: BitReader ;
#[doc = "Field `EXIT14IM` writer - Peripheral EXIT14 interrupt mask to CPU1"] pub type Exit14imW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EXIT15IM` reader - Peripheral EXIT15 interrupt mask to CPU1"] pub type Exit15imR = crate :: BitReader ;
#[doc = "Field `EXIT15IM` writer - Peripheral EXIT15 interrupt mask to CPU1"] pub type Exit15imW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 13 - Peripheral TIM1 interrupt mask to CPU1"]
#[inline (always)] pub fn tim1im (& self) -> Tim1imR { Tim1imR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Peripheral TIM16 interrupt mask to CPU1"]
#[inline (always)] pub fn tim16im (& self) -> Tim16imR { Tim16imR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Peripheral TIM17 interrupt mask to CPU1"]
#[inline (always)] pub fn tim17im (& self) -> Tim17imR { Tim17imR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 21 - Peripheral EXIT5 interrupt mask to CPU1"]
#[inline (always)] pub fn exit5im (& self) -> Exit5imR { Exit5imR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Peripheral EXIT6 interrupt mask to CPU1"]
#[inline (always)] pub fn exit6im (& self) -> Exit6imR { Exit6imR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Peripheral EXIT7 interrupt mask to CPU1"]
#[inline (always)] pub fn exit7im (& self) -> Exit7imR { Exit7imR :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Peripheral EXIT8 interrupt mask to CPU1"]
#[inline (always)] pub fn exit8im (& self) -> Exit8imR { Exit8imR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Peripheral EXIT9 interrupt mask to CPU1"]
#[inline (always)] pub fn exit9im (& self) -> Exit9imR { Exit9imR :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Peripheral EXIT10 interrupt mask to CPU1"]
#[inline (always)] pub fn exit10im (& self) -> Exit10imR { Exit10imR :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Peripheral EXIT11 interrupt mask to CPU1"]
#[inline (always)] pub fn exit11im (& self) -> Exit11imR { Exit11imR :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Peripheral EXIT12 interrupt mask to CPU1"]
#[inline (always)] pub fn exit12im (& self) -> Exit12imR { Exit12imR :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Peripheral EXIT13 interrupt mask to CPU1"]
#[inline (always)] pub fn exit13im (& self) -> Exit13imR { Exit13imR :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Peripheral EXIT14 interrupt mask to CPU1"]
#[inline (always)] pub fn exit14im (& self) -> Exit14imR { Exit14imR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Peripheral EXIT15 interrupt mask to CPU1"]
#[inline (always)] pub fn exit15im (& self) -> Exit15imR { Exit15imR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 13 - Peripheral TIM1 interrupt mask to CPU1"]
#[inline (always)] pub fn tim1im (& mut self) -> Tim1imW < '_ , SyscfgImr1Spec > { Tim1imW :: new (self , 13) }
#[doc = "Bit 14 - Peripheral TIM16 interrupt mask to CPU1"]
#[inline (always)] pub fn tim16im (& mut self) -> Tim16imW < '_ , SyscfgImr1Spec > { Tim16imW :: new (self , 14) }
#[doc = "Bit 15 - Peripheral TIM17 interrupt mask to CPU1"]
#[inline (always)] pub fn tim17im (& mut self) -> Tim17imW < '_ , SyscfgImr1Spec > { Tim17imW :: new (self , 15) }
#[doc = "Bit 21 - Peripheral EXIT5 interrupt mask to CPU1"]
#[inline (always)] pub fn exit5im (& mut self) -> Exit5imW < '_ , SyscfgImr1Spec > { Exit5imW :: new (self , 21) }
#[doc = "Bit 22 - Peripheral EXIT6 interrupt mask to CPU1"]
#[inline (always)] pub fn exit6im (& mut self) -> Exit6imW < '_ , SyscfgImr1Spec > { Exit6imW :: new (self , 22) }
#[doc = "Bit 23 - Peripheral EXIT7 interrupt mask to CPU1"]
#[inline (always)] pub fn exit7im (& mut self) -> Exit7imW < '_ , SyscfgImr1Spec > { Exit7imW :: new (self , 23) }
#[doc = "Bit 24 - Peripheral EXIT8 interrupt mask to CPU1"]
#[inline (always)] pub fn exit8im (& mut self) -> Exit8imW < '_ , SyscfgImr1Spec > { Exit8imW :: new (self , 24) }
#[doc = "Bit 25 - Peripheral EXIT9 interrupt mask to CPU1"]
#[inline (always)] pub fn exit9im (& mut self) -> Exit9imW < '_ , SyscfgImr1Spec > { Exit9imW :: new (self , 25) }
#[doc = "Bit 26 - Peripheral EXIT10 interrupt mask to CPU1"]
#[inline (always)] pub fn exit10im (& mut self) -> Exit10imW < '_ , SyscfgImr1Spec > { Exit10imW :: new (self , 26) }
#[doc = "Bit 27 - Peripheral EXIT11 interrupt mask to CPU1"]
#[inline (always)] pub fn exit11im (& mut self) -> Exit11imW < '_ , SyscfgImr1Spec > { Exit11imW :: new (self , 27) }
#[doc = "Bit 28 - Peripheral EXIT12 interrupt mask to CPU1"]
#[inline (always)] pub fn exit12im (& mut self) -> Exit12imW < '_ , SyscfgImr1Spec > { Exit12imW :: new (self , 28) }
#[doc = "Bit 29 - Peripheral EXIT13 interrupt mask to CPU1"]
#[inline (always)] pub fn exit13im (& mut self) -> Exit13imW < '_ , SyscfgImr1Spec > { Exit13imW :: new (self , 29) }
#[doc = "Bit 30 - Peripheral EXIT14 interrupt mask to CPU1"]
#[inline (always)] pub fn exit14im (& mut self) -> Exit14imW < '_ , SyscfgImr1Spec > { Exit14imW :: new (self , 30) }
#[doc = "Bit 31 - Peripheral EXIT15 interrupt mask to CPU1"]
#[inline (always)] pub fn exit15im (& mut self) -> Exit15imW < '_ , SyscfgImr1Spec > { Exit15imW :: new (self , 31) } }
#[doc = "CPU1 interrupt mask register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`syscfg_imr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_imr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SyscfgImr1Spec ; impl crate :: RegisterSpec for SyscfgImr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`syscfg_imr1::R`](R) reader structure"] impl crate :: Readable for SyscfgImr1Spec { }
#[doc = "`write(|w| ..)` method takes [`syscfg_imr1::W`](W) writer structure"] impl crate :: Writable for SyscfgImr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SYSCFG_IMR1 to value 0"] impl crate :: Resettable for SyscfgImr1Spec { } }
#[doc = "SYSCFG_IMR2 (rw) register accessor: CPU1 interrupt mask register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`syscfg_imr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_imr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@syscfg_imr2`] module"]
#[doc (alias = "SYSCFG_IMR2")] pub type SyscfgImr2 = crate :: Reg < syscfg_imr2 :: SyscfgImr2Spec > ;
#[doc = "CPU1 interrupt mask register 2"] pub mod syscfg_imr2 {
#[doc = "Register `SYSCFG_IMR2` reader"] pub type R = crate :: R < SyscfgImr2Spec > ;
#[doc = "Register `SYSCFG_IMR2` writer"] pub type W = crate :: W < SyscfgImr2Spec > ;
#[doc = "Field `PVM1IM` reader - Peripheral PVM1 interrupt mask to CPU1"] pub type Pvm1imR = crate :: BitReader ;
#[doc = "Field `PVM1IM` writer - Peripheral PVM1 interrupt mask to CPU1"] pub type Pvm1imW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PVM3IM` reader - Peripheral PVM3 interrupt mask to CPU1"] pub type Pvm3imR = crate :: BitReader ;
#[doc = "Field `PVM3IM` writer - Peripheral PVM3 interrupt mask to CPU1"] pub type Pvm3imW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PVDIM` reader - Peripheral PVD interrupt mask to CPU1"] pub type PvdimR = crate :: BitReader ;
#[doc = "Field `PVDIM` writer - Peripheral PVD interrupt mask to CPU1"] pub type PvdimW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 16 - Peripheral PVM1 interrupt mask to CPU1"]
#[inline (always)] pub fn pvm1im (& self) -> Pvm1imR { Pvm1imR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 18 - Peripheral PVM3 interrupt mask to CPU1"]
#[inline (always)] pub fn pvm3im (& self) -> Pvm3imR { Pvm3imR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 20 - Peripheral PVD interrupt mask to CPU1"]
#[inline (always)] pub fn pvdim (& self) -> PvdimR { PvdimR :: new (((self . bits >> 20) & 1) != 0) } } impl W {
#[doc = "Bit 16 - Peripheral PVM1 interrupt mask to CPU1"]
#[inline (always)] pub fn pvm1im (& mut self) -> Pvm1imW < '_ , SyscfgImr2Spec > { Pvm1imW :: new (self , 16) }
#[doc = "Bit 18 - Peripheral PVM3 interrupt mask to CPU1"]
#[inline (always)] pub fn pvm3im (& mut self) -> Pvm3imW < '_ , SyscfgImr2Spec > { Pvm3imW :: new (self , 18) }
#[doc = "Bit 20 - Peripheral PVD interrupt mask to CPU1"]
#[inline (always)] pub fn pvdim (& mut self) -> PvdimW < '_ , SyscfgImr2Spec > { PvdimW :: new (self , 20) } }
#[doc = "CPU1 interrupt mask register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`syscfg_imr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_imr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SyscfgImr2Spec ; impl crate :: RegisterSpec for SyscfgImr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`syscfg_imr2::R`](R) reader structure"] impl crate :: Readable for SyscfgImr2Spec { }
#[doc = "`write(|w| ..)` method takes [`syscfg_imr2::W`](W) writer structure"] impl crate :: Writable for SyscfgImr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SYSCFG_IMR2 to value 0"] impl crate :: Resettable for SyscfgImr2Spec { } }
#[doc = "SYSCFG_C2IMR1 (rw) register accessor: CPU2 interrupt mask register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`syscfg_c2imr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_c2imr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@syscfg_c2imr1`] module"]
#[doc (alias = "SYSCFG_C2IMR1")] pub type SyscfgC2imr1 = crate :: Reg < syscfg_c2imr1 :: SyscfgC2imr1Spec > ;
#[doc = "CPU2 interrupt mask register 1"] pub mod syscfg_c2imr1 {
#[doc = "Register `SYSCFG_C2IMR1` reader"] pub type R = crate :: R < SyscfgC2imr1Spec > ;
#[doc = "Register `SYSCFG_C2IMR1` writer"] pub type W = crate :: W < SyscfgC2imr1Spec > ;
#[doc = "Field `RTCSTAMP` reader - Peripheral RTCSTAMP interrupt mask to CPU2"] pub type RtcstampR = crate :: BitReader ;
#[doc = "Field `RTCSTAMP` writer - Peripheral RTCSTAMP interrupt mask to CPU2"] pub type RtcstampW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RTCWKUP` reader - Peripheral RTCWKUP interrupt mask to CPU2"] pub type RtcwkupR = crate :: BitReader ;
#[doc = "Field `RTCWKUP` writer - Peripheral RTCWKUP interrupt mask to CPU2"] pub type RtcwkupW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RTCALARM` reader - Peripheral RTCALARM interrupt mask to CPU2"] pub type RtcalarmR = crate :: BitReader ;
#[doc = "Field `RTCALARM` writer - Peripheral RTCALARM interrupt mask to CPU2"] pub type RtcalarmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RCC` reader - Peripheral RCC interrupt mask to CPU2"] pub type RccR = crate :: BitReader ;
#[doc = "Field `RCC` writer - Peripheral RCC interrupt mask to CPU2"] pub type RccW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FLASH` reader - Peripheral FLASH interrupt mask to CPU2"] pub type FlashR = crate :: BitReader ;
#[doc = "Field `FLASH` writer - Peripheral FLASH interrupt mask to CPU2"] pub type FlashW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PKA` reader - Peripheral PKA interrupt mask to CPU2"] pub type PkaR = crate :: BitReader ;
#[doc = "Field `PKA` writer - Peripheral PKA interrupt mask to CPU2"] pub type PkaW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RNG` reader - Peripheral RNG interrupt mask to CPU2"] pub type RngR = crate :: BitReader ;
#[doc = "Field `RNG` writer - Peripheral RNG interrupt mask to CPU2"] pub type RngW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AES1` reader - Peripheral AES1 interrupt mask to CPU2"] pub type Aes1R = crate :: BitReader ;
#[doc = "Field `AES1` writer - Peripheral AES1 interrupt mask to CPU2"] pub type Aes1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMP` reader - Peripheral COMP interrupt mask to CPU2"] pub type CompR = crate :: BitReader ;
#[doc = "Field `COMP` writer - Peripheral COMP interrupt mask to CPU2"] pub type CompW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADC` reader - Peripheral ADC interrupt mask to CPU2"] pub type AdcR = crate :: BitReader ;
#[doc = "Field `ADC` writer - Peripheral ADC interrupt mask to CPU2"] pub type AdcW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Peripheral RTCSTAMP interrupt mask to CPU2"]
#[inline (always)] pub fn rtcstamp (& self) -> RtcstampR { RtcstampR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 3 - Peripheral RTCWKUP interrupt mask to CPU2"]
#[inline (always)] pub fn rtcwkup (& self) -> RtcwkupR { RtcwkupR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Peripheral RTCALARM interrupt mask to CPU2"]
#[inline (always)] pub fn rtcalarm (& self) -> RtcalarmR { RtcalarmR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Peripheral RCC interrupt mask to CPU2"]
#[inline (always)] pub fn rcc (& self) -> RccR { RccR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral FLASH interrupt mask to CPU2"]
#[inline (always)] pub fn flash (& self) -> FlashR { FlashR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 8 - Peripheral PKA interrupt mask to CPU2"]
#[inline (always)] pub fn pka (& self) -> PkaR { PkaR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Peripheral RNG interrupt mask to CPU2"]
#[inline (always)] pub fn rng (& self) -> RngR { RngR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Peripheral AES1 interrupt mask to CPU2"]
#[inline (always)] pub fn aes1 (& self) -> Aes1R { Aes1R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Peripheral COMP interrupt mask to CPU2"]
#[inline (always)] pub fn comp (& self) -> CompR { CompR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Peripheral ADC interrupt mask to CPU2"]
#[inline (always)] pub fn adc (& self) -> AdcR { AdcR :: new (((self . bits >> 12) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Peripheral RTCSTAMP interrupt mask to CPU2"]
#[inline (always)] pub fn rtcstamp (& mut self) -> RtcstampW < '_ , SyscfgC2imr1Spec > { RtcstampW :: new (self , 0) }
#[doc = "Bit 3 - Peripheral RTCWKUP interrupt mask to CPU2"]
#[inline (always)] pub fn rtcwkup (& mut self) -> RtcwkupW < '_ , SyscfgC2imr1Spec > { RtcwkupW :: new (self , 3) }
#[doc = "Bit 4 - Peripheral RTCALARM interrupt mask to CPU2"]
#[inline (always)] pub fn rtcalarm (& mut self) -> RtcalarmW < '_ , SyscfgC2imr1Spec > { RtcalarmW :: new (self , 4) }
#[doc = "Bit 5 - Peripheral RCC interrupt mask to CPU2"]
#[inline (always)] pub fn rcc (& mut self) -> RccW < '_ , SyscfgC2imr1Spec > { RccW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral FLASH interrupt mask to CPU2"]
#[inline (always)] pub fn flash (& mut self) -> FlashW < '_ , SyscfgC2imr1Spec > { FlashW :: new (self , 6) }
#[doc = "Bit 8 - Peripheral PKA interrupt mask to CPU2"]
#[inline (always)] pub fn pka (& mut self) -> PkaW < '_ , SyscfgC2imr1Spec > { PkaW :: new (self , 8) }
#[doc = "Bit 9 - Peripheral RNG interrupt mask to CPU2"]
#[inline (always)] pub fn rng (& mut self) -> RngW < '_ , SyscfgC2imr1Spec > { RngW :: new (self , 9) }
#[doc = "Bit 10 - Peripheral AES1 interrupt mask to CPU2"]
#[inline (always)] pub fn aes1 (& mut self) -> Aes1W < '_ , SyscfgC2imr1Spec > { Aes1W :: new (self , 10) }
#[doc = "Bit 11 - Peripheral COMP interrupt mask to CPU2"]
#[inline (always)] pub fn comp (& mut self) -> CompW < '_ , SyscfgC2imr1Spec > { CompW :: new (self , 11) }
#[doc = "Bit 12 - Peripheral ADC interrupt mask to CPU2"]
#[inline (always)] pub fn adc (& mut self) -> AdcW < '_ , SyscfgC2imr1Spec > { AdcW :: new (self , 12) } }
#[doc = "CPU2 interrupt mask register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`syscfg_c2imr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_c2imr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SyscfgC2imr1Spec ; impl crate :: RegisterSpec for SyscfgC2imr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`syscfg_c2imr1::R`](R) reader structure"] impl crate :: Readable for SyscfgC2imr1Spec { }
#[doc = "`write(|w| ..)` method takes [`syscfg_c2imr1::W`](W) writer structure"] impl crate :: Writable for SyscfgC2imr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SYSCFG_C2IMR1 to value 0"] impl crate :: Resettable for SyscfgC2imr1Spec { } }
#[doc = "SYSCFG_C2IMR2 (rw) register accessor: CPU2 interrupt mask register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`syscfg_c2imr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_c2imr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@syscfg_c2imr2`] module"]
#[doc (alias = "SYSCFG_C2IMR2")] pub type SyscfgC2imr2 = crate :: Reg < syscfg_c2imr2 :: SyscfgC2imr2Spec > ;
#[doc = "CPU2 interrupt mask register 1"] pub mod syscfg_c2imr2 {
#[doc = "Register `SYSCFG_C2IMR2` reader"] pub type R = crate :: R < SyscfgC2imr2Spec > ;
#[doc = "Register `SYSCFG_C2IMR2` writer"] pub type W = crate :: W < SyscfgC2imr2Spec > ;
#[doc = "Field `DMA1_CH1_IM` reader - Peripheral DMA1 CH1 interrupt mask to CPU2"] pub type Dma1Ch1ImR = crate :: BitReader ;
#[doc = "Field `DMA1_CH1_IM` writer - Peripheral DMA1 CH1 interrupt mask to CPU2"] pub type Dma1Ch1ImW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMA1_CH2_IM` reader - Peripheral DMA1 CH2 interrupt mask to CPU2"] pub type Dma1Ch2ImR = crate :: BitReader ;
#[doc = "Field `DMA1_CH2_IM` writer - Peripheral DMA1 CH2 interrupt mask to CPU2"] pub type Dma1Ch2ImW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMA1_CH3_IM` reader - Peripheral DMA1 CH3 interrupt mask to CPU2"] pub type Dma1Ch3ImR = crate :: BitReader ;
#[doc = "Field `DMA1_CH3_IM` writer - Peripheral DMA1 CH3 interrupt mask to CPU2"] pub type Dma1Ch3ImW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMA1_CH4_IM` reader - Peripheral DMA1 CH4 interrupt mask to CPU2"] pub type Dma1Ch4ImR = crate :: BitReader ;
#[doc = "Field `DMA1_CH4_IM` writer - Peripheral DMA1 CH4 interrupt mask to CPU2"] pub type Dma1Ch4ImW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMA1_CH5_IM` reader - Peripheral DMA1 CH5 interrupt mask to CPU2"] pub type Dma1Ch5ImR = crate :: BitReader ;
#[doc = "Field `DMA1_CH5_IM` writer - Peripheral DMA1 CH5 interrupt mask to CPU2"] pub type Dma1Ch5ImW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMA1_CH6_IM` reader - Peripheral DMA1 CH6 interrupt mask to CPU2"] pub type Dma1Ch6ImR = crate :: BitReader ;
#[doc = "Field `DMA1_CH6_IM` writer - Peripheral DMA1 CH6 interrupt mask to CPU2"] pub type Dma1Ch6ImW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMA1_CH7_IM` reader - Peripheral DMA1 CH7 interrupt mask to CPU2"] pub type Dma1Ch7ImR = crate :: BitReader ;
#[doc = "Field `DMA1_CH7_IM` writer - Peripheral DMA1 CH7 interrupt mask to CPU2"] pub type Dma1Ch7ImW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMA2_CH1_IM` reader - Peripheral DMA2 CH1 interrupt mask to CPU1"] pub type Dma2Ch1ImR = crate :: BitReader ;
#[doc = "Field `DMA2_CH1_IM` writer - Peripheral DMA2 CH1 interrupt mask to CPU1"] pub type Dma2Ch1ImW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMA2_CH2_IM` reader - Peripheral DMA2 CH2 interrupt mask to CPU1"] pub type Dma2Ch2ImR = crate :: BitReader ;
#[doc = "Field `DMA2_CH2_IM` writer - Peripheral DMA2 CH2 interrupt mask to CPU1"] pub type Dma2Ch2ImW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMA2_CH3_IM` reader - Peripheral DMA2 CH3 interrupt mask to CPU1"] pub type Dma2Ch3ImR = crate :: BitReader ;
#[doc = "Field `DMA2_CH3_IM` writer - Peripheral DMA2 CH3 interrupt mask to CPU1"] pub type Dma2Ch3ImW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMA2_CH4_IM` reader - Peripheral DMA2 CH4 interrupt mask to CPU1"] pub type Dma2Ch4ImR = crate :: BitReader ;
#[doc = "Field `DMA2_CH4_IM` writer - Peripheral DMA2 CH4 interrupt mask to CPU1"] pub type Dma2Ch4ImW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMA2_CH5_IM` reader - Peripheral DMA2 CH5 interrupt mask to CPU1"] pub type Dma2Ch5ImR = crate :: BitReader ;
#[doc = "Field `DMA2_CH5_IM` writer - Peripheral DMA2 CH5 interrupt mask to CPU1"] pub type Dma2Ch5ImW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMA2_CH6_IM` reader - Peripheral DMA2 CH6 interrupt mask to CPU1"] pub type Dma2Ch6ImR = crate :: BitReader ;
#[doc = "Field `DMA2_CH6_IM` writer - Peripheral DMA2 CH6 interrupt mask to CPU1"] pub type Dma2Ch6ImW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMA2_CH7_IM` reader - Peripheral DMA2 CH7 interrupt mask to CPU1"] pub type Dma2Ch7ImR = crate :: BitReader ;
#[doc = "Field `DMA2_CH7_IM` writer - Peripheral DMA2 CH7 interrupt mask to CPU1"] pub type Dma2Ch7ImW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMAM_UX1_IM` reader - Peripheral DMAM UX1 interrupt mask to CPU1"] pub type DmamUx1ImR = crate :: BitReader ;
#[doc = "Field `DMAM_UX1_IM` writer - Peripheral DMAM UX1 interrupt mask to CPU1"] pub type DmamUx1ImW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PVM1IM` reader - Peripheral PVM1IM interrupt mask to CPU1"] pub type Pvm1imR = crate :: BitReader ;
#[doc = "Field `PVM1IM` writer - Peripheral PVM1IM interrupt mask to CPU1"] pub type Pvm1imW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PVM3IM` reader - Peripheral PVM3IM interrupt mask to CPU1"] pub type Pvm3imR = crate :: BitReader ;
#[doc = "Field `PVM3IM` writer - Peripheral PVM3IM interrupt mask to CPU1"] pub type Pvm3imW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PVDIM` reader - Peripheral PVDIM interrupt mask to CPU1"] pub type PvdimR = crate :: BitReader ;
#[doc = "Field `PVDIM` writer - Peripheral PVDIM interrupt mask to CPU1"] pub type PvdimW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TSCIM` reader - Peripheral TSCIM interrupt mask to CPU1"] pub type TscimR = crate :: BitReader ;
#[doc = "Field `TSCIM` writer - Peripheral TSCIM interrupt mask to CPU1"] pub type TscimW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCDIM` reader - Peripheral LCDIM interrupt mask to CPU1"] pub type LcdimR = crate :: BitReader ;
#[doc = "Field `LCDIM` writer - Peripheral LCDIM interrupt mask to CPU1"] pub type LcdimW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Peripheral DMA1 CH1 interrupt mask to CPU2"]
#[inline (always)] pub fn dma1_ch1_im (& self) -> Dma1Ch1ImR { Dma1Ch1ImR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Peripheral DMA1 CH2 interrupt mask to CPU2"]
#[inline (always)] pub fn dma1_ch2_im (& self) -> Dma1Ch2ImR { Dma1Ch2ImR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Peripheral DMA1 CH3 interrupt mask to CPU2"]
#[inline (always)] pub fn dma1_ch3_im (& self) -> Dma1Ch3ImR { Dma1Ch3ImR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Peripheral DMA1 CH4 interrupt mask to CPU2"]
#[inline (always)] pub fn dma1_ch4_im (& self) -> Dma1Ch4ImR { Dma1Ch4ImR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Peripheral DMA1 CH5 interrupt mask to CPU2"]
#[inline (always)] pub fn dma1_ch5_im (& self) -> Dma1Ch5ImR { Dma1Ch5ImR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Peripheral DMA1 CH6 interrupt mask to CPU2"]
#[inline (always)] pub fn dma1_ch6_im (& self) -> Dma1Ch6ImR { Dma1Ch6ImR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral DMA1 CH7 interrupt mask to CPU2"]
#[inline (always)] pub fn dma1_ch7_im (& self) -> Dma1Ch7ImR { Dma1Ch7ImR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 8 - Peripheral DMA2 CH1 interrupt mask to CPU1"]
#[inline (always)] pub fn dma2_ch1_im (& self) -> Dma2Ch1ImR { Dma2Ch1ImR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Peripheral DMA2 CH2 interrupt mask to CPU1"]
#[inline (always)] pub fn dma2_ch2_im (& self) -> Dma2Ch2ImR { Dma2Ch2ImR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Peripheral DMA2 CH3 interrupt mask to CPU1"]
#[inline (always)] pub fn dma2_ch3_im (& self) -> Dma2Ch3ImR { Dma2Ch3ImR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Peripheral DMA2 CH4 interrupt mask to CPU1"]
#[inline (always)] pub fn dma2_ch4_im (& self) -> Dma2Ch4ImR { Dma2Ch4ImR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Peripheral DMA2 CH5 interrupt mask to CPU1"]
#[inline (always)] pub fn dma2_ch5_im (& self) -> Dma2Ch5ImR { Dma2Ch5ImR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Peripheral DMA2 CH6 interrupt mask to CPU1"]
#[inline (always)] pub fn dma2_ch6_im (& self) -> Dma2Ch6ImR { Dma2Ch6ImR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Peripheral DMA2 CH7 interrupt mask to CPU1"]
#[inline (always)] pub fn dma2_ch7_im (& self) -> Dma2Ch7ImR { Dma2Ch7ImR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Peripheral DMAM UX1 interrupt mask to CPU1"]
#[inline (always)] pub fn dmam_ux1_im (& self) -> DmamUx1ImR { DmamUx1ImR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Peripheral PVM1IM interrupt mask to CPU1"]
#[inline (always)] pub fn pvm1im (& self) -> Pvm1imR { Pvm1imR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 18 - Peripheral PVM3IM interrupt mask to CPU1"]
#[inline (always)] pub fn pvm3im (& self) -> Pvm3imR { Pvm3imR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 20 - Peripheral PVDIM interrupt mask to CPU1"]
#[inline (always)] pub fn pvdim (& self) -> PvdimR { PvdimR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Peripheral TSCIM interrupt mask to CPU1"]
#[inline (always)] pub fn tscim (& self) -> TscimR { TscimR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Peripheral LCDIM interrupt mask to CPU1"]
#[inline (always)] pub fn lcdim (& self) -> LcdimR { LcdimR :: new (((self . bits >> 22) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Peripheral DMA1 CH1 interrupt mask to CPU2"]
#[inline (always)] pub fn dma1_ch1_im (& mut self) -> Dma1Ch1ImW < '_ , SyscfgC2imr2Spec > { Dma1Ch1ImW :: new (self , 0) }
#[doc = "Bit 1 - Peripheral DMA1 CH2 interrupt mask to CPU2"]
#[inline (always)] pub fn dma1_ch2_im (& mut self) -> Dma1Ch2ImW < '_ , SyscfgC2imr2Spec > { Dma1Ch2ImW :: new (self , 1) }
#[doc = "Bit 2 - Peripheral DMA1 CH3 interrupt mask to CPU2"]
#[inline (always)] pub fn dma1_ch3_im (& mut self) -> Dma1Ch3ImW < '_ , SyscfgC2imr2Spec > { Dma1Ch3ImW :: new (self , 2) }
#[doc = "Bit 3 - Peripheral DMA1 CH4 interrupt mask to CPU2"]
#[inline (always)] pub fn dma1_ch4_im (& mut self) -> Dma1Ch4ImW < '_ , SyscfgC2imr2Spec > { Dma1Ch4ImW :: new (self , 3) }
#[doc = "Bit 4 - Peripheral DMA1 CH5 interrupt mask to CPU2"]
#[inline (always)] pub fn dma1_ch5_im (& mut self) -> Dma1Ch5ImW < '_ , SyscfgC2imr2Spec > { Dma1Ch5ImW :: new (self , 4) }
#[doc = "Bit 5 - Peripheral DMA1 CH6 interrupt mask to CPU2"]
#[inline (always)] pub fn dma1_ch6_im (& mut self) -> Dma1Ch6ImW < '_ , SyscfgC2imr2Spec > { Dma1Ch6ImW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral DMA1 CH7 interrupt mask to CPU2"]
#[inline (always)] pub fn dma1_ch7_im (& mut self) -> Dma1Ch7ImW < '_ , SyscfgC2imr2Spec > { Dma1Ch7ImW :: new (self , 6) }
#[doc = "Bit 8 - Peripheral DMA2 CH1 interrupt mask to CPU1"]
#[inline (always)] pub fn dma2_ch1_im (& mut self) -> Dma2Ch1ImW < '_ , SyscfgC2imr2Spec > { Dma2Ch1ImW :: new (self , 8) }
#[doc = "Bit 9 - Peripheral DMA2 CH2 interrupt mask to CPU1"]
#[inline (always)] pub fn dma2_ch2_im (& mut self) -> Dma2Ch2ImW < '_ , SyscfgC2imr2Spec > { Dma2Ch2ImW :: new (self , 9) }
#[doc = "Bit 10 - Peripheral DMA2 CH3 interrupt mask to CPU1"]
#[inline (always)] pub fn dma2_ch3_im (& mut self) -> Dma2Ch3ImW < '_ , SyscfgC2imr2Spec > { Dma2Ch3ImW :: new (self , 10) }
#[doc = "Bit 11 - Peripheral DMA2 CH4 interrupt mask to CPU1"]
#[inline (always)] pub fn dma2_ch4_im (& mut self) -> Dma2Ch4ImW < '_ , SyscfgC2imr2Spec > { Dma2Ch4ImW :: new (self , 11) }
#[doc = "Bit 12 - Peripheral DMA2 CH5 interrupt mask to CPU1"]
#[inline (always)] pub fn dma2_ch5_im (& mut self) -> Dma2Ch5ImW < '_ , SyscfgC2imr2Spec > { Dma2Ch5ImW :: new (self , 12) }
#[doc = "Bit 13 - Peripheral DMA2 CH6 interrupt mask to CPU1"]
#[inline (always)] pub fn dma2_ch6_im (& mut self) -> Dma2Ch6ImW < '_ , SyscfgC2imr2Spec > { Dma2Ch6ImW :: new (self , 13) }
#[doc = "Bit 14 - Peripheral DMA2 CH7 interrupt mask to CPU1"]
#[inline (always)] pub fn dma2_ch7_im (& mut self) -> Dma2Ch7ImW < '_ , SyscfgC2imr2Spec > { Dma2Ch7ImW :: new (self , 14) }
#[doc = "Bit 15 - Peripheral DMAM UX1 interrupt mask to CPU1"]
#[inline (always)] pub fn dmam_ux1_im (& mut self) -> DmamUx1ImW < '_ , SyscfgC2imr2Spec > { DmamUx1ImW :: new (self , 15) }
#[doc = "Bit 16 - Peripheral PVM1IM interrupt mask to CPU1"]
#[inline (always)] pub fn pvm1im (& mut self) -> Pvm1imW < '_ , SyscfgC2imr2Spec > { Pvm1imW :: new (self , 16) }
#[doc = "Bit 18 - Peripheral PVM3IM interrupt mask to CPU1"]
#[inline (always)] pub fn pvm3im (& mut self) -> Pvm3imW < '_ , SyscfgC2imr2Spec > { Pvm3imW :: new (self , 18) }
#[doc = "Bit 20 - Peripheral PVDIM interrupt mask to CPU1"]
#[inline (always)] pub fn pvdim (& mut self) -> PvdimW < '_ , SyscfgC2imr2Spec > { PvdimW :: new (self , 20) }
#[doc = "Bit 21 - Peripheral TSCIM interrupt mask to CPU1"]
#[inline (always)] pub fn tscim (& mut self) -> TscimW < '_ , SyscfgC2imr2Spec > { TscimW :: new (self , 21) }
#[doc = "Bit 22 - Peripheral LCDIM interrupt mask to CPU1"]
#[inline (always)] pub fn lcdim (& mut self) -> LcdimW < '_ , SyscfgC2imr2Spec > { LcdimW :: new (self , 22) } }
#[doc = "CPU2 interrupt mask register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`syscfg_c2imr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_c2imr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SyscfgC2imr2Spec ; impl crate :: RegisterSpec for SyscfgC2imr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`syscfg_c2imr2::R`](R) reader structure"] impl crate :: Readable for SyscfgC2imr2Spec { }
#[doc = "`write(|w| ..)` method takes [`syscfg_c2imr2::W`](W) writer structure"] impl crate :: Writable for SyscfgC2imr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SYSCFG_C2IMR2 to value 0"] impl crate :: Resettable for SyscfgC2imr2Spec { } }
#[doc = "SYSCFG_SIPCR (rw) register accessor: secure IP control register\n\nYou can [`read`](crate::Reg::read) this register and get [`syscfg_sipcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_sipcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@syscfg_sipcr`] module"]
#[doc (alias = "SYSCFG_SIPCR")] pub type SyscfgSipcr = crate :: Reg < syscfg_sipcr :: SyscfgSipcrSpec > ;
#[doc = "secure IP control register"] pub mod syscfg_sipcr {
#[doc = "Register `SYSCFG_SIPCR` reader"] pub type R = crate :: R < SyscfgSipcrSpec > ;
#[doc = "Register `SYSCFG_SIPCR` writer"] pub type W = crate :: W < SyscfgSipcrSpec > ;
#[doc = "Field `SAES1` reader - Enable AES1 KEY\\[7:0\\] security."] pub type Saes1R = crate :: BitReader ;
#[doc = "Field `SAES1` writer - Enable AES1 KEY\\[7:0\\] security."] pub type Saes1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SAES2` reader - Enable AES2 security."] pub type Saes2R = crate :: BitReader ;
#[doc = "Field `SAES2` writer - Enable AES2 security."] pub type Saes2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPKA` reader - Enable PKA security"] pub type SpkaR = crate :: BitReader ;
#[doc = "Field `SPKA` writer - Enable PKA security"] pub type SpkaW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SRNG` reader - Enable True RNG security"] pub type SrngR = crate :: BitReader ;
#[doc = "Field `SRNG` writer - Enable True RNG security"] pub type SrngW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Enable AES1 KEY\\[7:0\\] security."]
#[inline (always)] pub fn saes1 (& self) -> Saes1R { Saes1R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Enable AES2 security."]
#[inline (always)] pub fn saes2 (& self) -> Saes2R { Saes2R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Enable PKA security"]
#[inline (always)] pub fn spka (& self) -> SpkaR { SpkaR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Enable True RNG security"]
#[inline (always)] pub fn srng (& self) -> SrngR { SrngR :: new (((self . bits >> 3) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Enable AES1 KEY\\[7:0\\] security."]
#[inline (always)] pub fn saes1 (& mut self) -> Saes1W < '_ , SyscfgSipcrSpec > { Saes1W :: new (self , 0) }
#[doc = "Bit 1 - Enable AES2 security."]
#[inline (always)] pub fn saes2 (& mut self) -> Saes2W < '_ , SyscfgSipcrSpec > { Saes2W :: new (self , 1) }
#[doc = "Bit 2 - Enable PKA security"]
#[inline (always)] pub fn spka (& mut self) -> SpkaW < '_ , SyscfgSipcrSpec > { SpkaW :: new (self , 2) }
#[doc = "Bit 3 - Enable True RNG security"]
#[inline (always)] pub fn srng (& mut self) -> SrngW < '_ , SyscfgSipcrSpec > { SrngW :: new (self , 3) } }
#[doc = "secure IP control register\n\nYou can [`read`](crate::Reg::read) this register and get [`syscfg_sipcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syscfg_sipcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SyscfgSipcrSpec ; impl crate :: RegisterSpec for SyscfgSipcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`syscfg_sipcr::R`](R) reader structure"] impl crate :: Readable for SyscfgSipcrSpec { }
#[doc = "`write(|w| ..)` method takes [`syscfg_sipcr::W`](W) writer structure"] impl crate :: Writable for SyscfgSipcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SYSCFG_SIPCR to value 0"] impl crate :: Resettable for SyscfgSipcrSpec { } } }
#[doc = "Comparator instance 1"] pub type Comp = crate :: Periph < comp :: RegisterBlock , 0x4001_0200 > ; impl core :: fmt :: Debug for Comp { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Comp") . finish () } }
#[doc = "Comparator instance 1"] pub mod comp {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { comp1_csr : Comp1Csr , comp2_csr : Comp2Csr , } impl RegisterBlock {
#[doc = "0x00 - Comparator control and status register"]
#[inline (always)] pub const fn comp1_csr (& self) -> & Comp1Csr { & self . comp1_csr }
#[doc = "0x04 - Comparator 2 control and status register"]
#[inline (always)] pub const fn comp2_csr (& self) -> & Comp2Csr { & self . comp2_csr } }
#[doc = "COMP1_CSR (rw) register accessor: Comparator control and status register\n\nYou can [`read`](crate::Reg::read) this register and get [`comp1_csr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`comp1_csr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@comp1_csr`] module"]
#[doc (alias = "COMP1_CSR")] pub type Comp1Csr = crate :: Reg < comp1_csr :: Comp1CsrSpec > ;
#[doc = "Comparator control and status register"] pub mod comp1_csr {
#[doc = "Register `COMP1_CSR` reader"] pub type R = crate :: R < Comp1CsrSpec > ;
#[doc = "Register `COMP1_CSR` writer"] pub type W = crate :: W < Comp1CsrSpec > ;
#[doc = "Field `COMP1_EN` reader - Comparator enable"] pub type Comp1EnR = crate :: BitReader ;
#[doc = "Field `COMP1_EN` writer - Comparator enable"] pub type Comp1EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMP1_PWRMODE` reader - Comparator power mode"] pub type Comp1PwrmodeR = crate :: FieldReader ;
#[doc = "Field `COMP1_PWRMODE` writer - Comparator power mode"] pub type Comp1PwrmodeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `COMP1_INMSEL` reader - Comparator input minus selection"] pub type Comp1InmselR = crate :: FieldReader ;
#[doc = "Field `COMP1_INMSEL` writer - Comparator input minus selection"] pub type Comp1InmselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `COMP1_INPSEL` reader - Comparator input plus selection"] pub type Comp1InpselR = crate :: FieldReader ;
#[doc = "Field `COMP1_INPSEL` writer - Comparator input plus selection"] pub type Comp1InpselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `COMP1_POLARITY` reader - Comparator output polarity"] pub type Comp1PolarityR = crate :: BitReader ;
#[doc = "Field `COMP1_POLARITY` writer - Comparator output polarity"] pub type Comp1PolarityW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMP1_HYST` reader - Comparator hysteresis"] pub type Comp1HystR = crate :: FieldReader ;
#[doc = "Field `COMP1_HYST` writer - Comparator hysteresis"] pub type Comp1HystW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `COMP1_BLANKING` reader - Comparator blanking source"] pub type Comp1BlankingR = crate :: FieldReader ;
#[doc = "Field `COMP1_BLANKING` writer - Comparator blanking source"] pub type Comp1BlankingW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `COMP1_BRGEN` reader - Comparator voltage scaler enable"] pub type Comp1BrgenR = crate :: BitReader ;
#[doc = "Field `COMP1_BRGEN` writer - Comparator voltage scaler enable"] pub type Comp1BrgenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMP1_SCALEN` reader - Comparator scaler bridge enable"] pub type Comp1ScalenR = crate :: BitReader ;
#[doc = "Field `COMP1_SCALEN` writer - Comparator scaler bridge enable"] pub type Comp1ScalenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMP1_INMESEL` reader - Comparator input minus extended selection"] pub type Comp1InmeselR = crate :: FieldReader ;
#[doc = "Field `COMP1_INMESEL` writer - Comparator input minus extended selection"] pub type Comp1InmeselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `COMP1_VALUE` reader - Comparator output level"] pub type Comp1ValueR = crate :: BitReader ;
#[doc = "Field `COMP1_LOCK` reader - Comparator lock"] pub type Comp1LockR = crate :: BitReader ;
#[doc = "Field `COMP1_LOCK` writer - Comparator lock"] pub type Comp1LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Comparator enable"]
#[inline (always)] pub fn comp1_en (& self) -> Comp1EnR { Comp1EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bits 2:3 - Comparator power mode"]
#[inline (always)] pub fn comp1_pwrmode (& self) -> Comp1PwrmodeR { Comp1PwrmodeR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:6 - Comparator input minus selection"]
#[inline (always)] pub fn comp1_inmsel (& self) -> Comp1InmselR { Comp1InmselR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bits 7:8 - Comparator input plus selection"]
#[inline (always)] pub fn comp1_inpsel (& self) -> Comp1InpselR { Comp1InpselR :: new (((self . bits >> 7) & 3) as u8) }
#[doc = "Bit 15 - Comparator output polarity"]
#[inline (always)] pub fn comp1_polarity (& self) -> Comp1PolarityR { Comp1PolarityR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bits 16:17 - Comparator hysteresis"]
#[inline (always)] pub fn comp1_hyst (& self) -> Comp1HystR { Comp1HystR :: new (((self . bits >> 16) & 3) as u8) }
#[doc = "Bits 18:20 - Comparator blanking source"]
#[inline (always)] pub fn comp1_blanking (& self) -> Comp1BlankingR { Comp1BlankingR :: new (((self . bits >> 18) & 7) as u8) }
#[doc = "Bit 22 - Comparator voltage scaler enable"]
#[inline (always)] pub fn comp1_brgen (& self) -> Comp1BrgenR { Comp1BrgenR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Comparator scaler bridge enable"]
#[inline (always)] pub fn comp1_scalen (& self) -> Comp1ScalenR { Comp1ScalenR :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bits 25:26 - Comparator input minus extended selection"]
#[inline (always)] pub fn comp1_inmesel (& self) -> Comp1InmeselR { Comp1InmeselR :: new (((self . bits >> 25) & 3) as u8) }
#[doc = "Bit 30 - Comparator output level"]
#[inline (always)] pub fn comp1_value (& self) -> Comp1ValueR { Comp1ValueR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Comparator lock"]
#[inline (always)] pub fn comp1_lock (& self) -> Comp1LockR { Comp1LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Comparator enable"]
#[inline (always)] pub fn comp1_en (& mut self) -> Comp1EnW < '_ , Comp1CsrSpec > { Comp1EnW :: new (self , 0) }
#[doc = "Bits 2:3 - Comparator power mode"]
#[inline (always)] pub fn comp1_pwrmode (& mut self) -> Comp1PwrmodeW < '_ , Comp1CsrSpec > { Comp1PwrmodeW :: new (self , 2) }
#[doc = "Bits 4:6 - Comparator input minus selection"]
#[inline (always)] pub fn comp1_inmsel (& mut self) -> Comp1InmselW < '_ , Comp1CsrSpec > { Comp1InmselW :: new (self , 4) }
#[doc = "Bits 7:8 - Comparator input plus selection"]
#[inline (always)] pub fn comp1_inpsel (& mut self) -> Comp1InpselW < '_ , Comp1CsrSpec > { Comp1InpselW :: new (self , 7) }
#[doc = "Bit 15 - Comparator output polarity"]
#[inline (always)] pub fn comp1_polarity (& mut self) -> Comp1PolarityW < '_ , Comp1CsrSpec > { Comp1PolarityW :: new (self , 15) }
#[doc = "Bits 16:17 - Comparator hysteresis"]
#[inline (always)] pub fn comp1_hyst (& mut self) -> Comp1HystW < '_ , Comp1CsrSpec > { Comp1HystW :: new (self , 16) }
#[doc = "Bits 18:20 - Comparator blanking source"]
#[inline (always)] pub fn comp1_blanking (& mut self) -> Comp1BlankingW < '_ , Comp1CsrSpec > { Comp1BlankingW :: new (self , 18) }
#[doc = "Bit 22 - Comparator voltage scaler enable"]
#[inline (always)] pub fn comp1_brgen (& mut self) -> Comp1BrgenW < '_ , Comp1CsrSpec > { Comp1BrgenW :: new (self , 22) }
#[doc = "Bit 23 - Comparator scaler bridge enable"]
#[inline (always)] pub fn comp1_scalen (& mut self) -> Comp1ScalenW < '_ , Comp1CsrSpec > { Comp1ScalenW :: new (self , 23) }
#[doc = "Bits 25:26 - Comparator input minus extended selection"]
#[inline (always)] pub fn comp1_inmesel (& mut self) -> Comp1InmeselW < '_ , Comp1CsrSpec > { Comp1InmeselW :: new (self , 25) }
#[doc = "Bit 31 - Comparator lock"]
#[inline (always)] pub fn comp1_lock (& mut self) -> Comp1LockW < '_ , Comp1CsrSpec > { Comp1LockW :: new (self , 31) } }
#[doc = "Comparator control and status register\n\nYou can [`read`](crate::Reg::read) this register and get [`comp1_csr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`comp1_csr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Comp1CsrSpec ; impl crate :: RegisterSpec for Comp1CsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`comp1_csr::R`](R) reader structure"] impl crate :: Readable for Comp1CsrSpec { }
#[doc = "`write(|w| ..)` method takes [`comp1_csr::W`](W) writer structure"] impl crate :: Writable for Comp1CsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets COMP1_CSR to value 0"] impl crate :: Resettable for Comp1CsrSpec { } }
#[doc = "COMP2_CSR (rw) register accessor: Comparator 2 control and status register\n\nYou can [`read`](crate::Reg::read) this register and get [`comp2_csr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`comp2_csr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@comp2_csr`] module"]
#[doc (alias = "COMP2_CSR")] pub type Comp2Csr = crate :: Reg < comp2_csr :: Comp2CsrSpec > ;
#[doc = "Comparator 2 control and status register"] pub mod comp2_csr {
#[doc = "Register `COMP2_CSR` reader"] pub type R = crate :: R < Comp2CsrSpec > ;
#[doc = "Register `COMP2_CSR` writer"] pub type W = crate :: W < Comp2CsrSpec > ;
#[doc = "Field `COMP2_EN` reader - Comparator 2 enable bit"] pub type Comp2EnR = crate :: BitReader ;
#[doc = "Field `COMP2_EN` writer - Comparator 2 enable bit"] pub type Comp2EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMP2_PWRMODE` reader - Power Mode of the comparator 2"] pub type Comp2PwrmodeR = crate :: FieldReader ;
#[doc = "Field `COMP2_PWRMODE` writer - Power Mode of the comparator 2"] pub type Comp2PwrmodeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `COMP2_INMSEL` reader - Comparator 2 input minus selection bits"] pub type Comp2InmselR = crate :: FieldReader ;
#[doc = "Field `COMP2_INMSEL` writer - Comparator 2 input minus selection bits"] pub type Comp2InmselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `COMP2_INPSEL` reader - Comparator 1 input plus selection bit"] pub type Comp2InpselR = crate :: FieldReader ;
#[doc = "Field `COMP2_INPSEL` writer - Comparator 1 input plus selection bit"] pub type Comp2InpselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `COMP2_WINMODE` reader - Windows mode selection bit"] pub type Comp2WinmodeR = crate :: BitReader ;
#[doc = "Field `COMP2_WINMODE` writer - Windows mode selection bit"] pub type Comp2WinmodeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMP2_POLARITY` reader - Comparator 2 polarity selection bit"] pub type Comp2PolarityR = crate :: BitReader ;
#[doc = "Field `COMP2_POLARITY` writer - Comparator 2 polarity selection bit"] pub type Comp2PolarityW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMP2_HYST` reader - Comparator 2 hysteresis selection bits"] pub type Comp2HystR = crate :: FieldReader ;
#[doc = "Field `COMP2_HYST` writer - Comparator 2 hysteresis selection bits"] pub type Comp2HystW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `COMP2_BLANKING` reader - Comparator 2 blanking source selection bits"] pub type Comp2BlankingR = crate :: FieldReader ;
#[doc = "Field `COMP2_BLANKING` writer - Comparator 2 blanking source selection bits"] pub type Comp2BlankingW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `COMP2_BRGEN` reader - Scaler bridge enable"] pub type Comp2BrgenR = crate :: BitReader ;
#[doc = "Field `COMP2_BRGEN` writer - Scaler bridge enable"] pub type Comp2BrgenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMP2_SCALEN` reader - Voltage scaler enable bit"] pub type Comp2ScalenR = crate :: BitReader ;
#[doc = "Field `COMP2_SCALEN` writer - Voltage scaler enable bit"] pub type Comp2ScalenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMP2_INMESEL` reader - comparator 2 input minus extended selection bits."] pub type Comp2InmeselR = crate :: FieldReader ;
#[doc = "Field `COMP2_INMESEL` writer - comparator 2 input minus extended selection bits."] pub type Comp2InmeselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `COMP2_VALUE` reader - Comparator 2 output status bit"] pub type Comp2ValueR = crate :: BitReader ;
#[doc = "Field `COMP2_LOCK` reader - CSR register lock bit"] pub type Comp2LockR = crate :: BitReader ;
#[doc = "Field `COMP2_LOCK` writer - CSR register lock bit"] pub type Comp2LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Comparator 2 enable bit"]
#[inline (always)] pub fn comp2_en (& self) -> Comp2EnR { Comp2EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bits 2:3 - Power Mode of the comparator 2"]
#[inline (always)] pub fn comp2_pwrmode (& self) -> Comp2PwrmodeR { Comp2PwrmodeR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:5 - Comparator 2 input minus selection bits"]
#[inline (always)] pub fn comp2_inmsel (& self) -> Comp2InmselR { Comp2InmselR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bits 7:8 - Comparator 1 input plus selection bit"]
#[inline (always)] pub fn comp2_inpsel (& self) -> Comp2InpselR { Comp2InpselR :: new (((self . bits >> 7) & 3) as u8) }
#[doc = "Bit 9 - Windows mode selection bit"]
#[inline (always)] pub fn comp2_winmode (& self) -> Comp2WinmodeR { Comp2WinmodeR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 15 - Comparator 2 polarity selection bit"]
#[inline (always)] pub fn comp2_polarity (& self) -> Comp2PolarityR { Comp2PolarityR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bits 16:17 - Comparator 2 hysteresis selection bits"]
#[inline (always)] pub fn comp2_hyst (& self) -> Comp2HystR { Comp2HystR :: new (((self . bits >> 16) & 3) as u8) }
#[doc = "Bits 18:20 - Comparator 2 blanking source selection bits"]
#[inline (always)] pub fn comp2_blanking (& self) -> Comp2BlankingR { Comp2BlankingR :: new (((self . bits >> 18) & 7) as u8) }
#[doc = "Bit 22 - Scaler bridge enable"]
#[inline (always)] pub fn comp2_brgen (& self) -> Comp2BrgenR { Comp2BrgenR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Voltage scaler enable bit"]
#[inline (always)] pub fn comp2_scalen (& self) -> Comp2ScalenR { Comp2ScalenR :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bits 25:26 - comparator 2 input minus extended selection bits."]
#[inline (always)] pub fn comp2_inmesel (& self) -> Comp2InmeselR { Comp2InmeselR :: new (((self . bits >> 25) & 3) as u8) }
#[doc = "Bit 30 - Comparator 2 output status bit"]
#[inline (always)] pub fn comp2_value (& self) -> Comp2ValueR { Comp2ValueR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - CSR register lock bit"]
#[inline (always)] pub fn comp2_lock (& self) -> Comp2LockR { Comp2LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Comparator 2 enable bit"]
#[inline (always)] pub fn comp2_en (& mut self) -> Comp2EnW < '_ , Comp2CsrSpec > { Comp2EnW :: new (self , 0) }
#[doc = "Bits 2:3 - Power Mode of the comparator 2"]
#[inline (always)] pub fn comp2_pwrmode (& mut self) -> Comp2PwrmodeW < '_ , Comp2CsrSpec > { Comp2PwrmodeW :: new (self , 2) }
#[doc = "Bits 4:5 - Comparator 2 input minus selection bits"]
#[inline (always)] pub fn comp2_inmsel (& mut self) -> Comp2InmselW < '_ , Comp2CsrSpec > { Comp2InmselW :: new (self , 4) }
#[doc = "Bits 7:8 - Comparator 1 input plus selection bit"]
#[inline (always)] pub fn comp2_inpsel (& mut self) -> Comp2InpselW < '_ , Comp2CsrSpec > { Comp2InpselW :: new (self , 7) }
#[doc = "Bit 9 - Windows mode selection bit"]
#[inline (always)] pub fn comp2_winmode (& mut self) -> Comp2WinmodeW < '_ , Comp2CsrSpec > { Comp2WinmodeW :: new (self , 9) }
#[doc = "Bit 15 - Comparator 2 polarity selection bit"]
#[inline (always)] pub fn comp2_polarity (& mut self) -> Comp2PolarityW < '_ , Comp2CsrSpec > { Comp2PolarityW :: new (self , 15) }
#[doc = "Bits 16:17 - Comparator 2 hysteresis selection bits"]
#[inline (always)] pub fn comp2_hyst (& mut self) -> Comp2HystW < '_ , Comp2CsrSpec > { Comp2HystW :: new (self , 16) }
#[doc = "Bits 18:20 - Comparator 2 blanking source selection bits"]
#[inline (always)] pub fn comp2_blanking (& mut self) -> Comp2BlankingW < '_ , Comp2CsrSpec > { Comp2BlankingW :: new (self , 18) }
#[doc = "Bit 22 - Scaler bridge enable"]
#[inline (always)] pub fn comp2_brgen (& mut self) -> Comp2BrgenW < '_ , Comp2CsrSpec > { Comp2BrgenW :: new (self , 22) }
#[doc = "Bit 23 - Voltage scaler enable bit"]
#[inline (always)] pub fn comp2_scalen (& mut self) -> Comp2ScalenW < '_ , Comp2CsrSpec > { Comp2ScalenW :: new (self , 23) }
#[doc = "Bits 25:26 - comparator 2 input minus extended selection bits."]
#[inline (always)] pub fn comp2_inmesel (& mut self) -> Comp2InmeselW < '_ , Comp2CsrSpec > { Comp2InmeselW :: new (self , 25) }
#[doc = "Bit 31 - CSR register lock bit"]
#[inline (always)] pub fn comp2_lock (& mut self) -> Comp2LockW < '_ , Comp2CsrSpec > { Comp2LockW :: new (self , 31) } }
#[doc = "Comparator 2 control and status register\n\nYou can [`read`](crate::Reg::read) this register and get [`comp2_csr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`comp2_csr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Comp2CsrSpec ; impl crate :: RegisterSpec for Comp2CsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`comp2_csr::R`](R) reader structure"] impl crate :: Readable for Comp2CsrSpec { }
#[doc = "`write(|w| ..)` method takes [`comp2_csr::W`](W) writer structure"] impl crate :: Writable for Comp2CsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets COMP2_CSR to value 0"] impl crate :: Resettable for Comp2CsrSpec { } } }
#[doc = "Random number generator"] pub type Rng = crate :: Periph < rng :: RegisterBlock , 0x5800_1000 > ; impl core :: fmt :: Debug for Rng { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rng") . finish () } }
#[doc = "Random number generator"] pub mod rng {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr : Cr , sr : Sr , dr : Dr , } impl RegisterBlock {
#[doc = "0x00 - control register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x04 - status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x08 - data register"]
#[inline (always)] pub const fn dr (& self) -> & Dr { & self . dr } }
#[doc = "CR (rw) register accessor: control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "control register"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `RNGEN` reader - Random number generator enable"] pub type RngenR = crate :: BitReader ;
#[doc = "Field `RNGEN` writer - Random number generator enable"] pub type RngenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IE` reader - Interrupt enable"] pub type IeR = crate :: BitReader ;
#[doc = "Field `IE` writer - Interrupt enable"] pub type IeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BYP` reader - Bypass mode enable"] pub type BypR = crate :: BitReader ;
#[doc = "Field `BYP` writer - Bypass mode enable"] pub type BypW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 2 - Random number generator enable"]
#[inline (always)] pub fn rngen (& self) -> RngenR { RngenR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Interrupt enable"]
#[inline (always)] pub fn ie (& self) -> IeR { IeR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 6 - Bypass mode enable"]
#[inline (always)] pub fn byp (& self) -> BypR { BypR :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bit 2 - Random number generator enable"]
#[inline (always)] pub fn rngen (& mut self) -> RngenW < '_ , CrSpec > { RngenW :: new (self , 2) }
#[doc = "Bit 3 - Interrupt enable"]
#[inline (always)] pub fn ie (& mut self) -> IeW < '_ , CrSpec > { IeW :: new (self , 3) }
#[doc = "Bit 6 - Bypass mode enable"]
#[inline (always)] pub fn byp (& mut self) -> BypW < '_ , CrSpec > { BypW :: new (self , 6) } }
#[doc = "control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { } }
#[doc = "SR (rw) register accessor: status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `DRDY` reader - Data ready"] pub type DrdyR = crate :: BitReader ;
#[doc = "Field `CECS` reader - Clock error current status"] pub type CecsR = crate :: BitReader ;
#[doc = "Field `SECS` reader - Seed error current status"] pub type SecsR = crate :: BitReader ;
#[doc = "Field `CEIS` reader - Clock error interrupt status"] pub type CeisR = crate :: BitReader ;
#[doc = "Field `CEIS` writer - Clock error interrupt status"] pub type CeisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SEIS` reader - Seed error interrupt status"] pub type SeisR = crate :: BitReader ;
#[doc = "Field `SEIS` writer - Seed error interrupt status"] pub type SeisW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Data ready"]
#[inline (always)] pub fn drdy (& self) -> DrdyR { DrdyR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Clock error current status"]
#[inline (always)] pub fn cecs (& self) -> CecsR { CecsR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Seed error current status"]
#[inline (always)] pub fn secs (& self) -> SecsR { SecsR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 5 - Clock error interrupt status"]
#[inline (always)] pub fn ceis (& self) -> CeisR { CeisR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Seed error interrupt status"]
#[inline (always)] pub fn seis (& self) -> SeisR { SeisR :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bit 5 - Clock error interrupt status"]
#[inline (always)] pub fn ceis (& mut self) -> CeisW < '_ , SrSpec > { CeisW :: new (self , 5) }
#[doc = "Bit 6 - Seed error interrupt status"]
#[inline (always)] pub fn seis (& mut self) -> SeisW < '_ , SrSpec > { SeisW :: new (self , 6) } }
#[doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "DR (r) register accessor: data register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr`] module"]
#[doc (alias = "DR")] pub type Dr = crate :: Reg < dr :: DrSpec > ;
#[doc = "data register"] pub mod dr {
#[doc = "Register `DR` reader"] pub type R = crate :: R < DrSpec > ;
#[doc = "Field `RNDATA` reader - Random data"] pub type RndataR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Random data"]
#[inline (always)] pub fn rndata (& self) -> RndataR { RndataR :: new (self . bits) } }
#[doc = "data register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DrSpec ; impl crate :: RegisterSpec for DrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr::R`](R) reader structure"] impl crate :: Readable for DrSpec { }
#[doc = "`reset()` method sets DR to value 0"] impl crate :: Resettable for DrSpec { } } }
#[doc = "Advanced encryption standard hardware accelerator 1"] pub type Aes1 = crate :: Periph < aes1 :: RegisterBlock , 0x5006_0000 > ; impl core :: fmt :: Debug for Aes1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Aes1") . finish () } }
#[doc = "Advanced encryption standard hardware accelerator 1"] pub mod aes1 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr : Cr , sr : Sr , dinr : Dinr , doutr : Doutr , keyr0 : Keyr0 , keyr1 : Keyr1 , keyr2 : Keyr2 , keyr3 : Keyr3 , ivr0 : Ivr0 , ivr1 : Ivr1 , ivr2 : Ivr2 , ivr3 : Ivr3 , keyr4 : Keyr4 , keyr5 : Keyr5 , keyr6 : Keyr6 , keyr7 : Keyr7 , susp0r : Susp0r , susp1r : Susp1r , susp2r : Susp2r , susp3r : Susp3r , susp4r : Susp4r , susp5r : Susp5r , susp6r : Susp6r , susp7r : Susp7r , _reserved24 : [u8 ; 0x0390] , hwcfr : Hwcfr , verr : Verr , ipidr : Ipidr , sidr : Sidr , } impl RegisterBlock {
#[doc = "0x00 - control register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x04 - status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x08 - data input register"]
#[inline (always)] pub const fn dinr (& self) -> & Dinr { & self . dinr }
#[doc = "0x0c - data output register"]
#[inline (always)] pub const fn doutr (& self) -> & Doutr { & self . doutr }
#[doc = "0x10 - key register 0"]
#[inline (always)] pub const fn keyr0 (& self) -> & Keyr0 { & self . keyr0 }
#[doc = "0x14 - key register 1"]
#[inline (always)] pub const fn keyr1 (& self) -> & Keyr1 { & self . keyr1 }
#[doc = "0x18 - key register 2"]
#[inline (always)] pub const fn keyr2 (& self) -> & Keyr2 { & self . keyr2 }
#[doc = "0x1c - key register 3"]
#[inline (always)] pub const fn keyr3 (& self) -> & Keyr3 { & self . keyr3 }
#[doc = "0x20 - initialization vector register 0"]
#[inline (always)] pub const fn ivr0 (& self) -> & Ivr0 { & self . ivr0 }
#[doc = "0x24 - initialization vector register 1"]
#[inline (always)] pub const fn ivr1 (& self) -> & Ivr1 { & self . ivr1 }
#[doc = "0x28 - initialization vector register 2"]
#[inline (always)] pub const fn ivr2 (& self) -> & Ivr2 { & self . ivr2 }
#[doc = "0x2c - initialization vector register 3"]
#[inline (always)] pub const fn ivr3 (& self) -> & Ivr3 { & self . ivr3 }
#[doc = "0x30 - key register 4"]
#[inline (always)] pub const fn keyr4 (& self) -> & Keyr4 { & self . keyr4 }
#[doc = "0x34 - key register 5"]
#[inline (always)] pub const fn keyr5 (& self) -> & Keyr5 { & self . keyr5 }
#[doc = "0x38 - key register 6"]
#[inline (always)] pub const fn keyr6 (& self) -> & Keyr6 { & self . keyr6 }
#[doc = "0x3c - key register 7"]
#[inline (always)] pub const fn keyr7 (& self) -> & Keyr7 { & self . keyr7 }
#[doc = "0x40 - AES suspend register 0"]
#[inline (always)] pub const fn susp0r (& self) -> & Susp0r { & self . susp0r }
#[doc = "0x44 - AES suspend register 1"]
#[inline (always)] pub const fn susp1r (& self) -> & Susp1r { & self . susp1r }
#[doc = "0x48 - AES suspend register 2"]
#[inline (always)] pub const fn susp2r (& self) -> & Susp2r { & self . susp2r }
#[doc = "0x4c - AES suspend register 3"]
#[inline (always)] pub const fn susp3r (& self) -> & Susp3r { & self . susp3r }
#[doc = "0x50 - AES suspend register 4"]
#[inline (always)] pub const fn susp4r (& self) -> & Susp4r { & self . susp4r }
#[doc = "0x54 - AES suspend register 5"]
#[inline (always)] pub const fn susp5r (& self) -> & Susp5r { & self . susp5r }
#[doc = "0x58 - AES suspend register 6"]
#[inline (always)] pub const fn susp6r (& self) -> & Susp6r { & self . susp6r }
#[doc = "0x5c - AES suspend register 7"]
#[inline (always)] pub const fn susp7r (& self) -> & Susp7r { & self . susp7r }
#[doc = "0x3f0 - AES hardware configuration register"]
#[inline (always)] pub const fn hwcfr (& self) -> & Hwcfr { & self . hwcfr }
#[doc = "0x3f4 - AES version register"]
#[inline (always)] pub const fn verr (& self) -> & Verr { & self . verr }
#[doc = "0x3f8 - AES identification register"]
#[inline (always)] pub const fn ipidr (& self) -> & Ipidr { & self . ipidr }
#[doc = "0x3fc - AES size ID register"]
#[inline (always)] pub const fn sidr (& self) -> & Sidr { & self . sidr } }
#[doc = "CR (rw) register accessor: control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "control register"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `EN` reader - AES enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - AES enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DATATYPE` reader - Data type selection (for data in and data out to/from the cryptographic block)"] pub type DatatypeR = crate :: FieldReader ;
#[doc = "Field `DATATYPE` writer - Data type selection (for data in and data out to/from the cryptographic block)"] pub type DatatypeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE` reader - AES operating mode"] pub type ModeR = crate :: FieldReader ;
#[doc = "Field `MODE` writer - AES operating mode"] pub type ModeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CHMOD10` reader - AES chaining mode Bit1 Bit0"] pub type Chmod10R = crate :: FieldReader ;
#[doc = "Field `CHMOD10` writer - AES chaining mode Bit1 Bit0"] pub type Chmod10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CCFC` reader - Computation Complete Flag Clear"] pub type CcfcR = crate :: BitReader ;
#[doc = "Field `CCFC` writer - Computation Complete Flag Clear"] pub type CcfcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ERRC` reader - Error clear"] pub type ErrcR = crate :: BitReader ;
#[doc = "Field `ERRC` writer - Error clear"] pub type ErrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CCFIE` reader - CCF flag interrupt enable"] pub type CcfieR = crate :: BitReader ;
#[doc = "Field `CCFIE` writer - CCF flag interrupt enable"] pub type CcfieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ERRIE` reader - Error interrupt enable"] pub type ErrieR = crate :: BitReader ;
#[doc = "Field `ERRIE` writer - Error interrupt enable"] pub type ErrieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMAINEN` reader - Enable DMA management of data input phase"] pub type DmainenR = crate :: BitReader ;
#[doc = "Field `DMAINEN` writer - Enable DMA management of data input phase"] pub type DmainenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMAOUTEN` reader - Enable DMA management of data output phase"] pub type DmaoutenR = crate :: BitReader ;
#[doc = "Field `DMAOUTEN` writer - Enable DMA management of data output phase"] pub type DmaoutenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GCMPH` reader - Used only for GCM, CCM and GMAC algorithms and has no effect when other algorithms are selected"] pub type GcmphR = crate :: FieldReader ;
#[doc = "Field `GCMPH` writer - Used only for GCM, CCM and GMAC algorithms and has no effect when other algorithms are selected"] pub type GcmphW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CHMOD2` reader - AES chaining mode Bit2"] pub type Chmod2R = crate :: BitReader ;
#[doc = "Field `CHMOD2` writer - AES chaining mode Bit2"] pub type Chmod2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `KEYSIZE` reader - Key size selection"] pub type KeysizeR = crate :: BitReader ;
#[doc = "Field `KEYSIZE` writer - Key size selection"] pub type KeysizeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NPBLB` reader - Number of padding bytes in last block of payload"] pub type NpblbR = crate :: FieldReader ;
#[doc = "Field `NPBLB` writer - Number of padding bytes in last block of payload"] pub type NpblbW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bit 0 - AES enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bits 1:2 - Data type selection (for data in and data out to/from the cryptographic block)"]
#[inline (always)] pub fn datatype (& self) -> DatatypeR { DatatypeR :: new (((self . bits >> 1) & 3) as u8) }
#[doc = "Bits 3:4 - AES operating mode"]
#[inline (always)] pub fn mode (& self) -> ModeR { ModeR :: new (((self . bits >> 3) & 3) as u8) }
#[doc = "Bits 5:6 - AES chaining mode Bit1 Bit0"]
#[inline (always)] pub fn chmod10 (& self) -> Chmod10R { Chmod10R :: new (((self . bits >> 5) & 3) as u8) }
#[doc = "Bit 7 - Computation Complete Flag Clear"]
#[inline (always)] pub fn ccfc (& self) -> CcfcR { CcfcR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Error clear"]
#[inline (always)] pub fn errc (& self) -> ErrcR { ErrcR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - CCF flag interrupt enable"]
#[inline (always)] pub fn ccfie (& self) -> CcfieR { CcfieR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Error interrupt enable"]
#[inline (always)] pub fn errie (& self) -> ErrieR { ErrieR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Enable DMA management of data input phase"]
#[inline (always)] pub fn dmainen (& self) -> DmainenR { DmainenR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Enable DMA management of data output phase"]
#[inline (always)] pub fn dmaouten (& self) -> DmaoutenR { DmaoutenR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bits 13:14 - Used only for GCM, CCM and GMAC algorithms and has no effect when other algorithms are selected"]
#[inline (always)] pub fn gcmph (& self) -> GcmphR { GcmphR :: new (((self . bits >> 13) & 3) as u8) }
#[doc = "Bit 16 - AES chaining mode Bit2"]
#[inline (always)] pub fn chmod2 (& self) -> Chmod2R { Chmod2R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 18 - Key size selection"]
#[inline (always)] pub fn keysize (& self) -> KeysizeR { KeysizeR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bits 20:23 - Number of padding bytes in last block of payload"]
#[inline (always)] pub fn npblb (& self) -> NpblbR { NpblbR :: new (((self . bits >> 20) & 0x0f) as u8) } } impl W {
#[doc = "Bit 0 - AES enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , CrSpec > { EnW :: new (self , 0) }
#[doc = "Bits 1:2 - Data type selection (for data in and data out to/from the cryptographic block)"]
#[inline (always)] pub fn datatype (& mut self) -> DatatypeW < '_ , CrSpec > { DatatypeW :: new (self , 1) }
#[doc = "Bits 3:4 - AES operating mode"]
#[inline (always)] pub fn mode (& mut self) -> ModeW < '_ , CrSpec > { ModeW :: new (self , 3) }
#[doc = "Bits 5:6 - AES chaining mode Bit1 Bit0"]
#[inline (always)] pub fn chmod10 (& mut self) -> Chmod10W < '_ , CrSpec > { Chmod10W :: new (self , 5) }
#[doc = "Bit 7 - Computation Complete Flag Clear"]
#[inline (always)] pub fn ccfc (& mut self) -> CcfcW < '_ , CrSpec > { CcfcW :: new (self , 7) }
#[doc = "Bit 8 - Error clear"]
#[inline (always)] pub fn errc (& mut self) -> ErrcW < '_ , CrSpec > { ErrcW :: new (self , 8) }
#[doc = "Bit 9 - CCF flag interrupt enable"]
#[inline (always)] pub fn ccfie (& mut self) -> CcfieW < '_ , CrSpec > { CcfieW :: new (self , 9) }
#[doc = "Bit 10 - Error interrupt enable"]
#[inline (always)] pub fn errie (& mut self) -> ErrieW < '_ , CrSpec > { ErrieW :: new (self , 10) }
#[doc = "Bit 11 - Enable DMA management of data input phase"]
#[inline (always)] pub fn dmainen (& mut self) -> DmainenW < '_ , CrSpec > { DmainenW :: new (self , 11) }
#[doc = "Bit 12 - Enable DMA management of data output phase"]
#[inline (always)] pub fn dmaouten (& mut self) -> DmaoutenW < '_ , CrSpec > { DmaoutenW :: new (self , 12) }
#[doc = "Bits 13:14 - Used only for GCM, CCM and GMAC algorithms and has no effect when other algorithms are selected"]
#[inline (always)] pub fn gcmph (& mut self) -> GcmphW < '_ , CrSpec > { GcmphW :: new (self , 13) }
#[doc = "Bit 16 - AES chaining mode Bit2"]
#[inline (always)] pub fn chmod2 (& mut self) -> Chmod2W < '_ , CrSpec > { Chmod2W :: new (self , 16) }
#[doc = "Bit 18 - Key size selection"]
#[inline (always)] pub fn keysize (& mut self) -> KeysizeW < '_ , CrSpec > { KeysizeW :: new (self , 18) }
#[doc = "Bits 20:23 - Number of padding bytes in last block of payload"]
#[inline (always)] pub fn npblb (& mut self) -> NpblbW < '_ , CrSpec > { NpblbW :: new (self , 20) } }
#[doc = "control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { } }
#[doc = "SR (r) register accessor: status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Field `CCF` reader - Computation complete flag"] pub type CcfR = crate :: BitReader ;
#[doc = "Field `RDERR` reader - Read error flag"] pub type RderrR = crate :: BitReader ;
#[doc = "Field `WRERR` reader - Write error flag"] pub type WrerrR = crate :: BitReader ;
#[doc = "Field `BUSY` reader - Busy flag"] pub type BusyR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Computation complete flag"]
#[inline (always)] pub fn ccf (& self) -> CcfR { CcfR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Read error flag"]
#[inline (always)] pub fn rderr (& self) -> RderrR { RderrR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Write error flag"]
#[inline (always)] pub fn wrerr (& self) -> WrerrR { WrerrR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Busy flag"]
#[inline (always)] pub fn busy (& self) -> BusyR { BusyR :: new (((self . bits >> 3) & 1) != 0) } }
#[doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "DINR (rw) register accessor: data input register\n\nYou can [`read`](crate::Reg::read) this register and get [`dinr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dinr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dinr`] module"]
#[doc (alias = "DINR")] pub type Dinr = crate :: Reg < dinr :: DinrSpec > ;
#[doc = "data input register"] pub mod dinr {
#[doc = "Register `DINR` reader"] pub type R = crate :: R < DinrSpec > ;
#[doc = "Register `DINR` writer"] pub type W = crate :: W < DinrSpec > ;
#[doc = "Field `AES_DINR` reader - Data Input Register"] pub type AesDinrR = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_DINR` writer - Data Input Register"] pub type AesDinrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Data Input Register"]
#[inline (always)] pub fn aes_dinr (& self) -> AesDinrR { AesDinrR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Data Input Register"]
#[inline (always)] pub fn aes_dinr (& mut self) -> AesDinrW < '_ , DinrSpec > { AesDinrW :: new (self , 0) } }
#[doc = "data input register\n\nYou can [`read`](crate::Reg::read) this register and get [`dinr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dinr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DinrSpec ; impl crate :: RegisterSpec for DinrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dinr::R`](R) reader structure"] impl crate :: Readable for DinrSpec { }
#[doc = "`write(|w| ..)` method takes [`dinr::W`](W) writer structure"] impl crate :: Writable for DinrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DINR to value 0"] impl crate :: Resettable for DinrSpec { } }
#[doc = "DOUTR (r) register accessor: data output register\n\nYou can [`read`](crate::Reg::read) this register and get [`doutr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@doutr`] module"]
#[doc (alias = "DOUTR")] pub type Doutr = crate :: Reg < doutr :: DoutrSpec > ;
#[doc = "data output register"] pub mod doutr {
#[doc = "Register `DOUTR` reader"] pub type R = crate :: R < DoutrSpec > ;
#[doc = "Field `AES_DOUTR` reader - Data output register"] pub type AesDoutrR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Data output register"]
#[inline (always)] pub fn aes_doutr (& self) -> AesDoutrR { AesDoutrR :: new (self . bits) } }
#[doc = "data output register\n\nYou can [`read`](crate::Reg::read) this register and get [`doutr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DoutrSpec ; impl crate :: RegisterSpec for DoutrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`doutr::R`](R) reader structure"] impl crate :: Readable for DoutrSpec { }
#[doc = "`reset()` method sets DOUTR to value 0"] impl crate :: Resettable for DoutrSpec { } }
#[doc = "KEYR0 (rw) register accessor: key register 0\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@keyr0`] module"]
#[doc (alias = "KEYR0")] pub type Keyr0 = crate :: Reg < keyr0 :: Keyr0Spec > ;
#[doc = "key register 0"] pub mod keyr0 {
#[doc = "Register `KEYR0` reader"] pub type R = crate :: R < Keyr0Spec > ;
#[doc = "Register `KEYR0` writer"] pub type W = crate :: W < Keyr0Spec > ;
#[doc = "Field `AES_KEYR0` reader - Data Output Register (LSB key \\[31:0\\])"] pub type AesKeyr0R = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_KEYR0` writer - Data Output Register (LSB key \\[31:0\\])"] pub type AesKeyr0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Data Output Register (LSB key \\[31:0\\])"]
#[inline (always)] pub fn aes_keyr0 (& self) -> AesKeyr0R { AesKeyr0R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Data Output Register (LSB key \\[31:0\\])"]
#[inline (always)] pub fn aes_keyr0 (& mut self) -> AesKeyr0W < '_ , Keyr0Spec > { AesKeyr0W :: new (self , 0) } }
#[doc = "key register 0\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Keyr0Spec ; impl crate :: RegisterSpec for Keyr0Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`keyr0::R`](R) reader structure"] impl crate :: Readable for Keyr0Spec { }
#[doc = "`write(|w| ..)` method takes [`keyr0::W`](W) writer structure"] impl crate :: Writable for Keyr0Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets KEYR0 to value 0"] impl crate :: Resettable for Keyr0Spec { } }
#[doc = "KEYR1 (rw) register accessor: key register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@keyr1`] module"]
#[doc (alias = "KEYR1")] pub type Keyr1 = crate :: Reg < keyr1 :: Keyr1Spec > ;
#[doc = "key register 1"] pub mod keyr1 {
#[doc = "Register `KEYR1` reader"] pub type R = crate :: R < Keyr1Spec > ;
#[doc = "Register `KEYR1` writer"] pub type W = crate :: W < Keyr1Spec > ;
#[doc = "Field `AES_KEYR1` reader - AES key register (key \\[63:32\\])"] pub type AesKeyr1R = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_KEYR1` writer - AES key register (key \\[63:32\\])"] pub type AesKeyr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES key register (key \\[63:32\\])"]
#[inline (always)] pub fn aes_keyr1 (& self) -> AesKeyr1R { AesKeyr1R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES key register (key \\[63:32\\])"]
#[inline (always)] pub fn aes_keyr1 (& mut self) -> AesKeyr1W < '_ , Keyr1Spec > { AesKeyr1W :: new (self , 0) } }
#[doc = "key register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Keyr1Spec ; impl crate :: RegisterSpec for Keyr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`keyr1::R`](R) reader structure"] impl crate :: Readable for Keyr1Spec { }
#[doc = "`write(|w| ..)` method takes [`keyr1::W`](W) writer structure"] impl crate :: Writable for Keyr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets KEYR1 to value 0"] impl crate :: Resettable for Keyr1Spec { } }
#[doc = "KEYR2 (rw) register accessor: key register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@keyr2`] module"]
#[doc (alias = "KEYR2")] pub type Keyr2 = crate :: Reg < keyr2 :: Keyr2Spec > ;
#[doc = "key register 2"] pub mod keyr2 {
#[doc = "Register `KEYR2` reader"] pub type R = crate :: R < Keyr2Spec > ;
#[doc = "Register `KEYR2` writer"] pub type W = crate :: W < Keyr2Spec > ;
#[doc = "Field `AES_KEYR2` reader - AES key register (key \\[95:64\\])"] pub type AesKeyr2R = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_KEYR2` writer - AES key register (key \\[95:64\\])"] pub type AesKeyr2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES key register (key \\[95:64\\])"]
#[inline (always)] pub fn aes_keyr2 (& self) -> AesKeyr2R { AesKeyr2R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES key register (key \\[95:64\\])"]
#[inline (always)] pub fn aes_keyr2 (& mut self) -> AesKeyr2W < '_ , Keyr2Spec > { AesKeyr2W :: new (self , 0) } }
#[doc = "key register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Keyr2Spec ; impl crate :: RegisterSpec for Keyr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`keyr2::R`](R) reader structure"] impl crate :: Readable for Keyr2Spec { }
#[doc = "`write(|w| ..)` method takes [`keyr2::W`](W) writer structure"] impl crate :: Writable for Keyr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets KEYR2 to value 0"] impl crate :: Resettable for Keyr2Spec { } }
#[doc = "KEYR3 (rw) register accessor: key register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@keyr3`] module"]
#[doc (alias = "KEYR3")] pub type Keyr3 = crate :: Reg < keyr3 :: Keyr3Spec > ;
#[doc = "key register 3"] pub mod keyr3 {
#[doc = "Register `KEYR3` reader"] pub type R = crate :: R < Keyr3Spec > ;
#[doc = "Register `KEYR3` writer"] pub type W = crate :: W < Keyr3Spec > ;
#[doc = "Field `AES_KEYR3` reader - AES key register (MSB key \\[127:96\\])"] pub type AesKeyr3R = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_KEYR3` writer - AES key register (MSB key \\[127:96\\])"] pub type AesKeyr3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES key register (MSB key \\[127:96\\])"]
#[inline (always)] pub fn aes_keyr3 (& self) -> AesKeyr3R { AesKeyr3R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES key register (MSB key \\[127:96\\])"]
#[inline (always)] pub fn aes_keyr3 (& mut self) -> AesKeyr3W < '_ , Keyr3Spec > { AesKeyr3W :: new (self , 0) } }
#[doc = "key register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Keyr3Spec ; impl crate :: RegisterSpec for Keyr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`keyr3::R`](R) reader structure"] impl crate :: Readable for Keyr3Spec { }
#[doc = "`write(|w| ..)` method takes [`keyr3::W`](W) writer structure"] impl crate :: Writable for Keyr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets KEYR3 to value 0"] impl crate :: Resettable for Keyr3Spec { } }
#[doc = "IVR0 (rw) register accessor: initialization vector register 0\n\nYou can [`read`](crate::Reg::read) this register and get [`ivr0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ivr0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ivr0`] module"]
#[doc (alias = "IVR0")] pub type Ivr0 = crate :: Reg < ivr0 :: Ivr0Spec > ;
#[doc = "initialization vector register 0"] pub mod ivr0 {
#[doc = "Register `IVR0` reader"] pub type R = crate :: R < Ivr0Spec > ;
#[doc = "Register `IVR0` writer"] pub type W = crate :: W < Ivr0Spec > ;
#[doc = "Field `AES_IVR0` reader - initialization vector register (LSB IVR \\[31:0\\])"] pub type AesIvr0R = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_IVR0` writer - initialization vector register (LSB IVR \\[31:0\\])"] pub type AesIvr0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - initialization vector register (LSB IVR \\[31:0\\])"]
#[inline (always)] pub fn aes_ivr0 (& self) -> AesIvr0R { AesIvr0R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - initialization vector register (LSB IVR \\[31:0\\])"]
#[inline (always)] pub fn aes_ivr0 (& mut self) -> AesIvr0W < '_ , Ivr0Spec > { AesIvr0W :: new (self , 0) } }
#[doc = "initialization vector register 0\n\nYou can [`read`](crate::Reg::read) this register and get [`ivr0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ivr0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ivr0Spec ; impl crate :: RegisterSpec for Ivr0Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ivr0::R`](R) reader structure"] impl crate :: Readable for Ivr0Spec { }
#[doc = "`write(|w| ..)` method takes [`ivr0::W`](W) writer structure"] impl crate :: Writable for Ivr0Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IVR0 to value 0"] impl crate :: Resettable for Ivr0Spec { } }
#[doc = "IVR1 (rw) register accessor: initialization vector register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ivr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ivr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ivr1`] module"]
#[doc (alias = "IVR1")] pub type Ivr1 = crate :: Reg < ivr1 :: Ivr1Spec > ;
#[doc = "initialization vector register 1"] pub mod ivr1 {
#[doc = "Register `IVR1` reader"] pub type R = crate :: R < Ivr1Spec > ;
#[doc = "Register `IVR1` writer"] pub type W = crate :: W < Ivr1Spec > ;
#[doc = "Field `AES_IVR1` reader - Initialization Vector Register (IVR \\[63:32\\])"] pub type AesIvr1R = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_IVR1` writer - Initialization Vector Register (IVR \\[63:32\\])"] pub type AesIvr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Initialization Vector Register (IVR \\[63:32\\])"]
#[inline (always)] pub fn aes_ivr1 (& self) -> AesIvr1R { AesIvr1R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Initialization Vector Register (IVR \\[63:32\\])"]
#[inline (always)] pub fn aes_ivr1 (& mut self) -> AesIvr1W < '_ , Ivr1Spec > { AesIvr1W :: new (self , 0) } }
#[doc = "initialization vector register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ivr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ivr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ivr1Spec ; impl crate :: RegisterSpec for Ivr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ivr1::R`](R) reader structure"] impl crate :: Readable for Ivr1Spec { }
#[doc = "`write(|w| ..)` method takes [`ivr1::W`](W) writer structure"] impl crate :: Writable for Ivr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IVR1 to value 0"] impl crate :: Resettable for Ivr1Spec { } }
#[doc = "IVR2 (rw) register accessor: initialization vector register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ivr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ivr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ivr2`] module"]
#[doc (alias = "IVR2")] pub type Ivr2 = crate :: Reg < ivr2 :: Ivr2Spec > ;
#[doc = "initialization vector register 2"] pub mod ivr2 {
#[doc = "Register `IVR2` reader"] pub type R = crate :: R < Ivr2Spec > ;
#[doc = "Register `IVR2` writer"] pub type W = crate :: W < Ivr2Spec > ;
#[doc = "Field `AES_IVR2` reader - Initialization Vector Register (IVR \\[95:64\\])"] pub type AesIvr2R = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_IVR2` writer - Initialization Vector Register (IVR \\[95:64\\])"] pub type AesIvr2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Initialization Vector Register (IVR \\[95:64\\])"]
#[inline (always)] pub fn aes_ivr2 (& self) -> AesIvr2R { AesIvr2R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Initialization Vector Register (IVR \\[95:64\\])"]
#[inline (always)] pub fn aes_ivr2 (& mut self) -> AesIvr2W < '_ , Ivr2Spec > { AesIvr2W :: new (self , 0) } }
#[doc = "initialization vector register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ivr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ivr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ivr2Spec ; impl crate :: RegisterSpec for Ivr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ivr2::R`](R) reader structure"] impl crate :: Readable for Ivr2Spec { }
#[doc = "`write(|w| ..)` method takes [`ivr2::W`](W) writer structure"] impl crate :: Writable for Ivr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IVR2 to value 0"] impl crate :: Resettable for Ivr2Spec { } }
#[doc = "IVR3 (rw) register accessor: initialization vector register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`ivr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ivr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ivr3`] module"]
#[doc (alias = "IVR3")] pub type Ivr3 = crate :: Reg < ivr3 :: Ivr3Spec > ;
#[doc = "initialization vector register 3"] pub mod ivr3 {
#[doc = "Register `IVR3` reader"] pub type R = crate :: R < Ivr3Spec > ;
#[doc = "Register `IVR3` writer"] pub type W = crate :: W < Ivr3Spec > ;
#[doc = "Field `AES_IVR3` reader - Initialization Vector Register (MSB IVR \\[127:96\\])"] pub type AesIvr3R = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_IVR3` writer - Initialization Vector Register (MSB IVR \\[127:96\\])"] pub type AesIvr3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Initialization Vector Register (MSB IVR \\[127:96\\])"]
#[inline (always)] pub fn aes_ivr3 (& self) -> AesIvr3R { AesIvr3R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Initialization Vector Register (MSB IVR \\[127:96\\])"]
#[inline (always)] pub fn aes_ivr3 (& mut self) -> AesIvr3W < '_ , Ivr3Spec > { AesIvr3W :: new (self , 0) } }
#[doc = "initialization vector register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`ivr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ivr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ivr3Spec ; impl crate :: RegisterSpec for Ivr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ivr3::R`](R) reader structure"] impl crate :: Readable for Ivr3Spec { }
#[doc = "`write(|w| ..)` method takes [`ivr3::W`](W) writer structure"] impl crate :: Writable for Ivr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IVR3 to value 0"] impl crate :: Resettable for Ivr3Spec { } }
#[doc = "KEYR4 (rw) register accessor: key register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@keyr4`] module"]
#[doc (alias = "KEYR4")] pub type Keyr4 = crate :: Reg < keyr4 :: Keyr4Spec > ;
#[doc = "key register 4"] pub mod keyr4 {
#[doc = "Register `KEYR4` reader"] pub type R = crate :: R < Keyr4Spec > ;
#[doc = "Register `KEYR4` writer"] pub type W = crate :: W < Keyr4Spec > ;
#[doc = "Field `AES_KEYR4` reader - AES key register (MSB key \\[159:128\\])"] pub type AesKeyr4R = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_KEYR4` writer - AES key register (MSB key \\[159:128\\])"] pub type AesKeyr4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES key register (MSB key \\[159:128\\])"]
#[inline (always)] pub fn aes_keyr4 (& self) -> AesKeyr4R { AesKeyr4R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES key register (MSB key \\[159:128\\])"]
#[inline (always)] pub fn aes_keyr4 (& mut self) -> AesKeyr4W < '_ , Keyr4Spec > { AesKeyr4W :: new (self , 0) } }
#[doc = "key register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Keyr4Spec ; impl crate :: RegisterSpec for Keyr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`keyr4::R`](R) reader structure"] impl crate :: Readable for Keyr4Spec { }
#[doc = "`write(|w| ..)` method takes [`keyr4::W`](W) writer structure"] impl crate :: Writable for Keyr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets KEYR4 to value 0"] impl crate :: Resettable for Keyr4Spec { } }
#[doc = "KEYR5 (rw) register accessor: key register 5\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@keyr5`] module"]
#[doc (alias = "KEYR5")] pub type Keyr5 = crate :: Reg < keyr5 :: Keyr5Spec > ;
#[doc = "key register 5"] pub mod keyr5 {
#[doc = "Register `KEYR5` reader"] pub type R = crate :: R < Keyr5Spec > ;
#[doc = "Register `KEYR5` writer"] pub type W = crate :: W < Keyr5Spec > ;
#[doc = "Field `AES_KEYR5` reader - AES key register (MSB key \\[191:160\\])"] pub type AesKeyr5R = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_KEYR5` writer - AES key register (MSB key \\[191:160\\])"] pub type AesKeyr5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES key register (MSB key \\[191:160\\])"]
#[inline (always)] pub fn aes_keyr5 (& self) -> AesKeyr5R { AesKeyr5R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES key register (MSB key \\[191:160\\])"]
#[inline (always)] pub fn aes_keyr5 (& mut self) -> AesKeyr5W < '_ , Keyr5Spec > { AesKeyr5W :: new (self , 0) } }
#[doc = "key register 5\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Keyr5Spec ; impl crate :: RegisterSpec for Keyr5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`keyr5::R`](R) reader structure"] impl crate :: Readable for Keyr5Spec { }
#[doc = "`write(|w| ..)` method takes [`keyr5::W`](W) writer structure"] impl crate :: Writable for Keyr5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets KEYR5 to value 0"] impl crate :: Resettable for Keyr5Spec { } }
#[doc = "KEYR6 (rw) register accessor: key register 6\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@keyr6`] module"]
#[doc (alias = "KEYR6")] pub type Keyr6 = crate :: Reg < keyr6 :: Keyr6Spec > ;
#[doc = "key register 6"] pub mod keyr6 {
#[doc = "Register `KEYR6` reader"] pub type R = crate :: R < Keyr6Spec > ;
#[doc = "Register `KEYR6` writer"] pub type W = crate :: W < Keyr6Spec > ;
#[doc = "Field `AES_KEYR6` reader - AES key register (MSB key \\[223:192\\])"] pub type AesKeyr6R = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_KEYR6` writer - AES key register (MSB key \\[223:192\\])"] pub type AesKeyr6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES key register (MSB key \\[223:192\\])"]
#[inline (always)] pub fn aes_keyr6 (& self) -> AesKeyr6R { AesKeyr6R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES key register (MSB key \\[223:192\\])"]
#[inline (always)] pub fn aes_keyr6 (& mut self) -> AesKeyr6W < '_ , Keyr6Spec > { AesKeyr6W :: new (self , 0) } }
#[doc = "key register 6\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Keyr6Spec ; impl crate :: RegisterSpec for Keyr6Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`keyr6::R`](R) reader structure"] impl crate :: Readable for Keyr6Spec { }
#[doc = "`write(|w| ..)` method takes [`keyr6::W`](W) writer structure"] impl crate :: Writable for Keyr6Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets KEYR6 to value 0"] impl crate :: Resettable for Keyr6Spec { } }
#[doc = "KEYR7 (rw) register accessor: key register 7\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr7::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr7::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@keyr7`] module"]
#[doc (alias = "KEYR7")] pub type Keyr7 = crate :: Reg < keyr7 :: Keyr7Spec > ;
#[doc = "key register 7"] pub mod keyr7 {
#[doc = "Register `KEYR7` reader"] pub type R = crate :: R < Keyr7Spec > ;
#[doc = "Register `KEYR7` writer"] pub type W = crate :: W < Keyr7Spec > ;
#[doc = "Field `AES_KEYR7` reader - AES key register (MSB key \\[255:224\\])"] pub type AesKeyr7R = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_KEYR7` writer - AES key register (MSB key \\[255:224\\])"] pub type AesKeyr7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES key register (MSB key \\[255:224\\])"]
#[inline (always)] pub fn aes_keyr7 (& self) -> AesKeyr7R { AesKeyr7R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES key register (MSB key \\[255:224\\])"]
#[inline (always)] pub fn aes_keyr7 (& mut self) -> AesKeyr7W < '_ , Keyr7Spec > { AesKeyr7W :: new (self , 0) } }
#[doc = "key register 7\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr7::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr7::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Keyr7Spec ; impl crate :: RegisterSpec for Keyr7Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`keyr7::R`](R) reader structure"] impl crate :: Readable for Keyr7Spec { }
#[doc = "`write(|w| ..)` method takes [`keyr7::W`](W) writer structure"] impl crate :: Writable for Keyr7Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets KEYR7 to value 0"] impl crate :: Resettable for Keyr7Spec { } }
#[doc = "SUSP0R (rw) register accessor: AES suspend register 0\n\nYou can [`read`](crate::Reg::read) this register and get [`susp0r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp0r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@susp0r`] module"]
#[doc (alias = "SUSP0R")] pub type Susp0r = crate :: Reg < susp0r :: Susp0rSpec > ;
#[doc = "AES suspend register 0"] pub mod susp0r {
#[doc = "Register `SUSP0R` reader"] pub type R = crate :: R < Susp0rSpec > ;
#[doc = "Register `SUSP0R` writer"] pub type W = crate :: W < Susp0rSpec > ;
#[doc = "Field `AES_SUSP0R` reader - AES suspend register 0"] pub type AesSusp0rR = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_SUSP0R` writer - AES suspend register 0"] pub type AesSusp0rW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES suspend register 0"]
#[inline (always)] pub fn aes_susp0r (& self) -> AesSusp0rR { AesSusp0rR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES suspend register 0"]
#[inline (always)] pub fn aes_susp0r (& mut self) -> AesSusp0rW < '_ , Susp0rSpec > { AesSusp0rW :: new (self , 0) } }
#[doc = "AES suspend register 0\n\nYou can [`read`](crate::Reg::read) this register and get [`susp0r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp0r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Susp0rSpec ; impl crate :: RegisterSpec for Susp0rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`susp0r::R`](R) reader structure"] impl crate :: Readable for Susp0rSpec { }
#[doc = "`write(|w| ..)` method takes [`susp0r::W`](W) writer structure"] impl crate :: Writable for Susp0rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SUSP0R to value 0"] impl crate :: Resettable for Susp0rSpec { } }
#[doc = "SUSP1R (rw) register accessor: AES suspend register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`susp1r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp1r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@susp1r`] module"]
#[doc (alias = "SUSP1R")] pub type Susp1r = crate :: Reg < susp1r :: Susp1rSpec > ;
#[doc = "AES suspend register 1"] pub mod susp1r {
#[doc = "Register `SUSP1R` reader"] pub type R = crate :: R < Susp1rSpec > ;
#[doc = "Register `SUSP1R` writer"] pub type W = crate :: W < Susp1rSpec > ;
#[doc = "Field `AES_SUSP1R` reader - AES suspend register 1"] pub type AesSusp1rR = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_SUSP1R` writer - AES suspend register 1"] pub type AesSusp1rW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES suspend register 1"]
#[inline (always)] pub fn aes_susp1r (& self) -> AesSusp1rR { AesSusp1rR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES suspend register 1"]
#[inline (always)] pub fn aes_susp1r (& mut self) -> AesSusp1rW < '_ , Susp1rSpec > { AesSusp1rW :: new (self , 0) } }
#[doc = "AES suspend register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`susp1r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp1r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Susp1rSpec ; impl crate :: RegisterSpec for Susp1rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`susp1r::R`](R) reader structure"] impl crate :: Readable for Susp1rSpec { }
#[doc = "`write(|w| ..)` method takes [`susp1r::W`](W) writer structure"] impl crate :: Writable for Susp1rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SUSP1R to value 0"] impl crate :: Resettable for Susp1rSpec { } }
#[doc = "SUSP2R (rw) register accessor: AES suspend register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`susp2r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp2r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@susp2r`] module"]
#[doc (alias = "SUSP2R")] pub type Susp2r = crate :: Reg < susp2r :: Susp2rSpec > ;
#[doc = "AES suspend register 2"] pub mod susp2r {
#[doc = "Register `SUSP2R` reader"] pub type R = crate :: R < Susp2rSpec > ;
#[doc = "Register `SUSP2R` writer"] pub type W = crate :: W < Susp2rSpec > ;
#[doc = "Field `AES_SUSP2R` reader - AES suspend register 2"] pub type AesSusp2rR = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_SUSP2R` writer - AES suspend register 2"] pub type AesSusp2rW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES suspend register 2"]
#[inline (always)] pub fn aes_susp2r (& self) -> AesSusp2rR { AesSusp2rR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES suspend register 2"]
#[inline (always)] pub fn aes_susp2r (& mut self) -> AesSusp2rW < '_ , Susp2rSpec > { AesSusp2rW :: new (self , 0) } }
#[doc = "AES suspend register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`susp2r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp2r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Susp2rSpec ; impl crate :: RegisterSpec for Susp2rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`susp2r::R`](R) reader structure"] impl crate :: Readable for Susp2rSpec { }
#[doc = "`write(|w| ..)` method takes [`susp2r::W`](W) writer structure"] impl crate :: Writable for Susp2rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SUSP2R to value 0"] impl crate :: Resettable for Susp2rSpec { } }
#[doc = "SUSP3R (rw) register accessor: AES suspend register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`susp3r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp3r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@susp3r`] module"]
#[doc (alias = "SUSP3R")] pub type Susp3r = crate :: Reg < susp3r :: Susp3rSpec > ;
#[doc = "AES suspend register 3"] pub mod susp3r {
#[doc = "Register `SUSP3R` reader"] pub type R = crate :: R < Susp3rSpec > ;
#[doc = "Register `SUSP3R` writer"] pub type W = crate :: W < Susp3rSpec > ;
#[doc = "Field `AES_SUSP3R` reader - AES suspend register 3"] pub type AesSusp3rR = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_SUSP3R` writer - AES suspend register 3"] pub type AesSusp3rW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES suspend register 3"]
#[inline (always)] pub fn aes_susp3r (& self) -> AesSusp3rR { AesSusp3rR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES suspend register 3"]
#[inline (always)] pub fn aes_susp3r (& mut self) -> AesSusp3rW < '_ , Susp3rSpec > { AesSusp3rW :: new (self , 0) } }
#[doc = "AES suspend register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`susp3r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp3r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Susp3rSpec ; impl crate :: RegisterSpec for Susp3rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`susp3r::R`](R) reader structure"] impl crate :: Readable for Susp3rSpec { }
#[doc = "`write(|w| ..)` method takes [`susp3r::W`](W) writer structure"] impl crate :: Writable for Susp3rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SUSP3R to value 0"] impl crate :: Resettable for Susp3rSpec { } }
#[doc = "SUSP4R (rw) register accessor: AES suspend register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`susp4r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp4r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@susp4r`] module"]
#[doc (alias = "SUSP4R")] pub type Susp4r = crate :: Reg < susp4r :: Susp4rSpec > ;
#[doc = "AES suspend register 4"] pub mod susp4r {
#[doc = "Register `SUSP4R` reader"] pub type R = crate :: R < Susp4rSpec > ;
#[doc = "Register `SUSP4R` writer"] pub type W = crate :: W < Susp4rSpec > ;
#[doc = "Field `AES_SUSP4R` reader - AES suspend register 4"] pub type AesSusp4rR = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_SUSP4R` writer - AES suspend register 4"] pub type AesSusp4rW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES suspend register 4"]
#[inline (always)] pub fn aes_susp4r (& self) -> AesSusp4rR { AesSusp4rR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES suspend register 4"]
#[inline (always)] pub fn aes_susp4r (& mut self) -> AesSusp4rW < '_ , Susp4rSpec > { AesSusp4rW :: new (self , 0) } }
#[doc = "AES suspend register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`susp4r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp4r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Susp4rSpec ; impl crate :: RegisterSpec for Susp4rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`susp4r::R`](R) reader structure"] impl crate :: Readable for Susp4rSpec { }
#[doc = "`write(|w| ..)` method takes [`susp4r::W`](W) writer structure"] impl crate :: Writable for Susp4rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SUSP4R to value 0"] impl crate :: Resettable for Susp4rSpec { } }
#[doc = "SUSP5R (rw) register accessor: AES suspend register 5\n\nYou can [`read`](crate::Reg::read) this register and get [`susp5r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp5r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@susp5r`] module"]
#[doc (alias = "SUSP5R")] pub type Susp5r = crate :: Reg < susp5r :: Susp5rSpec > ;
#[doc = "AES suspend register 5"] pub mod susp5r {
#[doc = "Register `SUSP5R` reader"] pub type R = crate :: R < Susp5rSpec > ;
#[doc = "Register `SUSP5R` writer"] pub type W = crate :: W < Susp5rSpec > ;
#[doc = "Field `AES_SUSP5R` reader - AES suspend register 5"] pub type AesSusp5rR = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_SUSP5R` writer - AES suspend register 5"] pub type AesSusp5rW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES suspend register 5"]
#[inline (always)] pub fn aes_susp5r (& self) -> AesSusp5rR { AesSusp5rR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES suspend register 5"]
#[inline (always)] pub fn aes_susp5r (& mut self) -> AesSusp5rW < '_ , Susp5rSpec > { AesSusp5rW :: new (self , 0) } }
#[doc = "AES suspend register 5\n\nYou can [`read`](crate::Reg::read) this register and get [`susp5r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp5r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Susp5rSpec ; impl crate :: RegisterSpec for Susp5rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`susp5r::R`](R) reader structure"] impl crate :: Readable for Susp5rSpec { }
#[doc = "`write(|w| ..)` method takes [`susp5r::W`](W) writer structure"] impl crate :: Writable for Susp5rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SUSP5R to value 0"] impl crate :: Resettable for Susp5rSpec { } }
#[doc = "SUSP6R (rw) register accessor: AES suspend register 6\n\nYou can [`read`](crate::Reg::read) this register and get [`susp6r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp6r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@susp6r`] module"]
#[doc (alias = "SUSP6R")] pub type Susp6r = crate :: Reg < susp6r :: Susp6rSpec > ;
#[doc = "AES suspend register 6"] pub mod susp6r {
#[doc = "Register `SUSP6R` reader"] pub type R = crate :: R < Susp6rSpec > ;
#[doc = "Register `SUSP6R` writer"] pub type W = crate :: W < Susp6rSpec > ;
#[doc = "Field `AES_SUSP6R` reader - AES suspend register 6"] pub type AesSusp6rR = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_SUSP6R` writer - AES suspend register 6"] pub type AesSusp6rW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES suspend register 6"]
#[inline (always)] pub fn aes_susp6r (& self) -> AesSusp6rR { AesSusp6rR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES suspend register 6"]
#[inline (always)] pub fn aes_susp6r (& mut self) -> AesSusp6rW < '_ , Susp6rSpec > { AesSusp6rW :: new (self , 0) } }
#[doc = "AES suspend register 6\n\nYou can [`read`](crate::Reg::read) this register and get [`susp6r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp6r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Susp6rSpec ; impl crate :: RegisterSpec for Susp6rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`susp6r::R`](R) reader structure"] impl crate :: Readable for Susp6rSpec { }
#[doc = "`write(|w| ..)` method takes [`susp6r::W`](W) writer structure"] impl crate :: Writable for Susp6rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SUSP6R to value 0"] impl crate :: Resettable for Susp6rSpec { } }
#[doc = "SUSP7R (rw) register accessor: AES suspend register 7\n\nYou can [`read`](crate::Reg::read) this register and get [`susp7r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp7r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@susp7r`] module"]
#[doc (alias = "SUSP7R")] pub type Susp7r = crate :: Reg < susp7r :: Susp7rSpec > ;
#[doc = "AES suspend register 7"] pub mod susp7r {
#[doc = "Register `SUSP7R` reader"] pub type R = crate :: R < Susp7rSpec > ;
#[doc = "Register `SUSP7R` writer"] pub type W = crate :: W < Susp7rSpec > ;
#[doc = "Field `AES_SUSP7R` reader - AES suspend register 7"] pub type AesSusp7rR = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_SUSP7R` writer - AES suspend register 7"] pub type AesSusp7rW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES suspend register 7"]
#[inline (always)] pub fn aes_susp7r (& self) -> AesSusp7rR { AesSusp7rR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES suspend register 7"]
#[inline (always)] pub fn aes_susp7r (& mut self) -> AesSusp7rW < '_ , Susp7rSpec > { AesSusp7rW :: new (self , 0) } }
#[doc = "AES suspend register 7\n\nYou can [`read`](crate::Reg::read) this register and get [`susp7r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp7r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Susp7rSpec ; impl crate :: RegisterSpec for Susp7rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`susp7r::R`](R) reader structure"] impl crate :: Readable for Susp7rSpec { }
#[doc = "`write(|w| ..)` method takes [`susp7r::W`](W) writer structure"] impl crate :: Writable for Susp7rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SUSP7R to value 0"] impl crate :: Resettable for Susp7rSpec { } }
#[doc = "HWCFR (r) register accessor: AES hardware configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`hwcfr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hwcfr`] module"]
#[doc (alias = "HWCFR")] pub type Hwcfr = crate :: Reg < hwcfr :: HwcfrSpec > ;
#[doc = "AES hardware configuration register"] pub mod hwcfr {
#[doc = "Register `HWCFR` reader"] pub type R = crate :: R < HwcfrSpec > ;
#[doc = "Field `CFG1` reader - HW Generic 1"] pub type Cfg1R = crate :: FieldReader ;
#[doc = "Field `CFG2` reader - HW Generic 2"] pub type Cfg2R = crate :: FieldReader ;
#[doc = "Field `CFG3` reader - HW Generic 3"] pub type Cfg3R = crate :: FieldReader ;
#[doc = "Field `CFG4` reader - HW Generic 4"] pub type Cfg4R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:3 - HW Generic 1"]
#[inline (always)] pub fn cfg1 (& self) -> Cfg1R { Cfg1R :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - HW Generic 2"]
#[inline (always)] pub fn cfg2 (& self) -> Cfg2R { Cfg2R :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:11 - HW Generic 3"]
#[inline (always)] pub fn cfg3 (& self) -> Cfg3R { Cfg3R :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:15 - HW Generic 4"]
#[inline (always)] pub fn cfg4 (& self) -> Cfg4R { Cfg4R :: new (((self . bits >> 12) & 0x0f) as u8) } }
#[doc = "AES hardware configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`hwcfr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct HwcfrSpec ; impl crate :: RegisterSpec for HwcfrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`hwcfr::R`](R) reader structure"] impl crate :: Readable for HwcfrSpec { }
#[doc = "`reset()` method sets HWCFR to value 0x02"] impl crate :: Resettable for HwcfrSpec { const RESET_VALUE : u32 = 0x02 ; } }
#[doc = "VERR (r) register accessor: AES version register\n\nYou can [`read`](crate::Reg::read) this register and get [`verr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@verr`] module"]
#[doc (alias = "VERR")] pub type Verr = crate :: Reg < verr :: VerrSpec > ;
#[doc = "AES version register"] pub mod verr {
#[doc = "Register `VERR` reader"] pub type R = crate :: R < VerrSpec > ;
#[doc = "Field `MINREV` reader - Minor revision"] pub type MinrevR = crate :: FieldReader ;
#[doc = "Field `MAJREV` reader - Major revision"] pub type MajrevR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:3 - Minor revision"]
#[inline (always)] pub fn minrev (& self) -> MinrevR { MinrevR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - Major revision"]
#[inline (always)] pub fn majrev (& self) -> MajrevR { MajrevR :: new (((self . bits >> 4) & 0x0f) as u8) } }
#[doc = "AES version register\n\nYou can [`read`](crate::Reg::read) this register and get [`verr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct VerrSpec ; impl crate :: RegisterSpec for VerrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`verr::R`](R) reader structure"] impl crate :: Readable for VerrSpec { }
#[doc = "`reset()` method sets VERR to value 0x10"] impl crate :: Resettable for VerrSpec { const RESET_VALUE : u32 = 0x10 ; } }
#[doc = "IPIDR (r) register accessor: AES identification register\n\nYou can [`read`](crate::Reg::read) this register and get [`ipidr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ipidr`] module"]
#[doc (alias = "IPIDR")] pub type Ipidr = crate :: Reg < ipidr :: IpidrSpec > ;
#[doc = "AES identification register"] pub mod ipidr {
#[doc = "Register `IPIDR` reader"] pub type R = crate :: R < IpidrSpec > ;
#[doc = "Field `ID` reader - Identification code"] pub type IdR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Identification code"]
#[inline (always)] pub fn id (& self) -> IdR { IdR :: new (self . bits) } }
#[doc = "AES identification register\n\nYou can [`read`](crate::Reg::read) this register and get [`ipidr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IpidrSpec ; impl crate :: RegisterSpec for IpidrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ipidr::R`](R) reader structure"] impl crate :: Readable for IpidrSpec { }
#[doc = "`reset()` method sets IPIDR to value 0x0017_0023"] impl crate :: Resettable for IpidrSpec { const RESET_VALUE : u32 = 0x0017_0023 ; } }
#[doc = "SIDR (r) register accessor: AES size ID register\n\nYou can [`read`](crate::Reg::read) this register and get [`sidr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sidr`] module"]
#[doc (alias = "SIDR")] pub type Sidr = crate :: Reg < sidr :: SidrSpec > ;
#[doc = "AES size ID register"] pub mod sidr {
#[doc = "Register `SIDR` reader"] pub type R = crate :: R < SidrSpec > ;
#[doc = "Field `ID` reader - Size Identification code"] pub type IdR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Size Identification code"]
#[inline (always)] pub fn id (& self) -> IdR { IdR :: new (self . bits) } }
#[doc = "AES size ID register\n\nYou can [`read`](crate::Reg::read) this register and get [`sidr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SidrSpec ; impl crate :: RegisterSpec for SidrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sidr::R`](R) reader structure"] impl crate :: Readable for SidrSpec { }
#[doc = "`reset()` method sets SIDR to value 0xa3c5_dd01"] impl crate :: Resettable for SidrSpec { const RESET_VALUE : u32 = 0xa3c5_dd01 ; } } }
#[doc = "Advanced encryption standard hardware accelerator 1"] pub type Aes2 = crate :: Periph < aes2 :: RegisterBlock , 0x5800_1800 > ; impl core :: fmt :: Debug for Aes2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Aes2") . finish () } }
#[doc = "Advanced encryption standard hardware accelerator 1"] pub mod aes2 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr : Cr , sr : Sr , dinr : Dinr , doutr : Doutr , keyr0 : Keyr0 , keyr1 : Keyr1 , keyr2 : Keyr2 , keyr3 : Keyr3 , ivr0 : Ivr0 , ivr1 : Ivr1 , ivr2 : Ivr2 , ivr3 : Ivr3 , keyr4 : Keyr4 , keyr5 : Keyr5 , keyr6 : Keyr6 , keyr7 : Keyr7 , susp0r : Susp0r , susp1r : Susp1r , susp2r : Susp2r , susp3r : Susp3r , susp4r : Susp4r , susp5r : Susp5r , susp6r : Susp6r , susp7r : Susp7r , hwcfr : Hwcfr , verr : Verr , ipidr : Ipidr , sidr : Sidr , } impl RegisterBlock {
#[doc = "0x00 - control register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x04 - status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x08 - data input register"]
#[inline (always)] pub const fn dinr (& self) -> & Dinr { & self . dinr }
#[doc = "0x0c - data output register"]
#[inline (always)] pub const fn doutr (& self) -> & Doutr { & self . doutr }
#[doc = "0x10 - key register 0"]
#[inline (always)] pub const fn keyr0 (& self) -> & Keyr0 { & self . keyr0 }
#[doc = "0x14 - key register 1"]
#[inline (always)] pub const fn keyr1 (& self) -> & Keyr1 { & self . keyr1 }
#[doc = "0x18 - key register 2"]
#[inline (always)] pub const fn keyr2 (& self) -> & Keyr2 { & self . keyr2 }
#[doc = "0x1c - key register 3"]
#[inline (always)] pub const fn keyr3 (& self) -> & Keyr3 { & self . keyr3 }
#[doc = "0x20 - initialization vector register 0"]
#[inline (always)] pub const fn ivr0 (& self) -> & Ivr0 { & self . ivr0 }
#[doc = "0x24 - initialization vector register 1"]
#[inline (always)] pub const fn ivr1 (& self) -> & Ivr1 { & self . ivr1 }
#[doc = "0x28 - initialization vector register 2"]
#[inline (always)] pub const fn ivr2 (& self) -> & Ivr2 { & self . ivr2 }
#[doc = "0x2c - initialization vector register 3"]
#[inline (always)] pub const fn ivr3 (& self) -> & Ivr3 { & self . ivr3 }
#[doc = "0x30 - key register 4"]
#[inline (always)] pub const fn keyr4 (& self) -> & Keyr4 { & self . keyr4 }
#[doc = "0x34 - key register 5"]
#[inline (always)] pub const fn keyr5 (& self) -> & Keyr5 { & self . keyr5 }
#[doc = "0x38 - key register 6"]
#[inline (always)] pub const fn keyr6 (& self) -> & Keyr6 { & self . keyr6 }
#[doc = "0x3c - key register 7"]
#[inline (always)] pub const fn keyr7 (& self) -> & Keyr7 { & self . keyr7 }
#[doc = "0x40 - AES suspend register 0"]
#[inline (always)] pub const fn susp0r (& self) -> & Susp0r { & self . susp0r }
#[doc = "0x44 - AES suspend register 1"]
#[inline (always)] pub const fn susp1r (& self) -> & Susp1r { & self . susp1r }
#[doc = "0x48 - AES suspend register 2"]
#[inline (always)] pub const fn susp2r (& self) -> & Susp2r { & self . susp2r }
#[doc = "0x4c - AES suspend register 3"]
#[inline (always)] pub const fn susp3r (& self) -> & Susp3r { & self . susp3r }
#[doc = "0x50 - AES suspend register 4"]
#[inline (always)] pub const fn susp4r (& self) -> & Susp4r { & self . susp4r }
#[doc = "0x54 - AES suspend register 5"]
#[inline (always)] pub const fn susp5r (& self) -> & Susp5r { & self . susp5r }
#[doc = "0x58 - AES suspend register 6"]
#[inline (always)] pub const fn susp6r (& self) -> & Susp6r { & self . susp6r }
#[doc = "0x5c - AES suspend register 7"]
#[inline (always)] pub const fn susp7r (& self) -> & Susp7r { & self . susp7r }
#[doc = "0x60 - AES hardware configuration register"]
#[inline (always)] pub const fn hwcfr (& self) -> & Hwcfr { & self . hwcfr }
#[doc = "0x64 - AES version register"]
#[inline (always)] pub const fn verr (& self) -> & Verr { & self . verr }
#[doc = "0x68 - AES identification register"]
#[inline (always)] pub const fn ipidr (& self) -> & Ipidr { & self . ipidr }
#[doc = "0x6c - AES size ID register"]
#[inline (always)] pub const fn sidr (& self) -> & Sidr { & self . sidr } }
#[doc = "CR (rw) register accessor: control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "control register"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `EN` reader - AES enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - AES enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DATATYPE` reader - Data type selection (for data in and data out to/from the cryptographic block)"] pub type DatatypeR = crate :: FieldReader ;
#[doc = "Field `DATATYPE` writer - Data type selection (for data in and data out to/from the cryptographic block)"] pub type DatatypeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE` reader - AES operating mode"] pub type ModeR = crate :: FieldReader ;
#[doc = "Field `MODE` writer - AES operating mode"] pub type ModeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CHMOD10` reader - AES chaining mode Bit1 Bit0"] pub type Chmod10R = crate :: FieldReader ;
#[doc = "Field `CHMOD10` writer - AES chaining mode Bit1 Bit0"] pub type Chmod10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CCFC` reader - Computation Complete Flag Clear"] pub type CcfcR = crate :: BitReader ;
#[doc = "Field `CCFC` writer - Computation Complete Flag Clear"] pub type CcfcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ERRC` reader - Error clear"] pub type ErrcR = crate :: BitReader ;
#[doc = "Field `ERRC` writer - Error clear"] pub type ErrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CCFIE` reader - CCF flag interrupt enable"] pub type CcfieR = crate :: BitReader ;
#[doc = "Field `CCFIE` writer - CCF flag interrupt enable"] pub type CcfieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ERRIE` reader - Error interrupt enable"] pub type ErrieR = crate :: BitReader ;
#[doc = "Field `ERRIE` writer - Error interrupt enable"] pub type ErrieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMAINEN` reader - Enable DMA management of data input phase"] pub type DmainenR = crate :: BitReader ;
#[doc = "Field `DMAINEN` writer - Enable DMA management of data input phase"] pub type DmainenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMAOUTEN` reader - Enable DMA management of data output phase"] pub type DmaoutenR = crate :: BitReader ;
#[doc = "Field `DMAOUTEN` writer - Enable DMA management of data output phase"] pub type DmaoutenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GCMPH` reader - Used only for GCM, CCM and GMAC algorithms and has no effect when other algorithms are selected"] pub type GcmphR = crate :: FieldReader ;
#[doc = "Field `GCMPH` writer - Used only for GCM, CCM and GMAC algorithms and has no effect when other algorithms are selected"] pub type GcmphW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CHMOD2` reader - AES chaining mode Bit2"] pub type Chmod2R = crate :: BitReader ;
#[doc = "Field `CHMOD2` writer - AES chaining mode Bit2"] pub type Chmod2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `KEYSIZE` reader - Key size selection"] pub type KeysizeR = crate :: BitReader ;
#[doc = "Field `KEYSIZE` writer - Key size selection"] pub type KeysizeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NPBLB` reader - Number of padding bytes in last block of payload"] pub type NpblbR = crate :: FieldReader ;
#[doc = "Field `NPBLB` writer - Number of padding bytes in last block of payload"] pub type NpblbW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bit 0 - AES enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bits 1:2 - Data type selection (for data in and data out to/from the cryptographic block)"]
#[inline (always)] pub fn datatype (& self) -> DatatypeR { DatatypeR :: new (((self . bits >> 1) & 3) as u8) }
#[doc = "Bits 3:4 - AES operating mode"]
#[inline (always)] pub fn mode (& self) -> ModeR { ModeR :: new (((self . bits >> 3) & 3) as u8) }
#[doc = "Bits 5:6 - AES chaining mode Bit1 Bit0"]
#[inline (always)] pub fn chmod10 (& self) -> Chmod10R { Chmod10R :: new (((self . bits >> 5) & 3) as u8) }
#[doc = "Bit 7 - Computation Complete Flag Clear"]
#[inline (always)] pub fn ccfc (& self) -> CcfcR { CcfcR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Error clear"]
#[inline (always)] pub fn errc (& self) -> ErrcR { ErrcR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - CCF flag interrupt enable"]
#[inline (always)] pub fn ccfie (& self) -> CcfieR { CcfieR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Error interrupt enable"]
#[inline (always)] pub fn errie (& self) -> ErrieR { ErrieR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Enable DMA management of data input phase"]
#[inline (always)] pub fn dmainen (& self) -> DmainenR { DmainenR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Enable DMA management of data output phase"]
#[inline (always)] pub fn dmaouten (& self) -> DmaoutenR { DmaoutenR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bits 13:14 - Used only for GCM, CCM and GMAC algorithms and has no effect when other algorithms are selected"]
#[inline (always)] pub fn gcmph (& self) -> GcmphR { GcmphR :: new (((self . bits >> 13) & 3) as u8) }
#[doc = "Bit 16 - AES chaining mode Bit2"]
#[inline (always)] pub fn chmod2 (& self) -> Chmod2R { Chmod2R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 18 - Key size selection"]
#[inline (always)] pub fn keysize (& self) -> KeysizeR { KeysizeR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bits 20:23 - Number of padding bytes in last block of payload"]
#[inline (always)] pub fn npblb (& self) -> NpblbR { NpblbR :: new (((self . bits >> 20) & 0x0f) as u8) } } impl W {
#[doc = "Bit 0 - AES enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , CrSpec > { EnW :: new (self , 0) }
#[doc = "Bits 1:2 - Data type selection (for data in and data out to/from the cryptographic block)"]
#[inline (always)] pub fn datatype (& mut self) -> DatatypeW < '_ , CrSpec > { DatatypeW :: new (self , 1) }
#[doc = "Bits 3:4 - AES operating mode"]
#[inline (always)] pub fn mode (& mut self) -> ModeW < '_ , CrSpec > { ModeW :: new (self , 3) }
#[doc = "Bits 5:6 - AES chaining mode Bit1 Bit0"]
#[inline (always)] pub fn chmod10 (& mut self) -> Chmod10W < '_ , CrSpec > { Chmod10W :: new (self , 5) }
#[doc = "Bit 7 - Computation Complete Flag Clear"]
#[inline (always)] pub fn ccfc (& mut self) -> CcfcW < '_ , CrSpec > { CcfcW :: new (self , 7) }
#[doc = "Bit 8 - Error clear"]
#[inline (always)] pub fn errc (& mut self) -> ErrcW < '_ , CrSpec > { ErrcW :: new (self , 8) }
#[doc = "Bit 9 - CCF flag interrupt enable"]
#[inline (always)] pub fn ccfie (& mut self) -> CcfieW < '_ , CrSpec > { CcfieW :: new (self , 9) }
#[doc = "Bit 10 - Error interrupt enable"]
#[inline (always)] pub fn errie (& mut self) -> ErrieW < '_ , CrSpec > { ErrieW :: new (self , 10) }
#[doc = "Bit 11 - Enable DMA management of data input phase"]
#[inline (always)] pub fn dmainen (& mut self) -> DmainenW < '_ , CrSpec > { DmainenW :: new (self , 11) }
#[doc = "Bit 12 - Enable DMA management of data output phase"]
#[inline (always)] pub fn dmaouten (& mut self) -> DmaoutenW < '_ , CrSpec > { DmaoutenW :: new (self , 12) }
#[doc = "Bits 13:14 - Used only for GCM, CCM and GMAC algorithms and has no effect when other algorithms are selected"]
#[inline (always)] pub fn gcmph (& mut self) -> GcmphW < '_ , CrSpec > { GcmphW :: new (self , 13) }
#[doc = "Bit 16 - AES chaining mode Bit2"]
#[inline (always)] pub fn chmod2 (& mut self) -> Chmod2W < '_ , CrSpec > { Chmod2W :: new (self , 16) }
#[doc = "Bit 18 - Key size selection"]
#[inline (always)] pub fn keysize (& mut self) -> KeysizeW < '_ , CrSpec > { KeysizeW :: new (self , 18) }
#[doc = "Bits 20:23 - Number of padding bytes in last block of payload"]
#[inline (always)] pub fn npblb (& mut self) -> NpblbW < '_ , CrSpec > { NpblbW :: new (self , 20) } }
#[doc = "control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { } }
#[doc = "SR (r) register accessor: status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Field `CCF` reader - Computation complete flag"] pub type CcfR = crate :: BitReader ;
#[doc = "Field `RDERR` reader - Read error flag"] pub type RderrR = crate :: BitReader ;
#[doc = "Field `WRERR` reader - Write error flag"] pub type WrerrR = crate :: BitReader ;
#[doc = "Field `BUSY` reader - Busy flag"] pub type BusyR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Computation complete flag"]
#[inline (always)] pub fn ccf (& self) -> CcfR { CcfR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Read error flag"]
#[inline (always)] pub fn rderr (& self) -> RderrR { RderrR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Write error flag"]
#[inline (always)] pub fn wrerr (& self) -> WrerrR { WrerrR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Busy flag"]
#[inline (always)] pub fn busy (& self) -> BusyR { BusyR :: new (((self . bits >> 3) & 1) != 0) } }
#[doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "DINR (rw) register accessor: data input register\n\nYou can [`read`](crate::Reg::read) this register and get [`dinr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dinr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dinr`] module"]
#[doc (alias = "DINR")] pub type Dinr = crate :: Reg < dinr :: DinrSpec > ;
#[doc = "data input register"] pub mod dinr {
#[doc = "Register `DINR` reader"] pub type R = crate :: R < DinrSpec > ;
#[doc = "Register `DINR` writer"] pub type W = crate :: W < DinrSpec > ;
#[doc = "Field `AES_DINR` reader - Data Input Register"] pub type AesDinrR = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_DINR` writer - Data Input Register"] pub type AesDinrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Data Input Register"]
#[inline (always)] pub fn aes_dinr (& self) -> AesDinrR { AesDinrR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Data Input Register"]
#[inline (always)] pub fn aes_dinr (& mut self) -> AesDinrW < '_ , DinrSpec > { AesDinrW :: new (self , 0) } }
#[doc = "data input register\n\nYou can [`read`](crate::Reg::read) this register and get [`dinr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dinr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DinrSpec ; impl crate :: RegisterSpec for DinrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dinr::R`](R) reader structure"] impl crate :: Readable for DinrSpec { }
#[doc = "`write(|w| ..)` method takes [`dinr::W`](W) writer structure"] impl crate :: Writable for DinrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DINR to value 0"] impl crate :: Resettable for DinrSpec { } }
#[doc = "DOUTR (r) register accessor: data output register\n\nYou can [`read`](crate::Reg::read) this register and get [`doutr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@doutr`] module"]
#[doc (alias = "DOUTR")] pub type Doutr = crate :: Reg < doutr :: DoutrSpec > ;
#[doc = "data output register"] pub mod doutr {
#[doc = "Register `DOUTR` reader"] pub type R = crate :: R < DoutrSpec > ;
#[doc = "Field `AES_DOUTR` reader - Data output register"] pub type AesDoutrR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Data output register"]
#[inline (always)] pub fn aes_doutr (& self) -> AesDoutrR { AesDoutrR :: new (self . bits) } }
#[doc = "data output register\n\nYou can [`read`](crate::Reg::read) this register and get [`doutr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DoutrSpec ; impl crate :: RegisterSpec for DoutrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`doutr::R`](R) reader structure"] impl crate :: Readable for DoutrSpec { }
#[doc = "`reset()` method sets DOUTR to value 0"] impl crate :: Resettable for DoutrSpec { } }
#[doc = "KEYR0 (rw) register accessor: key register 0\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@keyr0`] module"]
#[doc (alias = "KEYR0")] pub type Keyr0 = crate :: Reg < keyr0 :: Keyr0Spec > ;
#[doc = "key register 0"] pub mod keyr0 {
#[doc = "Register `KEYR0` reader"] pub type R = crate :: R < Keyr0Spec > ;
#[doc = "Register `KEYR0` writer"] pub type W = crate :: W < Keyr0Spec > ;
#[doc = "Field `AES_KEYR0` reader - Data Output Register (LSB key \\[31:0\\])"] pub type AesKeyr0R = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_KEYR0` writer - Data Output Register (LSB key \\[31:0\\])"] pub type AesKeyr0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Data Output Register (LSB key \\[31:0\\])"]
#[inline (always)] pub fn aes_keyr0 (& self) -> AesKeyr0R { AesKeyr0R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Data Output Register (LSB key \\[31:0\\])"]
#[inline (always)] pub fn aes_keyr0 (& mut self) -> AesKeyr0W < '_ , Keyr0Spec > { AesKeyr0W :: new (self , 0) } }
#[doc = "key register 0\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Keyr0Spec ; impl crate :: RegisterSpec for Keyr0Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`keyr0::R`](R) reader structure"] impl crate :: Readable for Keyr0Spec { }
#[doc = "`write(|w| ..)` method takes [`keyr0::W`](W) writer structure"] impl crate :: Writable for Keyr0Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets KEYR0 to value 0"] impl crate :: Resettable for Keyr0Spec { } }
#[doc = "KEYR1 (rw) register accessor: key register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@keyr1`] module"]
#[doc (alias = "KEYR1")] pub type Keyr1 = crate :: Reg < keyr1 :: Keyr1Spec > ;
#[doc = "key register 1"] pub mod keyr1 {
#[doc = "Register `KEYR1` reader"] pub type R = crate :: R < Keyr1Spec > ;
#[doc = "Register `KEYR1` writer"] pub type W = crate :: W < Keyr1Spec > ;
#[doc = "Field `AES_KEYR1` reader - AES key register (key \\[63:32\\])"] pub type AesKeyr1R = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_KEYR1` writer - AES key register (key \\[63:32\\])"] pub type AesKeyr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES key register (key \\[63:32\\])"]
#[inline (always)] pub fn aes_keyr1 (& self) -> AesKeyr1R { AesKeyr1R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES key register (key \\[63:32\\])"]
#[inline (always)] pub fn aes_keyr1 (& mut self) -> AesKeyr1W < '_ , Keyr1Spec > { AesKeyr1W :: new (self , 0) } }
#[doc = "key register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Keyr1Spec ; impl crate :: RegisterSpec for Keyr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`keyr1::R`](R) reader structure"] impl crate :: Readable for Keyr1Spec { }
#[doc = "`write(|w| ..)` method takes [`keyr1::W`](W) writer structure"] impl crate :: Writable for Keyr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets KEYR1 to value 0"] impl crate :: Resettable for Keyr1Spec { } }
#[doc = "KEYR2 (rw) register accessor: key register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@keyr2`] module"]
#[doc (alias = "KEYR2")] pub type Keyr2 = crate :: Reg < keyr2 :: Keyr2Spec > ;
#[doc = "key register 2"] pub mod keyr2 {
#[doc = "Register `KEYR2` reader"] pub type R = crate :: R < Keyr2Spec > ;
#[doc = "Register `KEYR2` writer"] pub type W = crate :: W < Keyr2Spec > ;
#[doc = "Field `AES_KEYR2` reader - AES key register (key \\[95:64\\])"] pub type AesKeyr2R = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_KEYR2` writer - AES key register (key \\[95:64\\])"] pub type AesKeyr2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES key register (key \\[95:64\\])"]
#[inline (always)] pub fn aes_keyr2 (& self) -> AesKeyr2R { AesKeyr2R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES key register (key \\[95:64\\])"]
#[inline (always)] pub fn aes_keyr2 (& mut self) -> AesKeyr2W < '_ , Keyr2Spec > { AesKeyr2W :: new (self , 0) } }
#[doc = "key register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Keyr2Spec ; impl crate :: RegisterSpec for Keyr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`keyr2::R`](R) reader structure"] impl crate :: Readable for Keyr2Spec { }
#[doc = "`write(|w| ..)` method takes [`keyr2::W`](W) writer structure"] impl crate :: Writable for Keyr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets KEYR2 to value 0"] impl crate :: Resettable for Keyr2Spec { } }
#[doc = "KEYR3 (rw) register accessor: key register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@keyr3`] module"]
#[doc (alias = "KEYR3")] pub type Keyr3 = crate :: Reg < keyr3 :: Keyr3Spec > ;
#[doc = "key register 3"] pub mod keyr3 {
#[doc = "Register `KEYR3` reader"] pub type R = crate :: R < Keyr3Spec > ;
#[doc = "Register `KEYR3` writer"] pub type W = crate :: W < Keyr3Spec > ;
#[doc = "Field `AES_KEYR3` reader - AES key register (MSB key \\[127:96\\])"] pub type AesKeyr3R = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_KEYR3` writer - AES key register (MSB key \\[127:96\\])"] pub type AesKeyr3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES key register (MSB key \\[127:96\\])"]
#[inline (always)] pub fn aes_keyr3 (& self) -> AesKeyr3R { AesKeyr3R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES key register (MSB key \\[127:96\\])"]
#[inline (always)] pub fn aes_keyr3 (& mut self) -> AesKeyr3W < '_ , Keyr3Spec > { AesKeyr3W :: new (self , 0) } }
#[doc = "key register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Keyr3Spec ; impl crate :: RegisterSpec for Keyr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`keyr3::R`](R) reader structure"] impl crate :: Readable for Keyr3Spec { }
#[doc = "`write(|w| ..)` method takes [`keyr3::W`](W) writer structure"] impl crate :: Writable for Keyr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets KEYR3 to value 0"] impl crate :: Resettable for Keyr3Spec { } }
#[doc = "IVR0 (rw) register accessor: initialization vector register 0\n\nYou can [`read`](crate::Reg::read) this register and get [`ivr0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ivr0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ivr0`] module"]
#[doc (alias = "IVR0")] pub type Ivr0 = crate :: Reg < ivr0 :: Ivr0Spec > ;
#[doc = "initialization vector register 0"] pub mod ivr0 {
#[doc = "Register `IVR0` reader"] pub type R = crate :: R < Ivr0Spec > ;
#[doc = "Register `IVR0` writer"] pub type W = crate :: W < Ivr0Spec > ;
#[doc = "Field `AES_IVR0` reader - initialization vector register (LSB IVR \\[31:0\\])"] pub type AesIvr0R = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_IVR0` writer - initialization vector register (LSB IVR \\[31:0\\])"] pub type AesIvr0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - initialization vector register (LSB IVR \\[31:0\\])"]
#[inline (always)] pub fn aes_ivr0 (& self) -> AesIvr0R { AesIvr0R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - initialization vector register (LSB IVR \\[31:0\\])"]
#[inline (always)] pub fn aes_ivr0 (& mut self) -> AesIvr0W < '_ , Ivr0Spec > { AesIvr0W :: new (self , 0) } }
#[doc = "initialization vector register 0\n\nYou can [`read`](crate::Reg::read) this register and get [`ivr0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ivr0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ivr0Spec ; impl crate :: RegisterSpec for Ivr0Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ivr0::R`](R) reader structure"] impl crate :: Readable for Ivr0Spec { }
#[doc = "`write(|w| ..)` method takes [`ivr0::W`](W) writer structure"] impl crate :: Writable for Ivr0Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IVR0 to value 0"] impl crate :: Resettable for Ivr0Spec { } }
#[doc = "IVR1 (rw) register accessor: initialization vector register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ivr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ivr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ivr1`] module"]
#[doc (alias = "IVR1")] pub type Ivr1 = crate :: Reg < ivr1 :: Ivr1Spec > ;
#[doc = "initialization vector register 1"] pub mod ivr1 {
#[doc = "Register `IVR1` reader"] pub type R = crate :: R < Ivr1Spec > ;
#[doc = "Register `IVR1` writer"] pub type W = crate :: W < Ivr1Spec > ;
#[doc = "Field `AES_IVR1` reader - Initialization Vector Register (IVR \\[63:32\\])"] pub type AesIvr1R = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_IVR1` writer - Initialization Vector Register (IVR \\[63:32\\])"] pub type AesIvr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Initialization Vector Register (IVR \\[63:32\\])"]
#[inline (always)] pub fn aes_ivr1 (& self) -> AesIvr1R { AesIvr1R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Initialization Vector Register (IVR \\[63:32\\])"]
#[inline (always)] pub fn aes_ivr1 (& mut self) -> AesIvr1W < '_ , Ivr1Spec > { AesIvr1W :: new (self , 0) } }
#[doc = "initialization vector register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ivr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ivr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ivr1Spec ; impl crate :: RegisterSpec for Ivr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ivr1::R`](R) reader structure"] impl crate :: Readable for Ivr1Spec { }
#[doc = "`write(|w| ..)` method takes [`ivr1::W`](W) writer structure"] impl crate :: Writable for Ivr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IVR1 to value 0"] impl crate :: Resettable for Ivr1Spec { } }
#[doc = "IVR2 (rw) register accessor: initialization vector register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ivr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ivr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ivr2`] module"]
#[doc (alias = "IVR2")] pub type Ivr2 = crate :: Reg < ivr2 :: Ivr2Spec > ;
#[doc = "initialization vector register 2"] pub mod ivr2 {
#[doc = "Register `IVR2` reader"] pub type R = crate :: R < Ivr2Spec > ;
#[doc = "Register `IVR2` writer"] pub type W = crate :: W < Ivr2Spec > ;
#[doc = "Field `AES_IVR2` reader - Initialization Vector Register (IVR \\[95:64\\])"] pub type AesIvr2R = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_IVR2` writer - Initialization Vector Register (IVR \\[95:64\\])"] pub type AesIvr2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Initialization Vector Register (IVR \\[95:64\\])"]
#[inline (always)] pub fn aes_ivr2 (& self) -> AesIvr2R { AesIvr2R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Initialization Vector Register (IVR \\[95:64\\])"]
#[inline (always)] pub fn aes_ivr2 (& mut self) -> AesIvr2W < '_ , Ivr2Spec > { AesIvr2W :: new (self , 0) } }
#[doc = "initialization vector register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ivr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ivr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ivr2Spec ; impl crate :: RegisterSpec for Ivr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ivr2::R`](R) reader structure"] impl crate :: Readable for Ivr2Spec { }
#[doc = "`write(|w| ..)` method takes [`ivr2::W`](W) writer structure"] impl crate :: Writable for Ivr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IVR2 to value 0"] impl crate :: Resettable for Ivr2Spec { } }
#[doc = "IVR3 (rw) register accessor: initialization vector register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`ivr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ivr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ivr3`] module"]
#[doc (alias = "IVR3")] pub type Ivr3 = crate :: Reg < ivr3 :: Ivr3Spec > ;
#[doc = "initialization vector register 3"] pub mod ivr3 {
#[doc = "Register `IVR3` reader"] pub type R = crate :: R < Ivr3Spec > ;
#[doc = "Register `IVR3` writer"] pub type W = crate :: W < Ivr3Spec > ;
#[doc = "Field `AES_IVR3` reader - Initialization Vector Register (MSB IVR \\[127:96\\])"] pub type AesIvr3R = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_IVR3` writer - Initialization Vector Register (MSB IVR \\[127:96\\])"] pub type AesIvr3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Initialization Vector Register (MSB IVR \\[127:96\\])"]
#[inline (always)] pub fn aes_ivr3 (& self) -> AesIvr3R { AesIvr3R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Initialization Vector Register (MSB IVR \\[127:96\\])"]
#[inline (always)] pub fn aes_ivr3 (& mut self) -> AesIvr3W < '_ , Ivr3Spec > { AesIvr3W :: new (self , 0) } }
#[doc = "initialization vector register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`ivr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ivr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ivr3Spec ; impl crate :: RegisterSpec for Ivr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ivr3::R`](R) reader structure"] impl crate :: Readable for Ivr3Spec { }
#[doc = "`write(|w| ..)` method takes [`ivr3::W`](W) writer structure"] impl crate :: Writable for Ivr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IVR3 to value 0"] impl crate :: Resettable for Ivr3Spec { } }
#[doc = "KEYR4 (rw) register accessor: key register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@keyr4`] module"]
#[doc (alias = "KEYR4")] pub type Keyr4 = crate :: Reg < keyr4 :: Keyr4Spec > ;
#[doc = "key register 4"] pub mod keyr4 {
#[doc = "Register `KEYR4` reader"] pub type R = crate :: R < Keyr4Spec > ;
#[doc = "Register `KEYR4` writer"] pub type W = crate :: W < Keyr4Spec > ;
#[doc = "Field `AES_KEYR4` reader - AES key register (MSB key \\[159:128\\])"] pub type AesKeyr4R = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_KEYR4` writer - AES key register (MSB key \\[159:128\\])"] pub type AesKeyr4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES key register (MSB key \\[159:128\\])"]
#[inline (always)] pub fn aes_keyr4 (& self) -> AesKeyr4R { AesKeyr4R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES key register (MSB key \\[159:128\\])"]
#[inline (always)] pub fn aes_keyr4 (& mut self) -> AesKeyr4W < '_ , Keyr4Spec > { AesKeyr4W :: new (self , 0) } }
#[doc = "key register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Keyr4Spec ; impl crate :: RegisterSpec for Keyr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`keyr4::R`](R) reader structure"] impl crate :: Readable for Keyr4Spec { }
#[doc = "`write(|w| ..)` method takes [`keyr4::W`](W) writer structure"] impl crate :: Writable for Keyr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets KEYR4 to value 0"] impl crate :: Resettable for Keyr4Spec { } }
#[doc = "KEYR5 (rw) register accessor: key register 5\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@keyr5`] module"]
#[doc (alias = "KEYR5")] pub type Keyr5 = crate :: Reg < keyr5 :: Keyr5Spec > ;
#[doc = "key register 5"] pub mod keyr5 {
#[doc = "Register `KEYR5` reader"] pub type R = crate :: R < Keyr5Spec > ;
#[doc = "Register `KEYR5` writer"] pub type W = crate :: W < Keyr5Spec > ;
#[doc = "Field `AES_KEYR5` reader - AES key register (MSB key \\[191:160\\])"] pub type AesKeyr5R = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_KEYR5` writer - AES key register (MSB key \\[191:160\\])"] pub type AesKeyr5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES key register (MSB key \\[191:160\\])"]
#[inline (always)] pub fn aes_keyr5 (& self) -> AesKeyr5R { AesKeyr5R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES key register (MSB key \\[191:160\\])"]
#[inline (always)] pub fn aes_keyr5 (& mut self) -> AesKeyr5W < '_ , Keyr5Spec > { AesKeyr5W :: new (self , 0) } }
#[doc = "key register 5\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Keyr5Spec ; impl crate :: RegisterSpec for Keyr5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`keyr5::R`](R) reader structure"] impl crate :: Readable for Keyr5Spec { }
#[doc = "`write(|w| ..)` method takes [`keyr5::W`](W) writer structure"] impl crate :: Writable for Keyr5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets KEYR5 to value 0"] impl crate :: Resettable for Keyr5Spec { } }
#[doc = "KEYR6 (rw) register accessor: key register 6\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@keyr6`] module"]
#[doc (alias = "KEYR6")] pub type Keyr6 = crate :: Reg < keyr6 :: Keyr6Spec > ;
#[doc = "key register 6"] pub mod keyr6 {
#[doc = "Register `KEYR6` reader"] pub type R = crate :: R < Keyr6Spec > ;
#[doc = "Register `KEYR6` writer"] pub type W = crate :: W < Keyr6Spec > ;
#[doc = "Field `AES_KEYR6` reader - AES key register (MSB key \\[223:192\\])"] pub type AesKeyr6R = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_KEYR6` writer - AES key register (MSB key \\[223:192\\])"] pub type AesKeyr6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES key register (MSB key \\[223:192\\])"]
#[inline (always)] pub fn aes_keyr6 (& self) -> AesKeyr6R { AesKeyr6R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES key register (MSB key \\[223:192\\])"]
#[inline (always)] pub fn aes_keyr6 (& mut self) -> AesKeyr6W < '_ , Keyr6Spec > { AesKeyr6W :: new (self , 0) } }
#[doc = "key register 6\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Keyr6Spec ; impl crate :: RegisterSpec for Keyr6Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`keyr6::R`](R) reader structure"] impl crate :: Readable for Keyr6Spec { }
#[doc = "`write(|w| ..)` method takes [`keyr6::W`](W) writer structure"] impl crate :: Writable for Keyr6Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets KEYR6 to value 0"] impl crate :: Resettable for Keyr6Spec { } }
#[doc = "KEYR7 (rw) register accessor: key register 7\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr7::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr7::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@keyr7`] module"]
#[doc (alias = "KEYR7")] pub type Keyr7 = crate :: Reg < keyr7 :: Keyr7Spec > ;
#[doc = "key register 7"] pub mod keyr7 {
#[doc = "Register `KEYR7` reader"] pub type R = crate :: R < Keyr7Spec > ;
#[doc = "Register `KEYR7` writer"] pub type W = crate :: W < Keyr7Spec > ;
#[doc = "Field `AES_KEYR7` reader - AES key register (MSB key \\[255:224\\])"] pub type AesKeyr7R = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_KEYR7` writer - AES key register (MSB key \\[255:224\\])"] pub type AesKeyr7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES key register (MSB key \\[255:224\\])"]
#[inline (always)] pub fn aes_keyr7 (& self) -> AesKeyr7R { AesKeyr7R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES key register (MSB key \\[255:224\\])"]
#[inline (always)] pub fn aes_keyr7 (& mut self) -> AesKeyr7W < '_ , Keyr7Spec > { AesKeyr7W :: new (self , 0) } }
#[doc = "key register 7\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr7::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr7::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Keyr7Spec ; impl crate :: RegisterSpec for Keyr7Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`keyr7::R`](R) reader structure"] impl crate :: Readable for Keyr7Spec { }
#[doc = "`write(|w| ..)` method takes [`keyr7::W`](W) writer structure"] impl crate :: Writable for Keyr7Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets KEYR7 to value 0"] impl crate :: Resettable for Keyr7Spec { } }
#[doc = "SUSP0R (rw) register accessor: AES suspend register 0\n\nYou can [`read`](crate::Reg::read) this register and get [`susp0r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp0r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@susp0r`] module"]
#[doc (alias = "SUSP0R")] pub type Susp0r = crate :: Reg < susp0r :: Susp0rSpec > ;
#[doc = "AES suspend register 0"] pub mod susp0r {
#[doc = "Register `SUSP0R` reader"] pub type R = crate :: R < Susp0rSpec > ;
#[doc = "Register `SUSP0R` writer"] pub type W = crate :: W < Susp0rSpec > ;
#[doc = "Field `AES_SUSP0R` reader - AES suspend register 0"] pub type AesSusp0rR = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_SUSP0R` writer - AES suspend register 0"] pub type AesSusp0rW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES suspend register 0"]
#[inline (always)] pub fn aes_susp0r (& self) -> AesSusp0rR { AesSusp0rR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES suspend register 0"]
#[inline (always)] pub fn aes_susp0r (& mut self) -> AesSusp0rW < '_ , Susp0rSpec > { AesSusp0rW :: new (self , 0) } }
#[doc = "AES suspend register 0\n\nYou can [`read`](crate::Reg::read) this register and get [`susp0r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp0r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Susp0rSpec ; impl crate :: RegisterSpec for Susp0rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`susp0r::R`](R) reader structure"] impl crate :: Readable for Susp0rSpec { }
#[doc = "`write(|w| ..)` method takes [`susp0r::W`](W) writer structure"] impl crate :: Writable for Susp0rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SUSP0R to value 0"] impl crate :: Resettable for Susp0rSpec { } }
#[doc = "SUSP1R (rw) register accessor: AES suspend register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`susp1r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp1r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@susp1r`] module"]
#[doc (alias = "SUSP1R")] pub type Susp1r = crate :: Reg < susp1r :: Susp1rSpec > ;
#[doc = "AES suspend register 1"] pub mod susp1r {
#[doc = "Register `SUSP1R` reader"] pub type R = crate :: R < Susp1rSpec > ;
#[doc = "Register `SUSP1R` writer"] pub type W = crate :: W < Susp1rSpec > ;
#[doc = "Field `AES_SUSP1R` reader - AES suspend register 1"] pub type AesSusp1rR = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_SUSP1R` writer - AES suspend register 1"] pub type AesSusp1rW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES suspend register 1"]
#[inline (always)] pub fn aes_susp1r (& self) -> AesSusp1rR { AesSusp1rR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES suspend register 1"]
#[inline (always)] pub fn aes_susp1r (& mut self) -> AesSusp1rW < '_ , Susp1rSpec > { AesSusp1rW :: new (self , 0) } }
#[doc = "AES suspend register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`susp1r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp1r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Susp1rSpec ; impl crate :: RegisterSpec for Susp1rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`susp1r::R`](R) reader structure"] impl crate :: Readable for Susp1rSpec { }
#[doc = "`write(|w| ..)` method takes [`susp1r::W`](W) writer structure"] impl crate :: Writable for Susp1rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SUSP1R to value 0"] impl crate :: Resettable for Susp1rSpec { } }
#[doc = "SUSP2R (rw) register accessor: AES suspend register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`susp2r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp2r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@susp2r`] module"]
#[doc (alias = "SUSP2R")] pub type Susp2r = crate :: Reg < susp2r :: Susp2rSpec > ;
#[doc = "AES suspend register 2"] pub mod susp2r {
#[doc = "Register `SUSP2R` reader"] pub type R = crate :: R < Susp2rSpec > ;
#[doc = "Register `SUSP2R` writer"] pub type W = crate :: W < Susp2rSpec > ;
#[doc = "Field `AES_SUSP2R` reader - AES suspend register 2"] pub type AesSusp2rR = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_SUSP2R` writer - AES suspend register 2"] pub type AesSusp2rW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES suspend register 2"]
#[inline (always)] pub fn aes_susp2r (& self) -> AesSusp2rR { AesSusp2rR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES suspend register 2"]
#[inline (always)] pub fn aes_susp2r (& mut self) -> AesSusp2rW < '_ , Susp2rSpec > { AesSusp2rW :: new (self , 0) } }
#[doc = "AES suspend register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`susp2r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp2r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Susp2rSpec ; impl crate :: RegisterSpec for Susp2rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`susp2r::R`](R) reader structure"] impl crate :: Readable for Susp2rSpec { }
#[doc = "`write(|w| ..)` method takes [`susp2r::W`](W) writer structure"] impl crate :: Writable for Susp2rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SUSP2R to value 0"] impl crate :: Resettable for Susp2rSpec { } }
#[doc = "SUSP3R (rw) register accessor: AES suspend register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`susp3r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp3r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@susp3r`] module"]
#[doc (alias = "SUSP3R")] pub type Susp3r = crate :: Reg < susp3r :: Susp3rSpec > ;
#[doc = "AES suspend register 3"] pub mod susp3r {
#[doc = "Register `SUSP3R` reader"] pub type R = crate :: R < Susp3rSpec > ;
#[doc = "Register `SUSP3R` writer"] pub type W = crate :: W < Susp3rSpec > ;
#[doc = "Field `AES_SUSP3R` reader - AES suspend register 3"] pub type AesSusp3rR = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_SUSP3R` writer - AES suspend register 3"] pub type AesSusp3rW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES suspend register 3"]
#[inline (always)] pub fn aes_susp3r (& self) -> AesSusp3rR { AesSusp3rR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES suspend register 3"]
#[inline (always)] pub fn aes_susp3r (& mut self) -> AesSusp3rW < '_ , Susp3rSpec > { AesSusp3rW :: new (self , 0) } }
#[doc = "AES suspend register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`susp3r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp3r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Susp3rSpec ; impl crate :: RegisterSpec for Susp3rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`susp3r::R`](R) reader structure"] impl crate :: Readable for Susp3rSpec { }
#[doc = "`write(|w| ..)` method takes [`susp3r::W`](W) writer structure"] impl crate :: Writable for Susp3rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SUSP3R to value 0"] impl crate :: Resettable for Susp3rSpec { } }
#[doc = "SUSP4R (rw) register accessor: AES suspend register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`susp4r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp4r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@susp4r`] module"]
#[doc (alias = "SUSP4R")] pub type Susp4r = crate :: Reg < susp4r :: Susp4rSpec > ;
#[doc = "AES suspend register 4"] pub mod susp4r {
#[doc = "Register `SUSP4R` reader"] pub type R = crate :: R < Susp4rSpec > ;
#[doc = "Register `SUSP4R` writer"] pub type W = crate :: W < Susp4rSpec > ;
#[doc = "Field `AES_SUSP4R` reader - AES suspend register 4"] pub type AesSusp4rR = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_SUSP4R` writer - AES suspend register 4"] pub type AesSusp4rW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES suspend register 4"]
#[inline (always)] pub fn aes_susp4r (& self) -> AesSusp4rR { AesSusp4rR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES suspend register 4"]
#[inline (always)] pub fn aes_susp4r (& mut self) -> AesSusp4rW < '_ , Susp4rSpec > { AesSusp4rW :: new (self , 0) } }
#[doc = "AES suspend register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`susp4r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp4r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Susp4rSpec ; impl crate :: RegisterSpec for Susp4rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`susp4r::R`](R) reader structure"] impl crate :: Readable for Susp4rSpec { }
#[doc = "`write(|w| ..)` method takes [`susp4r::W`](W) writer structure"] impl crate :: Writable for Susp4rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SUSP4R to value 0"] impl crate :: Resettable for Susp4rSpec { } }
#[doc = "SUSP5R (rw) register accessor: AES suspend register 5\n\nYou can [`read`](crate::Reg::read) this register and get [`susp5r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp5r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@susp5r`] module"]
#[doc (alias = "SUSP5R")] pub type Susp5r = crate :: Reg < susp5r :: Susp5rSpec > ;
#[doc = "AES suspend register 5"] pub mod susp5r {
#[doc = "Register `SUSP5R` reader"] pub type R = crate :: R < Susp5rSpec > ;
#[doc = "Register `SUSP5R` writer"] pub type W = crate :: W < Susp5rSpec > ;
#[doc = "Field `AES_SUSP5R` reader - AES suspend register 5"] pub type AesSusp5rR = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_SUSP5R` writer - AES suspend register 5"] pub type AesSusp5rW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES suspend register 5"]
#[inline (always)] pub fn aes_susp5r (& self) -> AesSusp5rR { AesSusp5rR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES suspend register 5"]
#[inline (always)] pub fn aes_susp5r (& mut self) -> AesSusp5rW < '_ , Susp5rSpec > { AesSusp5rW :: new (self , 0) } }
#[doc = "AES suspend register 5\n\nYou can [`read`](crate::Reg::read) this register and get [`susp5r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp5r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Susp5rSpec ; impl crate :: RegisterSpec for Susp5rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`susp5r::R`](R) reader structure"] impl crate :: Readable for Susp5rSpec { }
#[doc = "`write(|w| ..)` method takes [`susp5r::W`](W) writer structure"] impl crate :: Writable for Susp5rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SUSP5R to value 0"] impl crate :: Resettable for Susp5rSpec { } }
#[doc = "SUSP6R (rw) register accessor: AES suspend register 6\n\nYou can [`read`](crate::Reg::read) this register and get [`susp6r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp6r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@susp6r`] module"]
#[doc (alias = "SUSP6R")] pub type Susp6r = crate :: Reg < susp6r :: Susp6rSpec > ;
#[doc = "AES suspend register 6"] pub mod susp6r {
#[doc = "Register `SUSP6R` reader"] pub type R = crate :: R < Susp6rSpec > ;
#[doc = "Register `SUSP6R` writer"] pub type W = crate :: W < Susp6rSpec > ;
#[doc = "Field `AES_SUSP6R` reader - AES suspend register 6"] pub type AesSusp6rR = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_SUSP6R` writer - AES suspend register 6"] pub type AesSusp6rW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES suspend register 6"]
#[inline (always)] pub fn aes_susp6r (& self) -> AesSusp6rR { AesSusp6rR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES suspend register 6"]
#[inline (always)] pub fn aes_susp6r (& mut self) -> AesSusp6rW < '_ , Susp6rSpec > { AesSusp6rW :: new (self , 0) } }
#[doc = "AES suspend register 6\n\nYou can [`read`](crate::Reg::read) this register and get [`susp6r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp6r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Susp6rSpec ; impl crate :: RegisterSpec for Susp6rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`susp6r::R`](R) reader structure"] impl crate :: Readable for Susp6rSpec { }
#[doc = "`write(|w| ..)` method takes [`susp6r::W`](W) writer structure"] impl crate :: Writable for Susp6rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SUSP6R to value 0"] impl crate :: Resettable for Susp6rSpec { } }
#[doc = "SUSP7R (rw) register accessor: AES suspend register 7\n\nYou can [`read`](crate::Reg::read) this register and get [`susp7r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp7r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@susp7r`] module"]
#[doc (alias = "SUSP7R")] pub type Susp7r = crate :: Reg < susp7r :: Susp7rSpec > ;
#[doc = "AES suspend register 7"] pub mod susp7r {
#[doc = "Register `SUSP7R` reader"] pub type R = crate :: R < Susp7rSpec > ;
#[doc = "Register `SUSP7R` writer"] pub type W = crate :: W < Susp7rSpec > ;
#[doc = "Field `AES_SUSP7R` reader - AES suspend register 7"] pub type AesSusp7rR = crate :: FieldReader < u32 > ;
#[doc = "Field `AES_SUSP7R` writer - AES suspend register 7"] pub type AesSusp7rW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - AES suspend register 7"]
#[inline (always)] pub fn aes_susp7r (& self) -> AesSusp7rR { AesSusp7rR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - AES suspend register 7"]
#[inline (always)] pub fn aes_susp7r (& mut self) -> AesSusp7rW < '_ , Susp7rSpec > { AesSusp7rW :: new (self , 0) } }
#[doc = "AES suspend register 7\n\nYou can [`read`](crate::Reg::read) this register and get [`susp7r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`susp7r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Susp7rSpec ; impl crate :: RegisterSpec for Susp7rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`susp7r::R`](R) reader structure"] impl crate :: Readable for Susp7rSpec { }
#[doc = "`write(|w| ..)` method takes [`susp7r::W`](W) writer structure"] impl crate :: Writable for Susp7rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SUSP7R to value 0"] impl crate :: Resettable for Susp7rSpec { } }
#[doc = "HWCFR (r) register accessor: AES hardware configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`hwcfr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hwcfr`] module"]
#[doc (alias = "HWCFR")] pub type Hwcfr = crate :: Reg < hwcfr :: HwcfrSpec > ;
#[doc = "AES hardware configuration register"] pub mod hwcfr {
#[doc = "Register `HWCFR` reader"] pub type R = crate :: R < HwcfrSpec > ;
#[doc = "Field `CFG1` reader - HW Generic 1"] pub type Cfg1R = crate :: FieldReader ;
#[doc = "Field `CFG2` reader - HW Generic 2"] pub type Cfg2R = crate :: FieldReader ;
#[doc = "Field `CFG3` reader - HW Generic 3"] pub type Cfg3R = crate :: FieldReader ;
#[doc = "Field `CFG4` reader - HW Generic 4"] pub type Cfg4R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:3 - HW Generic 1"]
#[inline (always)] pub fn cfg1 (& self) -> Cfg1R { Cfg1R :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - HW Generic 2"]
#[inline (always)] pub fn cfg2 (& self) -> Cfg2R { Cfg2R :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:11 - HW Generic 3"]
#[inline (always)] pub fn cfg3 (& self) -> Cfg3R { Cfg3R :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:15 - HW Generic 4"]
#[inline (always)] pub fn cfg4 (& self) -> Cfg4R { Cfg4R :: new (((self . bits >> 12) & 0x0f) as u8) } }
#[doc = "AES hardware configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`hwcfr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct HwcfrSpec ; impl crate :: RegisterSpec for HwcfrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`hwcfr::R`](R) reader structure"] impl crate :: Readable for HwcfrSpec { }
#[doc = "`reset()` method sets HWCFR to value 0x02"] impl crate :: Resettable for HwcfrSpec { const RESET_VALUE : u32 = 0x02 ; } }
#[doc = "VERR (r) register accessor: AES version register\n\nYou can [`read`](crate::Reg::read) this register and get [`verr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@verr`] module"]
#[doc (alias = "VERR")] pub type Verr = crate :: Reg < verr :: VerrSpec > ;
#[doc = "AES version register"] pub mod verr {
#[doc = "Register `VERR` reader"] pub type R = crate :: R < VerrSpec > ;
#[doc = "Field `MINREV` reader - Minor revision"] pub type MinrevR = crate :: FieldReader ;
#[doc = "Field `MAJREV` reader - Major revision"] pub type MajrevR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:3 - Minor revision"]
#[inline (always)] pub fn minrev (& self) -> MinrevR { MinrevR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - Major revision"]
#[inline (always)] pub fn majrev (& self) -> MajrevR { MajrevR :: new (((self . bits >> 4) & 0x0f) as u8) } }
#[doc = "AES version register\n\nYou can [`read`](crate::Reg::read) this register and get [`verr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct VerrSpec ; impl crate :: RegisterSpec for VerrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`verr::R`](R) reader structure"] impl crate :: Readable for VerrSpec { }
#[doc = "`reset()` method sets VERR to value 0x10"] impl crate :: Resettable for VerrSpec { const RESET_VALUE : u32 = 0x10 ; } }
#[doc = "IPIDR (r) register accessor: AES identification register\n\nYou can [`read`](crate::Reg::read) this register and get [`ipidr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ipidr`] module"]
#[doc (alias = "IPIDR")] pub type Ipidr = crate :: Reg < ipidr :: IpidrSpec > ;
#[doc = "AES identification register"] pub mod ipidr {
#[doc = "Register `IPIDR` reader"] pub type R = crate :: R < IpidrSpec > ;
#[doc = "Field `ID` reader - Identification code"] pub type IdR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Identification code"]
#[inline (always)] pub fn id (& self) -> IdR { IdR :: new (self . bits) } }
#[doc = "AES identification register\n\nYou can [`read`](crate::Reg::read) this register and get [`ipidr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IpidrSpec ; impl crate :: RegisterSpec for IpidrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ipidr::R`](R) reader structure"] impl crate :: Readable for IpidrSpec { }
#[doc = "`reset()` method sets IPIDR to value 0x0017_0023"] impl crate :: Resettable for IpidrSpec { const RESET_VALUE : u32 = 0x0017_0023 ; } }
#[doc = "SIDR (r) register accessor: AES size ID register\n\nYou can [`read`](crate::Reg::read) this register and get [`sidr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sidr`] module"]
#[doc (alias = "SIDR")] pub type Sidr = crate :: Reg < sidr :: SidrSpec > ;
#[doc = "AES size ID register"] pub mod sidr {
#[doc = "Register `SIDR` reader"] pub type R = crate :: R < SidrSpec > ;
#[doc = "Field `ID` reader - Size Identification code"] pub type IdR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Size Identification code"]
#[inline (always)] pub fn id (& self) -> IdR { IdR :: new (self . bits) } }
#[doc = "AES size ID register\n\nYou can [`read`](crate::Reg::read) this register and get [`sidr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SidrSpec ; impl crate :: RegisterSpec for SidrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sidr::R`](R) reader structure"] impl crate :: Readable for SidrSpec { }
#[doc = "`reset()` method sets SIDR to value 0x0017_0023"] impl crate :: Resettable for SidrSpec { const RESET_VALUE : u32 = 0x0017_0023 ; } } }
#[doc = "HSEM"] pub type Hsem = crate :: Periph < hsem :: RegisterBlock , 0x5800_1400 > ; impl core :: fmt :: Debug for Hsem { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Hsem") . finish () } }
#[doc = "HSEM"] pub mod hsem {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { r0 : R0 , r1 : R1 , r2 : R2 , r3 : R3 , r4 : R4 , r5 : R5 , r6 : R6 , r7 : R7 , r8 : R8 , r9 : R9 , r10 : R10 , r11 : R11 , r12 : R12 , r13 : R13 , r14 : R14 , r15 : R15 , r16 : R16 , r17 : R17 , r18 : R18 , r19 : R19 , r20 : R20 , r21 : R21 , r22 : R22 , r23 : R23 , r24 : R24 , r25 : R25 , r26 : R26 , r27 : R27 , r28 : R28 , r29 : R29 , r30 : R30 , r31 : R31 , rlr0 : Rlr0 , rlr1 : Rlr1 , rlr2 : Rlr2 , rlr3 : Rlr3 , rlr4 : Rlr4 , rlr5 : Rlr5 , rlr6 : Rlr6 , rlr7 : Rlr7 , rlr8 : Rlr8 , rlr9 : Rlr9 , rlr10 : Rlr10 , rlr11 : Rlr11 , rlr12 : Rlr12 , rlr13 : Rlr13 , rlr14 : Rlr14 , rlr15 : Rlr15 , rlr16 : Rlr16 , rlr17 : Rlr17 , rlr18 : Rlr18 , rlr19 : Rlr19 , rlr20 : Rlr20 , rlr21 : Rlr21 , rlr22 : Rlr22 , rlr23 : Rlr23 , rlr24 : Rlr24 , rlr25 : Rlr25 , rlr26 : Rlr26 , rlr27 : Rlr27 , rlr28 : Rlr28 , rlr29 : Rlr29 , rlr30 : Rlr30 , rlr31 : Rlr31 , c1ier0 : C1ier0 , c1icr : C1icr , c1isr : C1isr , c1misr : C1misr , c2ier0 : C2ier0 , c2icr : C2icr , c2isr : C2isr , c2misr : C2misr , _reserved72 : [u8 ; 0x20] , cr : Cr , keyr : Keyr , _reserved74 : [u8 ; 0x02a4] , hwcfgr2 : Hwcfgr2 , hwcfgr1 : Hwcfgr1 , verr : Verr , ipidr : Ipidr , sidr : Sidr , } impl RegisterBlock {
#[doc = "0x00 - Semaphore 0 register"]
#[inline (always)] pub const fn r0 (& self) -> & R0 { & self . r0 }
#[doc = "0x04 - Semaphore 1 register"]
#[inline (always)] pub const fn r1 (& self) -> & R1 { & self . r1 }
#[doc = "0x08 - Semaphore 2 register"]
#[inline (always)] pub const fn r2 (& self) -> & R2 { & self . r2 }
#[doc = "0x0c - Semaphore 3 register"]
#[inline (always)] pub const fn r3 (& self) -> & R3 { & self . r3 }
#[doc = "0x10 - Semaphore 4 register"]
#[inline (always)] pub const fn r4 (& self) -> & R4 { & self . r4 }
#[doc = "0x14 - Semaphore 5 register"]
#[inline (always)] pub const fn r5 (& self) -> & R5 { & self . r5 }
#[doc = "0x18 - Semaphore 6 register"]
#[inline (always)] pub const fn r6 (& self) -> & R6 { & self . r6 }
#[doc = "0x1c - Semaphore 7 register"]
#[inline (always)] pub const fn r7 (& self) -> & R7 { & self . r7 }
#[doc = "0x20 - Semaphore 8 register"]
#[inline (always)] pub const fn r8 (& self) -> & R8 { & self . r8 }
#[doc = "0x24 - Semaphore 9 register"]
#[inline (always)] pub const fn r9 (& self) -> & R9 { & self . r9 }
#[doc = "0x28 - Semaphore 10 register"]
#[inline (always)] pub const fn r10 (& self) -> & R10 { & self . r10 }
#[doc = "0x2c - Semaphore 11 register"]
#[inline (always)] pub const fn r11 (& self) -> & R11 { & self . r11 }
#[doc = "0x30 - Semaphore 12 register"]
#[inline (always)] pub const fn r12 (& self) -> & R12 { & self . r12 }
#[doc = "0x34 - Semaphore 13 register"]
#[inline (always)] pub const fn r13 (& self) -> & R13 { & self . r13 }
#[doc = "0x38 - Semaphore 14 register"]
#[inline (always)] pub const fn r14 (& self) -> & R14 { & self . r14 }
#[doc = "0x3c - Semaphore 15 register"]
#[inline (always)] pub const fn r15 (& self) -> & R15 { & self . r15 }
#[doc = "0x40 - Semaphore 16 register"]
#[inline (always)] pub const fn r16 (& self) -> & R16 { & self . r16 }
#[doc = "0x44 - Semaphore 17 register"]
#[inline (always)] pub const fn r17 (& self) -> & R17 { & self . r17 }
#[doc = "0x48 - Semaphore 18 register"]
#[inline (always)] pub const fn r18 (& self) -> & R18 { & self . r18 }
#[doc = "0x4c - Semaphore 19 register"]
#[inline (always)] pub const fn r19 (& self) -> & R19 { & self . r19 }
#[doc = "0x50 - Semaphore 20 register"]
#[inline (always)] pub const fn r20 (& self) -> & R20 { & self . r20 }
#[doc = "0x54 - Semaphore 21 register"]
#[inline (always)] pub const fn r21 (& self) -> & R21 { & self . r21 }
#[doc = "0x58 - Semaphore 22 register"]
#[inline (always)] pub const fn r22 (& self) -> & R22 { & self . r22 }
#[doc = "0x5c - Semaphore 23 register"]
#[inline (always)] pub const fn r23 (& self) -> & R23 { & self . r23 }
#[doc = "0x60 - Semaphore 24 register"]
#[inline (always)] pub const fn r24 (& self) -> & R24 { & self . r24 }
#[doc = "0x64 - Semaphore 25 register"]
#[inline (always)] pub const fn r25 (& self) -> & R25 { & self . r25 }
#[doc = "0x68 - Semaphore 26 register"]
#[inline (always)] pub const fn r26 (& self) -> & R26 { & self . r26 }
#[doc = "0x6c - Semaphore 27 register"]
#[inline (always)] pub const fn r27 (& self) -> & R27 { & self . r27 }
#[doc = "0x70 - Semaphore 28 register"]
#[inline (always)] pub const fn r28 (& self) -> & R28 { & self . r28 }
#[doc = "0x74 - Semaphore 29 register"]
#[inline (always)] pub const fn r29 (& self) -> & R29 { & self . r29 }
#[doc = "0x78 - Semaphore 30 register"]
#[inline (always)] pub const fn r30 (& self) -> & R30 { & self . r30 }
#[doc = "0x7c - Semaphore 31 register"]
#[inline (always)] pub const fn r31 (& self) -> & R31 { & self . r31 }
#[doc = "0x80 - Semaphore 0 read lock register"]
#[inline (always)] pub const fn rlr0 (& self) -> & Rlr0 { & self . rlr0 }
#[doc = "0x84 - Semaphore 1 read lock register"]
#[inline (always)] pub const fn rlr1 (& self) -> & Rlr1 { & self . rlr1 }
#[doc = "0x88 - Semaphore 2 read lock register"]
#[inline (always)] pub const fn rlr2 (& self) -> & Rlr2 { & self . rlr2 }
#[doc = "0x8c - Semaphore 3 read lock register"]
#[inline (always)] pub const fn rlr3 (& self) -> & Rlr3 { & self . rlr3 }
#[doc = "0x90 - Semaphore 4 read lock read lock register"]
#[inline (always)] pub const fn rlr4 (& self) -> & Rlr4 { & self . rlr4 }
#[doc = "0x94 - Semaphore 5 read lock register"]
#[inline (always)] pub const fn rlr5 (& self) -> & Rlr5 { & self . rlr5 }
#[doc = "0x98 - Semaphore 6 read lock register"]
#[inline (always)] pub const fn rlr6 (& self) -> & Rlr6 { & self . rlr6 }
#[doc = "0x9c - Semaphore 7 read lock register"]
#[inline (always)] pub const fn rlr7 (& self) -> & Rlr7 { & self . rlr7 }
#[doc = "0xa0 - Semaphore 8 read lock register"]
#[inline (always)] pub const fn rlr8 (& self) -> & Rlr8 { & self . rlr8 }
#[doc = "0xa4 - Semaphore 9 read lock register"]
#[inline (always)] pub const fn rlr9 (& self) -> & Rlr9 { & self . rlr9 }
#[doc = "0xa8 - Semaphore 10 read lock register"]
#[inline (always)] pub const fn rlr10 (& self) -> & Rlr10 { & self . rlr10 }
#[doc = "0xac - Semaphore 11 read lock register"]
#[inline (always)] pub const fn rlr11 (& self) -> & Rlr11 { & self . rlr11 }
#[doc = "0xb0 - Semaphore 12 read lock register"]
#[inline (always)] pub const fn rlr12 (& self) -> & Rlr12 { & self . rlr12 }
#[doc = "0xb4 - Semaphore 13 read lock register"]
#[inline (always)] pub const fn rlr13 (& self) -> & Rlr13 { & self . rlr13 }
#[doc = "0xb8 - Semaphore 14 read lock register"]
#[inline (always)] pub const fn rlr14 (& self) -> & Rlr14 { & self . rlr14 }
#[doc = "0xbc - Semaphore 15 read lock register"]
#[inline (always)] pub const fn rlr15 (& self) -> & Rlr15 { & self . rlr15 }
#[doc = "0xc0 - Semaphore 16 read lock register"]
#[inline (always)] pub const fn rlr16 (& self) -> & Rlr16 { & self . rlr16 }
#[doc = "0xc4 - Semaphore 17 read lock register"]
#[inline (always)] pub const fn rlr17 (& self) -> & Rlr17 { & self . rlr17 }
#[doc = "0xc8 - Semaphore 18 read lock register"]
#[inline (always)] pub const fn rlr18 (& self) -> & Rlr18 { & self . rlr18 }
#[doc = "0xcc - Semaphore 19 read lock register"]
#[inline (always)] pub const fn rlr19 (& self) -> & Rlr19 { & self . rlr19 }
#[doc = "0xd0 - Semaphore 20 read lock register"]
#[inline (always)] pub const fn rlr20 (& self) -> & Rlr20 { & self . rlr20 }
#[doc = "0xd4 - Semaphore 21 read lock register"]
#[inline (always)] pub const fn rlr21 (& self) -> & Rlr21 { & self . rlr21 }
#[doc = "0xd8 - Semaphore 22 read lock register"]
#[inline (always)] pub const fn rlr22 (& self) -> & Rlr22 { & self . rlr22 }
#[doc = "0xdc - Semaphore 23 read lock register"]
#[inline (always)] pub const fn rlr23 (& self) -> & Rlr23 { & self . rlr23 }
#[doc = "0xe0 - Semaphore 24 read lock register"]
#[inline (always)] pub const fn rlr24 (& self) -> & Rlr24 { & self . rlr24 }
#[doc = "0xe4 - Semaphore 25 read lock register"]
#[inline (always)] pub const fn rlr25 (& self) -> & Rlr25 { & self . rlr25 }
#[doc = "0xe8 - Semaphore 26 read lock register"]
#[inline (always)] pub const fn rlr26 (& self) -> & Rlr26 { & self . rlr26 }
#[doc = "0xec - Semaphore 27 read lock register"]
#[inline (always)] pub const fn rlr27 (& self) -> & Rlr27 { & self . rlr27 }
#[doc = "0xf0 - Semaphore 28 read lock register"]
#[inline (always)] pub const fn rlr28 (& self) -> & Rlr28 { & self . rlr28 }
#[doc = "0xf4 - Semaphore 29 read lock register"]
#[inline (always)] pub const fn rlr29 (& self) -> & Rlr29 { & self . rlr29 }
#[doc = "0xf8 - Semaphore 30 read lock register"]
#[inline (always)] pub const fn rlr30 (& self) -> & Rlr30 { & self . rlr30 }
#[doc = "0xfc - Semaphore 31 read lock register"]
#[inline (always)] pub const fn rlr31 (& self) -> & Rlr31 { & self . rlr31 }
#[doc = "0x100 - HSEM Interrupt enable register"]
#[inline (always)] pub const fn c1ier0 (& self) -> & C1ier0 { & self . c1ier0 }
#[doc = "0x104 - HSEM Interrupt clear register"]
#[inline (always)] pub const fn c1icr (& self) -> & C1icr { & self . c1icr }
#[doc = "0x108 - HSEM Interrupt status register"]
#[inline (always)] pub const fn c1isr (& self) -> & C1isr { & self . c1isr }
#[doc = "0x10c - HSEM Masked interrupt status register"]
#[inline (always)] pub const fn c1misr (& self) -> & C1misr { & self . c1misr }
#[doc = "0x110 - HSEM Interrupt enable register"]
#[inline (always)] pub const fn c2ier0 (& self) -> & C2ier0 { & self . c2ier0 }
#[doc = "0x114 - HSEM Interrupt clear register"]
#[inline (always)] pub const fn c2icr (& self) -> & C2icr { & self . c2icr }
#[doc = "0x118 - HSEM Interrupt status register"]
#[inline (always)] pub const fn c2isr (& self) -> & C2isr { & self . c2isr }
#[doc = "0x11c - HSEM Masked interrupt status register"]
#[inline (always)] pub const fn c2misr (& self) -> & C2misr { & self . c2misr }
#[doc = "0x140 - Semaphore Clear register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x144 - Interrupt clear register"]
#[inline (always)] pub const fn keyr (& self) -> & Keyr { & self . keyr }
#[doc = "0x3ec - Semaphore hardware configuration register 2"]
#[inline (always)] pub const fn hwcfgr2 (& self) -> & Hwcfgr2 { & self . hwcfgr2 }
#[doc = "0x3f0 - Semaphore hardware configuration register 1"]
#[inline (always)] pub const fn hwcfgr1 (& self) -> & Hwcfgr1 { & self . hwcfgr1 }
#[doc = "0x3f4 - HSEM version register"]
#[inline (always)] pub const fn verr (& self) -> & Verr { & self . verr }
#[doc = "0x3f8 - HSEM indentification register"]
#[inline (always)] pub const fn ipidr (& self) -> & Ipidr { & self . ipidr }
#[doc = "0x3fc - HSEM size indentification register"]
#[inline (always)] pub const fn sidr (& self) -> & Sidr { & self . sidr } }
#[doc = "R0 (rw) register accessor: Semaphore 0 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r0`] module"] pub type R0 = crate :: Reg < r0 :: R0Spec > ;
#[doc = "Semaphore 0 register"] pub mod r0 {
#[doc = "Register `R0` reader"] pub type R = crate :: R < R0Spec > ;
#[doc = "Register `R0` writer"] pub type W = crate :: W < R0Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R0Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R0Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R0Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 0 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R0Spec ; impl crate :: RegisterSpec for R0Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r0::R`](R) reader structure"] impl crate :: Readable for R0Spec { }
#[doc = "`write(|w| ..)` method takes [`r0::W`](W) writer structure"] impl crate :: Writable for R0Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R0 to value 0"] impl crate :: Resettable for R0Spec { } }
#[doc = "R1 (rw) register accessor: Semaphore 1 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r1`] module"] pub type R1 = crate :: Reg < r1 :: R1Spec > ;
#[doc = "Semaphore 1 register"] pub mod r1 {
#[doc = "Register `R1` reader"] pub type R = crate :: R < R1Spec > ;
#[doc = "Register `R1` writer"] pub type W = crate :: W < R1Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R1Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R1Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R1Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 1 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R1Spec ; impl crate :: RegisterSpec for R1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r1::R`](R) reader structure"] impl crate :: Readable for R1Spec { }
#[doc = "`write(|w| ..)` method takes [`r1::W`](W) writer structure"] impl crate :: Writable for R1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R1 to value 0"] impl crate :: Resettable for R1Spec { } }
#[doc = "R2 (rw) register accessor: Semaphore 2 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r2`] module"] pub type R2 = crate :: Reg < r2 :: R2Spec > ;
#[doc = "Semaphore 2 register"] pub mod r2 {
#[doc = "Register `R2` reader"] pub type R = crate :: R < R2Spec > ;
#[doc = "Register `R2` writer"] pub type W = crate :: W < R2Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R2Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R2Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R2Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 2 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R2Spec ; impl crate :: RegisterSpec for R2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r2::R`](R) reader structure"] impl crate :: Readable for R2Spec { }
#[doc = "`write(|w| ..)` method takes [`r2::W`](W) writer structure"] impl crate :: Writable for R2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R2 to value 0"] impl crate :: Resettable for R2Spec { } }
#[doc = "R3 (rw) register accessor: Semaphore 3 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r3`] module"] pub type R3 = crate :: Reg < r3 :: R3Spec > ;
#[doc = "Semaphore 3 register"] pub mod r3 {
#[doc = "Register `R3` reader"] pub type R = crate :: R < R3Spec > ;
#[doc = "Register `R3` writer"] pub type W = crate :: W < R3Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R3Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R3Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R3Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 3 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R3Spec ; impl crate :: RegisterSpec for R3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r3::R`](R) reader structure"] impl crate :: Readable for R3Spec { }
#[doc = "`write(|w| ..)` method takes [`r3::W`](W) writer structure"] impl crate :: Writable for R3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R3 to value 0"] impl crate :: Resettable for R3Spec { } }
#[doc = "R4 (rw) register accessor: Semaphore 4 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r4`] module"] pub type R4 = crate :: Reg < r4 :: R4Spec > ;
#[doc = "Semaphore 4 register"] pub mod r4 {
#[doc = "Register `R4` reader"] pub type R = crate :: R < R4Spec > ;
#[doc = "Register `R4` writer"] pub type W = crate :: W < R4Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R4Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R4Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R4Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 4 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R4Spec ; impl crate :: RegisterSpec for R4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r4::R`](R) reader structure"] impl crate :: Readable for R4Spec { }
#[doc = "`write(|w| ..)` method takes [`r4::W`](W) writer structure"] impl crate :: Writable for R4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R4 to value 0"] impl crate :: Resettable for R4Spec { } }
#[doc = "R5 (rw) register accessor: Semaphore 5 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r5`] module"] pub type R5 = crate :: Reg < r5 :: R5Spec > ;
#[doc = "Semaphore 5 register"] pub mod r5 {
#[doc = "Register `R5` reader"] pub type R = crate :: R < R5Spec > ;
#[doc = "Register `R5` writer"] pub type W = crate :: W < R5Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R5Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R5Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R5Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 5 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R5Spec ; impl crate :: RegisterSpec for R5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r5::R`](R) reader structure"] impl crate :: Readable for R5Spec { }
#[doc = "`write(|w| ..)` method takes [`r5::W`](W) writer structure"] impl crate :: Writable for R5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R5 to value 0"] impl crate :: Resettable for R5Spec { } }
#[doc = "R6 (rw) register accessor: Semaphore 6 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r6`] module"] pub type R6 = crate :: Reg < r6 :: R6Spec > ;
#[doc = "Semaphore 6 register"] pub mod r6 {
#[doc = "Register `R6` reader"] pub type R = crate :: R < R6Spec > ;
#[doc = "Register `R6` writer"] pub type W = crate :: W < R6Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R6Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R6Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R6Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 6 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R6Spec ; impl crate :: RegisterSpec for R6Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r6::R`](R) reader structure"] impl crate :: Readable for R6Spec { }
#[doc = "`write(|w| ..)` method takes [`r6::W`](W) writer structure"] impl crate :: Writable for R6Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R6 to value 0"] impl crate :: Resettable for R6Spec { } }
#[doc = "R7 (rw) register accessor: Semaphore 7 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r7::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r7::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r7`] module"] pub type R7 = crate :: Reg < r7 :: R7Spec > ;
#[doc = "Semaphore 7 register"] pub mod r7 {
#[doc = "Register `R7` reader"] pub type R = crate :: R < R7Spec > ;
#[doc = "Register `R7` writer"] pub type W = crate :: W < R7Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R7Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R7Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R7Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 7 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r7::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r7::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R7Spec ; impl crate :: RegisterSpec for R7Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r7::R`](R) reader structure"] impl crate :: Readable for R7Spec { }
#[doc = "`write(|w| ..)` method takes [`r7::W`](W) writer structure"] impl crate :: Writable for R7Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R7 to value 0"] impl crate :: Resettable for R7Spec { } }
#[doc = "R8 (rw) register accessor: Semaphore 8 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r8::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r8::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r8`] module"] pub type R8 = crate :: Reg < r8 :: R8Spec > ;
#[doc = "Semaphore 8 register"] pub mod r8 {
#[doc = "Register `R8` reader"] pub type R = crate :: R < R8Spec > ;
#[doc = "Register `R8` writer"] pub type W = crate :: W < R8Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R8Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R8Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R8Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 8 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r8::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r8::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R8Spec ; impl crate :: RegisterSpec for R8Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r8::R`](R) reader structure"] impl crate :: Readable for R8Spec { }
#[doc = "`write(|w| ..)` method takes [`r8::W`](W) writer structure"] impl crate :: Writable for R8Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R8 to value 0"] impl crate :: Resettable for R8Spec { } }
#[doc = "R9 (rw) register accessor: Semaphore 9 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r9::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r9::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r9`] module"] pub type R9 = crate :: Reg < r9 :: R9Spec > ;
#[doc = "Semaphore 9 register"] pub mod r9 {
#[doc = "Register `R9` reader"] pub type R = crate :: R < R9Spec > ;
#[doc = "Register `R9` writer"] pub type W = crate :: W < R9Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R9Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R9Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R9Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 9 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r9::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r9::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R9Spec ; impl crate :: RegisterSpec for R9Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r9::R`](R) reader structure"] impl crate :: Readable for R9Spec { }
#[doc = "`write(|w| ..)` method takes [`r9::W`](W) writer structure"] impl crate :: Writable for R9Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R9 to value 0"] impl crate :: Resettable for R9Spec { } }
#[doc = "R10 (rw) register accessor: Semaphore 10 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r10::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r10::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r10`] module"] pub type R10 = crate :: Reg < r10 :: R10Spec > ;
#[doc = "Semaphore 10 register"] pub mod r10 {
#[doc = "Register `R10` reader"] pub type R = crate :: R < R10Spec > ;
#[doc = "Register `R10` writer"] pub type W = crate :: W < R10Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R10Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R10Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R10Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 10 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r10::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r10::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R10Spec ; impl crate :: RegisterSpec for R10Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r10::R`](R) reader structure"] impl crate :: Readable for R10Spec { }
#[doc = "`write(|w| ..)` method takes [`r10::W`](W) writer structure"] impl crate :: Writable for R10Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R10 to value 0"] impl crate :: Resettable for R10Spec { } }
#[doc = "R11 (rw) register accessor: Semaphore 11 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r11::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r11::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r11`] module"] pub type R11 = crate :: Reg < r11 :: R11Spec > ;
#[doc = "Semaphore 11 register"] pub mod r11 {
#[doc = "Register `R11` reader"] pub type R = crate :: R < R11Spec > ;
#[doc = "Register `R11` writer"] pub type W = crate :: W < R11Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R11Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R11Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R11Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 11 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r11::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r11::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R11Spec ; impl crate :: RegisterSpec for R11Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r11::R`](R) reader structure"] impl crate :: Readable for R11Spec { }
#[doc = "`write(|w| ..)` method takes [`r11::W`](W) writer structure"] impl crate :: Writable for R11Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R11 to value 0"] impl crate :: Resettable for R11Spec { } }
#[doc = "R12 (rw) register accessor: Semaphore 12 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r12::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r12::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r12`] module"] pub type R12 = crate :: Reg < r12 :: R12Spec > ;
#[doc = "Semaphore 12 register"] pub mod r12 {
#[doc = "Register `R12` reader"] pub type R = crate :: R < R12Spec > ;
#[doc = "Register `R12` writer"] pub type W = crate :: W < R12Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R12Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R12Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R12Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 12 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r12::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r12::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R12Spec ; impl crate :: RegisterSpec for R12Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r12::R`](R) reader structure"] impl crate :: Readable for R12Spec { }
#[doc = "`write(|w| ..)` method takes [`r12::W`](W) writer structure"] impl crate :: Writable for R12Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R12 to value 0"] impl crate :: Resettable for R12Spec { } }
#[doc = "R13 (rw) register accessor: Semaphore 13 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r13::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r13::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r13`] module"] pub type R13 = crate :: Reg < r13 :: R13Spec > ;
#[doc = "Semaphore 13 register"] pub mod r13 {
#[doc = "Register `R13` reader"] pub type R = crate :: R < R13Spec > ;
#[doc = "Register `R13` writer"] pub type W = crate :: W < R13Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R13Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R13Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R13Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 13 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r13::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r13::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R13Spec ; impl crate :: RegisterSpec for R13Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r13::R`](R) reader structure"] impl crate :: Readable for R13Spec { }
#[doc = "`write(|w| ..)` method takes [`r13::W`](W) writer structure"] impl crate :: Writable for R13Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R13 to value 0"] impl crate :: Resettable for R13Spec { } }
#[doc = "R14 (rw) register accessor: Semaphore 14 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r14::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r14::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r14`] module"] pub type R14 = crate :: Reg < r14 :: R14Spec > ;
#[doc = "Semaphore 14 register"] pub mod r14 {
#[doc = "Register `R14` reader"] pub type R = crate :: R < R14Spec > ;
#[doc = "Register `R14` writer"] pub type W = crate :: W < R14Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R14Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R14Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R14Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 14 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r14::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r14::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R14Spec ; impl crate :: RegisterSpec for R14Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r14::R`](R) reader structure"] impl crate :: Readable for R14Spec { }
#[doc = "`write(|w| ..)` method takes [`r14::W`](W) writer structure"] impl crate :: Writable for R14Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R14 to value 0"] impl crate :: Resettable for R14Spec { } }
#[doc = "R15 (rw) register accessor: Semaphore 15 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r15::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r15::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r15`] module"] pub type R15 = crate :: Reg < r15 :: R15Spec > ;
#[doc = "Semaphore 15 register"] pub mod r15 {
#[doc = "Register `R15` reader"] pub type R = crate :: R < R15Spec > ;
#[doc = "Register `R15` writer"] pub type W = crate :: W < R15Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R15Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R15Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R15Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 15 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r15::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r15::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R15Spec ; impl crate :: RegisterSpec for R15Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r15::R`](R) reader structure"] impl crate :: Readable for R15Spec { }
#[doc = "`write(|w| ..)` method takes [`r15::W`](W) writer structure"] impl crate :: Writable for R15Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R15 to value 0"] impl crate :: Resettable for R15Spec { } }
#[doc = "R16 (rw) register accessor: Semaphore 16 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r16::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r16::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r16`] module"] pub type R16 = crate :: Reg < r16 :: R16Spec > ;
#[doc = "Semaphore 16 register"] pub mod r16 {
#[doc = "Register `R16` reader"] pub type R = crate :: R < R16Spec > ;
#[doc = "Register `R16` writer"] pub type W = crate :: W < R16Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R16Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R16Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R16Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 16 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r16::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r16::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R16Spec ; impl crate :: RegisterSpec for R16Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r16::R`](R) reader structure"] impl crate :: Readable for R16Spec { }
#[doc = "`write(|w| ..)` method takes [`r16::W`](W) writer structure"] impl crate :: Writable for R16Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R16 to value 0"] impl crate :: Resettable for R16Spec { } }
#[doc = "R17 (rw) register accessor: Semaphore 17 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r17::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r17::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r17`] module"] pub type R17 = crate :: Reg < r17 :: R17Spec > ;
#[doc = "Semaphore 17 register"] pub mod r17 {
#[doc = "Register `R17` reader"] pub type R = crate :: R < R17Spec > ;
#[doc = "Register `R17` writer"] pub type W = crate :: W < R17Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R17Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R17Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R17Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 17 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r17::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r17::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R17Spec ; impl crate :: RegisterSpec for R17Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r17::R`](R) reader structure"] impl crate :: Readable for R17Spec { }
#[doc = "`write(|w| ..)` method takes [`r17::W`](W) writer structure"] impl crate :: Writable for R17Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R17 to value 0"] impl crate :: Resettable for R17Spec { } }
#[doc = "R18 (rw) register accessor: Semaphore 18 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r18::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r18::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r18`] module"] pub type R18 = crate :: Reg < r18 :: R18Spec > ;
#[doc = "Semaphore 18 register"] pub mod r18 {
#[doc = "Register `R18` reader"] pub type R = crate :: R < R18Spec > ;
#[doc = "Register `R18` writer"] pub type W = crate :: W < R18Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R18Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R18Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R18Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 18 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r18::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r18::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R18Spec ; impl crate :: RegisterSpec for R18Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r18::R`](R) reader structure"] impl crate :: Readable for R18Spec { }
#[doc = "`write(|w| ..)` method takes [`r18::W`](W) writer structure"] impl crate :: Writable for R18Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R18 to value 0"] impl crate :: Resettable for R18Spec { } }
#[doc = "R19 (rw) register accessor: Semaphore 19 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r19::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r19::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r19`] module"] pub type R19 = crate :: Reg < r19 :: R19Spec > ;
#[doc = "Semaphore 19 register"] pub mod r19 {
#[doc = "Register `R19` reader"] pub type R = crate :: R < R19Spec > ;
#[doc = "Register `R19` writer"] pub type W = crate :: W < R19Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R19Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R19Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R19Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 19 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r19::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r19::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R19Spec ; impl crate :: RegisterSpec for R19Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r19::R`](R) reader structure"] impl crate :: Readable for R19Spec { }
#[doc = "`write(|w| ..)` method takes [`r19::W`](W) writer structure"] impl crate :: Writable for R19Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R19 to value 0"] impl crate :: Resettable for R19Spec { } }
#[doc = "R20 (rw) register accessor: Semaphore 20 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r20::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r20::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r20`] module"] pub type R20 = crate :: Reg < r20 :: R20Spec > ;
#[doc = "Semaphore 20 register"] pub mod r20 {
#[doc = "Register `R20` reader"] pub type R = crate :: R < R20Spec > ;
#[doc = "Register `R20` writer"] pub type W = crate :: W < R20Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R20Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R20Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R20Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 20 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r20::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r20::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R20Spec ; impl crate :: RegisterSpec for R20Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r20::R`](R) reader structure"] impl crate :: Readable for R20Spec { }
#[doc = "`write(|w| ..)` method takes [`r20::W`](W) writer structure"] impl crate :: Writable for R20Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R20 to value 0"] impl crate :: Resettable for R20Spec { } }
#[doc = "R21 (rw) register accessor: Semaphore 21 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r21::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r21::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r21`] module"] pub type R21 = crate :: Reg < r21 :: R21Spec > ;
#[doc = "Semaphore 21 register"] pub mod r21 {
#[doc = "Register `R21` reader"] pub type R = crate :: R < R21Spec > ;
#[doc = "Register `R21` writer"] pub type W = crate :: W < R21Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R21Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R21Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R21Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 21 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r21::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r21::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R21Spec ; impl crate :: RegisterSpec for R21Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r21::R`](R) reader structure"] impl crate :: Readable for R21Spec { }
#[doc = "`write(|w| ..)` method takes [`r21::W`](W) writer structure"] impl crate :: Writable for R21Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R21 to value 0"] impl crate :: Resettable for R21Spec { } }
#[doc = "R22 (rw) register accessor: Semaphore 22 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r22::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r22::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r22`] module"] pub type R22 = crate :: Reg < r22 :: R22Spec > ;
#[doc = "Semaphore 22 register"] pub mod r22 {
#[doc = "Register `R22` reader"] pub type R = crate :: R < R22Spec > ;
#[doc = "Register `R22` writer"] pub type W = crate :: W < R22Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R22Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R22Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R22Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 22 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r22::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r22::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R22Spec ; impl crate :: RegisterSpec for R22Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r22::R`](R) reader structure"] impl crate :: Readable for R22Spec { }
#[doc = "`write(|w| ..)` method takes [`r22::W`](W) writer structure"] impl crate :: Writable for R22Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R22 to value 0"] impl crate :: Resettable for R22Spec { } }
#[doc = "R23 (rw) register accessor: Semaphore 23 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r23::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r23::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r23`] module"] pub type R23 = crate :: Reg < r23 :: R23Spec > ;
#[doc = "Semaphore 23 register"] pub mod r23 {
#[doc = "Register `R23` reader"] pub type R = crate :: R < R23Spec > ;
#[doc = "Register `R23` writer"] pub type W = crate :: W < R23Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R23Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R23Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R23Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 23 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r23::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r23::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R23Spec ; impl crate :: RegisterSpec for R23Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r23::R`](R) reader structure"] impl crate :: Readable for R23Spec { }
#[doc = "`write(|w| ..)` method takes [`r23::W`](W) writer structure"] impl crate :: Writable for R23Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R23 to value 0"] impl crate :: Resettable for R23Spec { } }
#[doc = "R24 (rw) register accessor: Semaphore 24 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r24::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r24::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r24`] module"] pub type R24 = crate :: Reg < r24 :: R24Spec > ;
#[doc = "Semaphore 24 register"] pub mod r24 {
#[doc = "Register `R24` reader"] pub type R = crate :: R < R24Spec > ;
#[doc = "Register `R24` writer"] pub type W = crate :: W < R24Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R24Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R24Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R24Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 24 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r24::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r24::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R24Spec ; impl crate :: RegisterSpec for R24Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r24::R`](R) reader structure"] impl crate :: Readable for R24Spec { }
#[doc = "`write(|w| ..)` method takes [`r24::W`](W) writer structure"] impl crate :: Writable for R24Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R24 to value 0"] impl crate :: Resettable for R24Spec { } }
#[doc = "R25 (rw) register accessor: Semaphore 25 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r25::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r25::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r25`] module"] pub type R25 = crate :: Reg < r25 :: R25Spec > ;
#[doc = "Semaphore 25 register"] pub mod r25 {
#[doc = "Register `R25` reader"] pub type R = crate :: R < R25Spec > ;
#[doc = "Register `R25` writer"] pub type W = crate :: W < R25Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R25Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R25Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R25Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 25 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r25::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r25::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R25Spec ; impl crate :: RegisterSpec for R25Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r25::R`](R) reader structure"] impl crate :: Readable for R25Spec { }
#[doc = "`write(|w| ..)` method takes [`r25::W`](W) writer structure"] impl crate :: Writable for R25Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R25 to value 0"] impl crate :: Resettable for R25Spec { } }
#[doc = "R26 (rw) register accessor: Semaphore 26 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r26::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r26::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r26`] module"] pub type R26 = crate :: Reg < r26 :: R26Spec > ;
#[doc = "Semaphore 26 register"] pub mod r26 {
#[doc = "Register `R26` reader"] pub type R = crate :: R < R26Spec > ;
#[doc = "Register `R26` writer"] pub type W = crate :: W < R26Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R26Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R26Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R26Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 26 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r26::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r26::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R26Spec ; impl crate :: RegisterSpec for R26Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r26::R`](R) reader structure"] impl crate :: Readable for R26Spec { }
#[doc = "`write(|w| ..)` method takes [`r26::W`](W) writer structure"] impl crate :: Writable for R26Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R26 to value 0"] impl crate :: Resettable for R26Spec { } }
#[doc = "R27 (rw) register accessor: Semaphore 27 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r27::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r27::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r27`] module"] pub type R27 = crate :: Reg < r27 :: R27Spec > ;
#[doc = "Semaphore 27 register"] pub mod r27 {
#[doc = "Register `R27` reader"] pub type R = crate :: R < R27Spec > ;
#[doc = "Register `R27` writer"] pub type W = crate :: W < R27Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R27Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R27Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R27Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 27 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r27::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r27::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R27Spec ; impl crate :: RegisterSpec for R27Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r27::R`](R) reader structure"] impl crate :: Readable for R27Spec { }
#[doc = "`write(|w| ..)` method takes [`r27::W`](W) writer structure"] impl crate :: Writable for R27Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R27 to value 0"] impl crate :: Resettable for R27Spec { } }
#[doc = "R28 (rw) register accessor: Semaphore 28 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r28::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r28::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r28`] module"] pub type R28 = crate :: Reg < r28 :: R28Spec > ;
#[doc = "Semaphore 28 register"] pub mod r28 {
#[doc = "Register `R28` reader"] pub type R = crate :: R < R28Spec > ;
#[doc = "Register `R28` writer"] pub type W = crate :: W < R28Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R28Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R28Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R28Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 28 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r28::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r28::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R28Spec ; impl crate :: RegisterSpec for R28Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r28::R`](R) reader structure"] impl crate :: Readable for R28Spec { }
#[doc = "`write(|w| ..)` method takes [`r28::W`](W) writer structure"] impl crate :: Writable for R28Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R28 to value 0"] impl crate :: Resettable for R28Spec { } }
#[doc = "R29 (rw) register accessor: Semaphore 29 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r29::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r29::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r29`] module"] pub type R29 = crate :: Reg < r29 :: R29Spec > ;
#[doc = "Semaphore 29 register"] pub mod r29 {
#[doc = "Register `R29` reader"] pub type R = crate :: R < R29Spec > ;
#[doc = "Register `R29` writer"] pub type W = crate :: W < R29Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R29Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R29Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R29Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 29 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r29::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r29::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R29Spec ; impl crate :: RegisterSpec for R29Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r29::R`](R) reader structure"] impl crate :: Readable for R29Spec { }
#[doc = "`write(|w| ..)` method takes [`r29::W`](W) writer structure"] impl crate :: Writable for R29Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R29 to value 0"] impl crate :: Resettable for R29Spec { } }
#[doc = "R30 (rw) register accessor: Semaphore 30 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r30::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r30::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r30`] module"] pub type R30 = crate :: Reg < r30 :: R30Spec > ;
#[doc = "Semaphore 30 register"] pub mod r30 {
#[doc = "Register `R30` reader"] pub type R = crate :: R < R30Spec > ;
#[doc = "Register `R30` writer"] pub type W = crate :: W < R30Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R30Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R30Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R30Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 30 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r30::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r30::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R30Spec ; impl crate :: RegisterSpec for R30Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r30::R`](R) reader structure"] impl crate :: Readable for R30Spec { }
#[doc = "`write(|w| ..)` method takes [`r30::W`](W) writer structure"] impl crate :: Writable for R30Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R30 to value 0"] impl crate :: Resettable for R30Spec { } }
#[doc = "R31 (rw) register accessor: Semaphore 31 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r31::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r31::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@r31`] module"] pub type R31 = crate :: Reg < r31 :: R31Spec > ;
#[doc = "Semaphore 31 register"] pub mod r31 {
#[doc = "Register `R31` reader"] pub type R = crate :: R < R31Spec > ;
#[doc = "Register `R31` writer"] pub type W = crate :: W < R31Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `PROCID` writer - Semaphore ProcessID"] pub type ProcidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - Semaphore CoreID"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - lock indication"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& mut self) -> ProcidW < '_ , R31Spec > { ProcidW :: new (self , 0) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , R31Spec > { CoreidW :: new (self , 8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , R31Spec > { LockW :: new (self , 31) } }
#[doc = "Semaphore 31 register\n\nYou can [`read`](crate::Reg::read) this register and get [`r31::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`r31::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct R31Spec ; impl crate :: RegisterSpec for R31Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`r31::R`](R) reader structure"] impl crate :: Readable for R31Spec { }
#[doc = "`write(|w| ..)` method takes [`r31::W`](W) writer structure"] impl crate :: Writable for R31Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets R31 to value 0"] impl crate :: Resettable for R31Spec { } }
#[doc = "RLR0 (r) register accessor: Semaphore 0 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr0::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr0`] module"]
#[doc (alias = "RLR0")] pub type Rlr0 = crate :: Reg < rlr0 :: Rlr0Spec > ;
#[doc = "Semaphore 0 read lock register"] pub mod rlr0 {
#[doc = "Register `RLR0` reader"] pub type R = crate :: R < Rlr0Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 0 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr0::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr0Spec ; impl crate :: RegisterSpec for Rlr0Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr0::R`](R) reader structure"] impl crate :: Readable for Rlr0Spec { }
#[doc = "`reset()` method sets RLR0 to value 0"] impl crate :: Resettable for Rlr0Spec { } }
#[doc = "RLR1 (r) register accessor: Semaphore 1 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr1::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr1`] module"]
#[doc (alias = "RLR1")] pub type Rlr1 = crate :: Reg < rlr1 :: Rlr1Spec > ;
#[doc = "Semaphore 1 read lock register"] pub mod rlr1 {
#[doc = "Register `RLR1` reader"] pub type R = crate :: R < Rlr1Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 1 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr1::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr1Spec ; impl crate :: RegisterSpec for Rlr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr1::R`](R) reader structure"] impl crate :: Readable for Rlr1Spec { }
#[doc = "`reset()` method sets RLR1 to value 0"] impl crate :: Resettable for Rlr1Spec { } }
#[doc = "RLR2 (r) register accessor: Semaphore 2 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr2::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr2`] module"]
#[doc (alias = "RLR2")] pub type Rlr2 = crate :: Reg < rlr2 :: Rlr2Spec > ;
#[doc = "Semaphore 2 read lock register"] pub mod rlr2 {
#[doc = "Register `RLR2` reader"] pub type R = crate :: R < Rlr2Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 2 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr2::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr2Spec ; impl crate :: RegisterSpec for Rlr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr2::R`](R) reader structure"] impl crate :: Readable for Rlr2Spec { }
#[doc = "`reset()` method sets RLR2 to value 0"] impl crate :: Resettable for Rlr2Spec { } }
#[doc = "RLR3 (r) register accessor: Semaphore 3 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr3::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr3`] module"]
#[doc (alias = "RLR3")] pub type Rlr3 = crate :: Reg < rlr3 :: Rlr3Spec > ;
#[doc = "Semaphore 3 read lock register"] pub mod rlr3 {
#[doc = "Register `RLR3` reader"] pub type R = crate :: R < Rlr3Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 3 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr3::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr3Spec ; impl crate :: RegisterSpec for Rlr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr3::R`](R) reader structure"] impl crate :: Readable for Rlr3Spec { }
#[doc = "`reset()` method sets RLR3 to value 0"] impl crate :: Resettable for Rlr3Spec { } }
#[doc = "RLR4 (r) register accessor: Semaphore 4 read lock read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr4::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr4`] module"]
#[doc (alias = "RLR4")] pub type Rlr4 = crate :: Reg < rlr4 :: Rlr4Spec > ;
#[doc = "Semaphore 4 read lock read lock register"] pub mod rlr4 {
#[doc = "Register `RLR4` reader"] pub type R = crate :: R < Rlr4Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 4 read lock read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr4::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr4Spec ; impl crate :: RegisterSpec for Rlr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr4::R`](R) reader structure"] impl crate :: Readable for Rlr4Spec { }
#[doc = "`reset()` method sets RLR4 to value 0"] impl crate :: Resettable for Rlr4Spec { } }
#[doc = "RLR5 (r) register accessor: Semaphore 5 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr5::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr5`] module"]
#[doc (alias = "RLR5")] pub type Rlr5 = crate :: Reg < rlr5 :: Rlr5Spec > ;
#[doc = "Semaphore 5 read lock register"] pub mod rlr5 {
#[doc = "Register `RLR5` reader"] pub type R = crate :: R < Rlr5Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 5 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr5::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr5Spec ; impl crate :: RegisterSpec for Rlr5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr5::R`](R) reader structure"] impl crate :: Readable for Rlr5Spec { }
#[doc = "`reset()` method sets RLR5 to value 0"] impl crate :: Resettable for Rlr5Spec { } }
#[doc = "RLR6 (r) register accessor: Semaphore 6 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr6::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr6`] module"]
#[doc (alias = "RLR6")] pub type Rlr6 = crate :: Reg < rlr6 :: Rlr6Spec > ;
#[doc = "Semaphore 6 read lock register"] pub mod rlr6 {
#[doc = "Register `RLR6` reader"] pub type R = crate :: R < Rlr6Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 6 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr6::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr6Spec ; impl crate :: RegisterSpec for Rlr6Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr6::R`](R) reader structure"] impl crate :: Readable for Rlr6Spec { }
#[doc = "`reset()` method sets RLR6 to value 0"] impl crate :: Resettable for Rlr6Spec { } }
#[doc = "RLR7 (r) register accessor: Semaphore 7 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr7::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr7`] module"]
#[doc (alias = "RLR7")] pub type Rlr7 = crate :: Reg < rlr7 :: Rlr7Spec > ;
#[doc = "Semaphore 7 read lock register"] pub mod rlr7 {
#[doc = "Register `RLR7` reader"] pub type R = crate :: R < Rlr7Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 7 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr7::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr7Spec ; impl crate :: RegisterSpec for Rlr7Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr7::R`](R) reader structure"] impl crate :: Readable for Rlr7Spec { }
#[doc = "`reset()` method sets RLR7 to value 0"] impl crate :: Resettable for Rlr7Spec { } }
#[doc = "RLR8 (r) register accessor: Semaphore 8 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr8::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr8`] module"]
#[doc (alias = "RLR8")] pub type Rlr8 = crate :: Reg < rlr8 :: Rlr8Spec > ;
#[doc = "Semaphore 8 read lock register"] pub mod rlr8 {
#[doc = "Register `RLR8` reader"] pub type R = crate :: R < Rlr8Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 8 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr8::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr8Spec ; impl crate :: RegisterSpec for Rlr8Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr8::R`](R) reader structure"] impl crate :: Readable for Rlr8Spec { }
#[doc = "`reset()` method sets RLR8 to value 0"] impl crate :: Resettable for Rlr8Spec { } }
#[doc = "RLR9 (r) register accessor: Semaphore 9 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr9::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr9`] module"]
#[doc (alias = "RLR9")] pub type Rlr9 = crate :: Reg < rlr9 :: Rlr9Spec > ;
#[doc = "Semaphore 9 read lock register"] pub mod rlr9 {
#[doc = "Register `RLR9` reader"] pub type R = crate :: R < Rlr9Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 9 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr9::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr9Spec ; impl crate :: RegisterSpec for Rlr9Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr9::R`](R) reader structure"] impl crate :: Readable for Rlr9Spec { }
#[doc = "`reset()` method sets RLR9 to value 0"] impl crate :: Resettable for Rlr9Spec { } }
#[doc = "RLR10 (r) register accessor: Semaphore 10 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr10::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr10`] module"]
#[doc (alias = "RLR10")] pub type Rlr10 = crate :: Reg < rlr10 :: Rlr10Spec > ;
#[doc = "Semaphore 10 read lock register"] pub mod rlr10 {
#[doc = "Register `RLR10` reader"] pub type R = crate :: R < Rlr10Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 10 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr10::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr10Spec ; impl crate :: RegisterSpec for Rlr10Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr10::R`](R) reader structure"] impl crate :: Readable for Rlr10Spec { }
#[doc = "`reset()` method sets RLR10 to value 0"] impl crate :: Resettable for Rlr10Spec { } }
#[doc = "RLR11 (r) register accessor: Semaphore 11 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr11::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr11`] module"]
#[doc (alias = "RLR11")] pub type Rlr11 = crate :: Reg < rlr11 :: Rlr11Spec > ;
#[doc = "Semaphore 11 read lock register"] pub mod rlr11 {
#[doc = "Register `RLR11` reader"] pub type R = crate :: R < Rlr11Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 11 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr11::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr11Spec ; impl crate :: RegisterSpec for Rlr11Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr11::R`](R) reader structure"] impl crate :: Readable for Rlr11Spec { }
#[doc = "`reset()` method sets RLR11 to value 0"] impl crate :: Resettable for Rlr11Spec { } }
#[doc = "RLR12 (r) register accessor: Semaphore 12 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr12::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr12`] module"]
#[doc (alias = "RLR12")] pub type Rlr12 = crate :: Reg < rlr12 :: Rlr12Spec > ;
#[doc = "Semaphore 12 read lock register"] pub mod rlr12 {
#[doc = "Register `RLR12` reader"] pub type R = crate :: R < Rlr12Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 12 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr12::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr12Spec ; impl crate :: RegisterSpec for Rlr12Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr12::R`](R) reader structure"] impl crate :: Readable for Rlr12Spec { }
#[doc = "`reset()` method sets RLR12 to value 0"] impl crate :: Resettable for Rlr12Spec { } }
#[doc = "RLR13 (r) register accessor: Semaphore 13 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr13::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr13`] module"]
#[doc (alias = "RLR13")] pub type Rlr13 = crate :: Reg < rlr13 :: Rlr13Spec > ;
#[doc = "Semaphore 13 read lock register"] pub mod rlr13 {
#[doc = "Register `RLR13` reader"] pub type R = crate :: R < Rlr13Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 13 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr13::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr13Spec ; impl crate :: RegisterSpec for Rlr13Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr13::R`](R) reader structure"] impl crate :: Readable for Rlr13Spec { }
#[doc = "`reset()` method sets RLR13 to value 0"] impl crate :: Resettable for Rlr13Spec { } }
#[doc = "RLR14 (r) register accessor: Semaphore 14 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr14::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr14`] module"]
#[doc (alias = "RLR14")] pub type Rlr14 = crate :: Reg < rlr14 :: Rlr14Spec > ;
#[doc = "Semaphore 14 read lock register"] pub mod rlr14 {
#[doc = "Register `RLR14` reader"] pub type R = crate :: R < Rlr14Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 14 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr14::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr14Spec ; impl crate :: RegisterSpec for Rlr14Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr14::R`](R) reader structure"] impl crate :: Readable for Rlr14Spec { }
#[doc = "`reset()` method sets RLR14 to value 0"] impl crate :: Resettable for Rlr14Spec { } }
#[doc = "RLR15 (r) register accessor: Semaphore 15 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr15::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr15`] module"]
#[doc (alias = "RLR15")] pub type Rlr15 = crate :: Reg < rlr15 :: Rlr15Spec > ;
#[doc = "Semaphore 15 read lock register"] pub mod rlr15 {
#[doc = "Register `RLR15` reader"] pub type R = crate :: R < Rlr15Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 15 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr15::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr15Spec ; impl crate :: RegisterSpec for Rlr15Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr15::R`](R) reader structure"] impl crate :: Readable for Rlr15Spec { }
#[doc = "`reset()` method sets RLR15 to value 0"] impl crate :: Resettable for Rlr15Spec { } }
#[doc = "RLR16 (r) register accessor: Semaphore 16 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr16::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr16`] module"]
#[doc (alias = "RLR16")] pub type Rlr16 = crate :: Reg < rlr16 :: Rlr16Spec > ;
#[doc = "Semaphore 16 read lock register"] pub mod rlr16 {
#[doc = "Register `RLR16` reader"] pub type R = crate :: R < Rlr16Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 16 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr16::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr16Spec ; impl crate :: RegisterSpec for Rlr16Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr16::R`](R) reader structure"] impl crate :: Readable for Rlr16Spec { }
#[doc = "`reset()` method sets RLR16 to value 0"] impl crate :: Resettable for Rlr16Spec { } }
#[doc = "RLR17 (r) register accessor: Semaphore 17 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr17::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr17`] module"]
#[doc (alias = "RLR17")] pub type Rlr17 = crate :: Reg < rlr17 :: Rlr17Spec > ;
#[doc = "Semaphore 17 read lock register"] pub mod rlr17 {
#[doc = "Register `RLR17` reader"] pub type R = crate :: R < Rlr17Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 17 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr17::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr17Spec ; impl crate :: RegisterSpec for Rlr17Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr17::R`](R) reader structure"] impl crate :: Readable for Rlr17Spec { }
#[doc = "`reset()` method sets RLR17 to value 0"] impl crate :: Resettable for Rlr17Spec { } }
#[doc = "RLR18 (r) register accessor: Semaphore 18 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr18::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr18`] module"]
#[doc (alias = "RLR18")] pub type Rlr18 = crate :: Reg < rlr18 :: Rlr18Spec > ;
#[doc = "Semaphore 18 read lock register"] pub mod rlr18 {
#[doc = "Register `RLR18` reader"] pub type R = crate :: R < Rlr18Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 18 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr18::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr18Spec ; impl crate :: RegisterSpec for Rlr18Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr18::R`](R) reader structure"] impl crate :: Readable for Rlr18Spec { }
#[doc = "`reset()` method sets RLR18 to value 0"] impl crate :: Resettable for Rlr18Spec { } }
#[doc = "RLR19 (r) register accessor: Semaphore 19 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr19::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr19`] module"]
#[doc (alias = "RLR19")] pub type Rlr19 = crate :: Reg < rlr19 :: Rlr19Spec > ;
#[doc = "Semaphore 19 read lock register"] pub mod rlr19 {
#[doc = "Register `RLR19` reader"] pub type R = crate :: R < Rlr19Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 19 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr19::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr19Spec ; impl crate :: RegisterSpec for Rlr19Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr19::R`](R) reader structure"] impl crate :: Readable for Rlr19Spec { }
#[doc = "`reset()` method sets RLR19 to value 0"] impl crate :: Resettable for Rlr19Spec { } }
#[doc = "RLR20 (r) register accessor: Semaphore 20 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr20::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr20`] module"]
#[doc (alias = "RLR20")] pub type Rlr20 = crate :: Reg < rlr20 :: Rlr20Spec > ;
#[doc = "Semaphore 20 read lock register"] pub mod rlr20 {
#[doc = "Register `RLR20` reader"] pub type R = crate :: R < Rlr20Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 20 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr20::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr20Spec ; impl crate :: RegisterSpec for Rlr20Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr20::R`](R) reader structure"] impl crate :: Readable for Rlr20Spec { }
#[doc = "`reset()` method sets RLR20 to value 0"] impl crate :: Resettable for Rlr20Spec { } }
#[doc = "RLR21 (r) register accessor: Semaphore 21 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr21::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr21`] module"]
#[doc (alias = "RLR21")] pub type Rlr21 = crate :: Reg < rlr21 :: Rlr21Spec > ;
#[doc = "Semaphore 21 read lock register"] pub mod rlr21 {
#[doc = "Register `RLR21` reader"] pub type R = crate :: R < Rlr21Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 21 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr21::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr21Spec ; impl crate :: RegisterSpec for Rlr21Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr21::R`](R) reader structure"] impl crate :: Readable for Rlr21Spec { }
#[doc = "`reset()` method sets RLR21 to value 0"] impl crate :: Resettable for Rlr21Spec { } }
#[doc = "RLR22 (r) register accessor: Semaphore 22 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr22::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr22`] module"]
#[doc (alias = "RLR22")] pub type Rlr22 = crate :: Reg < rlr22 :: Rlr22Spec > ;
#[doc = "Semaphore 22 read lock register"] pub mod rlr22 {
#[doc = "Register `RLR22` reader"] pub type R = crate :: R < Rlr22Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 22 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr22::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr22Spec ; impl crate :: RegisterSpec for Rlr22Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr22::R`](R) reader structure"] impl crate :: Readable for Rlr22Spec { }
#[doc = "`reset()` method sets RLR22 to value 0"] impl crate :: Resettable for Rlr22Spec { } }
#[doc = "RLR23 (r) register accessor: Semaphore 23 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr23::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr23`] module"]
#[doc (alias = "RLR23")] pub type Rlr23 = crate :: Reg < rlr23 :: Rlr23Spec > ;
#[doc = "Semaphore 23 read lock register"] pub mod rlr23 {
#[doc = "Register `RLR23` reader"] pub type R = crate :: R < Rlr23Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 23 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr23::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr23Spec ; impl crate :: RegisterSpec for Rlr23Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr23::R`](R) reader structure"] impl crate :: Readable for Rlr23Spec { }
#[doc = "`reset()` method sets RLR23 to value 0"] impl crate :: Resettable for Rlr23Spec { } }
#[doc = "RLR24 (r) register accessor: Semaphore 24 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr24::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr24`] module"]
#[doc (alias = "RLR24")] pub type Rlr24 = crate :: Reg < rlr24 :: Rlr24Spec > ;
#[doc = "Semaphore 24 read lock register"] pub mod rlr24 {
#[doc = "Register `RLR24` reader"] pub type R = crate :: R < Rlr24Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 24 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr24::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr24Spec ; impl crate :: RegisterSpec for Rlr24Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr24::R`](R) reader structure"] impl crate :: Readable for Rlr24Spec { }
#[doc = "`reset()` method sets RLR24 to value 0"] impl crate :: Resettable for Rlr24Spec { } }
#[doc = "RLR25 (r) register accessor: Semaphore 25 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr25::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr25`] module"]
#[doc (alias = "RLR25")] pub type Rlr25 = crate :: Reg < rlr25 :: Rlr25Spec > ;
#[doc = "Semaphore 25 read lock register"] pub mod rlr25 {
#[doc = "Register `RLR25` reader"] pub type R = crate :: R < Rlr25Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 25 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr25::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr25Spec ; impl crate :: RegisterSpec for Rlr25Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr25::R`](R) reader structure"] impl crate :: Readable for Rlr25Spec { }
#[doc = "`reset()` method sets RLR25 to value 0"] impl crate :: Resettable for Rlr25Spec { } }
#[doc = "RLR26 (r) register accessor: Semaphore 26 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr26::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr26`] module"]
#[doc (alias = "RLR26")] pub type Rlr26 = crate :: Reg < rlr26 :: Rlr26Spec > ;
#[doc = "Semaphore 26 read lock register"] pub mod rlr26 {
#[doc = "Register `RLR26` reader"] pub type R = crate :: R < Rlr26Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 26 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr26::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr26Spec ; impl crate :: RegisterSpec for Rlr26Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr26::R`](R) reader structure"] impl crate :: Readable for Rlr26Spec { }
#[doc = "`reset()` method sets RLR26 to value 0"] impl crate :: Resettable for Rlr26Spec { } }
#[doc = "RLR27 (r) register accessor: Semaphore 27 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr27::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr27`] module"]
#[doc (alias = "RLR27")] pub type Rlr27 = crate :: Reg < rlr27 :: Rlr27Spec > ;
#[doc = "Semaphore 27 read lock register"] pub mod rlr27 {
#[doc = "Register `RLR27` reader"] pub type R = crate :: R < Rlr27Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 27 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr27::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr27Spec ; impl crate :: RegisterSpec for Rlr27Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr27::R`](R) reader structure"] impl crate :: Readable for Rlr27Spec { }
#[doc = "`reset()` method sets RLR27 to value 0"] impl crate :: Resettable for Rlr27Spec { } }
#[doc = "RLR28 (r) register accessor: Semaphore 28 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr28::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr28`] module"]
#[doc (alias = "RLR28")] pub type Rlr28 = crate :: Reg < rlr28 :: Rlr28Spec > ;
#[doc = "Semaphore 28 read lock register"] pub mod rlr28 {
#[doc = "Register `RLR28` reader"] pub type R = crate :: R < Rlr28Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 28 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr28::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr28Spec ; impl crate :: RegisterSpec for Rlr28Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr28::R`](R) reader structure"] impl crate :: Readable for Rlr28Spec { }
#[doc = "`reset()` method sets RLR28 to value 0"] impl crate :: Resettable for Rlr28Spec { } }
#[doc = "RLR29 (r) register accessor: Semaphore 29 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr29::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr29`] module"]
#[doc (alias = "RLR29")] pub type Rlr29 = crate :: Reg < rlr29 :: Rlr29Spec > ;
#[doc = "Semaphore 29 read lock register"] pub mod rlr29 {
#[doc = "Register `RLR29` reader"] pub type R = crate :: R < Rlr29Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 29 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr29::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr29Spec ; impl crate :: RegisterSpec for Rlr29Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr29::R`](R) reader structure"] impl crate :: Readable for Rlr29Spec { }
#[doc = "`reset()` method sets RLR29 to value 0"] impl crate :: Resettable for Rlr29Spec { } }
#[doc = "RLR30 (r) register accessor: Semaphore 30 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr30::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr30`] module"]
#[doc (alias = "RLR30")] pub type Rlr30 = crate :: Reg < rlr30 :: Rlr30Spec > ;
#[doc = "Semaphore 30 read lock register"] pub mod rlr30 {
#[doc = "Register `RLR30` reader"] pub type R = crate :: R < Rlr30Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 30 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr30::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr30Spec ; impl crate :: RegisterSpec for Rlr30Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr30::R`](R) reader structure"] impl crate :: Readable for Rlr30Spec { }
#[doc = "`reset()` method sets RLR30 to value 0"] impl crate :: Resettable for Rlr30Spec { } }
#[doc = "RLR31 (r) register accessor: Semaphore 31 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr31::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr31`] module"]
#[doc (alias = "RLR31")] pub type Rlr31 = crate :: Reg < rlr31 :: Rlr31Spec > ;
#[doc = "Semaphore 31 read lock register"] pub mod rlr31 {
#[doc = "Register `RLR31` reader"] pub type R = crate :: R < Rlr31Spec > ;
#[doc = "Field `PROCID` reader - Semaphore ProcessID"] pub type ProcidR = crate :: FieldReader ;
#[doc = "Field `COREID` reader - Semaphore CoreID"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `LOCK` reader - lock indication"] pub type LockR = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - Semaphore ProcessID"]
#[inline (always)] pub fn procid (& self) -> ProcidR { ProcidR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Semaphore CoreID"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 31 - lock indication"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Semaphore 31 read lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr31::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rlr31Spec ; impl crate :: RegisterSpec for Rlr31Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr31::R`](R) reader structure"] impl crate :: Readable for Rlr31Spec { }
#[doc = "`reset()` method sets RLR31 to value 0"] impl crate :: Resettable for Rlr31Spec { } }
#[doc = "CR (rw) register accessor: Semaphore Clear register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "Semaphore Clear register"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `COREID` reader - CoreID of semaphore to be cleared"] pub type CoreidR = crate :: FieldReader ;
#[doc = "Field `COREID` writer - CoreID of semaphore to be cleared"] pub type CoreidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `KEY` reader - Semaphore clear Key"] pub type KeyR = crate :: FieldReader < u16 > ;
#[doc = "Field `KEY` writer - Semaphore clear Key"] pub type KeyW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 8:11 - CoreID of semaphore to be cleared"]
#[inline (always)] pub fn coreid (& self) -> CoreidR { CoreidR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 16:31 - Semaphore clear Key"]
#[inline (always)] pub fn key (& self) -> KeyR { KeyR :: new (((self . bits >> 16) & 0xffff) as u16) } } impl W {
#[doc = "Bits 8:11 - CoreID of semaphore to be cleared"]
#[inline (always)] pub fn coreid (& mut self) -> CoreidW < '_ , CrSpec > { CoreidW :: new (self , 8) }
#[doc = "Bits 16:31 - Semaphore clear Key"]
#[inline (always)] pub fn key (& mut self) -> KeyW < '_ , CrSpec > { KeyW :: new (self , 16) } }
#[doc = "Semaphore Clear register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { } }
#[doc = "KEYR (rw) register accessor: Interrupt clear register\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@keyr`] module"]
#[doc (alias = "KEYR")] pub type Keyr = crate :: Reg < keyr :: KeyrSpec > ;
#[doc = "Interrupt clear register"] pub mod keyr {
#[doc = "Register `KEYR` reader"] pub type R = crate :: R < KeyrSpec > ;
#[doc = "Register `KEYR` writer"] pub type W = crate :: W < KeyrSpec > ;
#[doc = "Field `KEY` reader - Semaphore Clear Key"] pub type KeyR = crate :: FieldReader < u16 > ;
#[doc = "Field `KEY` writer - Semaphore Clear Key"] pub type KeyW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 16:31 - Semaphore Clear Key"]
#[inline (always)] pub fn key (& self) -> KeyR { KeyR :: new (((self . bits >> 16) & 0xffff) as u16) } } impl W {
#[doc = "Bits 16:31 - Semaphore Clear Key"]
#[inline (always)] pub fn key (& mut self) -> KeyW < '_ , KeyrSpec > { KeyW :: new (self , 16) } }
#[doc = "Interrupt clear register\n\nYou can [`read`](crate::Reg::read) this register and get [`keyr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct KeyrSpec ; impl crate :: RegisterSpec for KeyrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`keyr::R`](R) reader structure"] impl crate :: Readable for KeyrSpec { }
#[doc = "`write(|w| ..)` method takes [`keyr::W`](W) writer structure"] impl crate :: Writable for KeyrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets KEYR to value 0"] impl crate :: Resettable for KeyrSpec { } }
#[doc = "HWCFGR2 (r) register accessor: Semaphore hardware configuration register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`hwcfgr2::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hwcfgr2`] module"]
#[doc (alias = "HWCFGR2")] pub type Hwcfgr2 = crate :: Reg < hwcfgr2 :: Hwcfgr2Spec > ;
#[doc = "Semaphore hardware configuration register 2"] pub mod hwcfgr2 {
#[doc = "Register `HWCFGR2` reader"] pub type R = crate :: R < Hwcfgr2Spec > ;
#[doc = "Field `MASTERID1` reader - Hardware Configuration valid bus masters ID1"] pub type Masterid1R = crate :: FieldReader ;
#[doc = "Field `MASTERID2` reader - Hardware Configuration valid bus masters ID2"] pub type Masterid2R = crate :: FieldReader ;
#[doc = "Field `MASTERID3` reader - Hardware Configuration valid bus masters ID3"] pub type Masterid3R = crate :: FieldReader ;
#[doc = "Field `MASTERID4` reader - Hardware Configuration valid bus masters ID4"] pub type Masterid4R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:3 - Hardware Configuration valid bus masters ID1"]
#[inline (always)] pub fn masterid1 (& self) -> Masterid1R { Masterid1R :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - Hardware Configuration valid bus masters ID2"]
#[inline (always)] pub fn masterid2 (& self) -> Masterid2R { Masterid2R :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:11 - Hardware Configuration valid bus masters ID3"]
#[inline (always)] pub fn masterid3 (& self) -> Masterid3R { Masterid3R :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:15 - Hardware Configuration valid bus masters ID4"]
#[inline (always)] pub fn masterid4 (& self) -> Masterid4R { Masterid4R :: new (((self . bits >> 12) & 0x0f) as u8) } }
#[doc = "Semaphore hardware configuration register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`hwcfgr2::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Hwcfgr2Spec ; impl crate :: RegisterSpec for Hwcfgr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`hwcfgr2::R`](R) reader structure"] impl crate :: Readable for Hwcfgr2Spec { }
#[doc = "`reset()` method sets HWCFGR2 to value 0x84"] impl crate :: Resettable for Hwcfgr2Spec { const RESET_VALUE : u32 = 0x84 ; } }
#[doc = "HWCFGR1 (r) register accessor: Semaphore hardware configuration register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`hwcfgr1::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hwcfgr1`] module"]
#[doc (alias = "HWCFGR1")] pub type Hwcfgr1 = crate :: Reg < hwcfgr1 :: Hwcfgr1Spec > ;
#[doc = "Semaphore hardware configuration register 1"] pub mod hwcfgr1 {
#[doc = "Register `HWCFGR1` reader"] pub type R = crate :: R < Hwcfgr1Spec > ;
#[doc = "Field `NBSEM` reader - Hardware Configuration number of semaphores"] pub type NbsemR = crate :: FieldReader ;
#[doc = "Field `NBINT` reader - Hardware Configuration number of interrupts supported number of master IDs"] pub type NbintR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - Hardware Configuration number of semaphores"]
#[inline (always)] pub fn nbsem (& self) -> NbsemR { NbsemR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - Hardware Configuration number of interrupts supported number of master IDs"]
#[inline (always)] pub fn nbint (& self) -> NbintR { NbintR :: new (((self . bits >> 8) & 0x0f) as u8) } }
#[doc = "Semaphore hardware configuration register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`hwcfgr1::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Hwcfgr1Spec ; impl crate :: RegisterSpec for Hwcfgr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`hwcfgr1::R`](R) reader structure"] impl crate :: Readable for Hwcfgr1Spec { }
#[doc = "`reset()` method sets HWCFGR1 to value 0x0220"] impl crate :: Resettable for Hwcfgr1Spec { const RESET_VALUE : u32 = 0x0220 ; } }
#[doc = "VERR (r) register accessor: HSEM version register\n\nYou can [`read`](crate::Reg::read) this register and get [`verr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@verr`] module"]
#[doc (alias = "VERR")] pub type Verr = crate :: Reg < verr :: VerrSpec > ;
#[doc = "HSEM version register"] pub mod verr {
#[doc = "Register `VERR` reader"] pub type R = crate :: R < VerrSpec > ;
#[doc = "Field `MINREV` reader - Minor Revision"] pub type MinrevR = crate :: FieldReader ;
#[doc = "Field `MAJREV` reader - Major Revision"] pub type MajrevR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:3 - Minor Revision"]
#[inline (always)] pub fn minrev (& self) -> MinrevR { MinrevR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - Major Revision"]
#[inline (always)] pub fn majrev (& self) -> MajrevR { MajrevR :: new (((self . bits >> 4) & 0x0f) as u8) } }
#[doc = "HSEM version register\n\nYou can [`read`](crate::Reg::read) this register and get [`verr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct VerrSpec ; impl crate :: RegisterSpec for VerrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`verr::R`](R) reader structure"] impl crate :: Readable for VerrSpec { }
#[doc = "`reset()` method sets VERR to value 0x20"] impl crate :: Resettable for VerrSpec { const RESET_VALUE : u32 = 0x20 ; } }
#[doc = "IPIDR (r) register accessor: HSEM indentification register\n\nYou can [`read`](crate::Reg::read) this register and get [`ipidr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ipidr`] module"]
#[doc (alias = "IPIDR")] pub type Ipidr = crate :: Reg < ipidr :: IpidrSpec > ;
#[doc = "HSEM indentification register"] pub mod ipidr {
#[doc = "Register `IPIDR` reader"] pub type R = crate :: R < IpidrSpec > ;
#[doc = "Field `ID` reader - Identification Code"] pub type IdR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Identification Code"]
#[inline (always)] pub fn id (& self) -> IdR { IdR :: new (self . bits) } }
#[doc = "HSEM indentification register\n\nYou can [`read`](crate::Reg::read) this register and get [`ipidr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IpidrSpec ; impl crate :: RegisterSpec for IpidrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ipidr::R`](R) reader structure"] impl crate :: Readable for IpidrSpec { }
#[doc = "`reset()` method sets IPIDR to value 0x0010_0072"] impl crate :: Resettable for IpidrSpec { const RESET_VALUE : u32 = 0x0010_0072 ; } }
#[doc = "SIDR (r) register accessor: HSEM size indentification register\n\nYou can [`read`](crate::Reg::read) this register and get [`sidr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sidr`] module"]
#[doc (alias = "SIDR")] pub type Sidr = crate :: Reg < sidr :: SidrSpec > ;
#[doc = "HSEM size indentification register"] pub mod sidr {
#[doc = "Register `SIDR` reader"] pub type R = crate :: R < SidrSpec > ;
#[doc = "Field `SID` reader - Size Identification Code"] pub type SidR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Size Identification Code"]
#[inline (always)] pub fn sid (& self) -> SidR { SidR :: new (self . bits) } }
#[doc = "HSEM size indentification register\n\nYou can [`read`](crate::Reg::read) this register and get [`sidr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SidrSpec ; impl crate :: RegisterSpec for SidrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sidr::R`](R) reader structure"] impl crate :: Readable for SidrSpec { }
#[doc = "`reset()` method sets SIDR to value 0xa3c5_dd01"] impl crate :: Resettable for SidrSpec { const RESET_VALUE : u32 = 0xa3c5_dd01 ; } }
#[doc = "C1IER0 (rw) register accessor: HSEM Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`c1ier0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c1ier0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c1ier0`] module"]
#[doc (alias = "C1IER0")] pub type C1ier0 = crate :: Reg < c1ier0 :: C1ier0Spec > ;
#[doc = "HSEM Interrupt enable register"] pub mod c1ier0 {
#[doc = "Register `C1IER0` reader"] pub type R = crate :: R < C1ier0Spec > ;
#[doc = "Register `C1IER0` writer"] pub type W = crate :: W < C1ier0Spec > ;
#[doc = "Field `ISEm` reader - CPU(n) semaphore m enable bit"] pub type IsemR = crate :: FieldReader < u32 > ;
#[doc = "Field `ISEm` writer - CPU(n) semaphore m enable bit"] pub type IsemW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - CPU(n) semaphore m enable bit"]
#[inline (always)] pub fn isem (& self) -> IsemR { IsemR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - CPU(n) semaphore m enable bit"]
#[inline (always)] pub fn isem (& mut self) -> IsemW < '_ , C1ier0Spec > { IsemW :: new (self , 0) } }
#[doc = "HSEM Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`c1ier0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c1ier0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C1ier0Spec ; impl crate :: RegisterSpec for C1ier0Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c1ier0::R`](R) reader structure"] impl crate :: Readable for C1ier0Spec { }
#[doc = "`write(|w| ..)` method takes [`c1ier0::W`](W) writer structure"] impl crate :: Writable for C1ier0Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C1IER0 to value 0"] impl crate :: Resettable for C1ier0Spec { } }
#[doc = "C1ICR (rw) register accessor: HSEM Interrupt clear register\n\nYou can [`read`](crate::Reg::read) this register and get [`c1icr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c1icr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c1icr`] module"]
#[doc (alias = "C1ICR")] pub type C1icr = crate :: Reg < c1icr :: C1icrSpec > ;
#[doc = "HSEM Interrupt clear register"] pub mod c1icr {
#[doc = "Register `C1ICR` reader"] pub type R = crate :: R < C1icrSpec > ;
#[doc = "Register `C1ICR` writer"] pub type W = crate :: W < C1icrSpec > ;
#[doc = "Field `ISCm` reader - CPU(n) semaphore m clear bit"] pub type IscmR = crate :: FieldReader < u32 > ;
#[doc = "Field `ISCm` writer - CPU(n) semaphore m clear bit"] pub type IscmW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - CPU(n) semaphore m clear bit"]
#[inline (always)] pub fn iscm (& self) -> IscmR { IscmR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - CPU(n) semaphore m clear bit"]
#[inline (always)] pub fn iscm (& mut self) -> IscmW < '_ , C1icrSpec > { IscmW :: new (self , 0) } }
#[doc = "HSEM Interrupt clear register\n\nYou can [`read`](crate::Reg::read) this register and get [`c1icr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c1icr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C1icrSpec ; impl crate :: RegisterSpec for C1icrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c1icr::R`](R) reader structure"] impl crate :: Readable for C1icrSpec { }
#[doc = "`write(|w| ..)` method takes [`c1icr::W`](W) writer structure"] impl crate :: Writable for C1icrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C1ICR to value 0"] impl crate :: Resettable for C1icrSpec { } }
#[doc = "C1ISR (r) register accessor: HSEM Interrupt status register\n\nYou can [`read`](crate::Reg::read) this register and get [`c1isr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c1isr`] module"]
#[doc (alias = "C1ISR")] pub type C1isr = crate :: Reg < c1isr :: C1isrSpec > ;
#[doc = "HSEM Interrupt status register"] pub mod c1isr {
#[doc = "Register `C1ISR` reader"] pub type R = crate :: R < C1isrSpec > ;
#[doc = "Field `ISFm` reader - CPU(n) semaphore m status bit before enable (mask)"] pub type IsfmR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - CPU(n) semaphore m status bit before enable (mask)"]
#[inline (always)] pub fn isfm (& self) -> IsfmR { IsfmR :: new (self . bits) } }
#[doc = "HSEM Interrupt status register\n\nYou can [`read`](crate::Reg::read) this register and get [`c1isr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C1isrSpec ; impl crate :: RegisterSpec for C1isrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c1isr::R`](R) reader structure"] impl crate :: Readable for C1isrSpec { }
#[doc = "`reset()` method sets C1ISR to value 0"] impl crate :: Resettable for C1isrSpec { } }
#[doc = "C1MISR (r) register accessor: HSEM Masked interrupt status register\n\nYou can [`read`](crate::Reg::read) this register and get [`c1misr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c1misr`] module"]
#[doc (alias = "C1MISR")] pub type C1misr = crate :: Reg < c1misr :: C1misrSpec > ;
#[doc = "HSEM Masked interrupt status register"] pub mod c1misr {
#[doc = "Register `C1MISR` reader"] pub type R = crate :: R < C1misrSpec > ;
#[doc = "Field `MISFm` reader - masked CPU(n) semaphore m status bit after enable (mask)."] pub type MisfmR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - masked CPU(n) semaphore m status bit after enable (mask)."]
#[inline (always)] pub fn misfm (& self) -> MisfmR { MisfmR :: new (self . bits) } }
#[doc = "HSEM Masked interrupt status register\n\nYou can [`read`](crate::Reg::read) this register and get [`c1misr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C1misrSpec ; impl crate :: RegisterSpec for C1misrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c1misr::R`](R) reader structure"] impl crate :: Readable for C1misrSpec { }
#[doc = "`reset()` method sets C1MISR to value 0"] impl crate :: Resettable for C1misrSpec { } }
#[doc = "C2IER0 (rw) register accessor: HSEM Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2ier0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2ier0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2ier0`] module"]
#[doc (alias = "C2IER0")] pub type C2ier0 = crate :: Reg < c2ier0 :: C2ier0Spec > ;
#[doc = "HSEM Interrupt enable register"] pub mod c2ier0 {
#[doc = "Register `C2IER0` reader"] pub type R = crate :: R < C2ier0Spec > ;
#[doc = "Register `C2IER0` writer"] pub type W = crate :: W < C2ier0Spec > ;
#[doc = "Field `ISEm` reader - CPU(2) semaphore m enable bit."] pub type IsemR = crate :: FieldReader < u32 > ;
#[doc = "Field `ISEm` writer - CPU(2) semaphore m enable bit."] pub type IsemW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - CPU(2) semaphore m enable bit."]
#[inline (always)] pub fn isem (& self) -> IsemR { IsemR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - CPU(2) semaphore m enable bit."]
#[inline (always)] pub fn isem (& mut self) -> IsemW < '_ , C2ier0Spec > { IsemW :: new (self , 0) } }
#[doc = "HSEM Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2ier0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2ier0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2ier0Spec ; impl crate :: RegisterSpec for C2ier0Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2ier0::R`](R) reader structure"] impl crate :: Readable for C2ier0Spec { }
#[doc = "`write(|w| ..)` method takes [`c2ier0::W`](W) writer structure"] impl crate :: Writable for C2ier0Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2IER0 to value 0"] impl crate :: Resettable for C2ier0Spec { } }
#[doc = "C2ICR (rw) register accessor: HSEM Interrupt clear register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2icr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2icr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2icr`] module"]
#[doc (alias = "C2ICR")] pub type C2icr = crate :: Reg < c2icr :: C2icrSpec > ;
#[doc = "HSEM Interrupt clear register"] pub mod c2icr {
#[doc = "Register `C2ICR` reader"] pub type R = crate :: R < C2icrSpec > ;
#[doc = "Register `C2ICR` writer"] pub type W = crate :: W < C2icrSpec > ;
#[doc = "Field `ISCm` reader - CPU(2) semaphore m clear bit"] pub type IscmR = crate :: FieldReader < u32 > ;
#[doc = "Field `ISCm` writer - CPU(2) semaphore m clear bit"] pub type IscmW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - CPU(2) semaphore m clear bit"]
#[inline (always)] pub fn iscm (& self) -> IscmR { IscmR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - CPU(2) semaphore m clear bit"]
#[inline (always)] pub fn iscm (& mut self) -> IscmW < '_ , C2icrSpec > { IscmW :: new (self , 0) } }
#[doc = "HSEM Interrupt clear register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2icr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2icr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2icrSpec ; impl crate :: RegisterSpec for C2icrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2icr::R`](R) reader structure"] impl crate :: Readable for C2icrSpec { }
#[doc = "`write(|w| ..)` method takes [`c2icr::W`](W) writer structure"] impl crate :: Writable for C2icrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2ICR to value 0"] impl crate :: Resettable for C2icrSpec { } }
#[doc = "C2ISR (r) register accessor: HSEM Interrupt status register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2isr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2isr`] module"]
#[doc (alias = "C2ISR")] pub type C2isr = crate :: Reg < c2isr :: C2isrSpec > ;
#[doc = "HSEM Interrupt status register"] pub mod c2isr {
#[doc = "Register `C2ISR` reader"] pub type R = crate :: R < C2isrSpec > ;
#[doc = "Field `ISFm` reader - CPU(2) semaphore m status bit before enable (mask)."] pub type IsfmR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - CPU(2) semaphore m status bit before enable (mask)."]
#[inline (always)] pub fn isfm (& self) -> IsfmR { IsfmR :: new (self . bits) } }
#[doc = "HSEM Interrupt status register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2isr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2isrSpec ; impl crate :: RegisterSpec for C2isrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2isr::R`](R) reader structure"] impl crate :: Readable for C2isrSpec { }
#[doc = "`reset()` method sets C2ISR to value 0"] impl crate :: Resettable for C2isrSpec { } }
#[doc = "C2MISR (r) register accessor: HSEM Masked interrupt status register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2misr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2misr`] module"]
#[doc (alias = "C2MISR")] pub type C2misr = crate :: Reg < c2misr :: C2misrSpec > ;
#[doc = "HSEM Masked interrupt status register"] pub mod c2misr {
#[doc = "Register `C2MISR` reader"] pub type R = crate :: R < C2misrSpec > ;
#[doc = "Field `MISFm` reader - masked CPU(2) semaphore m status bit after enable (mask)."] pub type MisfmR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - masked CPU(2) semaphore m status bit after enable (mask)."]
#[inline (always)] pub fn misfm (& self) -> MisfmR { MisfmR :: new (self . bits) } }
#[doc = "HSEM Masked interrupt status register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2misr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2misrSpec ; impl crate :: RegisterSpec for C2misrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2misr::R`](R) reader structure"] impl crate :: Readable for C2misrSpec { }
#[doc = "`reset()` method sets C2MISR to value 0"] impl crate :: Resettable for C2misrSpec { } } }
#[doc = "Analog to Digital Converter instance 1"] pub type Adc = crate :: Periph < adc :: RegisterBlock , 0x5004_0000 > ; impl core :: fmt :: Debug for Adc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Adc") . finish () } }
#[doc = "Analog to Digital Converter instance 1"] pub mod adc {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { isr : Isr , ier : Ier , cr : Cr , cfgr : Cfgr , cfgr2 : Cfgr2 , smpr1 : Smpr1 , smpr2 : Smpr2 , _reserved7 : [u8 ; 0x04] , tr1 : Tr1 , tr2 : Tr2 , tr3 : Tr3 , _reserved10 : [u8 ; 0x04] , sqr1 : Sqr1 , sqr2 : Sqr2 , sqr3 : Sqr3 , sqr4 : Sqr4 , dr : Dr , _reserved15 : [u8 ; 0x08] , jsqr : Jsqr , _reserved16 : [u8 ; 0x10] , ofr1 : Ofr1 , ofr2 : Ofr2 , ofr3 : Ofr3 , ofr4 : Ofr4 , _reserved20 : [u8 ; 0x10] , jdr1 : Jdr1 , jdr2 : Jdr2 , jdr3 : Jdr3 , jdr4 : Jdr4 , _reserved24 : [u8 ; 0x10] , awd2cr : Awd2cr , awd3cr : Awd3cr , _reserved26 : [u8 ; 0x08] , difsel : Difsel , calfact : Calfact , _reserved28 : [u8 ; 0x0250] , ccr : Ccr , } impl RegisterBlock {
#[doc = "0x00 - ADC interrupt and status register"]
#[inline (always)] pub const fn isr (& self) -> & Isr { & self . isr }
#[doc = "0x04 - ADC interrupt enable register"]
#[inline (always)] pub const fn ier (& self) -> & Ier { & self . ier }
#[doc = "0x08 - ADC control register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x0c - ADC configuration register 1"]
#[inline (always)] pub const fn cfgr (& self) -> & Cfgr { & self . cfgr }
#[doc = "0x10 - ADC configuration register 2"]
#[inline (always)] pub const fn cfgr2 (& self) -> & Cfgr2 { & self . cfgr2 }
#[doc = "0x14 - ADC sampling time register 1"]
#[inline (always)] pub const fn smpr1 (& self) -> & Smpr1 { & self . smpr1 }
#[doc = "0x18 - ADC sampling time register 2"]
#[inline (always)] pub const fn smpr2 (& self) -> & Smpr2 { & self . smpr2 }
#[doc = "0x20 - ADC analog watchdog 1 threshold register"]
#[inline (always)] pub const fn tr1 (& self) -> & Tr1 { & self . tr1 }
#[doc = "0x24 - ADC analog watchdog 2 threshold register"]
#[inline (always)] pub const fn tr2 (& self) -> & Tr2 { & self . tr2 }
#[doc = "0x28 - ADC analog watchdog 3 threshold register"]
#[inline (always)] pub const fn tr3 (& self) -> & Tr3 { & self . tr3 }
#[doc = "0x30 - ADC group regular sequencer ranks register 1"]
#[inline (always)] pub const fn sqr1 (& self) -> & Sqr1 { & self . sqr1 }
#[doc = "0x34 - ADC group regular sequencer ranks register 2"]
#[inline (always)] pub const fn sqr2 (& self) -> & Sqr2 { & self . sqr2 }
#[doc = "0x38 - ADC group regular sequencer ranks register 3"]
#[inline (always)] pub const fn sqr3 (& self) -> & Sqr3 { & self . sqr3 }
#[doc = "0x3c - ADC group regular sequencer ranks register 4"]
#[inline (always)] pub const fn sqr4 (& self) -> & Sqr4 { & self . sqr4 }
#[doc = "0x40 - ADC group regular conversion data register"]
#[inline (always)] pub const fn dr (& self) -> & Dr { & self . dr }
#[doc = "0x4c - ADC group injected sequencer register"]
#[inline (always)] pub const fn jsqr (& self) -> & Jsqr { & self . jsqr }
#[doc = "0x60 - ADC offset number 1 register"]
#[inline (always)] pub const fn ofr1 (& self) -> & Ofr1 { & self . ofr1 }
#[doc = "0x64 - ADC offset number 2 register"]
#[inline (always)] pub const fn ofr2 (& self) -> & Ofr2 { & self . ofr2 }
#[doc = "0x68 - ADC offset number 3 register"]
#[inline (always)] pub const fn ofr3 (& self) -> & Ofr3 { & self . ofr3 }
#[doc = "0x6c - ADC offset number 4 register"]
#[inline (always)] pub const fn ofr4 (& self) -> & Ofr4 { & self . ofr4 }
#[doc = "0x80 - ADC group injected sequencer rank 1 register"]
#[inline (always)] pub const fn jdr1 (& self) -> & Jdr1 { & self . jdr1 }
#[doc = "0x84 - ADC group injected sequencer rank 2 register"]
#[inline (always)] pub const fn jdr2 (& self) -> & Jdr2 { & self . jdr2 }
#[doc = "0x88 - ADC group injected sequencer rank 3 register"]
#[inline (always)] pub const fn jdr3 (& self) -> & Jdr3 { & self . jdr3 }
#[doc = "0x8c - ADC group injected sequencer rank 4 register"]
#[inline (always)] pub const fn jdr4 (& self) -> & Jdr4 { & self . jdr4 }
#[doc = "0xa0 - ADC analog watchdog 2 configuration register"]
#[inline (always)] pub const fn awd2cr (& self) -> & Awd2cr { & self . awd2cr }
#[doc = "0xa4 - ADC analog watchdog 3 configuration register"]
#[inline (always)] pub const fn awd3cr (& self) -> & Awd3cr { & self . awd3cr }
#[doc = "0xb0 - ADC channel differential or single-ended mode selection register"]
#[inline (always)] pub const fn difsel (& self) -> & Difsel { & self . difsel }
#[doc = "0xb4 - ADC calibration factors register"]
#[inline (always)] pub const fn calfact (& self) -> & Calfact { & self . calfact }
#[doc = "0x308 - ADC common control register"]
#[inline (always)] pub const fn ccr (& self) -> & Ccr { & self . ccr } }
#[doc = "ISR (rw) register accessor: ADC interrupt and status register\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`isr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@isr`] module"]
#[doc (alias = "ISR")] pub type Isr = crate :: Reg < isr :: IsrSpec > ;
#[doc = "ADC interrupt and status register"] pub mod isr {
#[doc = "Register `ISR` reader"] pub type R = crate :: R < IsrSpec > ;
#[doc = "Register `ISR` writer"] pub type W = crate :: W < IsrSpec > ;
#[doc = "Field `ADRDY` reader - ADC ready flag"] pub type AdrdyR = crate :: BitReader ;
#[doc = "Field `ADRDY` writer - ADC ready flag"] pub type AdrdyW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EOSMP` reader - ADC group regular end of sampling flag"] pub type EosmpR = crate :: BitReader ;
#[doc = "Field `EOSMP` writer - ADC group regular end of sampling flag"] pub type EosmpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EOC` reader - ADC group regular end of unitary conversion flag"] pub type EocR = crate :: BitReader ;
#[doc = "Field `EOC` writer - ADC group regular end of unitary conversion flag"] pub type EocW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EOS` reader - ADC group regular end of sequence conversions flag"] pub type EosR = crate :: BitReader ;
#[doc = "Field `EOS` writer - ADC group regular end of sequence conversions flag"] pub type EosW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OVR` reader - ADC group regular overrun flag"] pub type OvrR = crate :: BitReader ;
#[doc = "Field `OVR` writer - ADC group regular overrun flag"] pub type OvrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `JEOC` reader - ADC group injected end of unitary conversion flag"] pub type JeocR = crate :: BitReader ;
#[doc = "Field `JEOC` writer - ADC group injected end of unitary conversion flag"] pub type JeocW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `JEOS` reader - ADC group injected end of sequence conversions flag"] pub type JeosR = crate :: BitReader ;
#[doc = "Field `JEOS` writer - ADC group injected end of sequence conversions flag"] pub type JeosW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AWD1` reader - ADC analog watchdog 1 flag"] pub type Awd1R = crate :: BitReader ;
#[doc = "Field `AWD1` writer - ADC analog watchdog 1 flag"] pub type Awd1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AWD2` reader - ADC analog watchdog 2 flag"] pub type Awd2R = crate :: BitReader ;
#[doc = "Field `AWD2` writer - ADC analog watchdog 2 flag"] pub type Awd2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AWD3` reader - ADC analog watchdog 3 flag"] pub type Awd3R = crate :: BitReader ;
#[doc = "Field `AWD3` writer - ADC analog watchdog 3 flag"] pub type Awd3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `JQOVF` reader - ADC group injected contexts queue overflow flag"] pub type JqovfR = crate :: BitReader ;
#[doc = "Field `JQOVF` writer - ADC group injected contexts queue overflow flag"] pub type JqovfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - ADC ready flag"]
#[inline (always)] pub fn adrdy (& self) -> AdrdyR { AdrdyR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - ADC group regular end of sampling flag"]
#[inline (always)] pub fn eosmp (& self) -> EosmpR { EosmpR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - ADC group regular end of unitary conversion flag"]
#[inline (always)] pub fn eoc (& self) -> EocR { EocR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - ADC group regular end of sequence conversions flag"]
#[inline (always)] pub fn eos (& self) -> EosR { EosR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - ADC group regular overrun flag"]
#[inline (always)] pub fn ovr (& self) -> OvrR { OvrR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - ADC group injected end of unitary conversion flag"]
#[inline (always)] pub fn jeoc (& self) -> JeocR { JeocR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - ADC group injected end of sequence conversions flag"]
#[inline (always)] pub fn jeos (& self) -> JeosR { JeosR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - ADC analog watchdog 1 flag"]
#[inline (always)] pub fn awd1 (& self) -> Awd1R { Awd1R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - ADC analog watchdog 2 flag"]
#[inline (always)] pub fn awd2 (& self) -> Awd2R { Awd2R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - ADC analog watchdog 3 flag"]
#[inline (always)] pub fn awd3 (& self) -> Awd3R { Awd3R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - ADC group injected contexts queue overflow flag"]
#[inline (always)] pub fn jqovf (& self) -> JqovfR { JqovfR :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bit 0 - ADC ready flag"]
#[inline (always)] pub fn adrdy (& mut self) -> AdrdyW < '_ , IsrSpec > { AdrdyW :: new (self , 0) }
#[doc = "Bit 1 - ADC group regular end of sampling flag"]
#[inline (always)] pub fn eosmp (& mut self) -> EosmpW < '_ , IsrSpec > { EosmpW :: new (self , 1) }
#[doc = "Bit 2 - ADC group regular end of unitary conversion flag"]
#[inline (always)] pub fn eoc (& mut self) -> EocW < '_ , IsrSpec > { EocW :: new (self , 2) }
#[doc = "Bit 3 - ADC group regular end of sequence conversions flag"]
#[inline (always)] pub fn eos (& mut self) -> EosW < '_ , IsrSpec > { EosW :: new (self , 3) }
#[doc = "Bit 4 - ADC group regular overrun flag"]
#[inline (always)] pub fn ovr (& mut self) -> OvrW < '_ , IsrSpec > { OvrW :: new (self , 4) }
#[doc = "Bit 5 - ADC group injected end of unitary conversion flag"]
#[inline (always)] pub fn jeoc (& mut self) -> JeocW < '_ , IsrSpec > { JeocW :: new (self , 5) }
#[doc = "Bit 6 - ADC group injected end of sequence conversions flag"]
#[inline (always)] pub fn jeos (& mut self) -> JeosW < '_ , IsrSpec > { JeosW :: new (self , 6) }
#[doc = "Bit 7 - ADC analog watchdog 1 flag"]
#[inline (always)] pub fn awd1 (& mut self) -> Awd1W < '_ , IsrSpec > { Awd1W :: new (self , 7) }
#[doc = "Bit 8 - ADC analog watchdog 2 flag"]
#[inline (always)] pub fn awd2 (& mut self) -> Awd2W < '_ , IsrSpec > { Awd2W :: new (self , 8) }
#[doc = "Bit 9 - ADC analog watchdog 3 flag"]
#[inline (always)] pub fn awd3 (& mut self) -> Awd3W < '_ , IsrSpec > { Awd3W :: new (self , 9) }
#[doc = "Bit 10 - ADC group injected contexts queue overflow flag"]
#[inline (always)] pub fn jqovf (& mut self) -> JqovfW < '_ , IsrSpec > { JqovfW :: new (self , 10) } }
#[doc = "ADC interrupt and status register\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`isr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IsrSpec ; impl crate :: RegisterSpec for IsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`isr::R`](R) reader structure"] impl crate :: Readable for IsrSpec { }
#[doc = "`write(|w| ..)` method takes [`isr::W`](W) writer structure"] impl crate :: Writable for IsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ISR to value 0"] impl crate :: Resettable for IsrSpec { } }
#[doc = "IER (rw) register accessor: ADC interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ier`] module"]
#[doc (alias = "IER")] pub type Ier = crate :: Reg < ier :: IerSpec > ;
#[doc = "ADC interrupt enable register"] pub mod ier {
#[doc = "Register `IER` reader"] pub type R = crate :: R < IerSpec > ;
#[doc = "Register `IER` writer"] pub type W = crate :: W < IerSpec > ;
#[doc = "Field `ADRDYIE` reader - ADC ready interrupt"] pub type AdrdyieR = crate :: BitReader ;
#[doc = "Field `ADRDYIE` writer - ADC ready interrupt"] pub type AdrdyieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EOSMPIE` reader - ADC group regular end of sampling interrupt"] pub type EosmpieR = crate :: BitReader ;
#[doc = "Field `EOSMPIE` writer - ADC group regular end of sampling interrupt"] pub type EosmpieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EOCIE` reader - ADC group regular end of unitary conversion interrupt"] pub type EocieR = crate :: BitReader ;
#[doc = "Field `EOCIE` writer - ADC group regular end of unitary conversion interrupt"] pub type EocieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EOSIE` reader - ADC group regular end of sequence conversions interrupt"] pub type EosieR = crate :: BitReader ;
#[doc = "Field `EOSIE` writer - ADC group regular end of sequence conversions interrupt"] pub type EosieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OVRIE` reader - ADC group regular overrun interrupt"] pub type OvrieR = crate :: BitReader ;
#[doc = "Field `OVRIE` writer - ADC group regular overrun interrupt"] pub type OvrieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `JEOCIE` reader - ADC group injected end of unitary conversion interrupt"] pub type JeocieR = crate :: BitReader ;
#[doc = "Field `JEOCIE` writer - ADC group injected end of unitary conversion interrupt"] pub type JeocieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `JEOSIE` reader - ADC group injected end of sequence conversions interrupt"] pub type JeosieR = crate :: BitReader ;
#[doc = "Field `JEOSIE` writer - ADC group injected end of sequence conversions interrupt"] pub type JeosieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AWD1IE` reader - ADC analog watchdog 1 interrupt"] pub type Awd1ieR = crate :: BitReader ;
#[doc = "Field `AWD1IE` writer - ADC analog watchdog 1 interrupt"] pub type Awd1ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AWD2IE` reader - ADC analog watchdog 2 interrupt"] pub type Awd2ieR = crate :: BitReader ;
#[doc = "Field `AWD2IE` writer - ADC analog watchdog 2 interrupt"] pub type Awd2ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AWD3IE` reader - ADC analog watchdog 3 interrupt"] pub type Awd3ieR = crate :: BitReader ;
#[doc = "Field `AWD3IE` writer - ADC analog watchdog 3 interrupt"] pub type Awd3ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `JQOVFIE` reader - ADC group injected contexts queue overflow interrupt"] pub type JqovfieR = crate :: BitReader ;
#[doc = "Field `JQOVFIE` writer - ADC group injected contexts queue overflow interrupt"] pub type JqovfieW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - ADC ready interrupt"]
#[inline (always)] pub fn adrdyie (& self) -> AdrdyieR { AdrdyieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - ADC group regular end of sampling interrupt"]
#[inline (always)] pub fn eosmpie (& self) -> EosmpieR { EosmpieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - ADC group regular end of unitary conversion interrupt"]
#[inline (always)] pub fn eocie (& self) -> EocieR { EocieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - ADC group regular end of sequence conversions interrupt"]
#[inline (always)] pub fn eosie (& self) -> EosieR { EosieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - ADC group regular overrun interrupt"]
#[inline (always)] pub fn ovrie (& self) -> OvrieR { OvrieR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - ADC group injected end of unitary conversion interrupt"]
#[inline (always)] pub fn jeocie (& self) -> JeocieR { JeocieR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - ADC group injected end of sequence conversions interrupt"]
#[inline (always)] pub fn jeosie (& self) -> JeosieR { JeosieR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - ADC analog watchdog 1 interrupt"]
#[inline (always)] pub fn awd1ie (& self) -> Awd1ieR { Awd1ieR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - ADC analog watchdog 2 interrupt"]
#[inline (always)] pub fn awd2ie (& self) -> Awd2ieR { Awd2ieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - ADC analog watchdog 3 interrupt"]
#[inline (always)] pub fn awd3ie (& self) -> Awd3ieR { Awd3ieR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - ADC group injected contexts queue overflow interrupt"]
#[inline (always)] pub fn jqovfie (& self) -> JqovfieR { JqovfieR :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bit 0 - ADC ready interrupt"]
#[inline (always)] pub fn adrdyie (& mut self) -> AdrdyieW < '_ , IerSpec > { AdrdyieW :: new (self , 0) }
#[doc = "Bit 1 - ADC group regular end of sampling interrupt"]
#[inline (always)] pub fn eosmpie (& mut self) -> EosmpieW < '_ , IerSpec > { EosmpieW :: new (self , 1) }
#[doc = "Bit 2 - ADC group regular end of unitary conversion interrupt"]
#[inline (always)] pub fn eocie (& mut self) -> EocieW < '_ , IerSpec > { EocieW :: new (self , 2) }
#[doc = "Bit 3 - ADC group regular end of sequence conversions interrupt"]
#[inline (always)] pub fn eosie (& mut self) -> EosieW < '_ , IerSpec > { EosieW :: new (self , 3) }
#[doc = "Bit 4 - ADC group regular overrun interrupt"]
#[inline (always)] pub fn ovrie (& mut self) -> OvrieW < '_ , IerSpec > { OvrieW :: new (self , 4) }
#[doc = "Bit 5 - ADC group injected end of unitary conversion interrupt"]
#[inline (always)] pub fn jeocie (& mut self) -> JeocieW < '_ , IerSpec > { JeocieW :: new (self , 5) }
#[doc = "Bit 6 - ADC group injected end of sequence conversions interrupt"]
#[inline (always)] pub fn jeosie (& mut self) -> JeosieW < '_ , IerSpec > { JeosieW :: new (self , 6) }
#[doc = "Bit 7 - ADC analog watchdog 1 interrupt"]
#[inline (always)] pub fn awd1ie (& mut self) -> Awd1ieW < '_ , IerSpec > { Awd1ieW :: new (self , 7) }
#[doc = "Bit 8 - ADC analog watchdog 2 interrupt"]
#[inline (always)] pub fn awd2ie (& mut self) -> Awd2ieW < '_ , IerSpec > { Awd2ieW :: new (self , 8) }
#[doc = "Bit 9 - ADC analog watchdog 3 interrupt"]
#[inline (always)] pub fn awd3ie (& mut self) -> Awd3ieW < '_ , IerSpec > { Awd3ieW :: new (self , 9) }
#[doc = "Bit 10 - ADC group injected contexts queue overflow interrupt"]
#[inline (always)] pub fn jqovfie (& mut self) -> JqovfieW < '_ , IerSpec > { JqovfieW :: new (self , 10) } }
#[doc = "ADC interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IerSpec ; impl crate :: RegisterSpec for IerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ier::R`](R) reader structure"] impl crate :: Readable for IerSpec { }
#[doc = "`write(|w| ..)` method takes [`ier::W`](W) writer structure"] impl crate :: Writable for IerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IER to value 0"] impl crate :: Resettable for IerSpec { } }
#[doc = "CR (rw) register accessor: ADC control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "ADC control register"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `ADEN` reader - ADC enable"] pub type AdenR = crate :: BitReader ;
#[doc = "Field `ADEN` writer - ADC enable"] pub type AdenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADDIS` reader - ADC disable"] pub type AddisR = crate :: BitReader ;
#[doc = "Field `ADDIS` writer - ADC disable"] pub type AddisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADSTART` reader - ADC group regular conversion start"] pub type AdstartR = crate :: BitReader ;
#[doc = "Field `ADSTART` writer - ADC group regular conversion start"] pub type AdstartW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `JADSTART` reader - ADC group injected conversion start"] pub type JadstartR = crate :: BitReader ;
#[doc = "Field `JADSTART` writer - ADC group injected conversion start"] pub type JadstartW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADSTP` reader - ADC group regular conversion stop"] pub type AdstpR = crate :: BitReader ;
#[doc = "Field `ADSTP` writer - ADC group regular conversion stop"] pub type AdstpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `JADSTP` reader - ADC group injected conversion stop"] pub type JadstpR = crate :: BitReader ;
#[doc = "Field `JADSTP` writer - ADC group injected conversion stop"] pub type JadstpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADVREGEN` reader - ADC voltage regulator enable"] pub type AdvregenR = crate :: BitReader ;
#[doc = "Field `ADVREGEN` writer - ADC voltage regulator enable"] pub type AdvregenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DEEPPWD` reader - ADC deep power down enable"] pub type DeeppwdR = crate :: BitReader ;
#[doc = "Field `DEEPPWD` writer - ADC deep power down enable"] pub type DeeppwdW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADCALDIF` reader - ADC differential mode for calibration"] pub type AdcaldifR = crate :: BitReader ;
#[doc = "Field `ADCALDIF` writer - ADC differential mode for calibration"] pub type AdcaldifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADCAL` reader - ADC calibration"] pub type AdcalR = crate :: BitReader ;
#[doc = "Field `ADCAL` writer - ADC calibration"] pub type AdcalW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - ADC enable"]
#[inline (always)] pub fn aden (& self) -> AdenR { AdenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - ADC disable"]
#[inline (always)] pub fn addis (& self) -> AddisR { AddisR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - ADC group regular conversion start"]
#[inline (always)] pub fn adstart (& self) -> AdstartR { AdstartR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - ADC group injected conversion start"]
#[inline (always)] pub fn jadstart (& self) -> JadstartR { JadstartR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - ADC group regular conversion stop"]
#[inline (always)] pub fn adstp (& self) -> AdstpR { AdstpR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - ADC group injected conversion stop"]
#[inline (always)] pub fn jadstp (& self) -> JadstpR { JadstpR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 28 - ADC voltage regulator enable"]
#[inline (always)] pub fn advregen (& self) -> AdvregenR { AdvregenR :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - ADC deep power down enable"]
#[inline (always)] pub fn deeppwd (& self) -> DeeppwdR { DeeppwdR :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - ADC differential mode for calibration"]
#[inline (always)] pub fn adcaldif (& self) -> AdcaldifR { AdcaldifR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - ADC calibration"]
#[inline (always)] pub fn adcal (& self) -> AdcalR { AdcalR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - ADC enable"]
#[inline (always)] pub fn aden (& mut self) -> AdenW < '_ , CrSpec > { AdenW :: new (self , 0) }
#[doc = "Bit 1 - ADC disable"]
#[inline (always)] pub fn addis (& mut self) -> AddisW < '_ , CrSpec > { AddisW :: new (self , 1) }
#[doc = "Bit 2 - ADC group regular conversion start"]
#[inline (always)] pub fn adstart (& mut self) -> AdstartW < '_ , CrSpec > { AdstartW :: new (self , 2) }
#[doc = "Bit 3 - ADC group injected conversion start"]
#[inline (always)] pub fn jadstart (& mut self) -> JadstartW < '_ , CrSpec > { JadstartW :: new (self , 3) }
#[doc = "Bit 4 - ADC group regular conversion stop"]
#[inline (always)] pub fn adstp (& mut self) -> AdstpW < '_ , CrSpec > { AdstpW :: new (self , 4) }
#[doc = "Bit 5 - ADC group injected conversion stop"]
#[inline (always)] pub fn jadstp (& mut self) -> JadstpW < '_ , CrSpec > { JadstpW :: new (self , 5) }
#[doc = "Bit 28 - ADC voltage regulator enable"]
#[inline (always)] pub fn advregen (& mut self) -> AdvregenW < '_ , CrSpec > { AdvregenW :: new (self , 28) }
#[doc = "Bit 29 - ADC deep power down enable"]
#[inline (always)] pub fn deeppwd (& mut self) -> DeeppwdW < '_ , CrSpec > { DeeppwdW :: new (self , 29) }
#[doc = "Bit 30 - ADC differential mode for calibration"]
#[inline (always)] pub fn adcaldif (& mut self) -> AdcaldifW < '_ , CrSpec > { AdcaldifW :: new (self , 30) }
#[doc = "Bit 31 - ADC calibration"]
#[inline (always)] pub fn adcal (& mut self) -> AdcalW < '_ , CrSpec > { AdcalW :: new (self , 31) } }
#[doc = "ADC control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { } }
#[doc = "CFGR (rw) register accessor: ADC configuration register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfgr`] module"]
#[doc (alias = "CFGR")] pub type Cfgr = crate :: Reg < cfgr :: CfgrSpec > ;
#[doc = "ADC configuration register 1"] pub mod cfgr {
#[doc = "Register `CFGR` reader"] pub type R = crate :: R < CfgrSpec > ;
#[doc = "Register `CFGR` writer"] pub type W = crate :: W < CfgrSpec > ;
#[doc = "Field `DMAEN` reader - ADC DMA transfer enable"] pub type DmaenR = crate :: BitReader ;
#[doc = "Field `DMAEN` writer - ADC DMA transfer enable"] pub type DmaenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMACFG` reader - ADC DMA transfer configuration"] pub type DmacfgR = crate :: BitReader ;
#[doc = "Field `DMACFG` writer - ADC DMA transfer configuration"] pub type DmacfgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RES` reader - ADC data resolution"] pub type ResR = crate :: FieldReader ;
#[doc = "Field `RES` writer - ADC data resolution"] pub type ResW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ALIGN` reader - ADC data alignement"] pub type AlignR = crate :: BitReader ;
#[doc = "Field `ALIGN` writer - ADC data alignement"] pub type AlignW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EXTSEL` reader - ADC group regular external trigger source"] pub type ExtselR = crate :: FieldReader ;
#[doc = "Field `EXTSEL` writer - ADC group regular external trigger source"] pub type ExtselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EXTEN` reader - ADC group regular external trigger polarity"] pub type ExtenR = crate :: FieldReader ;
#[doc = "Field `EXTEN` writer - ADC group regular external trigger polarity"] pub type ExtenW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OVRMOD` reader - ADC group regular overrun configuration"] pub type OvrmodR = crate :: BitReader ;
#[doc = "Field `OVRMOD` writer - ADC group regular overrun configuration"] pub type OvrmodW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CONT` reader - ADC group regular continuous conversion mode"] pub type ContR = crate :: BitReader ;
#[doc = "Field `CONT` writer - ADC group regular continuous conversion mode"] pub type ContW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AUTDLY` reader - ADC low power auto wait"] pub type AutdlyR = crate :: BitReader ;
#[doc = "Field `AUTDLY` writer - ADC low power auto wait"] pub type AutdlyW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DISCEN` reader - ADC group regular sequencer discontinuous mode"] pub type DiscenR = crate :: BitReader ;
#[doc = "Field `DISCEN` writer - ADC group regular sequencer discontinuous mode"] pub type DiscenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DISCNUM` reader - ADC group regular sequencer discontinuous number of ranks"] pub type DiscnumR = crate :: FieldReader ;
#[doc = "Field `DISCNUM` writer - ADC group regular sequencer discontinuous number of ranks"] pub type DiscnumW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `JDISCEN` reader - ADC group injected sequencer discontinuous mode"] pub type JdiscenR = crate :: BitReader ;
#[doc = "Field `JDISCEN` writer - ADC group injected sequencer discontinuous mode"] pub type JdiscenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `JQM` reader - ADC group injected contexts queue mode"] pub type JqmR = crate :: BitReader ;
#[doc = "Field `JQM` writer - ADC group injected contexts queue mode"] pub type JqmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AWD1SGL` reader - ADC analog watchdog 1 monitoring a single channel or all channels"] pub type Awd1sglR = crate :: BitReader ;
#[doc = "Field `AWD1SGL` writer - ADC analog watchdog 1 monitoring a single channel or all channels"] pub type Awd1sglW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AWD1EN` reader - ADC analog watchdog 1 enable on scope ADC group regular"] pub type Awd1enR = crate :: BitReader ;
#[doc = "Field `AWD1EN` writer - ADC analog watchdog 1 enable on scope ADC group regular"] pub type Awd1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `JAWD1EN` reader - ADC analog watchdog 1 enable on scope ADC group injected"] pub type Jawd1enR = crate :: BitReader ;
#[doc = "Field `JAWD1EN` writer - ADC analog watchdog 1 enable on scope ADC group injected"] pub type Jawd1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `JAUTO` reader - ADC group injected automatic trigger mode"] pub type JautoR = crate :: BitReader ;
#[doc = "Field `JAUTO` writer - ADC group injected automatic trigger mode"] pub type JautoW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AWDCH1CH` reader - ADC analog watchdog 1 monitored channel selection"] pub type Awdch1chR = crate :: FieldReader ;
#[doc = "Field `AWDCH1CH` writer - ADC analog watchdog 1 monitored channel selection"] pub type Awdch1chW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `JQDIS` reader - ADC group injected contexts queue disable"] pub type JqdisR = crate :: BitReader ;
#[doc = "Field `JQDIS` writer - ADC group injected contexts queue disable"] pub type JqdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - ADC DMA transfer enable"]
#[inline (always)] pub fn dmaen (& self) -> DmaenR { DmaenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - ADC DMA transfer configuration"]
#[inline (always)] pub fn dmacfg (& self) -> DmacfgR { DmacfgR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bits 3:4 - ADC data resolution"]
#[inline (always)] pub fn res (& self) -> ResR { ResR :: new (((self . bits >> 3) & 3) as u8) }
#[doc = "Bit 5 - ADC data alignement"]
#[inline (always)] pub fn align (& self) -> AlignR { AlignR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bits 6:9 - ADC group regular external trigger source"]
#[inline (always)] pub fn extsel (& self) -> ExtselR { ExtselR :: new (((self . bits >> 6) & 0x0f) as u8) }
#[doc = "Bits 10:11 - ADC group regular external trigger polarity"]
#[inline (always)] pub fn exten (& self) -> ExtenR { ExtenR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bit 12 - ADC group regular overrun configuration"]
#[inline (always)] pub fn ovrmod (& self) -> OvrmodR { OvrmodR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - ADC group regular continuous conversion mode"]
#[inline (always)] pub fn cont (& self) -> ContR { ContR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - ADC low power auto wait"]
#[inline (always)] pub fn autdly (& self) -> AutdlyR { AutdlyR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 16 - ADC group regular sequencer discontinuous mode"]
#[inline (always)] pub fn discen (& self) -> DiscenR { DiscenR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:19 - ADC group regular sequencer discontinuous number of ranks"]
#[inline (always)] pub fn discnum (& self) -> DiscnumR { DiscnumR :: new (((self . bits >> 17) & 7) as u8) }
#[doc = "Bit 20 - ADC group injected sequencer discontinuous mode"]
#[inline (always)] pub fn jdiscen (& self) -> JdiscenR { JdiscenR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - ADC group injected contexts queue mode"]
#[inline (always)] pub fn jqm (& self) -> JqmR { JqmR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - ADC analog watchdog 1 monitoring a single channel or all channels"]
#[inline (always)] pub fn awd1sgl (& self) -> Awd1sglR { Awd1sglR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - ADC analog watchdog 1 enable on scope ADC group regular"]
#[inline (always)] pub fn awd1en (& self) -> Awd1enR { Awd1enR :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - ADC analog watchdog 1 enable on scope ADC group injected"]
#[inline (always)] pub fn jawd1en (& self) -> Jawd1enR { Jawd1enR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - ADC group injected automatic trigger mode"]
#[inline (always)] pub fn jauto (& self) -> JautoR { JautoR :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bits 26:30 - ADC analog watchdog 1 monitored channel selection"]
#[inline (always)] pub fn awdch1ch (& self) -> Awdch1chR { Awdch1chR :: new (((self . bits >> 26) & 0x1f) as u8) }
#[doc = "Bit 31 - ADC group injected contexts queue disable"]
#[inline (always)] pub fn jqdis (& self) -> JqdisR { JqdisR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - ADC DMA transfer enable"]
#[inline (always)] pub fn dmaen (& mut self) -> DmaenW < '_ , CfgrSpec > { DmaenW :: new (self , 0) }
#[doc = "Bit 1 - ADC DMA transfer configuration"]
#[inline (always)] pub fn dmacfg (& mut self) -> DmacfgW < '_ , CfgrSpec > { DmacfgW :: new (self , 1) }
#[doc = "Bits 3:4 - ADC data resolution"]
#[inline (always)] pub fn res (& mut self) -> ResW < '_ , CfgrSpec > { ResW :: new (self , 3) }
#[doc = "Bit 5 - ADC data alignement"]
#[inline (always)] pub fn align (& mut self) -> AlignW < '_ , CfgrSpec > { AlignW :: new (self , 5) }
#[doc = "Bits 6:9 - ADC group regular external trigger source"]
#[inline (always)] pub fn extsel (& mut self) -> ExtselW < '_ , CfgrSpec > { ExtselW :: new (self , 6) }
#[doc = "Bits 10:11 - ADC group regular external trigger polarity"]
#[inline (always)] pub fn exten (& mut self) -> ExtenW < '_ , CfgrSpec > { ExtenW :: new (self , 10) }
#[doc = "Bit 12 - ADC group regular overrun configuration"]
#[inline (always)] pub fn ovrmod (& mut self) -> OvrmodW < '_ , CfgrSpec > { OvrmodW :: new (self , 12) }
#[doc = "Bit 13 - ADC group regular continuous conversion mode"]
#[inline (always)] pub fn cont (& mut self) -> ContW < '_ , CfgrSpec > { ContW :: new (self , 13) }
#[doc = "Bit 14 - ADC low power auto wait"]
#[inline (always)] pub fn autdly (& mut self) -> AutdlyW < '_ , CfgrSpec > { AutdlyW :: new (self , 14) }
#[doc = "Bit 16 - ADC group regular sequencer discontinuous mode"]
#[inline (always)] pub fn discen (& mut self) -> DiscenW < '_ , CfgrSpec > { DiscenW :: new (self , 16) }
#[doc = "Bits 17:19 - ADC group regular sequencer discontinuous number of ranks"]
#[inline (always)] pub fn discnum (& mut self) -> DiscnumW < '_ , CfgrSpec > { DiscnumW :: new (self , 17) }
#[doc = "Bit 20 - ADC group injected sequencer discontinuous mode"]
#[inline (always)] pub fn jdiscen (& mut self) -> JdiscenW < '_ , CfgrSpec > { JdiscenW :: new (self , 20) }
#[doc = "Bit 21 - ADC group injected contexts queue mode"]
#[inline (always)] pub fn jqm (& mut self) -> JqmW < '_ , CfgrSpec > { JqmW :: new (self , 21) }
#[doc = "Bit 22 - ADC analog watchdog 1 monitoring a single channel or all channels"]
#[inline (always)] pub fn awd1sgl (& mut self) -> Awd1sglW < '_ , CfgrSpec > { Awd1sglW :: new (self , 22) }
#[doc = "Bit 23 - ADC analog watchdog 1 enable on scope ADC group regular"]
#[inline (always)] pub fn awd1en (& mut self) -> Awd1enW < '_ , CfgrSpec > { Awd1enW :: new (self , 23) }
#[doc = "Bit 24 - ADC analog watchdog 1 enable on scope ADC group injected"]
#[inline (always)] pub fn jawd1en (& mut self) -> Jawd1enW < '_ , CfgrSpec > { Jawd1enW :: new (self , 24) }
#[doc = "Bit 25 - ADC group injected automatic trigger mode"]
#[inline (always)] pub fn jauto (& mut self) -> JautoW < '_ , CfgrSpec > { JautoW :: new (self , 25) }
#[doc = "Bits 26:30 - ADC analog watchdog 1 monitored channel selection"]
#[inline (always)] pub fn awdch1ch (& mut self) -> Awdch1chW < '_ , CfgrSpec > { Awdch1chW :: new (self , 26) }
#[doc = "Bit 31 - ADC group injected contexts queue disable"]
#[inline (always)] pub fn jqdis (& mut self) -> JqdisW < '_ , CfgrSpec > { JqdisW :: new (self , 31) } }
#[doc = "ADC configuration register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CfgrSpec ; impl crate :: RegisterSpec for CfgrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cfgr::R`](R) reader structure"] impl crate :: Readable for CfgrSpec { }
#[doc = "`write(|w| ..)` method takes [`cfgr::W`](W) writer structure"] impl crate :: Writable for CfgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CFGR to value 0x8000_0000"] impl crate :: Resettable for CfgrSpec { const RESET_VALUE : u32 = 0x8000_0000 ; } }
#[doc = "CFGR2 (rw) register accessor: ADC configuration register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfgr2`] module"]
#[doc (alias = "CFGR2")] pub type Cfgr2 = crate :: Reg < cfgr2 :: Cfgr2Spec > ;
#[doc = "ADC configuration register 2"] pub mod cfgr2 {
#[doc = "Register `CFGR2` reader"] pub type R = crate :: R < Cfgr2Spec > ;
#[doc = "Register `CFGR2` writer"] pub type W = crate :: W < Cfgr2Spec > ;
#[doc = "Field `ROVSE` reader - ADC oversampler enable on scope ADC group regular"] pub type RovseR = crate :: BitReader ;
#[doc = "Field `ROVSE` writer - ADC oversampler enable on scope ADC group regular"] pub type RovseW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `JOVSE` reader - ADC oversampler enable on scope ADC group injected"] pub type JovseR = crate :: BitReader ;
#[doc = "Field `JOVSE` writer - ADC oversampler enable on scope ADC group injected"] pub type JovseW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OVSR` reader - ADC oversampling ratio"] pub type OvsrR = crate :: FieldReader ;
#[doc = "Field `OVSR` writer - ADC oversampling ratio"] pub type OvsrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OVSS` reader - ADC oversampling shift"] pub type OvssR = crate :: FieldReader ;
#[doc = "Field `OVSS` writer - ADC oversampling shift"] pub type OvssW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `TOVS` reader - ADC oversampling discontinuous mode (triggered mode) for ADC group regular"] pub type TovsR = crate :: BitReader ;
#[doc = "Field `TOVS` writer - ADC oversampling discontinuous mode (triggered mode) for ADC group regular"] pub type TovsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ROVSM` reader - ADC oversampling mode managing interlaced conversions of ADC group regular and group injected"] pub type RovsmR = crate :: BitReader ;
#[doc = "Field `ROVSM` writer - ADC oversampling mode managing interlaced conversions of ADC group regular and group injected"] pub type RovsmW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - ADC oversampler enable on scope ADC group regular"]
#[inline (always)] pub fn rovse (& self) -> RovseR { RovseR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - ADC oversampler enable on scope ADC group injected"]
#[inline (always)] pub fn jovse (& self) -> JovseR { JovseR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bits 2:4 - ADC oversampling ratio"]
#[inline (always)] pub fn ovsr (& self) -> OvsrR { OvsrR :: new (((self . bits >> 2) & 7) as u8) }
#[doc = "Bits 5:8 - ADC oversampling shift"]
#[inline (always)] pub fn ovss (& self) -> OvssR { OvssR :: new (((self . bits >> 5) & 0x0f) as u8) }
#[doc = "Bit 9 - ADC oversampling discontinuous mode (triggered mode) for ADC group regular"]
#[inline (always)] pub fn tovs (& self) -> TovsR { TovsR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - ADC oversampling mode managing interlaced conversions of ADC group regular and group injected"]
#[inline (always)] pub fn rovsm (& self) -> RovsmR { RovsmR :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bit 0 - ADC oversampler enable on scope ADC group regular"]
#[inline (always)] pub fn rovse (& mut self) -> RovseW < '_ , Cfgr2Spec > { RovseW :: new (self , 0) }
#[doc = "Bit 1 - ADC oversampler enable on scope ADC group injected"]
#[inline (always)] pub fn jovse (& mut self) -> JovseW < '_ , Cfgr2Spec > { JovseW :: new (self , 1) }
#[doc = "Bits 2:4 - ADC oversampling ratio"]
#[inline (always)] pub fn ovsr (& mut self) -> OvsrW < '_ , Cfgr2Spec > { OvsrW :: new (self , 2) }
#[doc = "Bits 5:8 - ADC oversampling shift"]
#[inline (always)] pub fn ovss (& mut self) -> OvssW < '_ , Cfgr2Spec > { OvssW :: new (self , 5) }
#[doc = "Bit 9 - ADC oversampling discontinuous mode (triggered mode) for ADC group regular"]
#[inline (always)] pub fn tovs (& mut self) -> TovsW < '_ , Cfgr2Spec > { TovsW :: new (self , 9) }
#[doc = "Bit 10 - ADC oversampling mode managing interlaced conversions of ADC group regular and group injected"]
#[inline (always)] pub fn rovsm (& mut self) -> RovsmW < '_ , Cfgr2Spec > { RovsmW :: new (self , 10) } }
#[doc = "ADC configuration register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cfgr2Spec ; impl crate :: RegisterSpec for Cfgr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cfgr2::R`](R) reader structure"] impl crate :: Readable for Cfgr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cfgr2::W`](W) writer structure"] impl crate :: Writable for Cfgr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CFGR2 to value 0"] impl crate :: Resettable for Cfgr2Spec { } }
#[doc = "SMPR1 (rw) register accessor: ADC sampling time register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`smpr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smpr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@smpr1`] module"]
#[doc (alias = "SMPR1")] pub type Smpr1 = crate :: Reg < smpr1 :: Smpr1Spec > ;
#[doc = "ADC sampling time register 1"] pub mod smpr1 {
#[doc = "Register `SMPR1` reader"] pub type R = crate :: R < Smpr1Spec > ;
#[doc = "Register `SMPR1` writer"] pub type W = crate :: W < Smpr1Spec > ;
#[doc = "Field `SMP0` reader - ADC channel 0 sampling time selection"] pub type Smp0R = crate :: FieldReader ;
#[doc = "Field `SMP0` writer - ADC channel 0 sampling time selection"] pub type Smp0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP1` reader - ADC channel 1 sampling time selection"] pub type Smp1R = crate :: FieldReader ;
#[doc = "Field `SMP1` writer - ADC channel 1 sampling time selection"] pub type Smp1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP2` reader - ADC channel 2 sampling time selection"] pub type Smp2R = crate :: FieldReader ;
#[doc = "Field `SMP2` writer - ADC channel 2 sampling time selection"] pub type Smp2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP3` reader - ADC channel 3 sampling time selection"] pub type Smp3R = crate :: FieldReader ;
#[doc = "Field `SMP3` writer - ADC channel 3 sampling time selection"] pub type Smp3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP4` reader - ADC channel 4 sampling time selection"] pub type Smp4R = crate :: FieldReader ;
#[doc = "Field `SMP4` writer - ADC channel 4 sampling time selection"] pub type Smp4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP5` reader - ADC channel 5 sampling time selection"] pub type Smp5R = crate :: FieldReader ;
#[doc = "Field `SMP5` writer - ADC channel 5 sampling time selection"] pub type Smp5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP6` reader - ADC channel 6 sampling time selection"] pub type Smp6R = crate :: FieldReader ;
#[doc = "Field `SMP6` writer - ADC channel 6 sampling time selection"] pub type Smp6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP7` reader - ADC channel 7 sampling time selection"] pub type Smp7R = crate :: FieldReader ;
#[doc = "Field `SMP7` writer - ADC channel 7 sampling time selection"] pub type Smp7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP8` reader - ADC channel 8 sampling time selection"] pub type Smp8R = crate :: FieldReader ;
#[doc = "Field `SMP8` writer - ADC channel 8 sampling time selection"] pub type Smp8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP9` reader - ADC channel 9 sampling time selection"] pub type Smp9R = crate :: FieldReader ;
#[doc = "Field `SMP9` writer - ADC channel 9 sampling time selection"] pub type Smp9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:2 - ADC channel 0 sampling time selection"]
#[inline (always)] pub fn smp0 (& self) -> Smp0R { Smp0R :: new ((self . bits & 7) as u8) }
#[doc = "Bits 3:5 - ADC channel 1 sampling time selection"]
#[inline (always)] pub fn smp1 (& self) -> Smp1R { Smp1R :: new (((self . bits >> 3) & 7) as u8) }
#[doc = "Bits 6:8 - ADC channel 2 sampling time selection"]
#[inline (always)] pub fn smp2 (& self) -> Smp2R { Smp2R :: new (((self . bits >> 6) & 7) as u8) }
#[doc = "Bits 9:11 - ADC channel 3 sampling time selection"]
#[inline (always)] pub fn smp3 (& self) -> Smp3R { Smp3R :: new (((self . bits >> 9) & 7) as u8) }
#[doc = "Bits 12:14 - ADC channel 4 sampling time selection"]
#[inline (always)] pub fn smp4 (& self) -> Smp4R { Smp4R :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bits 15:17 - ADC channel 5 sampling time selection"]
#[inline (always)] pub fn smp5 (& self) -> Smp5R { Smp5R :: new (((self . bits >> 15) & 7) as u8) }
#[doc = "Bits 18:20 - ADC channel 6 sampling time selection"]
#[inline (always)] pub fn smp6 (& self) -> Smp6R { Smp6R :: new (((self . bits >> 18) & 7) as u8) }
#[doc = "Bits 21:23 - ADC channel 7 sampling time selection"]
#[inline (always)] pub fn smp7 (& self) -> Smp7R { Smp7R :: new (((self . bits >> 21) & 7) as u8) }
#[doc = "Bits 24:26 - ADC channel 8 sampling time selection"]
#[inline (always)] pub fn smp8 (& self) -> Smp8R { Smp8R :: new (((self . bits >> 24) & 7) as u8) }
#[doc = "Bits 27:29 - ADC channel 9 sampling time selection"]
#[inline (always)] pub fn smp9 (& self) -> Smp9R { Smp9R :: new (((self . bits >> 27) & 7) as u8) } } impl W {
#[doc = "Bits 0:2 - ADC channel 0 sampling time selection"]
#[inline (always)] pub fn smp0 (& mut self) -> Smp0W < '_ , Smpr1Spec > { Smp0W :: new (self , 0) }
#[doc = "Bits 3:5 - ADC channel 1 sampling time selection"]
#[inline (always)] pub fn smp1 (& mut self) -> Smp1W < '_ , Smpr1Spec > { Smp1W :: new (self , 3) }
#[doc = "Bits 6:8 - ADC channel 2 sampling time selection"]
#[inline (always)] pub fn smp2 (& mut self) -> Smp2W < '_ , Smpr1Spec > { Smp2W :: new (self , 6) }
#[doc = "Bits 9:11 - ADC channel 3 sampling time selection"]
#[inline (always)] pub fn smp3 (& mut self) -> Smp3W < '_ , Smpr1Spec > { Smp3W :: new (self , 9) }
#[doc = "Bits 12:14 - ADC channel 4 sampling time selection"]
#[inline (always)] pub fn smp4 (& mut self) -> Smp4W < '_ , Smpr1Spec > { Smp4W :: new (self , 12) }
#[doc = "Bits 15:17 - ADC channel 5 sampling time selection"]
#[inline (always)] pub fn smp5 (& mut self) -> Smp5W < '_ , Smpr1Spec > { Smp5W :: new (self , 15) }
#[doc = "Bits 18:20 - ADC channel 6 sampling time selection"]
#[inline (always)] pub fn smp6 (& mut self) -> Smp6W < '_ , Smpr1Spec > { Smp6W :: new (self , 18) }
#[doc = "Bits 21:23 - ADC channel 7 sampling time selection"]
#[inline (always)] pub fn smp7 (& mut self) -> Smp7W < '_ , Smpr1Spec > { Smp7W :: new (self , 21) }
#[doc = "Bits 24:26 - ADC channel 8 sampling time selection"]
#[inline (always)] pub fn smp8 (& mut self) -> Smp8W < '_ , Smpr1Spec > { Smp8W :: new (self , 24) }
#[doc = "Bits 27:29 - ADC channel 9 sampling time selection"]
#[inline (always)] pub fn smp9 (& mut self) -> Smp9W < '_ , Smpr1Spec > { Smp9W :: new (self , 27) } }
#[doc = "ADC sampling time register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`smpr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smpr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Smpr1Spec ; impl crate :: RegisterSpec for Smpr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`smpr1::R`](R) reader structure"] impl crate :: Readable for Smpr1Spec { }
#[doc = "`write(|w| ..)` method takes [`smpr1::W`](W) writer structure"] impl crate :: Writable for Smpr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SMPR1 to value 0"] impl crate :: Resettable for Smpr1Spec { } }
#[doc = "SMPR2 (rw) register accessor: ADC sampling time register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`smpr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smpr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@smpr2`] module"]
#[doc (alias = "SMPR2")] pub type Smpr2 = crate :: Reg < smpr2 :: Smpr2Spec > ;
#[doc = "ADC sampling time register 2"] pub mod smpr2 {
#[doc = "Register `SMPR2` reader"] pub type R = crate :: R < Smpr2Spec > ;
#[doc = "Register `SMPR2` writer"] pub type W = crate :: W < Smpr2Spec > ;
#[doc = "Field `SMP10` reader - ADC channel 10 sampling time selection"] pub type Smp10R = crate :: FieldReader ;
#[doc = "Field `SMP10` writer - ADC channel 10 sampling time selection"] pub type Smp10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP11` reader - ADC channel 11 sampling time selection"] pub type Smp11R = crate :: FieldReader ;
#[doc = "Field `SMP11` writer - ADC channel 11 sampling time selection"] pub type Smp11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP12` reader - ADC channel 12 sampling time selection"] pub type Smp12R = crate :: FieldReader ;
#[doc = "Field `SMP12` writer - ADC channel 12 sampling time selection"] pub type Smp12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP13` reader - ADC channel 13 sampling time selection"] pub type Smp13R = crate :: FieldReader ;
#[doc = "Field `SMP13` writer - ADC channel 13 sampling time selection"] pub type Smp13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP14` reader - ADC channel 14 sampling time selection"] pub type Smp14R = crate :: FieldReader ;
#[doc = "Field `SMP14` writer - ADC channel 14 sampling time selection"] pub type Smp14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP15` reader - ADC channel 15 sampling time selection"] pub type Smp15R = crate :: FieldReader ;
#[doc = "Field `SMP15` writer - ADC channel 15 sampling time selection"] pub type Smp15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP16` reader - ADC channel 16 sampling time selection"] pub type Smp16R = crate :: FieldReader ;
#[doc = "Field `SMP16` writer - ADC channel 16 sampling time selection"] pub type Smp16W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP17` reader - ADC channel 17 sampling time selection"] pub type Smp17R = crate :: FieldReader ;
#[doc = "Field `SMP17` writer - ADC channel 17 sampling time selection"] pub type Smp17W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP18` reader - ADC channel 18 sampling time selection"] pub type Smp18R = crate :: FieldReader ;
#[doc = "Field `SMP18` writer - ADC channel 18 sampling time selection"] pub type Smp18W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:2 - ADC channel 10 sampling time selection"]
#[inline (always)] pub fn smp10 (& self) -> Smp10R { Smp10R :: new ((self . bits & 7) as u8) }
#[doc = "Bits 3:5 - ADC channel 11 sampling time selection"]
#[inline (always)] pub fn smp11 (& self) -> Smp11R { Smp11R :: new (((self . bits >> 3) & 7) as u8) }
#[doc = "Bits 6:8 - ADC channel 12 sampling time selection"]
#[inline (always)] pub fn smp12 (& self) -> Smp12R { Smp12R :: new (((self . bits >> 6) & 7) as u8) }
#[doc = "Bits 9:11 - ADC channel 13 sampling time selection"]
#[inline (always)] pub fn smp13 (& self) -> Smp13R { Smp13R :: new (((self . bits >> 9) & 7) as u8) }
#[doc = "Bits 12:14 - ADC channel 14 sampling time selection"]
#[inline (always)] pub fn smp14 (& self) -> Smp14R { Smp14R :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bits 15:17 - ADC channel 15 sampling time selection"]
#[inline (always)] pub fn smp15 (& self) -> Smp15R { Smp15R :: new (((self . bits >> 15) & 7) as u8) }
#[doc = "Bits 18:20 - ADC channel 16 sampling time selection"]
#[inline (always)] pub fn smp16 (& self) -> Smp16R { Smp16R :: new (((self . bits >> 18) & 7) as u8) }
#[doc = "Bits 21:23 - ADC channel 17 sampling time selection"]
#[inline (always)] pub fn smp17 (& self) -> Smp17R { Smp17R :: new (((self . bits >> 21) & 7) as u8) }
#[doc = "Bits 24:26 - ADC channel 18 sampling time selection"]
#[inline (always)] pub fn smp18 (& self) -> Smp18R { Smp18R :: new (((self . bits >> 24) & 7) as u8) } } impl W {
#[doc = "Bits 0:2 - ADC channel 10 sampling time selection"]
#[inline (always)] pub fn smp10 (& mut self) -> Smp10W < '_ , Smpr2Spec > { Smp10W :: new (self , 0) }
#[doc = "Bits 3:5 - ADC channel 11 sampling time selection"]
#[inline (always)] pub fn smp11 (& mut self) -> Smp11W < '_ , Smpr2Spec > { Smp11W :: new (self , 3) }
#[doc = "Bits 6:8 - ADC channel 12 sampling time selection"]
#[inline (always)] pub fn smp12 (& mut self) -> Smp12W < '_ , Smpr2Spec > { Smp12W :: new (self , 6) }
#[doc = "Bits 9:11 - ADC channel 13 sampling time selection"]
#[inline (always)] pub fn smp13 (& mut self) -> Smp13W < '_ , Smpr2Spec > { Smp13W :: new (self , 9) }
#[doc = "Bits 12:14 - ADC channel 14 sampling time selection"]
#[inline (always)] pub fn smp14 (& mut self) -> Smp14W < '_ , Smpr2Spec > { Smp14W :: new (self , 12) }
#[doc = "Bits 15:17 - ADC channel 15 sampling time selection"]
#[inline (always)] pub fn smp15 (& mut self) -> Smp15W < '_ , Smpr2Spec > { Smp15W :: new (self , 15) }
#[doc = "Bits 18:20 - ADC channel 16 sampling time selection"]
#[inline (always)] pub fn smp16 (& mut self) -> Smp16W < '_ , Smpr2Spec > { Smp16W :: new (self , 18) }
#[doc = "Bits 21:23 - ADC channel 17 sampling time selection"]
#[inline (always)] pub fn smp17 (& mut self) -> Smp17W < '_ , Smpr2Spec > { Smp17W :: new (self , 21) }
#[doc = "Bits 24:26 - ADC channel 18 sampling time selection"]
#[inline (always)] pub fn smp18 (& mut self) -> Smp18W < '_ , Smpr2Spec > { Smp18W :: new (self , 24) } }
#[doc = "ADC sampling time register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`smpr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smpr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Smpr2Spec ; impl crate :: RegisterSpec for Smpr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`smpr2::R`](R) reader structure"] impl crate :: Readable for Smpr2Spec { }
#[doc = "`write(|w| ..)` method takes [`smpr2::W`](W) writer structure"] impl crate :: Writable for Smpr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SMPR2 to value 0"] impl crate :: Resettable for Smpr2Spec { } }
#[doc = "TR1 (rw) register accessor: ADC analog watchdog 1 threshold register\n\nYou can [`read`](crate::Reg::read) this register and get [`tr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tr1`] module"]
#[doc (alias = "TR1")] pub type Tr1 = crate :: Reg < tr1 :: Tr1Spec > ;
#[doc = "ADC analog watchdog 1 threshold register"] pub mod tr1 {
#[doc = "Register `TR1` reader"] pub type R = crate :: R < Tr1Spec > ;
#[doc = "Register `TR1` writer"] pub type W = crate :: W < Tr1Spec > ;
#[doc = "Field `LT1` reader - ADC analog watchdog 1 threshold low"] pub type Lt1R = crate :: FieldReader < u16 > ;
#[doc = "Field `LT1` writer - ADC analog watchdog 1 threshold low"] pub type Lt1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ;
#[doc = "Field `HT1` reader - ADC analog watchdog 1 threshold high"] pub type Ht1R = crate :: FieldReader < u16 > ;
#[doc = "Field `HT1` writer - ADC analog watchdog 1 threshold high"] pub type Ht1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 0:11 - ADC analog watchdog 1 threshold low"]
#[inline (always)] pub fn lt1 (& self) -> Lt1R { Lt1R :: new ((self . bits & 0x0fff) as u16) }
#[doc = "Bits 16:27 - ADC analog watchdog 1 threshold high"]
#[inline (always)] pub fn ht1 (& self) -> Ht1R { Ht1R :: new (((self . bits >> 16) & 0x0fff) as u16) } } impl W {
#[doc = "Bits 0:11 - ADC analog watchdog 1 threshold low"]
#[inline (always)] pub fn lt1 (& mut self) -> Lt1W < '_ , Tr1Spec > { Lt1W :: new (self , 0) }
#[doc = "Bits 16:27 - ADC analog watchdog 1 threshold high"]
#[inline (always)] pub fn ht1 (& mut self) -> Ht1W < '_ , Tr1Spec > { Ht1W :: new (self , 16) } }
#[doc = "ADC analog watchdog 1 threshold register\n\nYou can [`read`](crate::Reg::read) this register and get [`tr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Tr1Spec ; impl crate :: RegisterSpec for Tr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`tr1::R`](R) reader structure"] impl crate :: Readable for Tr1Spec { }
#[doc = "`write(|w| ..)` method takes [`tr1::W`](W) writer structure"] impl crate :: Writable for Tr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets TR1 to value 0x0fff_0000"] impl crate :: Resettable for Tr1Spec { const RESET_VALUE : u32 = 0x0fff_0000 ; } }
#[doc = "TR2 (rw) register accessor: ADC analog watchdog 2 threshold register\n\nYou can [`read`](crate::Reg::read) this register and get [`tr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tr2`] module"]
#[doc (alias = "TR2")] pub type Tr2 = crate :: Reg < tr2 :: Tr2Spec > ;
#[doc = "ADC analog watchdog 2 threshold register"] pub mod tr2 {
#[doc = "Register `TR2` reader"] pub type R = crate :: R < Tr2Spec > ;
#[doc = "Register `TR2` writer"] pub type W = crate :: W < Tr2Spec > ;
#[doc = "Field `LT2` reader - ADC analog watchdog 2 threshold low"] pub type Lt2R = crate :: FieldReader ;
#[doc = "Field `LT2` writer - ADC analog watchdog 2 threshold low"] pub type Lt2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `HT2` reader - ADC analog watchdog 2 threshold high"] pub type Ht2R = crate :: FieldReader ;
#[doc = "Field `HT2` writer - ADC analog watchdog 2 threshold high"] pub type Ht2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - ADC analog watchdog 2 threshold low"]
#[inline (always)] pub fn lt2 (& self) -> Lt2R { Lt2R :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 16:23 - ADC analog watchdog 2 threshold high"]
#[inline (always)] pub fn ht2 (& self) -> Ht2R { Ht2R :: new (((self . bits >> 16) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - ADC analog watchdog 2 threshold low"]
#[inline (always)] pub fn lt2 (& mut self) -> Lt2W < '_ , Tr2Spec > { Lt2W :: new (self , 0) }
#[doc = "Bits 16:23 - ADC analog watchdog 2 threshold high"]
#[inline (always)] pub fn ht2 (& mut self) -> Ht2W < '_ , Tr2Spec > { Ht2W :: new (self , 16) } }
#[doc = "ADC analog watchdog 2 threshold register\n\nYou can [`read`](crate::Reg::read) this register and get [`tr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Tr2Spec ; impl crate :: RegisterSpec for Tr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`tr2::R`](R) reader structure"] impl crate :: Readable for Tr2Spec { }
#[doc = "`write(|w| ..)` method takes [`tr2::W`](W) writer structure"] impl crate :: Writable for Tr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets TR2 to value 0x0fff_0000"] impl crate :: Resettable for Tr2Spec { const RESET_VALUE : u32 = 0x0fff_0000 ; } }
#[doc = "TR3 (rw) register accessor: ADC analog watchdog 3 threshold register\n\nYou can [`read`](crate::Reg::read) this register and get [`tr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tr3`] module"]
#[doc (alias = "TR3")] pub type Tr3 = crate :: Reg < tr3 :: Tr3Spec > ;
#[doc = "ADC analog watchdog 3 threshold register"] pub mod tr3 {
#[doc = "Register `TR3` reader"] pub type R = crate :: R < Tr3Spec > ;
#[doc = "Register `TR3` writer"] pub type W = crate :: W < Tr3Spec > ;
#[doc = "Field `LT3` reader - ADC analog watchdog 3 threshold low"] pub type Lt3R = crate :: FieldReader ;
#[doc = "Field `LT3` writer - ADC analog watchdog 3 threshold low"] pub type Lt3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `HT3` reader - ADC analog watchdog 3 threshold high"] pub type Ht3R = crate :: FieldReader ;
#[doc = "Field `HT3` writer - ADC analog watchdog 3 threshold high"] pub type Ht3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - ADC analog watchdog 3 threshold low"]
#[inline (always)] pub fn lt3 (& self) -> Lt3R { Lt3R :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 16:23 - ADC analog watchdog 3 threshold high"]
#[inline (always)] pub fn ht3 (& self) -> Ht3R { Ht3R :: new (((self . bits >> 16) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - ADC analog watchdog 3 threshold low"]
#[inline (always)] pub fn lt3 (& mut self) -> Lt3W < '_ , Tr3Spec > { Lt3W :: new (self , 0) }
#[doc = "Bits 16:23 - ADC analog watchdog 3 threshold high"]
#[inline (always)] pub fn ht3 (& mut self) -> Ht3W < '_ , Tr3Spec > { Ht3W :: new (self , 16) } }
#[doc = "ADC analog watchdog 3 threshold register\n\nYou can [`read`](crate::Reg::read) this register and get [`tr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Tr3Spec ; impl crate :: RegisterSpec for Tr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`tr3::R`](R) reader structure"] impl crate :: Readable for Tr3Spec { }
#[doc = "`write(|w| ..)` method takes [`tr3::W`](W) writer structure"] impl crate :: Writable for Tr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets TR3 to value 0x0fff_0000"] impl crate :: Resettable for Tr3Spec { const RESET_VALUE : u32 = 0x0fff_0000 ; } }
#[doc = "SQR1 (rw) register accessor: ADC group regular sequencer ranks register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`sqr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sqr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sqr1`] module"]
#[doc (alias = "SQR1")] pub type Sqr1 = crate :: Reg < sqr1 :: Sqr1Spec > ;
#[doc = "ADC group regular sequencer ranks register 1"] pub mod sqr1 {
#[doc = "Register `SQR1` reader"] pub type R = crate :: R < Sqr1Spec > ;
#[doc = "Register `SQR1` writer"] pub type W = crate :: W < Sqr1Spec > ;
#[doc = "Field `L3` reader - L3"] pub type L3R = crate :: FieldReader ;
#[doc = "Field `L3` writer - L3"] pub type L3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `SQ1` reader - ADC group regular sequencer rank 1"] pub type Sq1R = crate :: FieldReader ;
#[doc = "Field `SQ1` writer - ADC group regular sequencer rank 1"] pub type Sq1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ2` reader - ADC group regular sequencer rank 2"] pub type Sq2R = crate :: FieldReader ;
#[doc = "Field `SQ2` writer - ADC group regular sequencer rank 2"] pub type Sq2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ3` reader - ADC group regular sequencer rank 3"] pub type Sq3R = crate :: FieldReader ;
#[doc = "Field `SQ3` writer - ADC group regular sequencer rank 3"] pub type Sq3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ4` reader - ADC group regular sequencer rank 4"] pub type Sq4R = crate :: FieldReader ;
#[doc = "Field `SQ4` writer - ADC group regular sequencer rank 4"] pub type Sq4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:3 - L3"]
#[inline (always)] pub fn l3 (& self) -> L3R { L3R :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 6:10 - ADC group regular sequencer rank 1"]
#[inline (always)] pub fn sq1 (& self) -> Sq1R { Sq1R :: new (((self . bits >> 6) & 0x1f) as u8) }
#[doc = "Bits 12:16 - ADC group regular sequencer rank 2"]
#[inline (always)] pub fn sq2 (& self) -> Sq2R { Sq2R :: new (((self . bits >> 12) & 0x1f) as u8) }
#[doc = "Bits 18:22 - ADC group regular sequencer rank 3"]
#[inline (always)] pub fn sq3 (& self) -> Sq3R { Sq3R :: new (((self . bits >> 18) & 0x1f) as u8) }
#[doc = "Bits 24:28 - ADC group regular sequencer rank 4"]
#[inline (always)] pub fn sq4 (& self) -> Sq4R { Sq4R :: new (((self . bits >> 24) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:3 - L3"]
#[inline (always)] pub fn l3 (& mut self) -> L3W < '_ , Sqr1Spec > { L3W :: new (self , 0) }
#[doc = "Bits 6:10 - ADC group regular sequencer rank 1"]
#[inline (always)] pub fn sq1 (& mut self) -> Sq1W < '_ , Sqr1Spec > { Sq1W :: new (self , 6) }
#[doc = "Bits 12:16 - ADC group regular sequencer rank 2"]
#[inline (always)] pub fn sq2 (& mut self) -> Sq2W < '_ , Sqr1Spec > { Sq2W :: new (self , 12) }
#[doc = "Bits 18:22 - ADC group regular sequencer rank 3"]
#[inline (always)] pub fn sq3 (& mut self) -> Sq3W < '_ , Sqr1Spec > { Sq3W :: new (self , 18) }
#[doc = "Bits 24:28 - ADC group regular sequencer rank 4"]
#[inline (always)] pub fn sq4 (& mut self) -> Sq4W < '_ , Sqr1Spec > { Sq4W :: new (self , 24) } }
#[doc = "ADC group regular sequencer ranks register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`sqr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sqr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Sqr1Spec ; impl crate :: RegisterSpec for Sqr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sqr1::R`](R) reader structure"] impl crate :: Readable for Sqr1Spec { }
#[doc = "`write(|w| ..)` method takes [`sqr1::W`](W) writer structure"] impl crate :: Writable for Sqr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SQR1 to value 0"] impl crate :: Resettable for Sqr1Spec { } }
#[doc = "SQR2 (rw) register accessor: ADC group regular sequencer ranks register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`sqr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sqr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sqr2`] module"]
#[doc (alias = "SQR2")] pub type Sqr2 = crate :: Reg < sqr2 :: Sqr2Spec > ;
#[doc = "ADC group regular sequencer ranks register 2"] pub mod sqr2 {
#[doc = "Register `SQR2` reader"] pub type R = crate :: R < Sqr2Spec > ;
#[doc = "Register `SQR2` writer"] pub type W = crate :: W < Sqr2Spec > ;
#[doc = "Field `SQ5` reader - ADC group regular sequencer rank 5"] pub type Sq5R = crate :: FieldReader ;
#[doc = "Field `SQ5` writer - ADC group regular sequencer rank 5"] pub type Sq5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ6` reader - ADC group regular sequencer rank 6"] pub type Sq6R = crate :: FieldReader ;
#[doc = "Field `SQ6` writer - ADC group regular sequencer rank 6"] pub type Sq6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ7` reader - ADC group regular sequencer rank 7"] pub type Sq7R = crate :: FieldReader ;
#[doc = "Field `SQ7` writer - ADC group regular sequencer rank 7"] pub type Sq7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ8` reader - ADC group regular sequencer rank 8"] pub type Sq8R = crate :: FieldReader ;
#[doc = "Field `SQ8` writer - ADC group regular sequencer rank 8"] pub type Sq8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ9` reader - ADC group regular sequencer rank 9"] pub type Sq9R = crate :: FieldReader ;
#[doc = "Field `SQ9` writer - ADC group regular sequencer rank 9"] pub type Sq9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:4 - ADC group regular sequencer rank 5"]
#[inline (always)] pub fn sq5 (& self) -> Sq5R { Sq5R :: new ((self . bits & 0x1f) as u8) }
#[doc = "Bits 6:10 - ADC group regular sequencer rank 6"]
#[inline (always)] pub fn sq6 (& self) -> Sq6R { Sq6R :: new (((self . bits >> 6) & 0x1f) as u8) }
#[doc = "Bits 12:16 - ADC group regular sequencer rank 7"]
#[inline (always)] pub fn sq7 (& self) -> Sq7R { Sq7R :: new (((self . bits >> 12) & 0x1f) as u8) }
#[doc = "Bits 18:22 - ADC group regular sequencer rank 8"]
#[inline (always)] pub fn sq8 (& self) -> Sq8R { Sq8R :: new (((self . bits >> 18) & 0x1f) as u8) }
#[doc = "Bits 24:28 - ADC group regular sequencer rank 9"]
#[inline (always)] pub fn sq9 (& self) -> Sq9R { Sq9R :: new (((self . bits >> 24) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:4 - ADC group regular sequencer rank 5"]
#[inline (always)] pub fn sq5 (& mut self) -> Sq5W < '_ , Sqr2Spec > { Sq5W :: new (self , 0) }
#[doc = "Bits 6:10 - ADC group regular sequencer rank 6"]
#[inline (always)] pub fn sq6 (& mut self) -> Sq6W < '_ , Sqr2Spec > { Sq6W :: new (self , 6) }
#[doc = "Bits 12:16 - ADC group regular sequencer rank 7"]
#[inline (always)] pub fn sq7 (& mut self) -> Sq7W < '_ , Sqr2Spec > { Sq7W :: new (self , 12) }
#[doc = "Bits 18:22 - ADC group regular sequencer rank 8"]
#[inline (always)] pub fn sq8 (& mut self) -> Sq8W < '_ , Sqr2Spec > { Sq8W :: new (self , 18) }
#[doc = "Bits 24:28 - ADC group regular sequencer rank 9"]
#[inline (always)] pub fn sq9 (& mut self) -> Sq9W < '_ , Sqr2Spec > { Sq9W :: new (self , 24) } }
#[doc = "ADC group regular sequencer ranks register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`sqr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sqr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Sqr2Spec ; impl crate :: RegisterSpec for Sqr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sqr2::R`](R) reader structure"] impl crate :: Readable for Sqr2Spec { }
#[doc = "`write(|w| ..)` method takes [`sqr2::W`](W) writer structure"] impl crate :: Writable for Sqr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SQR2 to value 0"] impl crate :: Resettable for Sqr2Spec { } }
#[doc = "SQR3 (rw) register accessor: ADC group regular sequencer ranks register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`sqr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sqr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sqr3`] module"]
#[doc (alias = "SQR3")] pub type Sqr3 = crate :: Reg < sqr3 :: Sqr3Spec > ;
#[doc = "ADC group regular sequencer ranks register 3"] pub mod sqr3 {
#[doc = "Register `SQR3` reader"] pub type R = crate :: R < Sqr3Spec > ;
#[doc = "Register `SQR3` writer"] pub type W = crate :: W < Sqr3Spec > ;
#[doc = "Field `SQ10` reader - ADC group regular sequencer rank 10"] pub type Sq10R = crate :: FieldReader ;
#[doc = "Field `SQ10` writer - ADC group regular sequencer rank 10"] pub type Sq10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ11` reader - ADC group regular sequencer rank 11"] pub type Sq11R = crate :: FieldReader ;
#[doc = "Field `SQ11` writer - ADC group regular sequencer rank 11"] pub type Sq11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ12` reader - ADC group regular sequencer rank 12"] pub type Sq12R = crate :: FieldReader ;
#[doc = "Field `SQ12` writer - ADC group regular sequencer rank 12"] pub type Sq12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ13` reader - ADC group regular sequencer rank 13"] pub type Sq13R = crate :: FieldReader ;
#[doc = "Field `SQ13` writer - ADC group regular sequencer rank 13"] pub type Sq13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ14` reader - ADC group regular sequencer rank 14"] pub type Sq14R = crate :: FieldReader ;
#[doc = "Field `SQ14` writer - ADC group regular sequencer rank 14"] pub type Sq14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:4 - ADC group regular sequencer rank 10"]
#[inline (always)] pub fn sq10 (& self) -> Sq10R { Sq10R :: new ((self . bits & 0x1f) as u8) }
#[doc = "Bits 6:10 - ADC group regular sequencer rank 11"]
#[inline (always)] pub fn sq11 (& self) -> Sq11R { Sq11R :: new (((self . bits >> 6) & 0x1f) as u8) }
#[doc = "Bits 12:16 - ADC group regular sequencer rank 12"]
#[inline (always)] pub fn sq12 (& self) -> Sq12R { Sq12R :: new (((self . bits >> 12) & 0x1f) as u8) }
#[doc = "Bits 18:22 - ADC group regular sequencer rank 13"]
#[inline (always)] pub fn sq13 (& self) -> Sq13R { Sq13R :: new (((self . bits >> 18) & 0x1f) as u8) }
#[doc = "Bits 24:28 - ADC group regular sequencer rank 14"]
#[inline (always)] pub fn sq14 (& self) -> Sq14R { Sq14R :: new (((self . bits >> 24) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:4 - ADC group regular sequencer rank 10"]
#[inline (always)] pub fn sq10 (& mut self) -> Sq10W < '_ , Sqr3Spec > { Sq10W :: new (self , 0) }
#[doc = "Bits 6:10 - ADC group regular sequencer rank 11"]
#[inline (always)] pub fn sq11 (& mut self) -> Sq11W < '_ , Sqr3Spec > { Sq11W :: new (self , 6) }
#[doc = "Bits 12:16 - ADC group regular sequencer rank 12"]
#[inline (always)] pub fn sq12 (& mut self) -> Sq12W < '_ , Sqr3Spec > { Sq12W :: new (self , 12) }
#[doc = "Bits 18:22 - ADC group regular sequencer rank 13"]
#[inline (always)] pub fn sq13 (& mut self) -> Sq13W < '_ , Sqr3Spec > { Sq13W :: new (self , 18) }
#[doc = "Bits 24:28 - ADC group regular sequencer rank 14"]
#[inline (always)] pub fn sq14 (& mut self) -> Sq14W < '_ , Sqr3Spec > { Sq14W :: new (self , 24) } }
#[doc = "ADC group regular sequencer ranks register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`sqr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sqr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Sqr3Spec ; impl crate :: RegisterSpec for Sqr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sqr3::R`](R) reader structure"] impl crate :: Readable for Sqr3Spec { }
#[doc = "`write(|w| ..)` method takes [`sqr3::W`](W) writer structure"] impl crate :: Writable for Sqr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SQR3 to value 0"] impl crate :: Resettable for Sqr3Spec { } }
#[doc = "SQR4 (rw) register accessor: ADC group regular sequencer ranks register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`sqr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sqr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sqr4`] module"]
#[doc (alias = "SQR4")] pub type Sqr4 = crate :: Reg < sqr4 :: Sqr4Spec > ;
#[doc = "ADC group regular sequencer ranks register 4"] pub mod sqr4 {
#[doc = "Register `SQR4` reader"] pub type R = crate :: R < Sqr4Spec > ;
#[doc = "Register `SQR4` writer"] pub type W = crate :: W < Sqr4Spec > ;
#[doc = "Field `SQ15` reader - ADC group regular sequencer rank 15"] pub type Sq15R = crate :: FieldReader ;
#[doc = "Field `SQ15` writer - ADC group regular sequencer rank 15"] pub type Sq15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ16` reader - ADC group regular sequencer rank 16"] pub type Sq16R = crate :: FieldReader ;
#[doc = "Field `SQ16` writer - ADC group regular sequencer rank 16"] pub type Sq16W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:4 - ADC group regular sequencer rank 15"]
#[inline (always)] pub fn sq15 (& self) -> Sq15R { Sq15R :: new ((self . bits & 0x1f) as u8) }
#[doc = "Bits 6:10 - ADC group regular sequencer rank 16"]
#[inline (always)] pub fn sq16 (& self) -> Sq16R { Sq16R :: new (((self . bits >> 6) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:4 - ADC group regular sequencer rank 15"]
#[inline (always)] pub fn sq15 (& mut self) -> Sq15W < '_ , Sqr4Spec > { Sq15W :: new (self , 0) }
#[doc = "Bits 6:10 - ADC group regular sequencer rank 16"]
#[inline (always)] pub fn sq16 (& mut self) -> Sq16W < '_ , Sqr4Spec > { Sq16W :: new (self , 6) } }
#[doc = "ADC group regular sequencer ranks register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`sqr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sqr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Sqr4Spec ; impl crate :: RegisterSpec for Sqr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sqr4::R`](R) reader structure"] impl crate :: Readable for Sqr4Spec { }
#[doc = "`write(|w| ..)` method takes [`sqr4::W`](W) writer structure"] impl crate :: Writable for Sqr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SQR4 to value 0"] impl crate :: Resettable for Sqr4Spec { } }
#[doc = "DR (rw) register accessor: ADC group regular conversion data register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr`] module"]
#[doc (alias = "DR")] pub type Dr = crate :: Reg < dr :: DrSpec > ;
#[doc = "ADC group regular conversion data register"] pub mod dr {
#[doc = "Register `DR` reader"] pub type R = crate :: R < DrSpec > ;
#[doc = "Register `DR` writer"] pub type W = crate :: W < DrSpec > ;
#[doc = "Field `RDATA_0_6` reader - Regular Data converted 0_6"] pub type Rdata0_6R = crate :: FieldReader ;
#[doc = "Field `RDATA_0_6` writer - Regular Data converted 0_6"] pub type Rdata0_6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 > ;
#[doc = "Field `RDATA_7_15` reader - 15"] pub type Rdata7_15R = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:5 - Regular Data converted 0_6"]
#[inline (always)] pub fn rdata_0_6 (& self) -> Rdata0_6R { Rdata0_6R :: new ((self . bits & 0x3f) as u8) }
#[doc = "Bits 7:15 - 15"]
#[inline (always)] pub fn rdata_7_15 (& self) -> Rdata7_15R { Rdata7_15R :: new (((self . bits >> 7) & 0x01ff) as u16) } } impl W {
#[doc = "Bits 0:5 - Regular Data converted 0_6"]
#[inline (always)] pub fn rdata_0_6 (& mut self) -> Rdata0_6W < '_ , DrSpec > { Rdata0_6W :: new (self , 0) } }
#[doc = "ADC group regular conversion data register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DrSpec ; impl crate :: RegisterSpec for DrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr::R`](R) reader structure"] impl crate :: Readable for DrSpec { }
#[doc = "`write(|w| ..)` method takes [`dr::W`](W) writer structure"] impl crate :: Writable for DrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR to value 0"] impl crate :: Resettable for DrSpec { } }
#[doc = "JSQR (rw) register accessor: ADC group injected sequencer register\n\nYou can [`read`](crate::Reg::read) this register and get [`jsqr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`jsqr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@jsqr`] module"]
#[doc (alias = "JSQR")] pub type Jsqr = crate :: Reg < jsqr :: JsqrSpec > ;
#[doc = "ADC group injected sequencer register"] pub mod jsqr {
#[doc = "Register `JSQR` reader"] pub type R = crate :: R < JsqrSpec > ;
#[doc = "Register `JSQR` writer"] pub type W = crate :: W < JsqrSpec > ;
#[doc = "Field `JL` reader - ADC group injected sequencer scan length"] pub type JlR = crate :: FieldReader ;
#[doc = "Field `JL` writer - ADC group injected sequencer scan length"] pub type JlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `JEXTSEL` reader - ADC group injected external trigger source"] pub type JextselR = crate :: FieldReader ;
#[doc = "Field `JEXTSEL` writer - ADC group injected external trigger source"] pub type JextselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `JEXTEN` reader - ADC group injected external trigger polarity"] pub type JextenR = crate :: FieldReader ;
#[doc = "Field `JEXTEN` writer - ADC group injected external trigger polarity"] pub type JextenW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `JSQ1` reader - ADC group injected sequencer rank 1"] pub type Jsq1R = crate :: FieldReader ;
#[doc = "Field `JSQ1` writer - ADC group injected sequencer rank 1"] pub type Jsq1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `JSQ2` reader - ADC group injected sequencer rank 2"] pub type Jsq2R = crate :: FieldReader ;
#[doc = "Field `JSQ2` writer - ADC group injected sequencer rank 2"] pub type Jsq2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `JSQ3` reader - ADC group injected sequencer rank 3"] pub type Jsq3R = crate :: FieldReader ;
#[doc = "Field `JSQ3` writer - ADC group injected sequencer rank 3"] pub type Jsq3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `JSQ4` reader - ADC group injected sequencer rank 4"] pub type Jsq4R = crate :: FieldReader ;
#[doc = "Field `JSQ4` writer - ADC group injected sequencer rank 4"] pub type Jsq4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:1 - ADC group injected sequencer scan length"]
#[inline (always)] pub fn jl (& self) -> JlR { JlR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:5 - ADC group injected external trigger source"]
#[inline (always)] pub fn jextsel (& self) -> JextselR { JextselR :: new (((self . bits >> 2) & 0x0f) as u8) }
#[doc = "Bits 6:7 - ADC group injected external trigger polarity"]
#[inline (always)] pub fn jexten (& self) -> JextenR { JextenR :: new (((self . bits >> 6) & 3) as u8) }
#[doc = "Bits 8:12 - ADC group injected sequencer rank 1"]
#[inline (always)] pub fn jsq1 (& self) -> Jsq1R { Jsq1R :: new (((self . bits >> 8) & 0x1f) as u8) }
#[doc = "Bits 14:18 - ADC group injected sequencer rank 2"]
#[inline (always)] pub fn jsq2 (& self) -> Jsq2R { Jsq2R :: new (((self . bits >> 14) & 0x1f) as u8) }
#[doc = "Bits 20:24 - ADC group injected sequencer rank 3"]
#[inline (always)] pub fn jsq3 (& self) -> Jsq3R { Jsq3R :: new (((self . bits >> 20) & 0x1f) as u8) }
#[doc = "Bits 26:30 - ADC group injected sequencer rank 4"]
#[inline (always)] pub fn jsq4 (& self) -> Jsq4R { Jsq4R :: new (((self . bits >> 26) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:1 - ADC group injected sequencer scan length"]
#[inline (always)] pub fn jl (& mut self) -> JlW < '_ , JsqrSpec > { JlW :: new (self , 0) }
#[doc = "Bits 2:5 - ADC group injected external trigger source"]
#[inline (always)] pub fn jextsel (& mut self) -> JextselW < '_ , JsqrSpec > { JextselW :: new (self , 2) }
#[doc = "Bits 6:7 - ADC group injected external trigger polarity"]
#[inline (always)] pub fn jexten (& mut self) -> JextenW < '_ , JsqrSpec > { JextenW :: new (self , 6) }
#[doc = "Bits 8:12 - ADC group injected sequencer rank 1"]
#[inline (always)] pub fn jsq1 (& mut self) -> Jsq1W < '_ , JsqrSpec > { Jsq1W :: new (self , 8) }
#[doc = "Bits 14:18 - ADC group injected sequencer rank 2"]
#[inline (always)] pub fn jsq2 (& mut self) -> Jsq2W < '_ , JsqrSpec > { Jsq2W :: new (self , 14) }
#[doc = "Bits 20:24 - ADC group injected sequencer rank 3"]
#[inline (always)] pub fn jsq3 (& mut self) -> Jsq3W < '_ , JsqrSpec > { Jsq3W :: new (self , 20) }
#[doc = "Bits 26:30 - ADC group injected sequencer rank 4"]
#[inline (always)] pub fn jsq4 (& mut self) -> Jsq4W < '_ , JsqrSpec > { Jsq4W :: new (self , 26) } }
#[doc = "ADC group injected sequencer register\n\nYou can [`read`](crate::Reg::read) this register and get [`jsqr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`jsqr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct JsqrSpec ; impl crate :: RegisterSpec for JsqrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`jsqr::R`](R) reader structure"] impl crate :: Readable for JsqrSpec { }
#[doc = "`write(|w| ..)` method takes [`jsqr::W`](W) writer structure"] impl crate :: Writable for JsqrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets JSQR to value 0"] impl crate :: Resettable for JsqrSpec { } }
#[doc = "OFR1 (rw) register accessor: ADC offset number 1 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ofr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ofr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ofr1`] module"]
#[doc (alias = "OFR1")] pub type Ofr1 = crate :: Reg < ofr1 :: Ofr1Spec > ;
#[doc = "ADC offset number 1 register"] pub mod ofr1 {
#[doc = "Register `OFR1` reader"] pub type R = crate :: R < Ofr1Spec > ;
#[doc = "Register `OFR1` writer"] pub type W = crate :: W < Ofr1Spec > ;
#[doc = "Field `OFFSET1` reader - ADC offset number 1 offset level"] pub type Offset1R = crate :: FieldReader < u16 > ;
#[doc = "Field `OFFSET1` writer - ADC offset number 1 offset level"] pub type Offset1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ;
#[doc = "Field `OFFSET1_CH` reader - ADC offset number 1 channel selection"] pub type Offset1ChR = crate :: FieldReader ;
#[doc = "Field `OFFSET1_CH` writer - ADC offset number 1 channel selection"] pub type Offset1ChW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `OFFSET1_EN` reader - ADC offset number 1 enable"] pub type Offset1EnR = crate :: BitReader ;
#[doc = "Field `OFFSET1_EN` writer - ADC offset number 1 enable"] pub type Offset1EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:11 - ADC offset number 1 offset level"]
#[inline (always)] pub fn offset1 (& self) -> Offset1R { Offset1R :: new ((self . bits & 0x0fff) as u16) }
#[doc = "Bits 26:30 - ADC offset number 1 channel selection"]
#[inline (always)] pub fn offset1_ch (& self) -> Offset1ChR { Offset1ChR :: new (((self . bits >> 26) & 0x1f) as u8) }
#[doc = "Bit 31 - ADC offset number 1 enable"]
#[inline (always)] pub fn offset1_en (& self) -> Offset1EnR { Offset1EnR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:11 - ADC offset number 1 offset level"]
#[inline (always)] pub fn offset1 (& mut self) -> Offset1W < '_ , Ofr1Spec > { Offset1W :: new (self , 0) }
#[doc = "Bits 26:30 - ADC offset number 1 channel selection"]
#[inline (always)] pub fn offset1_ch (& mut self) -> Offset1ChW < '_ , Ofr1Spec > { Offset1ChW :: new (self , 26) }
#[doc = "Bit 31 - ADC offset number 1 enable"]
#[inline (always)] pub fn offset1_en (& mut self) -> Offset1EnW < '_ , Ofr1Spec > { Offset1EnW :: new (self , 31) } }
#[doc = "ADC offset number 1 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ofr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ofr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ofr1Spec ; impl crate :: RegisterSpec for Ofr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ofr1::R`](R) reader structure"] impl crate :: Readable for Ofr1Spec { }
#[doc = "`write(|w| ..)` method takes [`ofr1::W`](W) writer structure"] impl crate :: Writable for Ofr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OFR1 to value 0"] impl crate :: Resettable for Ofr1Spec { } }
#[doc = "OFR2 (rw) register accessor: ADC offset number 2 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ofr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ofr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ofr2`] module"]
#[doc (alias = "OFR2")] pub type Ofr2 = crate :: Reg < ofr2 :: Ofr2Spec > ;
#[doc = "ADC offset number 2 register"] pub mod ofr2 {
#[doc = "Register `OFR2` reader"] pub type R = crate :: R < Ofr2Spec > ;
#[doc = "Register `OFR2` writer"] pub type W = crate :: W < Ofr2Spec > ;
#[doc = "Field `OFFSET2` reader - ADC offset number 2 offset level"] pub type Offset2R = crate :: FieldReader < u16 > ;
#[doc = "Field `OFFSET2` writer - ADC offset number 2 offset level"] pub type Offset2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ;
#[doc = "Field `OFFSET2_CH` reader - ADC offset number 2 channel selection"] pub type Offset2ChR = crate :: FieldReader ;
#[doc = "Field `OFFSET2_CH` writer - ADC offset number 2 channel selection"] pub type Offset2ChW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `OFFSET2_EN` reader - ADC offset number 2 enable"] pub type Offset2EnR = crate :: BitReader ;
#[doc = "Field `OFFSET2_EN` writer - ADC offset number 2 enable"] pub type Offset2EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:11 - ADC offset number 2 offset level"]
#[inline (always)] pub fn offset2 (& self) -> Offset2R { Offset2R :: new ((self . bits & 0x0fff) as u16) }
#[doc = "Bits 26:30 - ADC offset number 2 channel selection"]
#[inline (always)] pub fn offset2_ch (& self) -> Offset2ChR { Offset2ChR :: new (((self . bits >> 26) & 0x1f) as u8) }
#[doc = "Bit 31 - ADC offset number 2 enable"]
#[inline (always)] pub fn offset2_en (& self) -> Offset2EnR { Offset2EnR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:11 - ADC offset number 2 offset level"]
#[inline (always)] pub fn offset2 (& mut self) -> Offset2W < '_ , Ofr2Spec > { Offset2W :: new (self , 0) }
#[doc = "Bits 26:30 - ADC offset number 2 channel selection"]
#[inline (always)] pub fn offset2_ch (& mut self) -> Offset2ChW < '_ , Ofr2Spec > { Offset2ChW :: new (self , 26) }
#[doc = "Bit 31 - ADC offset number 2 enable"]
#[inline (always)] pub fn offset2_en (& mut self) -> Offset2EnW < '_ , Ofr2Spec > { Offset2EnW :: new (self , 31) } }
#[doc = "ADC offset number 2 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ofr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ofr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ofr2Spec ; impl crate :: RegisterSpec for Ofr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ofr2::R`](R) reader structure"] impl crate :: Readable for Ofr2Spec { }
#[doc = "`write(|w| ..)` method takes [`ofr2::W`](W) writer structure"] impl crate :: Writable for Ofr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OFR2 to value 0"] impl crate :: Resettable for Ofr2Spec { } }
#[doc = "OFR3 (rw) register accessor: ADC offset number 3 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ofr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ofr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ofr3`] module"]
#[doc (alias = "OFR3")] pub type Ofr3 = crate :: Reg < ofr3 :: Ofr3Spec > ;
#[doc = "ADC offset number 3 register"] pub mod ofr3 {
#[doc = "Register `OFR3` reader"] pub type R = crate :: R < Ofr3Spec > ;
#[doc = "Register `OFR3` writer"] pub type W = crate :: W < Ofr3Spec > ;
#[doc = "Field `OFFSET3` reader - ADC offset number 3 offset level"] pub type Offset3R = crate :: FieldReader < u16 > ;
#[doc = "Field `OFFSET3` writer - ADC offset number 3 offset level"] pub type Offset3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ;
#[doc = "Field `OFFSET3_CH` reader - ADC offset number 3 channel selection"] pub type Offset3ChR = crate :: FieldReader ;
#[doc = "Field `OFFSET3_CH` writer - ADC offset number 3 channel selection"] pub type Offset3ChW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `OFFSET3_EN` reader - ADC offset number 3 enable"] pub type Offset3EnR = crate :: BitReader ;
#[doc = "Field `OFFSET3_EN` writer - ADC offset number 3 enable"] pub type Offset3EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:11 - ADC offset number 3 offset level"]
#[inline (always)] pub fn offset3 (& self) -> Offset3R { Offset3R :: new ((self . bits & 0x0fff) as u16) }
#[doc = "Bits 26:30 - ADC offset number 3 channel selection"]
#[inline (always)] pub fn offset3_ch (& self) -> Offset3ChR { Offset3ChR :: new (((self . bits >> 26) & 0x1f) as u8) }
#[doc = "Bit 31 - ADC offset number 3 enable"]
#[inline (always)] pub fn offset3_en (& self) -> Offset3EnR { Offset3EnR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:11 - ADC offset number 3 offset level"]
#[inline (always)] pub fn offset3 (& mut self) -> Offset3W < '_ , Ofr3Spec > { Offset3W :: new (self , 0) }
#[doc = "Bits 26:30 - ADC offset number 3 channel selection"]
#[inline (always)] pub fn offset3_ch (& mut self) -> Offset3ChW < '_ , Ofr3Spec > { Offset3ChW :: new (self , 26) }
#[doc = "Bit 31 - ADC offset number 3 enable"]
#[inline (always)] pub fn offset3_en (& mut self) -> Offset3EnW < '_ , Ofr3Spec > { Offset3EnW :: new (self , 31) } }
#[doc = "ADC offset number 3 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ofr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ofr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ofr3Spec ; impl crate :: RegisterSpec for Ofr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ofr3::R`](R) reader structure"] impl crate :: Readable for Ofr3Spec { }
#[doc = "`write(|w| ..)` method takes [`ofr3::W`](W) writer structure"] impl crate :: Writable for Ofr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OFR3 to value 0"] impl crate :: Resettable for Ofr3Spec { } }
#[doc = "OFR4 (rw) register accessor: ADC offset number 4 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ofr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ofr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ofr4`] module"]
#[doc (alias = "OFR4")] pub type Ofr4 = crate :: Reg < ofr4 :: Ofr4Spec > ;
#[doc = "ADC offset number 4 register"] pub mod ofr4 {
#[doc = "Register `OFR4` reader"] pub type R = crate :: R < Ofr4Spec > ;
#[doc = "Register `OFR4` writer"] pub type W = crate :: W < Ofr4Spec > ;
#[doc = "Field `OFFSET4` reader - ADC offset number 4 offset level"] pub type Offset4R = crate :: FieldReader < u16 > ;
#[doc = "Field `OFFSET4` writer - ADC offset number 4 offset level"] pub type Offset4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ;
#[doc = "Field `OFFSET4_CH` reader - ADC offset number 4 channel selection"] pub type Offset4ChR = crate :: FieldReader ;
#[doc = "Field `OFFSET4_CH` writer - ADC offset number 4 channel selection"] pub type Offset4ChW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `OFFSET4_EN` reader - ADC offset number 4 enable"] pub type Offset4EnR = crate :: BitReader ;
#[doc = "Field `OFFSET4_EN` writer - ADC offset number 4 enable"] pub type Offset4EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:11 - ADC offset number 4 offset level"]
#[inline (always)] pub fn offset4 (& self) -> Offset4R { Offset4R :: new ((self . bits & 0x0fff) as u16) }
#[doc = "Bits 26:30 - ADC offset number 4 channel selection"]
#[inline (always)] pub fn offset4_ch (& self) -> Offset4ChR { Offset4ChR :: new (((self . bits >> 26) & 0x1f) as u8) }
#[doc = "Bit 31 - ADC offset number 4 enable"]
#[inline (always)] pub fn offset4_en (& self) -> Offset4EnR { Offset4EnR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:11 - ADC offset number 4 offset level"]
#[inline (always)] pub fn offset4 (& mut self) -> Offset4W < '_ , Ofr4Spec > { Offset4W :: new (self , 0) }
#[doc = "Bits 26:30 - ADC offset number 4 channel selection"]
#[inline (always)] pub fn offset4_ch (& mut self) -> Offset4ChW < '_ , Ofr4Spec > { Offset4ChW :: new (self , 26) }
#[doc = "Bit 31 - ADC offset number 4 enable"]
#[inline (always)] pub fn offset4_en (& mut self) -> Offset4EnW < '_ , Ofr4Spec > { Offset4EnW :: new (self , 31) } }
#[doc = "ADC offset number 4 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ofr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ofr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ofr4Spec ; impl crate :: RegisterSpec for Ofr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ofr4::R`](R) reader structure"] impl crate :: Readable for Ofr4Spec { }
#[doc = "`write(|w| ..)` method takes [`ofr4::W`](W) writer structure"] impl crate :: Writable for Ofr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OFR4 to value 0"] impl crate :: Resettable for Ofr4Spec { } }
#[doc = "JDR1 (r) register accessor: ADC group injected sequencer rank 1 register\n\nYou can [`read`](crate::Reg::read) this register and get [`jdr1::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@jdr1`] module"]
#[doc (alias = "JDR1")] pub type Jdr1 = crate :: Reg < jdr1 :: Jdr1Spec > ;
#[doc = "ADC group injected sequencer rank 1 register"] pub mod jdr1 {
#[doc = "Register `JDR1` reader"] pub type R = crate :: R < Jdr1Spec > ;
#[doc = "Field `JDATA1` reader - ADC group injected sequencer rank 1 conversion data"] pub type Jdata1R = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - ADC group injected sequencer rank 1 conversion data"]
#[inline (always)] pub fn jdata1 (& self) -> Jdata1R { Jdata1R :: new ((self . bits & 0xffff) as u16) } }
#[doc = "ADC group injected sequencer rank 1 register\n\nYou can [`read`](crate::Reg::read) this register and get [`jdr1::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Jdr1Spec ; impl crate :: RegisterSpec for Jdr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`jdr1::R`](R) reader structure"] impl crate :: Readable for Jdr1Spec { }
#[doc = "`reset()` method sets JDR1 to value 0"] impl crate :: Resettable for Jdr1Spec { } }
#[doc = "JDR2 (r) register accessor: ADC group injected sequencer rank 2 register\n\nYou can [`read`](crate::Reg::read) this register and get [`jdr2::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@jdr2`] module"]
#[doc (alias = "JDR2")] pub type Jdr2 = crate :: Reg < jdr2 :: Jdr2Spec > ;
#[doc = "ADC group injected sequencer rank 2 register"] pub mod jdr2 {
#[doc = "Register `JDR2` reader"] pub type R = crate :: R < Jdr2Spec > ;
#[doc = "Field `JDATA2` reader - ADC group injected sequencer rank 2 conversion data"] pub type Jdata2R = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - ADC group injected sequencer rank 2 conversion data"]
#[inline (always)] pub fn jdata2 (& self) -> Jdata2R { Jdata2R :: new ((self . bits & 0xffff) as u16) } }
#[doc = "ADC group injected sequencer rank 2 register\n\nYou can [`read`](crate::Reg::read) this register and get [`jdr2::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Jdr2Spec ; impl crate :: RegisterSpec for Jdr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`jdr2::R`](R) reader structure"] impl crate :: Readable for Jdr2Spec { }
#[doc = "`reset()` method sets JDR2 to value 0"] impl crate :: Resettable for Jdr2Spec { } }
#[doc = "JDR3 (r) register accessor: ADC group injected sequencer rank 3 register\n\nYou can [`read`](crate::Reg::read) this register and get [`jdr3::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@jdr3`] module"]
#[doc (alias = "JDR3")] pub type Jdr3 = crate :: Reg < jdr3 :: Jdr3Spec > ;
#[doc = "ADC group injected sequencer rank 3 register"] pub mod jdr3 {
#[doc = "Register `JDR3` reader"] pub type R = crate :: R < Jdr3Spec > ;
#[doc = "Field `JDATA3` reader - ADC group injected sequencer rank 3 conversion data"] pub type Jdata3R = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - ADC group injected sequencer rank 3 conversion data"]
#[inline (always)] pub fn jdata3 (& self) -> Jdata3R { Jdata3R :: new ((self . bits & 0xffff) as u16) } }
#[doc = "ADC group injected sequencer rank 3 register\n\nYou can [`read`](crate::Reg::read) this register and get [`jdr3::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Jdr3Spec ; impl crate :: RegisterSpec for Jdr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`jdr3::R`](R) reader structure"] impl crate :: Readable for Jdr3Spec { }
#[doc = "`reset()` method sets JDR3 to value 0"] impl crate :: Resettable for Jdr3Spec { } }
#[doc = "JDR4 (r) register accessor: ADC group injected sequencer rank 4 register\n\nYou can [`read`](crate::Reg::read) this register and get [`jdr4::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@jdr4`] module"]
#[doc (alias = "JDR4")] pub type Jdr4 = crate :: Reg < jdr4 :: Jdr4Spec > ;
#[doc = "ADC group injected sequencer rank 4 register"] pub mod jdr4 {
#[doc = "Register `JDR4` reader"] pub type R = crate :: R < Jdr4Spec > ;
#[doc = "Field `JDATA4` reader - ADC group injected sequencer rank 4 conversion data"] pub type Jdata4R = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - ADC group injected sequencer rank 4 conversion data"]
#[inline (always)] pub fn jdata4 (& self) -> Jdata4R { Jdata4R :: new ((self . bits & 0xffff) as u16) } }
#[doc = "ADC group injected sequencer rank 4 register\n\nYou can [`read`](crate::Reg::read) this register and get [`jdr4::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Jdr4Spec ; impl crate :: RegisterSpec for Jdr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`jdr4::R`](R) reader structure"] impl crate :: Readable for Jdr4Spec { }
#[doc = "`reset()` method sets JDR4 to value 0"] impl crate :: Resettable for Jdr4Spec { } }
#[doc = "AWD2CR (rw) register accessor: ADC analog watchdog 2 configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`awd2cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`awd2cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@awd2cr`] module"]
#[doc (alias = "AWD2CR")] pub type Awd2cr = crate :: Reg < awd2cr :: Awd2crSpec > ;
#[doc = "ADC analog watchdog 2 configuration register"] pub mod awd2cr {
#[doc = "Register `AWD2CR` reader"] pub type R = crate :: R < Awd2crSpec > ;
#[doc = "Register `AWD2CR` writer"] pub type W = crate :: W < Awd2crSpec > ;
#[doc = "Field `AWD2CH` reader - ADC analog watchdog 2 monitored channel selection"] pub type Awd2chR = crate :: FieldReader < u32 > ;
#[doc = "Field `AWD2CH` writer - ADC analog watchdog 2 monitored channel selection"] pub type Awd2chW < 'a , REG > = crate :: FieldWriter < 'a , REG , 19 , u32 > ; impl R {
#[doc = "Bits 0:18 - ADC analog watchdog 2 monitored channel selection"]
#[inline (always)] pub fn awd2ch (& self) -> Awd2chR { Awd2chR :: new (self . bits & 0x0007_ffff) } } impl W {
#[doc = "Bits 0:18 - ADC analog watchdog 2 monitored channel selection"]
#[inline (always)] pub fn awd2ch (& mut self) -> Awd2chW < '_ , Awd2crSpec > { Awd2chW :: new (self , 0) } }
#[doc = "ADC analog watchdog 2 configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`awd2cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`awd2cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Awd2crSpec ; impl crate :: RegisterSpec for Awd2crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`awd2cr::R`](R) reader structure"] impl crate :: Readable for Awd2crSpec { }
#[doc = "`write(|w| ..)` method takes [`awd2cr::W`](W) writer structure"] impl crate :: Writable for Awd2crSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AWD2CR to value 0"] impl crate :: Resettable for Awd2crSpec { } }
#[doc = "AWD3CR (rw) register accessor: ADC analog watchdog 3 configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`awd3cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`awd3cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@awd3cr`] module"]
#[doc (alias = "AWD3CR")] pub type Awd3cr = crate :: Reg < awd3cr :: Awd3crSpec > ;
#[doc = "ADC analog watchdog 3 configuration register"] pub mod awd3cr {
#[doc = "Register `AWD3CR` reader"] pub type R = crate :: R < Awd3crSpec > ;
#[doc = "Register `AWD3CR` writer"] pub type W = crate :: W < Awd3crSpec > ;
#[doc = "Field `AWD3CH` reader - ADC analog watchdog 3 monitored channel selection"] pub type Awd3chR = crate :: FieldReader < u32 > ;
#[doc = "Field `AWD3CH` writer - ADC analog watchdog 3 monitored channel selection"] pub type Awd3chW < 'a , REG > = crate :: FieldWriter < 'a , REG , 19 , u32 > ; impl R {
#[doc = "Bits 0:18 - ADC analog watchdog 3 monitored channel selection"]
#[inline (always)] pub fn awd3ch (& self) -> Awd3chR { Awd3chR :: new (self . bits & 0x0007_ffff) } } impl W {
#[doc = "Bits 0:18 - ADC analog watchdog 3 monitored channel selection"]
#[inline (always)] pub fn awd3ch (& mut self) -> Awd3chW < '_ , Awd3crSpec > { Awd3chW :: new (self , 0) } }
#[doc = "ADC analog watchdog 3 configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`awd3cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`awd3cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Awd3crSpec ; impl crate :: RegisterSpec for Awd3crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`awd3cr::R`](R) reader structure"] impl crate :: Readable for Awd3crSpec { }
#[doc = "`write(|w| ..)` method takes [`awd3cr::W`](W) writer structure"] impl crate :: Writable for Awd3crSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AWD3CR to value 0"] impl crate :: Resettable for Awd3crSpec { } }
#[doc = "DIFSEL (rw) register accessor: ADC channel differential or single-ended mode selection register\n\nYou can [`read`](crate::Reg::read) this register and get [`difsel::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`difsel::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@difsel`] module"]
#[doc (alias = "DIFSEL")] pub type Difsel = crate :: Reg < difsel :: DifselSpec > ;
#[doc = "ADC channel differential or single-ended mode selection register"] pub mod difsel {
#[doc = "Register `DIFSEL` reader"] pub type R = crate :: R < DifselSpec > ;
#[doc = "Register `DIFSEL` writer"] pub type W = crate :: W < DifselSpec > ;
#[doc = "Field `DIFSEL_0` reader - ADC channel differential or single-ended mode for channel 0"] pub type Difsel0R = crate :: BitReader ;
#[doc = "Field `DIFSEL_1_15` reader - ADC channel differential or single-ended mode for channels 1 to 15"] pub type Difsel1_15R = crate :: FieldReader < u16 > ;
#[doc = "Field `DIFSEL_1_15` writer - ADC channel differential or single-ended mode for channels 1 to 15"] pub type Difsel1_15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 15 , u16 > ;
#[doc = "Field `DIFSEL_16_18` reader - ADC channel differential or single-ended mode for channels 18 to 16"] pub type Difsel16_18R = crate :: FieldReader ; impl R {
#[doc = "Bit 0 - ADC channel differential or single-ended mode for channel 0"]
#[inline (always)] pub fn difsel_0 (& self) -> Difsel0R { Difsel0R :: new ((self . bits & 1) != 0) }
#[doc = "Bits 1:15 - ADC channel differential or single-ended mode for channels 1 to 15"]
#[inline (always)] pub fn difsel_1_15 (& self) -> Difsel1_15R { Difsel1_15R :: new (((self . bits >> 1) & 0x7fff) as u16) }
#[doc = "Bits 16:18 - ADC channel differential or single-ended mode for channels 18 to 16"]
#[inline (always)] pub fn difsel_16_18 (& self) -> Difsel16_18R { Difsel16_18R :: new (((self . bits >> 16) & 7) as u8) } } impl W {
#[doc = "Bits 1:15 - ADC channel differential or single-ended mode for channels 1 to 15"]
#[inline (always)] pub fn difsel_1_15 (& mut self) -> Difsel1_15W < '_ , DifselSpec > { Difsel1_15W :: new (self , 1) } }
#[doc = "ADC channel differential or single-ended mode selection register\n\nYou can [`read`](crate::Reg::read) this register and get [`difsel::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`difsel::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DifselSpec ; impl crate :: RegisterSpec for DifselSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`difsel::R`](R) reader structure"] impl crate :: Readable for DifselSpec { }
#[doc = "`write(|w| ..)` method takes [`difsel::W`](W) writer structure"] impl crate :: Writable for DifselSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIFSEL to value 0"] impl crate :: Resettable for DifselSpec { } }
#[doc = "CALFACT (rw) register accessor: ADC calibration factors register\n\nYou can [`read`](crate::Reg::read) this register and get [`calfact::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`calfact::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@calfact`] module"]
#[doc (alias = "CALFACT")] pub type Calfact = crate :: Reg < calfact :: CalfactSpec > ;
#[doc = "ADC calibration factors register"] pub mod calfact {
#[doc = "Register `CALFACT` reader"] pub type R = crate :: R < CalfactSpec > ;
#[doc = "Register `CALFACT` writer"] pub type W = crate :: W < CalfactSpec > ;
#[doc = "Field `CALFACT_S` reader - ADC calibration factor in single-ended mode"] pub type CalfactSR = crate :: FieldReader ;
#[doc = "Field `CALFACT_S` writer - ADC calibration factor in single-ended mode"] pub type CalfactSW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `CALFACT_D` reader - ADC calibration factor in differential mode"] pub type CalfactDR = crate :: FieldReader ;
#[doc = "Field `CALFACT_D` writer - ADC calibration factor in differential mode"] pub type CalfactDW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ; impl R {
#[doc = "Bits 0:6 - ADC calibration factor in single-ended mode"]
#[inline (always)] pub fn calfact_s (& self) -> CalfactSR { CalfactSR :: new ((self . bits & 0x7f) as u8) }
#[doc = "Bits 16:22 - ADC calibration factor in differential mode"]
#[inline (always)] pub fn calfact_d (& self) -> CalfactDR { CalfactDR :: new (((self . bits >> 16) & 0x7f) as u8) } } impl W {
#[doc = "Bits 0:6 - ADC calibration factor in single-ended mode"]
#[inline (always)] pub fn calfact_s (& mut self) -> CalfactSW < '_ , CalfactSpec > { CalfactSW :: new (self , 0) }
#[doc = "Bits 16:22 - ADC calibration factor in differential mode"]
#[inline (always)] pub fn calfact_d (& mut self) -> CalfactDW < '_ , CalfactSpec > { CalfactDW :: new (self , 16) } }
#[doc = "ADC calibration factors register\n\nYou can [`read`](crate::Reg::read) this register and get [`calfact::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`calfact::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CalfactSpec ; impl crate :: RegisterSpec for CalfactSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`calfact::R`](R) reader structure"] impl crate :: Readable for CalfactSpec { }
#[doc = "`write(|w| ..)` method takes [`calfact::W`](W) writer structure"] impl crate :: Writable for CalfactSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CALFACT to value 0"] impl crate :: Resettable for CalfactSpec { } }
#[doc = "CCR (rw) register accessor: ADC common control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr`] module"]
#[doc (alias = "CCR")] pub type Ccr = crate :: Reg < ccr :: CcrSpec > ;
#[doc = "ADC common control register"] pub mod ccr {
#[doc = "Register `CCR` reader"] pub type R = crate :: R < CcrSpec > ;
#[doc = "Register `CCR` writer"] pub type W = crate :: W < CcrSpec > ;
#[doc = "Field `CKMODE` reader - ADC clock mode"] pub type CkmodeR = crate :: FieldReader ;
#[doc = "Field `CKMODE` writer - ADC clock mode"] pub type CkmodeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PRESC` reader - ADC prescaler"] pub type PrescR = crate :: FieldReader ;
#[doc = "Field `PRESC` writer - ADC prescaler"] pub type PrescW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `VREFEN` reader - VREFEN"] pub type VrefenR = crate :: BitReader ;
#[doc = "Field `VREFEN` writer - VREFEN"] pub type VrefenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TSEN` reader - Temperature sensor enable"] pub type TsenR = crate :: BitReader ;
#[doc = "Field `TSEN` writer - Temperature sensor enable"] pub type TsenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `VBATEN` reader - VBAT enable"] pub type VbatenR = crate :: BitReader ;
#[doc = "Field `VBATEN` writer - VBAT enable"] pub type VbatenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 16:17 - ADC clock mode"]
#[inline (always)] pub fn ckmode (& self) -> CkmodeR { CkmodeR :: new (((self . bits >> 16) & 3) as u8) }
#[doc = "Bits 18:21 - ADC prescaler"]
#[inline (always)] pub fn presc (& self) -> PrescR { PrescR :: new (((self . bits >> 18) & 0x0f) as u8) }
#[doc = "Bit 22 - VREFEN"]
#[inline (always)] pub fn vrefen (& self) -> VrefenR { VrefenR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Temperature sensor enable"]
#[inline (always)] pub fn tsen (& self) -> TsenR { TsenR :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - VBAT enable"]
#[inline (always)] pub fn vbaten (& self) -> VbatenR { VbatenR :: new (((self . bits >> 24) & 1) != 0) } } impl W {
#[doc = "Bits 16:17 - ADC clock mode"]
#[inline (always)] pub fn ckmode (& mut self) -> CkmodeW < '_ , CcrSpec > { CkmodeW :: new (self , 16) }
#[doc = "Bits 18:21 - ADC prescaler"]
#[inline (always)] pub fn presc (& mut self) -> PrescW < '_ , CcrSpec > { PrescW :: new (self , 18) }
#[doc = "Bit 22 - VREFEN"]
#[inline (always)] pub fn vrefen (& mut self) -> VrefenW < '_ , CcrSpec > { VrefenW :: new (self , 22) }
#[doc = "Bit 23 - Temperature sensor enable"]
#[inline (always)] pub fn tsen (& mut self) -> TsenW < '_ , CcrSpec > { TsenW :: new (self , 23) }
#[doc = "Bit 24 - VBAT enable"]
#[inline (always)] pub fn vbaten (& mut self) -> VbatenW < '_ , CcrSpec > { VbatenW :: new (self , 24) } }
#[doc = "ADC common control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CcrSpec ; impl crate :: RegisterSpec for CcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr::R`](R) reader structure"] impl crate :: Readable for CcrSpec { }
#[doc = "`write(|w| ..)` method takes [`ccr::W`](W) writer structure"] impl crate :: Writable for CcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR to value 0"] impl crate :: Resettable for CcrSpec { } } }
#[doc = "General-purpose I/Os"] pub type Gpioa = crate :: Periph < gpioa :: RegisterBlock , 0x4800_0000 > ; impl core :: fmt :: Debug for Gpioa { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpioa") . finish () } }
#[doc = "General-purpose I/Os"] pub mod gpioa {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { moder : Moder , otyper : Otyper , ospeedr : Ospeedr , pupdr : Pupdr , idr : Idr , odr : Odr , bsrr : Bsrr , lckr : Lckr , afrl : Afrl , afrh : Afrh , brr : Brr , } impl RegisterBlock {
#[doc = "0x00 - GPIO port mode register"]
#[inline (always)] pub const fn moder (& self) -> & Moder { & self . moder }
#[doc = "0x04 - GPIO port output type register"]
#[inline (always)] pub const fn otyper (& self) -> & Otyper { & self . otyper }
#[doc = "0x08 - GPIO port output speed register"]
#[inline (always)] pub const fn ospeedr (& self) -> & Ospeedr { & self . ospeedr }
#[doc = "0x0c - GPIO port pull-up/pull-down register"]
#[inline (always)] pub const fn pupdr (& self) -> & Pupdr { & self . pupdr }
#[doc = "0x10 - GPIO port input data register"]
#[inline (always)] pub const fn idr (& self) -> & Idr { & self . idr }
#[doc = "0x14 - GPIO port output data register"]
#[inline (always)] pub const fn odr (& self) -> & Odr { & self . odr }
#[doc = "0x18 - GPIO port bit set/reset register"]
#[inline (always)] pub const fn bsrr (& self) -> & Bsrr { & self . bsrr }
#[doc = "0x1c - GPIO port configuration lock register"]
#[inline (always)] pub const fn lckr (& self) -> & Lckr { & self . lckr }
#[doc = "0x20 - GPIO alternate function low register"]
#[inline (always)] pub const fn afrl (& self) -> & Afrl { & self . afrl }
#[doc = "0x24 - GPIO alternate function high register"]
#[inline (always)] pub const fn afrh (& self) -> & Afrh { & self . afrh }
#[doc = "0x28 - port bit reset register"]
#[inline (always)] pub const fn brr (& self) -> & Brr { & self . brr } }
#[doc = "MODER (rw) register accessor: GPIO port mode register\n\nYou can [`read`](crate::Reg::read) this register and get [`moder::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`moder::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@moder`] module"]
#[doc (alias = "MODER")] pub type Moder = crate :: Reg < moder :: ModerSpec > ;
#[doc = "GPIO port mode register"] pub mod moder {
#[doc = "Register `MODER` reader"] pub type R = crate :: R < ModerSpec > ;
#[doc = "Register `MODER` writer"] pub type W = crate :: W < ModerSpec > ;
#[doc = "Field `MODER0` reader - Port x configuration bits (y = 0..15)"] pub type Moder0R = crate :: FieldReader ;
#[doc = "Field `MODER0` writer - Port x configuration bits (y = 0..15)"] pub type Moder0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER1` reader - Port x configuration bits (y = 0..15)"] pub type Moder1R = crate :: FieldReader ;
#[doc = "Field `MODER1` writer - Port x configuration bits (y = 0..15)"] pub type Moder1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER2` reader - Port x configuration bits (y = 0..15)"] pub type Moder2R = crate :: FieldReader ;
#[doc = "Field `MODER2` writer - Port x configuration bits (y = 0..15)"] pub type Moder2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER3` reader - Port x configuration bits (y = 0..15)"] pub type Moder3R = crate :: FieldReader ;
#[doc = "Field `MODER3` writer - Port x configuration bits (y = 0..15)"] pub type Moder3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER4` reader - Port x configuration bits (y = 0..15)"] pub type Moder4R = crate :: FieldReader ;
#[doc = "Field `MODER4` writer - Port x configuration bits (y = 0..15)"] pub type Moder4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER5` reader - Port x configuration bits (y = 0..15)"] pub type Moder5R = crate :: FieldReader ;
#[doc = "Field `MODER5` writer - Port x configuration bits (y = 0..15)"] pub type Moder5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER6` reader - Port x configuration bits (y = 0..15)"] pub type Moder6R = crate :: FieldReader ;
#[doc = "Field `MODER6` writer - Port x configuration bits (y = 0..15)"] pub type Moder6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER7` reader - Port x configuration bits (y = 0..15)"] pub type Moder7R = crate :: FieldReader ;
#[doc = "Field `MODER7` writer - Port x configuration bits (y = 0..15)"] pub type Moder7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER8` reader - Port x configuration bits (y = 0..15)"] pub type Moder8R = crate :: FieldReader ;
#[doc = "Field `MODER8` writer - Port x configuration bits (y = 0..15)"] pub type Moder8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER9` reader - Port x configuration bits (y = 0..15)"] pub type Moder9R = crate :: FieldReader ;
#[doc = "Field `MODER9` writer - Port x configuration bits (y = 0..15)"] pub type Moder9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER10` reader - Port x configuration bits (y = 0..15)"] pub type Moder10R = crate :: FieldReader ;
#[doc = "Field `MODER10` writer - Port x configuration bits (y = 0..15)"] pub type Moder10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER11` reader - Port x configuration bits (y = 0..15)"] pub type Moder11R = crate :: FieldReader ;
#[doc = "Field `MODER11` writer - Port x configuration bits (y = 0..15)"] pub type Moder11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER12` reader - Port x configuration bits (y = 0..15)"] pub type Moder12R = crate :: FieldReader ;
#[doc = "Field `MODER12` writer - Port x configuration bits (y = 0..15)"] pub type Moder12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER13` reader - Port x configuration bits (y = 0..15)"] pub type Moder13R = crate :: FieldReader ;
#[doc = "Field `MODER13` writer - Port x configuration bits (y = 0..15)"] pub type Moder13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER14` reader - Port x configuration bits (y = 0..15)"] pub type Moder14R = crate :: FieldReader ;
#[doc = "Field `MODER14` writer - Port x configuration bits (y = 0..15)"] pub type Moder14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER15` reader - Port x configuration bits (y = 0..15)"] pub type Moder15R = crate :: FieldReader ;
#[doc = "Field `MODER15` writer - Port x configuration bits (y = 0..15)"] pub type Moder15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder0 (& self) -> Moder0R { Moder0R :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder1 (& self) -> Moder1R { Moder1R :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder2 (& self) -> Moder2R { Moder2R :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder3 (& self) -> Moder3R { Moder3R :: new (((self . bits >> 6) & 3) as u8) }
#[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder4 (& self) -> Moder4R { Moder4R :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder5 (& self) -> Moder5R { Moder5R :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder6 (& self) -> Moder6R { Moder6R :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder7 (& self) -> Moder7R { Moder7R :: new (((self . bits >> 14) & 3) as u8) }
#[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder8 (& self) -> Moder8R { Moder8R :: new (((self . bits >> 16) & 3) as u8) }
#[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder9 (& self) -> Moder9R { Moder9R :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder10 (& self) -> Moder10R { Moder10R :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder11 (& self) -> Moder11R { Moder11R :: new (((self . bits >> 22) & 3) as u8) }
#[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder12 (& self) -> Moder12R { Moder12R :: new (((self . bits >> 24) & 3) as u8) }
#[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder13 (& self) -> Moder13R { Moder13R :: new (((self . bits >> 26) & 3) as u8) }
#[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder14 (& self) -> Moder14R { Moder14R :: new (((self . bits >> 28) & 3) as u8) }
#[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder15 (& self) -> Moder15R { Moder15R :: new (((self . bits >> 30) & 3) as u8) } } impl W {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder0 (& mut self) -> Moder0W < '_ , ModerSpec > { Moder0W :: new (self , 0) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder1 (& mut self) -> Moder1W < '_ , ModerSpec > { Moder1W :: new (self , 2) }
#[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder2 (& mut self) -> Moder2W < '_ , ModerSpec > { Moder2W :: new (self , 4) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder3 (& mut self) -> Moder3W < '_ , ModerSpec > { Moder3W :: new (self , 6) }
#[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder4 (& mut self) -> Moder4W < '_ , ModerSpec > { Moder4W :: new (self , 8) }
#[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder5 (& mut self) -> Moder5W < '_ , ModerSpec > { Moder5W :: new (self , 10) }
#[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder6 (& mut self) -> Moder6W < '_ , ModerSpec > { Moder6W :: new (self , 12) }
#[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder7 (& mut self) -> Moder7W < '_ , ModerSpec > { Moder7W :: new (self , 14) }
#[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder8 (& mut self) -> Moder8W < '_ , ModerSpec > { Moder8W :: new (self , 16) }
#[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder9 (& mut self) -> Moder9W < '_ , ModerSpec > { Moder9W :: new (self , 18) }
#[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder10 (& mut self) -> Moder10W < '_ , ModerSpec > { Moder10W :: new (self , 20) }
#[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder11 (& mut self) -> Moder11W < '_ , ModerSpec > { Moder11W :: new (self , 22) }
#[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder12 (& mut self) -> Moder12W < '_ , ModerSpec > { Moder12W :: new (self , 24) }
#[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder13 (& mut self) -> Moder13W < '_ , ModerSpec > { Moder13W :: new (self , 26) }
#[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder14 (& mut self) -> Moder14W < '_ , ModerSpec > { Moder14W :: new (self , 28) }
#[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder15 (& mut self) -> Moder15W < '_ , ModerSpec > { Moder15W :: new (self , 30) } }
#[doc = "GPIO port mode register\n\nYou can [`read`](crate::Reg::read) this register and get [`moder::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`moder::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ModerSpec ; impl crate :: RegisterSpec for ModerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`moder::R`](R) reader structure"] impl crate :: Readable for ModerSpec { }
#[doc = "`write(|w| ..)` method takes [`moder::W`](W) writer structure"] impl crate :: Writable for ModerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MODER to value 0xabff_ffff"] impl crate :: Resettable for ModerSpec { const RESET_VALUE : u32 = 0xabff_ffff ; } }
#[doc = "OTYPER (rw) register accessor: GPIO port output type register\n\nYou can [`read`](crate::Reg::read) this register and get [`otyper::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`otyper::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@otyper`] module"]
#[doc (alias = "OTYPER")] pub type Otyper = crate :: Reg < otyper :: OtyperSpec > ;
#[doc = "GPIO port output type register"] pub mod otyper {
#[doc = "Register `OTYPER` reader"] pub type R = crate :: R < OtyperSpec > ;
#[doc = "Register `OTYPER` writer"] pub type W = crate :: W < OtyperSpec > ;
#[doc = "Field `OT0` reader - Port x configuration bits (y = 0..15)"] pub type Ot0R = crate :: BitReader ;
#[doc = "Field `OT0` writer - Port x configuration bits (y = 0..15)"] pub type Ot0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT1` reader - Port x configuration bits (y = 0..15)"] pub type Ot1R = crate :: BitReader ;
#[doc = "Field `OT1` writer - Port x configuration bits (y = 0..15)"] pub type Ot1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT2` reader - Port x configuration bits (y = 0..15)"] pub type Ot2R = crate :: BitReader ;
#[doc = "Field `OT2` writer - Port x configuration bits (y = 0..15)"] pub type Ot2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT3` reader - Port x configuration bits (y = 0..15)"] pub type Ot3R = crate :: BitReader ;
#[doc = "Field `OT3` writer - Port x configuration bits (y = 0..15)"] pub type Ot3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT4` reader - Port x configuration bits (y = 0..15)"] pub type Ot4R = crate :: BitReader ;
#[doc = "Field `OT4` writer - Port x configuration bits (y = 0..15)"] pub type Ot4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT5` reader - Port x configuration bits (y = 0..15)"] pub type Ot5R = crate :: BitReader ;
#[doc = "Field `OT5` writer - Port x configuration bits (y = 0..15)"] pub type Ot5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT6` reader - Port x configuration bits (y = 0..15)"] pub type Ot6R = crate :: BitReader ;
#[doc = "Field `OT6` writer - Port x configuration bits (y = 0..15)"] pub type Ot6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT7` reader - Port x configuration bits (y = 0..15)"] pub type Ot7R = crate :: BitReader ;
#[doc = "Field `OT7` writer - Port x configuration bits (y = 0..15)"] pub type Ot7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT8` reader - Port x configuration bits (y = 0..15)"] pub type Ot8R = crate :: BitReader ;
#[doc = "Field `OT8` writer - Port x configuration bits (y = 0..15)"] pub type Ot8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT9` reader - Port x configuration bits (y = 0..15)"] pub type Ot9R = crate :: BitReader ;
#[doc = "Field `OT9` writer - Port x configuration bits (y = 0..15)"] pub type Ot9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT10` reader - Port x configuration bits (y = 0..15)"] pub type Ot10R = crate :: BitReader ;
#[doc = "Field `OT10` writer - Port x configuration bits (y = 0..15)"] pub type Ot10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT11` reader - Port x configuration bits (y = 0..15)"] pub type Ot11R = crate :: BitReader ;
#[doc = "Field `OT11` writer - Port x configuration bits (y = 0..15)"] pub type Ot11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT12` reader - Port x configuration bits (y = 0..15)"] pub type Ot12R = crate :: BitReader ;
#[doc = "Field `OT12` writer - Port x configuration bits (y = 0..15)"] pub type Ot12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT13` reader - Port x configuration bits (y = 0..15)"] pub type Ot13R = crate :: BitReader ;
#[doc = "Field `OT13` writer - Port x configuration bits (y = 0..15)"] pub type Ot13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT14` reader - Port x configuration bits (y = 0..15)"] pub type Ot14R = crate :: BitReader ;
#[doc = "Field `OT14` writer - Port x configuration bits (y = 0..15)"] pub type Ot14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT15` reader - Port x configuration bits (y = 0..15)"] pub type Ot15R = crate :: BitReader ;
#[doc = "Field `OT15` writer - Port x configuration bits (y = 0..15)"] pub type Ot15W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot0 (& self) -> Ot0R { Ot0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot1 (& self) -> Ot1R { Ot1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot2 (& self) -> Ot2R { Ot2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot3 (& self) -> Ot3R { Ot3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot4 (& self) -> Ot4R { Ot4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot5 (& self) -> Ot5R { Ot5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot6 (& self) -> Ot6R { Ot6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot7 (& self) -> Ot7R { Ot7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot8 (& self) -> Ot8R { Ot8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot9 (& self) -> Ot9R { Ot9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot10 (& self) -> Ot10R { Ot10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot11 (& self) -> Ot11R { Ot11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot12 (& self) -> Ot12R { Ot12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot13 (& self) -> Ot13R { Ot13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot14 (& self) -> Ot14R { Ot14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot15 (& self) -> Ot15R { Ot15R :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot0 (& mut self) -> Ot0W < '_ , OtyperSpec > { Ot0W :: new (self , 0) }
#[doc = "Bit 1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot1 (& mut self) -> Ot1W < '_ , OtyperSpec > { Ot1W :: new (self , 1) }
#[doc = "Bit 2 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot2 (& mut self) -> Ot2W < '_ , OtyperSpec > { Ot2W :: new (self , 2) }
#[doc = "Bit 3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot3 (& mut self) -> Ot3W < '_ , OtyperSpec > { Ot3W :: new (self , 3) }
#[doc = "Bit 4 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot4 (& mut self) -> Ot4W < '_ , OtyperSpec > { Ot4W :: new (self , 4) }
#[doc = "Bit 5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot5 (& mut self) -> Ot5W < '_ , OtyperSpec > { Ot5W :: new (self , 5) }
#[doc = "Bit 6 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot6 (& mut self) -> Ot6W < '_ , OtyperSpec > { Ot6W :: new (self , 6) }
#[doc = "Bit 7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot7 (& mut self) -> Ot7W < '_ , OtyperSpec > { Ot7W :: new (self , 7) }
#[doc = "Bit 8 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot8 (& mut self) -> Ot8W < '_ , OtyperSpec > { Ot8W :: new (self , 8) }
#[doc = "Bit 9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot9 (& mut self) -> Ot9W < '_ , OtyperSpec > { Ot9W :: new (self , 9) }
#[doc = "Bit 10 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot10 (& mut self) -> Ot10W < '_ , OtyperSpec > { Ot10W :: new (self , 10) }
#[doc = "Bit 11 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot11 (& mut self) -> Ot11W < '_ , OtyperSpec > { Ot11W :: new (self , 11) }
#[doc = "Bit 12 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot12 (& mut self) -> Ot12W < '_ , OtyperSpec > { Ot12W :: new (self , 12) }
#[doc = "Bit 13 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot13 (& mut self) -> Ot13W < '_ , OtyperSpec > { Ot13W :: new (self , 13) }
#[doc = "Bit 14 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot14 (& mut self) -> Ot14W < '_ , OtyperSpec > { Ot14W :: new (self , 14) }
#[doc = "Bit 15 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot15 (& mut self) -> Ot15W < '_ , OtyperSpec > { Ot15W :: new (self , 15) } }
#[doc = "GPIO port output type register\n\nYou can [`read`](crate::Reg::read) this register and get [`otyper::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`otyper::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OtyperSpec ; impl crate :: RegisterSpec for OtyperSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`otyper::R`](R) reader structure"] impl crate :: Readable for OtyperSpec { }
#[doc = "`write(|w| ..)` method takes [`otyper::W`](W) writer structure"] impl crate :: Writable for OtyperSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OTYPER to value 0"] impl crate :: Resettable for OtyperSpec { } }
#[doc = "OSPEEDR (rw) register accessor: GPIO port output speed register\n\nYou can [`read`](crate::Reg::read) this register and get [`ospeedr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ospeedr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ospeedr`] module"]
#[doc (alias = "OSPEEDR")] pub type Ospeedr = crate :: Reg < ospeedr :: OspeedrSpec > ;
#[doc = "GPIO port output speed register"] pub mod ospeedr {
#[doc = "Register `OSPEEDR` reader"] pub type R = crate :: R < OspeedrSpec > ;
#[doc = "Register `OSPEEDR` writer"] pub type W = crate :: W < OspeedrSpec > ;
#[doc = "Field `OSPEEDR0` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr0R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR0` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR1` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr1R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR1` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR2` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr2R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR2` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR3` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr3R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR3` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR4` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr4R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR4` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR5` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr5R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR5` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR6` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr6R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR6` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR7` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr7R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR7` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR8` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr8R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR8` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR9` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr9R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR9` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR10` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr10R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR10` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR11` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr11R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR11` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR12` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr12R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR12` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR13` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr13R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR13` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR14` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr14R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR14` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR15` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr15R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR15` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr0 (& self) -> Ospeedr0R { Ospeedr0R :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr1 (& self) -> Ospeedr1R { Ospeedr1R :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr2 (& self) -> Ospeedr2R { Ospeedr2R :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr3 (& self) -> Ospeedr3R { Ospeedr3R :: new (((self . bits >> 6) & 3) as u8) }
#[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr4 (& self) -> Ospeedr4R { Ospeedr4R :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr5 (& self) -> Ospeedr5R { Ospeedr5R :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr6 (& self) -> Ospeedr6R { Ospeedr6R :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr7 (& self) -> Ospeedr7R { Ospeedr7R :: new (((self . bits >> 14) & 3) as u8) }
#[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr8 (& self) -> Ospeedr8R { Ospeedr8R :: new (((self . bits >> 16) & 3) as u8) }
#[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr9 (& self) -> Ospeedr9R { Ospeedr9R :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr10 (& self) -> Ospeedr10R { Ospeedr10R :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr11 (& self) -> Ospeedr11R { Ospeedr11R :: new (((self . bits >> 22) & 3) as u8) }
#[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr12 (& self) -> Ospeedr12R { Ospeedr12R :: new (((self . bits >> 24) & 3) as u8) }
#[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr13 (& self) -> Ospeedr13R { Ospeedr13R :: new (((self . bits >> 26) & 3) as u8) }
#[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr14 (& self) -> Ospeedr14R { Ospeedr14R :: new (((self . bits >> 28) & 3) as u8) }
#[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr15 (& self) -> Ospeedr15R { Ospeedr15R :: new (((self . bits >> 30) & 3) as u8) } } impl W {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr0 (& mut self) -> Ospeedr0W < '_ , OspeedrSpec > { Ospeedr0W :: new (self , 0) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr1 (& mut self) -> Ospeedr1W < '_ , OspeedrSpec > { Ospeedr1W :: new (self , 2) }
#[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr2 (& mut self) -> Ospeedr2W < '_ , OspeedrSpec > { Ospeedr2W :: new (self , 4) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr3 (& mut self) -> Ospeedr3W < '_ , OspeedrSpec > { Ospeedr3W :: new (self , 6) }
#[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr4 (& mut self) -> Ospeedr4W < '_ , OspeedrSpec > { Ospeedr4W :: new (self , 8) }
#[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr5 (& mut self) -> Ospeedr5W < '_ , OspeedrSpec > { Ospeedr5W :: new (self , 10) }
#[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr6 (& mut self) -> Ospeedr6W < '_ , OspeedrSpec > { Ospeedr6W :: new (self , 12) }
#[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr7 (& mut self) -> Ospeedr7W < '_ , OspeedrSpec > { Ospeedr7W :: new (self , 14) }
#[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr8 (& mut self) -> Ospeedr8W < '_ , OspeedrSpec > { Ospeedr8W :: new (self , 16) }
#[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr9 (& mut self) -> Ospeedr9W < '_ , OspeedrSpec > { Ospeedr9W :: new (self , 18) }
#[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr10 (& mut self) -> Ospeedr10W < '_ , OspeedrSpec > { Ospeedr10W :: new (self , 20) }
#[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr11 (& mut self) -> Ospeedr11W < '_ , OspeedrSpec > { Ospeedr11W :: new (self , 22) }
#[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr12 (& mut self) -> Ospeedr12W < '_ , OspeedrSpec > { Ospeedr12W :: new (self , 24) }
#[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr13 (& mut self) -> Ospeedr13W < '_ , OspeedrSpec > { Ospeedr13W :: new (self , 26) }
#[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr14 (& mut self) -> Ospeedr14W < '_ , OspeedrSpec > { Ospeedr14W :: new (self , 28) }
#[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr15 (& mut self) -> Ospeedr15W < '_ , OspeedrSpec > { Ospeedr15W :: new (self , 30) } }
#[doc = "GPIO port output speed register\n\nYou can [`read`](crate::Reg::read) this register and get [`ospeedr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ospeedr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OspeedrSpec ; impl crate :: RegisterSpec for OspeedrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ospeedr::R`](R) reader structure"] impl crate :: Readable for OspeedrSpec { }
#[doc = "`write(|w| ..)` method takes [`ospeedr::W`](W) writer structure"] impl crate :: Writable for OspeedrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OSPEEDR to value 0x0c00_0000"] impl crate :: Resettable for OspeedrSpec { const RESET_VALUE : u32 = 0x0c00_0000 ; } }
#[doc = "PUPDR (rw) register accessor: GPIO port pull-up/pull-down register\n\nYou can [`read`](crate::Reg::read) this register and get [`pupdr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pupdr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pupdr`] module"]
#[doc (alias = "PUPDR")] pub type Pupdr = crate :: Reg < pupdr :: PupdrSpec > ;
#[doc = "GPIO port pull-up/pull-down register"] pub mod pupdr {
#[doc = "Register `PUPDR` reader"] pub type R = crate :: R < PupdrSpec > ;
#[doc = "Register `PUPDR` writer"] pub type W = crate :: W < PupdrSpec > ;
#[doc = "Field `PUPDR0` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr0R = crate :: FieldReader ;
#[doc = "Field `PUPDR0` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR1` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr1R = crate :: FieldReader ;
#[doc = "Field `PUPDR1` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR2` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr2R = crate :: FieldReader ;
#[doc = "Field `PUPDR2` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR3` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr3R = crate :: FieldReader ;
#[doc = "Field `PUPDR3` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR4` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr4R = crate :: FieldReader ;
#[doc = "Field `PUPDR4` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR5` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr5R = crate :: FieldReader ;
#[doc = "Field `PUPDR5` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR6` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr6R = crate :: FieldReader ;
#[doc = "Field `PUPDR6` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR7` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr7R = crate :: FieldReader ;
#[doc = "Field `PUPDR7` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR8` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr8R = crate :: FieldReader ;
#[doc = "Field `PUPDR8` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR9` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr9R = crate :: FieldReader ;
#[doc = "Field `PUPDR9` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR10` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr10R = crate :: FieldReader ;
#[doc = "Field `PUPDR10` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR11` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr11R = crate :: FieldReader ;
#[doc = "Field `PUPDR11` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR12` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr12R = crate :: FieldReader ;
#[doc = "Field `PUPDR12` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR13` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr13R = crate :: FieldReader ;
#[doc = "Field `PUPDR13` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR14` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr14R = crate :: FieldReader ;
#[doc = "Field `PUPDR14` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR15` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr15R = crate :: FieldReader ;
#[doc = "Field `PUPDR15` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr0 (& self) -> Pupdr0R { Pupdr0R :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr1 (& self) -> Pupdr1R { Pupdr1R :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr2 (& self) -> Pupdr2R { Pupdr2R :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr3 (& self) -> Pupdr3R { Pupdr3R :: new (((self . bits >> 6) & 3) as u8) }
#[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr4 (& self) -> Pupdr4R { Pupdr4R :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr5 (& self) -> Pupdr5R { Pupdr5R :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr6 (& self) -> Pupdr6R { Pupdr6R :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr7 (& self) -> Pupdr7R { Pupdr7R :: new (((self . bits >> 14) & 3) as u8) }
#[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr8 (& self) -> Pupdr8R { Pupdr8R :: new (((self . bits >> 16) & 3) as u8) }
#[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr9 (& self) -> Pupdr9R { Pupdr9R :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr10 (& self) -> Pupdr10R { Pupdr10R :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr11 (& self) -> Pupdr11R { Pupdr11R :: new (((self . bits >> 22) & 3) as u8) }
#[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr12 (& self) -> Pupdr12R { Pupdr12R :: new (((self . bits >> 24) & 3) as u8) }
#[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr13 (& self) -> Pupdr13R { Pupdr13R :: new (((self . bits >> 26) & 3) as u8) }
#[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr14 (& self) -> Pupdr14R { Pupdr14R :: new (((self . bits >> 28) & 3) as u8) }
#[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr15 (& self) -> Pupdr15R { Pupdr15R :: new (((self . bits >> 30) & 3) as u8) } } impl W {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr0 (& mut self) -> Pupdr0W < '_ , PupdrSpec > { Pupdr0W :: new (self , 0) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr1 (& mut self) -> Pupdr1W < '_ , PupdrSpec > { Pupdr1W :: new (self , 2) }
#[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr2 (& mut self) -> Pupdr2W < '_ , PupdrSpec > { Pupdr2W :: new (self , 4) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr3 (& mut self) -> Pupdr3W < '_ , PupdrSpec > { Pupdr3W :: new (self , 6) }
#[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr4 (& mut self) -> Pupdr4W < '_ , PupdrSpec > { Pupdr4W :: new (self , 8) }
#[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr5 (& mut self) -> Pupdr5W < '_ , PupdrSpec > { Pupdr5W :: new (self , 10) }
#[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr6 (& mut self) -> Pupdr6W < '_ , PupdrSpec > { Pupdr6W :: new (self , 12) }
#[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr7 (& mut self) -> Pupdr7W < '_ , PupdrSpec > { Pupdr7W :: new (self , 14) }
#[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr8 (& mut self) -> Pupdr8W < '_ , PupdrSpec > { Pupdr8W :: new (self , 16) }
#[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr9 (& mut self) -> Pupdr9W < '_ , PupdrSpec > { Pupdr9W :: new (self , 18) }
#[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr10 (& mut self) -> Pupdr10W < '_ , PupdrSpec > { Pupdr10W :: new (self , 20) }
#[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr11 (& mut self) -> Pupdr11W < '_ , PupdrSpec > { Pupdr11W :: new (self , 22) }
#[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr12 (& mut self) -> Pupdr12W < '_ , PupdrSpec > { Pupdr12W :: new (self , 24) }
#[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr13 (& mut self) -> Pupdr13W < '_ , PupdrSpec > { Pupdr13W :: new (self , 26) }
#[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr14 (& mut self) -> Pupdr14W < '_ , PupdrSpec > { Pupdr14W :: new (self , 28) }
#[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr15 (& mut self) -> Pupdr15W < '_ , PupdrSpec > { Pupdr15W :: new (self , 30) } }
#[doc = "GPIO port pull-up/pull-down register\n\nYou can [`read`](crate::Reg::read) this register and get [`pupdr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pupdr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PupdrSpec ; impl crate :: RegisterSpec for PupdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pupdr::R`](R) reader structure"] impl crate :: Readable for PupdrSpec { }
#[doc = "`write(|w| ..)` method takes [`pupdr::W`](W) writer structure"] impl crate :: Writable for PupdrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PUPDR to value 0x6400_0000"] impl crate :: Resettable for PupdrSpec { const RESET_VALUE : u32 = 0x6400_0000 ; } }
#[doc = "IDR (r) register accessor: GPIO port input data register\n\nYou can [`read`](crate::Reg::read) this register and get [`idr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@idr`] module"]
#[doc (alias = "IDR")] pub type Idr = crate :: Reg < idr :: IdrSpec > ;
#[doc = "GPIO port input data register"] pub mod idr {
#[doc = "Register `IDR` reader"] pub type R = crate :: R < IdrSpec > ;
#[doc = "Field `IDR0` reader - Port input data (y = 0..15)"] pub type Idr0R = crate :: BitReader ;
#[doc = "Field `IDR1` reader - Port input data (y = 0..15)"] pub type Idr1R = crate :: BitReader ;
#[doc = "Field `IDR2` reader - Port input data (y = 0..15)"] pub type Idr2R = crate :: BitReader ;
#[doc = "Field `IDR3` reader - Port input data (y = 0..15)"] pub type Idr3R = crate :: BitReader ;
#[doc = "Field `IDR4` reader - Port input data (y = 0..15)"] pub type Idr4R = crate :: BitReader ;
#[doc = "Field `IDR5` reader - Port input data (y = 0..15)"] pub type Idr5R = crate :: BitReader ;
#[doc = "Field `IDR6` reader - Port input data (y = 0..15)"] pub type Idr6R = crate :: BitReader ;
#[doc = "Field `IDR7` reader - Port input data (y = 0..15)"] pub type Idr7R = crate :: BitReader ;
#[doc = "Field `IDR8` reader - Port input data (y = 0..15)"] pub type Idr8R = crate :: BitReader ;
#[doc = "Field `IDR9` reader - Port input data (y = 0..15)"] pub type Idr9R = crate :: BitReader ;
#[doc = "Field `IDR10` reader - Port input data (y = 0..15)"] pub type Idr10R = crate :: BitReader ;
#[doc = "Field `IDR11` reader - Port input data (y = 0..15)"] pub type Idr11R = crate :: BitReader ;
#[doc = "Field `IDR12` reader - Port input data (y = 0..15)"] pub type Idr12R = crate :: BitReader ;
#[doc = "Field `IDR13` reader - Port input data (y = 0..15)"] pub type Idr13R = crate :: BitReader ;
#[doc = "Field `IDR14` reader - Port input data (y = 0..15)"] pub type Idr14R = crate :: BitReader ;
#[doc = "Field `IDR15` reader - Port input data (y = 0..15)"] pub type Idr15R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr0 (& self) -> Idr0R { Idr0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr1 (& self) -> Idr1R { Idr1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr2 (& self) -> Idr2R { Idr2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr3 (& self) -> Idr3R { Idr3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr4 (& self) -> Idr4R { Idr4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr5 (& self) -> Idr5R { Idr5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr6 (& self) -> Idr6R { Idr6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr7 (& self) -> Idr7R { Idr7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr8 (& self) -> Idr8R { Idr8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr9 (& self) -> Idr9R { Idr9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr10 (& self) -> Idr10R { Idr10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr11 (& self) -> Idr11R { Idr11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr12 (& self) -> Idr12R { Idr12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr13 (& self) -> Idr13R { Idr13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr14 (& self) -> Idr14R { Idr14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr15 (& self) -> Idr15R { Idr15R :: new (((self . bits >> 15) & 1) != 0) } }
#[doc = "GPIO port input data register\n\nYou can [`read`](crate::Reg::read) this register and get [`idr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IdrSpec ; impl crate :: RegisterSpec for IdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`idr::R`](R) reader structure"] impl crate :: Readable for IdrSpec { }
#[doc = "`reset()` method sets IDR to value 0"] impl crate :: Resettable for IdrSpec { } }
#[doc = "ODR (rw) register accessor: GPIO port output data register\n\nYou can [`read`](crate::Reg::read) this register and get [`odr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`odr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@odr`] module"]
#[doc (alias = "ODR")] pub type Odr = crate :: Reg < odr :: OdrSpec > ;
#[doc = "GPIO port output data register"] pub mod odr {
#[doc = "Register `ODR` reader"] pub type R = crate :: R < OdrSpec > ;
#[doc = "Register `ODR` writer"] pub type W = crate :: W < OdrSpec > ;
#[doc = "Field `ODR0` reader - Port output data (y = 0..15)"] pub type Odr0R = crate :: BitReader ;
#[doc = "Field `ODR0` writer - Port output data (y = 0..15)"] pub type Odr0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR1` reader - Port output data (y = 0..15)"] pub type Odr1R = crate :: BitReader ;
#[doc = "Field `ODR1` writer - Port output data (y = 0..15)"] pub type Odr1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR2` reader - Port output data (y = 0..15)"] pub type Odr2R = crate :: BitReader ;
#[doc = "Field `ODR2` writer - Port output data (y = 0..15)"] pub type Odr2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR3` reader - Port output data (y = 0..15)"] pub type Odr3R = crate :: BitReader ;
#[doc = "Field `ODR3` writer - Port output data (y = 0..15)"] pub type Odr3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR4` reader - Port output data (y = 0..15)"] pub type Odr4R = crate :: BitReader ;
#[doc = "Field `ODR4` writer - Port output data (y = 0..15)"] pub type Odr4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR5` reader - Port output data (y = 0..15)"] pub type Odr5R = crate :: BitReader ;
#[doc = "Field `ODR5` writer - Port output data (y = 0..15)"] pub type Odr5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR6` reader - Port output data (y = 0..15)"] pub type Odr6R = crate :: BitReader ;
#[doc = "Field `ODR6` writer - Port output data (y = 0..15)"] pub type Odr6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR7` reader - Port output data (y = 0..15)"] pub type Odr7R = crate :: BitReader ;
#[doc = "Field `ODR7` writer - Port output data (y = 0..15)"] pub type Odr7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR8` reader - Port output data (y = 0..15)"] pub type Odr8R = crate :: BitReader ;
#[doc = "Field `ODR8` writer - Port output data (y = 0..15)"] pub type Odr8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR9` reader - Port output data (y = 0..15)"] pub type Odr9R = crate :: BitReader ;
#[doc = "Field `ODR9` writer - Port output data (y = 0..15)"] pub type Odr9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR10` reader - Port output data (y = 0..15)"] pub type Odr10R = crate :: BitReader ;
#[doc = "Field `ODR10` writer - Port output data (y = 0..15)"] pub type Odr10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR11` reader - Port output data (y = 0..15)"] pub type Odr11R = crate :: BitReader ;
#[doc = "Field `ODR11` writer - Port output data (y = 0..15)"] pub type Odr11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR12` reader - Port output data (y = 0..15)"] pub type Odr12R = crate :: BitReader ;
#[doc = "Field `ODR12` writer - Port output data (y = 0..15)"] pub type Odr12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR13` reader - Port output data (y = 0..15)"] pub type Odr13R = crate :: BitReader ;
#[doc = "Field `ODR13` writer - Port output data (y = 0..15)"] pub type Odr13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR14` reader - Port output data (y = 0..15)"] pub type Odr14R = crate :: BitReader ;
#[doc = "Field `ODR14` writer - Port output data (y = 0..15)"] pub type Odr14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR15` reader - Port output data (y = 0..15)"] pub type Odr15R = crate :: BitReader ;
#[doc = "Field `ODR15` writer - Port output data (y = 0..15)"] pub type Odr15W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr0 (& self) -> Odr0R { Odr0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr1 (& self) -> Odr1R { Odr1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr2 (& self) -> Odr2R { Odr2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr3 (& self) -> Odr3R { Odr3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr4 (& self) -> Odr4R { Odr4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr5 (& self) -> Odr5R { Odr5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr6 (& self) -> Odr6R { Odr6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr7 (& self) -> Odr7R { Odr7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr8 (& self) -> Odr8R { Odr8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr9 (& self) -> Odr9R { Odr9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr10 (& self) -> Odr10R { Odr10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr11 (& self) -> Odr11R { Odr11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr12 (& self) -> Odr12R { Odr12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr13 (& self) -> Odr13R { Odr13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr14 (& self) -> Odr14R { Odr14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr15 (& self) -> Odr15R { Odr15R :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr0 (& mut self) -> Odr0W < '_ , OdrSpec > { Odr0W :: new (self , 0) }
#[doc = "Bit 1 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr1 (& mut self) -> Odr1W < '_ , OdrSpec > { Odr1W :: new (self , 1) }
#[doc = "Bit 2 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr2 (& mut self) -> Odr2W < '_ , OdrSpec > { Odr2W :: new (self , 2) }
#[doc = "Bit 3 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr3 (& mut self) -> Odr3W < '_ , OdrSpec > { Odr3W :: new (self , 3) }
#[doc = "Bit 4 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr4 (& mut self) -> Odr4W < '_ , OdrSpec > { Odr4W :: new (self , 4) }
#[doc = "Bit 5 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr5 (& mut self) -> Odr5W < '_ , OdrSpec > { Odr5W :: new (self , 5) }
#[doc = "Bit 6 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr6 (& mut self) -> Odr6W < '_ , OdrSpec > { Odr6W :: new (self , 6) }
#[doc = "Bit 7 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr7 (& mut self) -> Odr7W < '_ , OdrSpec > { Odr7W :: new (self , 7) }
#[doc = "Bit 8 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr8 (& mut self) -> Odr8W < '_ , OdrSpec > { Odr8W :: new (self , 8) }
#[doc = "Bit 9 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr9 (& mut self) -> Odr9W < '_ , OdrSpec > { Odr9W :: new (self , 9) }
#[doc = "Bit 10 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr10 (& mut self) -> Odr10W < '_ , OdrSpec > { Odr10W :: new (self , 10) }
#[doc = "Bit 11 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr11 (& mut self) -> Odr11W < '_ , OdrSpec > { Odr11W :: new (self , 11) }
#[doc = "Bit 12 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr12 (& mut self) -> Odr12W < '_ , OdrSpec > { Odr12W :: new (self , 12) }
#[doc = "Bit 13 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr13 (& mut self) -> Odr13W < '_ , OdrSpec > { Odr13W :: new (self , 13) }
#[doc = "Bit 14 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr14 (& mut self) -> Odr14W < '_ , OdrSpec > { Odr14W :: new (self , 14) }
#[doc = "Bit 15 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr15 (& mut self) -> Odr15W < '_ , OdrSpec > { Odr15W :: new (self , 15) } }
#[doc = "GPIO port output data register\n\nYou can [`read`](crate::Reg::read) this register and get [`odr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`odr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OdrSpec ; impl crate :: RegisterSpec for OdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`odr::R`](R) reader structure"] impl crate :: Readable for OdrSpec { }
#[doc = "`write(|w| ..)` method takes [`odr::W`](W) writer structure"] impl crate :: Writable for OdrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ODR to value 0"] impl crate :: Resettable for OdrSpec { } }
#[doc = "BSRR (w) register accessor: GPIO port bit set/reset register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bsrr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bsrr`] module"]
#[doc (alias = "BSRR")] pub type Bsrr = crate :: Reg < bsrr :: BsrrSpec > ;
#[doc = "GPIO port bit set/reset register"] pub mod bsrr {
#[doc = "Register `BSRR` writer"] pub type W = crate :: W < BsrrSpec > ;
#[doc = "Field `BS0` writer - Port x set bit y (y= 0..15)"] pub type Bs0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS1` writer - Port x set bit y (y= 0..15)"] pub type Bs1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS2` writer - Port x set bit y (y= 0..15)"] pub type Bs2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS3` writer - Port x set bit y (y= 0..15)"] pub type Bs3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS4` writer - Port x set bit y (y= 0..15)"] pub type Bs4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS5` writer - Port x set bit y (y= 0..15)"] pub type Bs5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS6` writer - Port x set bit y (y= 0..15)"] pub type Bs6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS7` writer - Port x set bit y (y= 0..15)"] pub type Bs7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS8` writer - Port x set bit y (y= 0..15)"] pub type Bs8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS9` writer - Port x set bit y (y= 0..15)"] pub type Bs9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS10` writer - Port x set bit y (y= 0..15)"] pub type Bs10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS11` writer - Port x set bit y (y= 0..15)"] pub type Bs11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS12` writer - Port x set bit y (y= 0..15)"] pub type Bs12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS13` writer - Port x set bit y (y= 0..15)"] pub type Bs13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS14` writer - Port x set bit y (y= 0..15)"] pub type Bs14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS15` writer - Port x set bit y (y= 0..15)"] pub type Bs15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR0` writer - Port x set bit y (y= 0..15)"] pub type Br0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR1` writer - Port x reset bit y (y = 0..15)"] pub type Br1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR2` writer - Port x reset bit y (y = 0..15)"] pub type Br2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR3` writer - Port x reset bit y (y = 0..15)"] pub type Br3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR4` writer - Port x reset bit y (y = 0..15)"] pub type Br4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR5` writer - Port x reset bit y (y = 0..15)"] pub type Br5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR6` writer - Port x reset bit y (y = 0..15)"] pub type Br6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR7` writer - Port x reset bit y (y = 0..15)"] pub type Br7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR8` writer - Port x reset bit y (y = 0..15)"] pub type Br8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR9` writer - Port x reset bit y (y = 0..15)"] pub type Br9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR10` writer - Port x reset bit y (y = 0..15)"] pub type Br10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR11` writer - Port x reset bit y (y = 0..15)"] pub type Br11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR12` writer - Port x reset bit y (y = 0..15)"] pub type Br12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR13` writer - Port x reset bit y (y = 0..15)"] pub type Br13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR14` writer - Port x reset bit y (y = 0..15)"] pub type Br14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR15` writer - Port x reset bit y (y = 0..15)"] pub type Br15W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs0 (& mut self) -> Bs0W < '_ , BsrrSpec > { Bs0W :: new (self , 0) }
#[doc = "Bit 1 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs1 (& mut self) -> Bs1W < '_ , BsrrSpec > { Bs1W :: new (self , 1) }
#[doc = "Bit 2 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs2 (& mut self) -> Bs2W < '_ , BsrrSpec > { Bs2W :: new (self , 2) }
#[doc = "Bit 3 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs3 (& mut self) -> Bs3W < '_ , BsrrSpec > { Bs3W :: new (self , 3) }
#[doc = "Bit 4 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs4 (& mut self) -> Bs4W < '_ , BsrrSpec > { Bs4W :: new (self , 4) }
#[doc = "Bit 5 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs5 (& mut self) -> Bs5W < '_ , BsrrSpec > { Bs5W :: new (self , 5) }
#[doc = "Bit 6 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs6 (& mut self) -> Bs6W < '_ , BsrrSpec > { Bs6W :: new (self , 6) }
#[doc = "Bit 7 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs7 (& mut self) -> Bs7W < '_ , BsrrSpec > { Bs7W :: new (self , 7) }
#[doc = "Bit 8 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs8 (& mut self) -> Bs8W < '_ , BsrrSpec > { Bs8W :: new (self , 8) }
#[doc = "Bit 9 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs9 (& mut self) -> Bs9W < '_ , BsrrSpec > { Bs9W :: new (self , 9) }
#[doc = "Bit 10 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs10 (& mut self) -> Bs10W < '_ , BsrrSpec > { Bs10W :: new (self , 10) }
#[doc = "Bit 11 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs11 (& mut self) -> Bs11W < '_ , BsrrSpec > { Bs11W :: new (self , 11) }
#[doc = "Bit 12 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs12 (& mut self) -> Bs12W < '_ , BsrrSpec > { Bs12W :: new (self , 12) }
#[doc = "Bit 13 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs13 (& mut self) -> Bs13W < '_ , BsrrSpec > { Bs13W :: new (self , 13) }
#[doc = "Bit 14 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs14 (& mut self) -> Bs14W < '_ , BsrrSpec > { Bs14W :: new (self , 14) }
#[doc = "Bit 15 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs15 (& mut self) -> Bs15W < '_ , BsrrSpec > { Bs15W :: new (self , 15) }
#[doc = "Bit 16 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn br0 (& mut self) -> Br0W < '_ , BsrrSpec > { Br0W :: new (self , 16) }
#[doc = "Bit 17 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br1 (& mut self) -> Br1W < '_ , BsrrSpec > { Br1W :: new (self , 17) }
#[doc = "Bit 18 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br2 (& mut self) -> Br2W < '_ , BsrrSpec > { Br2W :: new (self , 18) }
#[doc = "Bit 19 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br3 (& mut self) -> Br3W < '_ , BsrrSpec > { Br3W :: new (self , 19) }
#[doc = "Bit 20 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br4 (& mut self) -> Br4W < '_ , BsrrSpec > { Br4W :: new (self , 20) }
#[doc = "Bit 21 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br5 (& mut self) -> Br5W < '_ , BsrrSpec > { Br5W :: new (self , 21) }
#[doc = "Bit 22 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br6 (& mut self) -> Br6W < '_ , BsrrSpec > { Br6W :: new (self , 22) }
#[doc = "Bit 23 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br7 (& mut self) -> Br7W < '_ , BsrrSpec > { Br7W :: new (self , 23) }
#[doc = "Bit 24 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br8 (& mut self) -> Br8W < '_ , BsrrSpec > { Br8W :: new (self , 24) }
#[doc = "Bit 25 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br9 (& mut self) -> Br9W < '_ , BsrrSpec > { Br9W :: new (self , 25) }
#[doc = "Bit 26 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br10 (& mut self) -> Br10W < '_ , BsrrSpec > { Br10W :: new (self , 26) }
#[doc = "Bit 27 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br11 (& mut self) -> Br11W < '_ , BsrrSpec > { Br11W :: new (self , 27) }
#[doc = "Bit 28 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br12 (& mut self) -> Br12W < '_ , BsrrSpec > { Br12W :: new (self , 28) }
#[doc = "Bit 29 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br13 (& mut self) -> Br13W < '_ , BsrrSpec > { Br13W :: new (self , 29) }
#[doc = "Bit 30 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br14 (& mut self) -> Br14W < '_ , BsrrSpec > { Br14W :: new (self , 30) }
#[doc = "Bit 31 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br15 (& mut self) -> Br15W < '_ , BsrrSpec > { Br15W :: new (self , 31) } }
#[doc = "GPIO port bit set/reset register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bsrr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BsrrSpec ; impl crate :: RegisterSpec for BsrrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`bsrr::W`](W) writer structure"] impl crate :: Writable for BsrrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BSRR to value 0"] impl crate :: Resettable for BsrrSpec { } }
#[doc = "LCKR (rw) register accessor: GPIO port configuration lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`lckr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lckr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lckr`] module"]
#[doc (alias = "LCKR")] pub type Lckr = crate :: Reg < lckr :: LckrSpec > ;
#[doc = "GPIO port configuration lock register"] pub mod lckr {
#[doc = "Register `LCKR` reader"] pub type R = crate :: R < LckrSpec > ;
#[doc = "Register `LCKR` writer"] pub type W = crate :: W < LckrSpec > ;
#[doc = "Field `LCK0` reader - Port x lock bit y (y= 0..15)"] pub type Lck0R = crate :: BitReader ;
#[doc = "Field `LCK0` writer - Port x lock bit y (y= 0..15)"] pub type Lck0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK1` reader - Port x lock bit y (y= 0..15)"] pub type Lck1R = crate :: BitReader ;
#[doc = "Field `LCK1` writer - Port x lock bit y (y= 0..15)"] pub type Lck1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK2` reader - Port x lock bit y (y= 0..15)"] pub type Lck2R = crate :: BitReader ;
#[doc = "Field `LCK2` writer - Port x lock bit y (y= 0..15)"] pub type Lck2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK3` reader - Port x lock bit y (y= 0..15)"] pub type Lck3R = crate :: BitReader ;
#[doc = "Field `LCK3` writer - Port x lock bit y (y= 0..15)"] pub type Lck3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK4` reader - Port x lock bit y (y= 0..15)"] pub type Lck4R = crate :: BitReader ;
#[doc = "Field `LCK4` writer - Port x lock bit y (y= 0..15)"] pub type Lck4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK5` reader - Port x lock bit y (y= 0..15)"] pub type Lck5R = crate :: BitReader ;
#[doc = "Field `LCK5` writer - Port x lock bit y (y= 0..15)"] pub type Lck5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK6` reader - Port x lock bit y (y= 0..15)"] pub type Lck6R = crate :: BitReader ;
#[doc = "Field `LCK6` writer - Port x lock bit y (y= 0..15)"] pub type Lck6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK7` reader - Port x lock bit y (y= 0..15)"] pub type Lck7R = crate :: BitReader ;
#[doc = "Field `LCK7` writer - Port x lock bit y (y= 0..15)"] pub type Lck7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK8` reader - Port x lock bit y (y= 0..15)"] pub type Lck8R = crate :: BitReader ;
#[doc = "Field `LCK8` writer - Port x lock bit y (y= 0..15)"] pub type Lck8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK9` reader - Port x lock bit y (y= 0..15)"] pub type Lck9R = crate :: BitReader ;
#[doc = "Field `LCK9` writer - Port x lock bit y (y= 0..15)"] pub type Lck9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK10` reader - Port x lock bit y (y= 0..15)"] pub type Lck10R = crate :: BitReader ;
#[doc = "Field `LCK10` writer - Port x lock bit y (y= 0..15)"] pub type Lck10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK11` reader - Port x lock bit y (y= 0..15)"] pub type Lck11R = crate :: BitReader ;
#[doc = "Field `LCK11` writer - Port x lock bit y (y= 0..15)"] pub type Lck11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK12` reader - Port x lock bit y (y= 0..15)"] pub type Lck12R = crate :: BitReader ;
#[doc = "Field `LCK12` writer - Port x lock bit y (y= 0..15)"] pub type Lck12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK13` reader - Port x lock bit y (y= 0..15)"] pub type Lck13R = crate :: BitReader ;
#[doc = "Field `LCK13` writer - Port x lock bit y (y= 0..15)"] pub type Lck13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK14` reader - Port x lock bit y (y= 0..15)"] pub type Lck14R = crate :: BitReader ;
#[doc = "Field `LCK14` writer - Port x lock bit y (y= 0..15)"] pub type Lck14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK15` reader - Port x lock bit y (y= 0..15)"] pub type Lck15R = crate :: BitReader ;
#[doc = "Field `LCK15` writer - Port x lock bit y (y= 0..15)"] pub type Lck15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCKK` reader - Port x lock bit y (y= 0..15)"] pub type LckkR = crate :: BitReader ;
#[doc = "Field `LCKK` writer - Port x lock bit y (y= 0..15)"] pub type LckkW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck0 (& self) -> Lck0R { Lck0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck1 (& self) -> Lck1R { Lck1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck2 (& self) -> Lck2R { Lck2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck3 (& self) -> Lck3R { Lck3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck4 (& self) -> Lck4R { Lck4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck5 (& self) -> Lck5R { Lck5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck6 (& self) -> Lck6R { Lck6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck7 (& self) -> Lck7R { Lck7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck8 (& self) -> Lck8R { Lck8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck9 (& self) -> Lck9R { Lck9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck10 (& self) -> Lck10R { Lck10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck11 (& self) -> Lck11R { Lck11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck12 (& self) -> Lck12R { Lck12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck13 (& self) -> Lck13R { Lck13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck14 (& self) -> Lck14R { Lck14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck15 (& self) -> Lck15R { Lck15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lckk (& self) -> LckkR { LckkR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck0 (& mut self) -> Lck0W < '_ , LckrSpec > { Lck0W :: new (self , 0) }
#[doc = "Bit 1 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck1 (& mut self) -> Lck1W < '_ , LckrSpec > { Lck1W :: new (self , 1) }
#[doc = "Bit 2 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck2 (& mut self) -> Lck2W < '_ , LckrSpec > { Lck2W :: new (self , 2) }
#[doc = "Bit 3 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck3 (& mut self) -> Lck3W < '_ , LckrSpec > { Lck3W :: new (self , 3) }
#[doc = "Bit 4 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck4 (& mut self) -> Lck4W < '_ , LckrSpec > { Lck4W :: new (self , 4) }
#[doc = "Bit 5 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck5 (& mut self) -> Lck5W < '_ , LckrSpec > { Lck5W :: new (self , 5) }
#[doc = "Bit 6 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck6 (& mut self) -> Lck6W < '_ , LckrSpec > { Lck6W :: new (self , 6) }
#[doc = "Bit 7 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck7 (& mut self) -> Lck7W < '_ , LckrSpec > { Lck7W :: new (self , 7) }
#[doc = "Bit 8 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck8 (& mut self) -> Lck8W < '_ , LckrSpec > { Lck8W :: new (self , 8) }
#[doc = "Bit 9 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck9 (& mut self) -> Lck9W < '_ , LckrSpec > { Lck9W :: new (self , 9) }
#[doc = "Bit 10 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck10 (& mut self) -> Lck10W < '_ , LckrSpec > { Lck10W :: new (self , 10) }
#[doc = "Bit 11 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck11 (& mut self) -> Lck11W < '_ , LckrSpec > { Lck11W :: new (self , 11) }
#[doc = "Bit 12 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck12 (& mut self) -> Lck12W < '_ , LckrSpec > { Lck12W :: new (self , 12) }
#[doc = "Bit 13 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck13 (& mut self) -> Lck13W < '_ , LckrSpec > { Lck13W :: new (self , 13) }
#[doc = "Bit 14 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck14 (& mut self) -> Lck14W < '_ , LckrSpec > { Lck14W :: new (self , 14) }
#[doc = "Bit 15 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck15 (& mut self) -> Lck15W < '_ , LckrSpec > { Lck15W :: new (self , 15) }
#[doc = "Bit 16 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lckk (& mut self) -> LckkW < '_ , LckrSpec > { LckkW :: new (self , 16) } }
#[doc = "GPIO port configuration lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`lckr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lckr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct LckrSpec ; impl crate :: RegisterSpec for LckrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`lckr::R`](R) reader structure"] impl crate :: Readable for LckrSpec { }
#[doc = "`write(|w| ..)` method takes [`lckr::W`](W) writer structure"] impl crate :: Writable for LckrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets LCKR to value 0"] impl crate :: Resettable for LckrSpec { } }
#[doc = "AFRL (rw) register accessor: GPIO alternate function low register\n\nYou can [`read`](crate::Reg::read) this register and get [`afrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@afrl`] module"]
#[doc (alias = "AFRL")] pub type Afrl = crate :: Reg < afrl :: AfrlSpec > ;
#[doc = "GPIO alternate function low register"] pub mod afrl {
#[doc = "Register `AFRL` reader"] pub type R = crate :: R < AfrlSpec > ;
#[doc = "Register `AFRL` writer"] pub type W = crate :: W < AfrlSpec > ;
#[doc = "Field `AFSEL0` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel0R = crate :: FieldReader ;
#[doc = "Field `AFSEL0` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL1` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel1R = crate :: FieldReader ;
#[doc = "Field `AFSEL1` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL2` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel2R = crate :: FieldReader ;
#[doc = "Field `AFSEL2` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL3` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel3R = crate :: FieldReader ;
#[doc = "Field `AFSEL3` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL4` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel4R = crate :: FieldReader ;
#[doc = "Field `AFSEL4` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL5` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel5R = crate :: FieldReader ;
#[doc = "Field `AFSEL5` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL6` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel6R = crate :: FieldReader ;
#[doc = "Field `AFSEL6` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL7` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel7R = crate :: FieldReader ;
#[doc = "Field `AFSEL7` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel0 (& self) -> Afsel0R { Afsel0R :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel1 (& self) -> Afsel1R { Afsel1R :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel2 (& self) -> Afsel2R { Afsel2R :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel3 (& self) -> Afsel3R { Afsel3R :: new (((self . bits >> 12) & 0x0f) as u8) }
#[doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel4 (& self) -> Afsel4R { Afsel4R :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel5 (& self) -> Afsel5R { Afsel5R :: new (((self . bits >> 20) & 0x0f) as u8) }
#[doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel6 (& self) -> Afsel6R { Afsel6R :: new (((self . bits >> 24) & 0x0f) as u8) }
#[doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel7 (& self) -> Afsel7R { Afsel7R :: new (((self . bits >> 28) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel0 (& mut self) -> Afsel0W < '_ , AfrlSpec > { Afsel0W :: new (self , 0) }
#[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel1 (& mut self) -> Afsel1W < '_ , AfrlSpec > { Afsel1W :: new (self , 4) }
#[doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel2 (& mut self) -> Afsel2W < '_ , AfrlSpec > { Afsel2W :: new (self , 8) }
#[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel3 (& mut self) -> Afsel3W < '_ , AfrlSpec > { Afsel3W :: new (self , 12) }
#[doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel4 (& mut self) -> Afsel4W < '_ , AfrlSpec > { Afsel4W :: new (self , 16) }
#[doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel5 (& mut self) -> Afsel5W < '_ , AfrlSpec > { Afsel5W :: new (self , 20) }
#[doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel6 (& mut self) -> Afsel6W < '_ , AfrlSpec > { Afsel6W :: new (self , 24) }
#[doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel7 (& mut self) -> Afsel7W < '_ , AfrlSpec > { Afsel7W :: new (self , 28) } }
#[doc = "GPIO alternate function low register\n\nYou can [`read`](crate::Reg::read) this register and get [`afrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AfrlSpec ; impl crate :: RegisterSpec for AfrlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`afrl::R`](R) reader structure"] impl crate :: Readable for AfrlSpec { }
#[doc = "`write(|w| ..)` method takes [`afrl::W`](W) writer structure"] impl crate :: Writable for AfrlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AFRL to value 0"] impl crate :: Resettable for AfrlSpec { } }
#[doc = "AFRH (rw) register accessor: GPIO alternate function high register\n\nYou can [`read`](crate::Reg::read) this register and get [`afrh::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrh::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@afrh`] module"]
#[doc (alias = "AFRH")] pub type Afrh = crate :: Reg < afrh :: AfrhSpec > ;
#[doc = "GPIO alternate function high register"] pub mod afrh {
#[doc = "Register `AFRH` reader"] pub type R = crate :: R < AfrhSpec > ;
#[doc = "Register `AFRH` writer"] pub type W = crate :: W < AfrhSpec > ;
#[doc = "Field `AFSEL8` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel8R = crate :: FieldReader ;
#[doc = "Field `AFSEL8` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL9` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel9R = crate :: FieldReader ;
#[doc = "Field `AFSEL9` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL10` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel10R = crate :: FieldReader ;
#[doc = "Field `AFSEL10` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL11` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel11R = crate :: FieldReader ;
#[doc = "Field `AFSEL11` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL12` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel12R = crate :: FieldReader ;
#[doc = "Field `AFSEL12` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL13` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel13R = crate :: FieldReader ;
#[doc = "Field `AFSEL13` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL14` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel14R = crate :: FieldReader ;
#[doc = "Field `AFSEL14` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL15` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel15R = crate :: FieldReader ;
#[doc = "Field `AFSEL15` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel8 (& self) -> Afsel8R { Afsel8R :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel9 (& self) -> Afsel9R { Afsel9R :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel10 (& self) -> Afsel10R { Afsel10R :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel11 (& self) -> Afsel11R { Afsel11R :: new (((self . bits >> 12) & 0x0f) as u8) }
#[doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel12 (& self) -> Afsel12R { Afsel12R :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel13 (& self) -> Afsel13R { Afsel13R :: new (((self . bits >> 20) & 0x0f) as u8) }
#[doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel14 (& self) -> Afsel14R { Afsel14R :: new (((self . bits >> 24) & 0x0f) as u8) }
#[doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel15 (& self) -> Afsel15R { Afsel15R :: new (((self . bits >> 28) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel8 (& mut self) -> Afsel8W < '_ , AfrhSpec > { Afsel8W :: new (self , 0) }
#[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel9 (& mut self) -> Afsel9W < '_ , AfrhSpec > { Afsel9W :: new (self , 4) }
#[doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel10 (& mut self) -> Afsel10W < '_ , AfrhSpec > { Afsel10W :: new (self , 8) }
#[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel11 (& mut self) -> Afsel11W < '_ , AfrhSpec > { Afsel11W :: new (self , 12) }
#[doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel12 (& mut self) -> Afsel12W < '_ , AfrhSpec > { Afsel12W :: new (self , 16) }
#[doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel13 (& mut self) -> Afsel13W < '_ , AfrhSpec > { Afsel13W :: new (self , 20) }
#[doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel14 (& mut self) -> Afsel14W < '_ , AfrhSpec > { Afsel14W :: new (self , 24) }
#[doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel15 (& mut self) -> Afsel15W < '_ , AfrhSpec > { Afsel15W :: new (self , 28) } }
#[doc = "GPIO alternate function high register\n\nYou can [`read`](crate::Reg::read) this register and get [`afrh::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrh::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AfrhSpec ; impl crate :: RegisterSpec for AfrhSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`afrh::R`](R) reader structure"] impl crate :: Readable for AfrhSpec { }
#[doc = "`write(|w| ..)` method takes [`afrh::W`](W) writer structure"] impl crate :: Writable for AfrhSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AFRH to value 0"] impl crate :: Resettable for AfrhSpec { } }
#[doc = "BRR (w) register accessor: port bit reset register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@brr`] module"]
#[doc (alias = "BRR")] pub type Brr = crate :: Reg < brr :: BrrSpec > ;
#[doc = "port bit reset register"] pub mod brr {
#[doc = "Register `BRR` writer"] pub type W = crate :: W < BrrSpec > ;
#[doc = "Field `BR0` writer - Port Reset bit"] pub type Br0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR1` writer - Port Reset bit"] pub type Br1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR2` writer - Port Reset bit"] pub type Br2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR3` writer - Port Reset bit"] pub type Br3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR4` writer - Port Reset bit"] pub type Br4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR5` writer - Port Reset bit"] pub type Br5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR6` writer - Port Reset bit"] pub type Br6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR7` writer - Port Reset bit"] pub type Br7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR8` writer - Port Reset bit"] pub type Br8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR9` writer - Port Reset bit"] pub type Br9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR10` writer - Port Reset bit"] pub type Br10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR11` writer - Port Reset bit"] pub type Br11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR12` writer - Port Reset bit"] pub type Br12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR13` writer - Port Reset bit"] pub type Br13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR14` writer - Port Reset bit"] pub type Br14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR15` writer - Port Reset bit"] pub type Br15W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Port Reset bit"]
#[inline (always)] pub fn br0 (& mut self) -> Br0W < '_ , BrrSpec > { Br0W :: new (self , 0) }
#[doc = "Bit 1 - Port Reset bit"]
#[inline (always)] pub fn br1 (& mut self) -> Br1W < '_ , BrrSpec > { Br1W :: new (self , 1) }
#[doc = "Bit 2 - Port Reset bit"]
#[inline (always)] pub fn br2 (& mut self) -> Br2W < '_ , BrrSpec > { Br2W :: new (self , 2) }
#[doc = "Bit 3 - Port Reset bit"]
#[inline (always)] pub fn br3 (& mut self) -> Br3W < '_ , BrrSpec > { Br3W :: new (self , 3) }
#[doc = "Bit 4 - Port Reset bit"]
#[inline (always)] pub fn br4 (& mut self) -> Br4W < '_ , BrrSpec > { Br4W :: new (self , 4) }
#[doc = "Bit 5 - Port Reset bit"]
#[inline (always)] pub fn br5 (& mut self) -> Br5W < '_ , BrrSpec > { Br5W :: new (self , 5) }
#[doc = "Bit 6 - Port Reset bit"]
#[inline (always)] pub fn br6 (& mut self) -> Br6W < '_ , BrrSpec > { Br6W :: new (self , 6) }
#[doc = "Bit 7 - Port Reset bit"]
#[inline (always)] pub fn br7 (& mut self) -> Br7W < '_ , BrrSpec > { Br7W :: new (self , 7) }
#[doc = "Bit 8 - Port Reset bit"]
#[inline (always)] pub fn br8 (& mut self) -> Br8W < '_ , BrrSpec > { Br8W :: new (self , 8) }
#[doc = "Bit 9 - Port Reset bit"]
#[inline (always)] pub fn br9 (& mut self) -> Br9W < '_ , BrrSpec > { Br9W :: new (self , 9) }
#[doc = "Bit 10 - Port Reset bit"]
#[inline (always)] pub fn br10 (& mut self) -> Br10W < '_ , BrrSpec > { Br10W :: new (self , 10) }
#[doc = "Bit 11 - Port Reset bit"]
#[inline (always)] pub fn br11 (& mut self) -> Br11W < '_ , BrrSpec > { Br11W :: new (self , 11) }
#[doc = "Bit 12 - Port Reset bit"]
#[inline (always)] pub fn br12 (& mut self) -> Br12W < '_ , BrrSpec > { Br12W :: new (self , 12) }
#[doc = "Bit 13 - Port Reset bit"]
#[inline (always)] pub fn br13 (& mut self) -> Br13W < '_ , BrrSpec > { Br13W :: new (self , 13) }
#[doc = "Bit 14 - Port Reset bit"]
#[inline (always)] pub fn br14 (& mut self) -> Br14W < '_ , BrrSpec > { Br14W :: new (self , 14) }
#[doc = "Bit 15 - Port Reset bit"]
#[inline (always)] pub fn br15 (& mut self) -> Br15W < '_ , BrrSpec > { Br15W :: new (self , 15) } }
#[doc = "port bit reset register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BrrSpec ; impl crate :: RegisterSpec for BrrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`brr::W`](W) writer structure"] impl crate :: Writable for BrrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BRR to value 0"] impl crate :: Resettable for BrrSpec { } } }
#[doc = "General-purpose I/Os"] pub type Gpiob = crate :: Periph < gpiob :: RegisterBlock , 0x4800_0400 > ; impl core :: fmt :: Debug for Gpiob { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpiob") . finish () } }
#[doc = "General-purpose I/Os"] pub mod gpiob {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { moder : Moder , otyper : Otyper , ospeedr : Ospeedr , pupdr : Pupdr , idr : Idr , odr : Odr , bsrr : Bsrr , lckr : Lckr , afrl : Afrl , afrh : Afrh , brr : Brr , } impl RegisterBlock {
#[doc = "0x00 - GPIO port mode register"]
#[inline (always)] pub const fn moder (& self) -> & Moder { & self . moder }
#[doc = "0x04 - GPIO port output type register"]
#[inline (always)] pub const fn otyper (& self) -> & Otyper { & self . otyper }
#[doc = "0x08 - GPIO port output speed register"]
#[inline (always)] pub const fn ospeedr (& self) -> & Ospeedr { & self . ospeedr }
#[doc = "0x0c - GPIO port pull-up/pull-down register"]
#[inline (always)] pub const fn pupdr (& self) -> & Pupdr { & self . pupdr }
#[doc = "0x10 - GPIO port input data register"]
#[inline (always)] pub const fn idr (& self) -> & Idr { & self . idr }
#[doc = "0x14 - GPIO port output data register"]
#[inline (always)] pub const fn odr (& self) -> & Odr { & self . odr }
#[doc = "0x18 - GPIO port bit set/reset register"]
#[inline (always)] pub const fn bsrr (& self) -> & Bsrr { & self . bsrr }
#[doc = "0x1c - GPIO port configuration lock register"]
#[inline (always)] pub const fn lckr (& self) -> & Lckr { & self . lckr }
#[doc = "0x20 - GPIO alternate function low register"]
#[inline (always)] pub const fn afrl (& self) -> & Afrl { & self . afrl }
#[doc = "0x24 - GPIO alternate function high register"]
#[inline (always)] pub const fn afrh (& self) -> & Afrh { & self . afrh }
#[doc = "0x28 - port bit reset register"]
#[inline (always)] pub const fn brr (& self) -> & Brr { & self . brr } }
#[doc = "MODER (rw) register accessor: GPIO port mode register\n\nYou can [`read`](crate::Reg::read) this register and get [`moder::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`moder::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@moder`] module"]
#[doc (alias = "MODER")] pub type Moder = crate :: Reg < moder :: ModerSpec > ;
#[doc = "GPIO port mode register"] pub mod moder {
#[doc = "Register `MODER` reader"] pub type R = crate :: R < ModerSpec > ;
#[doc = "Register `MODER` writer"] pub type W = crate :: W < ModerSpec > ;
#[doc = "Field `MODER0` reader - Port x configuration bits (y = 0..15)"] pub type Moder0R = crate :: FieldReader ;
#[doc = "Field `MODER0` writer - Port x configuration bits (y = 0..15)"] pub type Moder0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER1` reader - Port x configuration bits (y = 0..15)"] pub type Moder1R = crate :: FieldReader ;
#[doc = "Field `MODER1` writer - Port x configuration bits (y = 0..15)"] pub type Moder1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER2` reader - Port x configuration bits (y = 0..15)"] pub type Moder2R = crate :: FieldReader ;
#[doc = "Field `MODER2` writer - Port x configuration bits (y = 0..15)"] pub type Moder2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER3` reader - Port x configuration bits (y = 0..15)"] pub type Moder3R = crate :: FieldReader ;
#[doc = "Field `MODER3` writer - Port x configuration bits (y = 0..15)"] pub type Moder3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER4` reader - Port x configuration bits (y = 0..15)"] pub type Moder4R = crate :: FieldReader ;
#[doc = "Field `MODER4` writer - Port x configuration bits (y = 0..15)"] pub type Moder4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER5` reader - Port x configuration bits (y = 0..15)"] pub type Moder5R = crate :: FieldReader ;
#[doc = "Field `MODER5` writer - Port x configuration bits (y = 0..15)"] pub type Moder5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER6` reader - Port x configuration bits (y = 0..15)"] pub type Moder6R = crate :: FieldReader ;
#[doc = "Field `MODER6` writer - Port x configuration bits (y = 0..15)"] pub type Moder6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER7` reader - Port x configuration bits (y = 0..15)"] pub type Moder7R = crate :: FieldReader ;
#[doc = "Field `MODER7` writer - Port x configuration bits (y = 0..15)"] pub type Moder7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER8` reader - Port x configuration bits (y = 0..15)"] pub type Moder8R = crate :: FieldReader ;
#[doc = "Field `MODER8` writer - Port x configuration bits (y = 0..15)"] pub type Moder8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER9` reader - Port x configuration bits (y = 0..15)"] pub type Moder9R = crate :: FieldReader ;
#[doc = "Field `MODER9` writer - Port x configuration bits (y = 0..15)"] pub type Moder9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER10` reader - Port x configuration bits (y = 0..15)"] pub type Moder10R = crate :: FieldReader ;
#[doc = "Field `MODER10` writer - Port x configuration bits (y = 0..15)"] pub type Moder10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER11` reader - Port x configuration bits (y = 0..15)"] pub type Moder11R = crate :: FieldReader ;
#[doc = "Field `MODER11` writer - Port x configuration bits (y = 0..15)"] pub type Moder11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER12` reader - Port x configuration bits (y = 0..15)"] pub type Moder12R = crate :: FieldReader ;
#[doc = "Field `MODER12` writer - Port x configuration bits (y = 0..15)"] pub type Moder12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER13` reader - Port x configuration bits (y = 0..15)"] pub type Moder13R = crate :: FieldReader ;
#[doc = "Field `MODER13` writer - Port x configuration bits (y = 0..15)"] pub type Moder13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER14` reader - Port x configuration bits (y = 0..15)"] pub type Moder14R = crate :: FieldReader ;
#[doc = "Field `MODER14` writer - Port x configuration bits (y = 0..15)"] pub type Moder14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER15` reader - Port x configuration bits (y = 0..15)"] pub type Moder15R = crate :: FieldReader ;
#[doc = "Field `MODER15` writer - Port x configuration bits (y = 0..15)"] pub type Moder15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder0 (& self) -> Moder0R { Moder0R :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder1 (& self) -> Moder1R { Moder1R :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder2 (& self) -> Moder2R { Moder2R :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder3 (& self) -> Moder3R { Moder3R :: new (((self . bits >> 6) & 3) as u8) }
#[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder4 (& self) -> Moder4R { Moder4R :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder5 (& self) -> Moder5R { Moder5R :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder6 (& self) -> Moder6R { Moder6R :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder7 (& self) -> Moder7R { Moder7R :: new (((self . bits >> 14) & 3) as u8) }
#[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder8 (& self) -> Moder8R { Moder8R :: new (((self . bits >> 16) & 3) as u8) }
#[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder9 (& self) -> Moder9R { Moder9R :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder10 (& self) -> Moder10R { Moder10R :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder11 (& self) -> Moder11R { Moder11R :: new (((self . bits >> 22) & 3) as u8) }
#[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder12 (& self) -> Moder12R { Moder12R :: new (((self . bits >> 24) & 3) as u8) }
#[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder13 (& self) -> Moder13R { Moder13R :: new (((self . bits >> 26) & 3) as u8) }
#[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder14 (& self) -> Moder14R { Moder14R :: new (((self . bits >> 28) & 3) as u8) }
#[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder15 (& self) -> Moder15R { Moder15R :: new (((self . bits >> 30) & 3) as u8) } } impl W {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder0 (& mut self) -> Moder0W < '_ , ModerSpec > { Moder0W :: new (self , 0) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder1 (& mut self) -> Moder1W < '_ , ModerSpec > { Moder1W :: new (self , 2) }
#[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder2 (& mut self) -> Moder2W < '_ , ModerSpec > { Moder2W :: new (self , 4) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder3 (& mut self) -> Moder3W < '_ , ModerSpec > { Moder3W :: new (self , 6) }
#[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder4 (& mut self) -> Moder4W < '_ , ModerSpec > { Moder4W :: new (self , 8) }
#[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder5 (& mut self) -> Moder5W < '_ , ModerSpec > { Moder5W :: new (self , 10) }
#[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder6 (& mut self) -> Moder6W < '_ , ModerSpec > { Moder6W :: new (self , 12) }
#[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder7 (& mut self) -> Moder7W < '_ , ModerSpec > { Moder7W :: new (self , 14) }
#[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder8 (& mut self) -> Moder8W < '_ , ModerSpec > { Moder8W :: new (self , 16) }
#[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder9 (& mut self) -> Moder9W < '_ , ModerSpec > { Moder9W :: new (self , 18) }
#[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder10 (& mut self) -> Moder10W < '_ , ModerSpec > { Moder10W :: new (self , 20) }
#[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder11 (& mut self) -> Moder11W < '_ , ModerSpec > { Moder11W :: new (self , 22) }
#[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder12 (& mut self) -> Moder12W < '_ , ModerSpec > { Moder12W :: new (self , 24) }
#[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder13 (& mut self) -> Moder13W < '_ , ModerSpec > { Moder13W :: new (self , 26) }
#[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder14 (& mut self) -> Moder14W < '_ , ModerSpec > { Moder14W :: new (self , 28) }
#[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder15 (& mut self) -> Moder15W < '_ , ModerSpec > { Moder15W :: new (self , 30) } }
#[doc = "GPIO port mode register\n\nYou can [`read`](crate::Reg::read) this register and get [`moder::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`moder::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ModerSpec ; impl crate :: RegisterSpec for ModerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`moder::R`](R) reader structure"] impl crate :: Readable for ModerSpec { }
#[doc = "`write(|w| ..)` method takes [`moder::W`](W) writer structure"] impl crate :: Writable for ModerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MODER to value 0xffff_febf"] impl crate :: Resettable for ModerSpec { const RESET_VALUE : u32 = 0xffff_febf ; } }
#[doc = "OTYPER (rw) register accessor: GPIO port output type register\n\nYou can [`read`](crate::Reg::read) this register and get [`otyper::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`otyper::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@otyper`] module"]
#[doc (alias = "OTYPER")] pub type Otyper = crate :: Reg < otyper :: OtyperSpec > ;
#[doc = "GPIO port output type register"] pub mod otyper {
#[doc = "Register `OTYPER` reader"] pub type R = crate :: R < OtyperSpec > ;
#[doc = "Register `OTYPER` writer"] pub type W = crate :: W < OtyperSpec > ;
#[doc = "Field `OT0` reader - Port x configuration bits (y = 0..15)"] pub type Ot0R = crate :: BitReader ;
#[doc = "Field `OT0` writer - Port x configuration bits (y = 0..15)"] pub type Ot0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT1` reader - Port x configuration bits (y = 0..15)"] pub type Ot1R = crate :: BitReader ;
#[doc = "Field `OT1` writer - Port x configuration bits (y = 0..15)"] pub type Ot1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT2` reader - Port x configuration bits (y = 0..15)"] pub type Ot2R = crate :: BitReader ;
#[doc = "Field `OT2` writer - Port x configuration bits (y = 0..15)"] pub type Ot2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT3` reader - Port x configuration bits (y = 0..15)"] pub type Ot3R = crate :: BitReader ;
#[doc = "Field `OT3` writer - Port x configuration bits (y = 0..15)"] pub type Ot3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT4` reader - Port x configuration bits (y = 0..15)"] pub type Ot4R = crate :: BitReader ;
#[doc = "Field `OT4` writer - Port x configuration bits (y = 0..15)"] pub type Ot4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT5` reader - Port x configuration bits (y = 0..15)"] pub type Ot5R = crate :: BitReader ;
#[doc = "Field `OT5` writer - Port x configuration bits (y = 0..15)"] pub type Ot5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT6` reader - Port x configuration bits (y = 0..15)"] pub type Ot6R = crate :: BitReader ;
#[doc = "Field `OT6` writer - Port x configuration bits (y = 0..15)"] pub type Ot6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT7` reader - Port x configuration bits (y = 0..15)"] pub type Ot7R = crate :: BitReader ;
#[doc = "Field `OT7` writer - Port x configuration bits (y = 0..15)"] pub type Ot7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT8` reader - Port x configuration bits (y = 0..15)"] pub type Ot8R = crate :: BitReader ;
#[doc = "Field `OT8` writer - Port x configuration bits (y = 0..15)"] pub type Ot8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT9` reader - Port x configuration bits (y = 0..15)"] pub type Ot9R = crate :: BitReader ;
#[doc = "Field `OT9` writer - Port x configuration bits (y = 0..15)"] pub type Ot9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT10` reader - Port x configuration bits (y = 0..15)"] pub type Ot10R = crate :: BitReader ;
#[doc = "Field `OT10` writer - Port x configuration bits (y = 0..15)"] pub type Ot10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT11` reader - Port x configuration bits (y = 0..15)"] pub type Ot11R = crate :: BitReader ;
#[doc = "Field `OT11` writer - Port x configuration bits (y = 0..15)"] pub type Ot11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT12` reader - Port x configuration bits (y = 0..15)"] pub type Ot12R = crate :: BitReader ;
#[doc = "Field `OT12` writer - Port x configuration bits (y = 0..15)"] pub type Ot12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT13` reader - Port x configuration bits (y = 0..15)"] pub type Ot13R = crate :: BitReader ;
#[doc = "Field `OT13` writer - Port x configuration bits (y = 0..15)"] pub type Ot13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT14` reader - Port x configuration bits (y = 0..15)"] pub type Ot14R = crate :: BitReader ;
#[doc = "Field `OT14` writer - Port x configuration bits (y = 0..15)"] pub type Ot14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT15` reader - Port x configuration bits (y = 0..15)"] pub type Ot15R = crate :: BitReader ;
#[doc = "Field `OT15` writer - Port x configuration bits (y = 0..15)"] pub type Ot15W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot0 (& self) -> Ot0R { Ot0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot1 (& self) -> Ot1R { Ot1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot2 (& self) -> Ot2R { Ot2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot3 (& self) -> Ot3R { Ot3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot4 (& self) -> Ot4R { Ot4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot5 (& self) -> Ot5R { Ot5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot6 (& self) -> Ot6R { Ot6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot7 (& self) -> Ot7R { Ot7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot8 (& self) -> Ot8R { Ot8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot9 (& self) -> Ot9R { Ot9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot10 (& self) -> Ot10R { Ot10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot11 (& self) -> Ot11R { Ot11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot12 (& self) -> Ot12R { Ot12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot13 (& self) -> Ot13R { Ot13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot14 (& self) -> Ot14R { Ot14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot15 (& self) -> Ot15R { Ot15R :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot0 (& mut self) -> Ot0W < '_ , OtyperSpec > { Ot0W :: new (self , 0) }
#[doc = "Bit 1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot1 (& mut self) -> Ot1W < '_ , OtyperSpec > { Ot1W :: new (self , 1) }
#[doc = "Bit 2 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot2 (& mut self) -> Ot2W < '_ , OtyperSpec > { Ot2W :: new (self , 2) }
#[doc = "Bit 3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot3 (& mut self) -> Ot3W < '_ , OtyperSpec > { Ot3W :: new (self , 3) }
#[doc = "Bit 4 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot4 (& mut self) -> Ot4W < '_ , OtyperSpec > { Ot4W :: new (self , 4) }
#[doc = "Bit 5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot5 (& mut self) -> Ot5W < '_ , OtyperSpec > { Ot5W :: new (self , 5) }
#[doc = "Bit 6 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot6 (& mut self) -> Ot6W < '_ , OtyperSpec > { Ot6W :: new (self , 6) }
#[doc = "Bit 7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot7 (& mut self) -> Ot7W < '_ , OtyperSpec > { Ot7W :: new (self , 7) }
#[doc = "Bit 8 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot8 (& mut self) -> Ot8W < '_ , OtyperSpec > { Ot8W :: new (self , 8) }
#[doc = "Bit 9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot9 (& mut self) -> Ot9W < '_ , OtyperSpec > { Ot9W :: new (self , 9) }
#[doc = "Bit 10 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot10 (& mut self) -> Ot10W < '_ , OtyperSpec > { Ot10W :: new (self , 10) }
#[doc = "Bit 11 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot11 (& mut self) -> Ot11W < '_ , OtyperSpec > { Ot11W :: new (self , 11) }
#[doc = "Bit 12 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot12 (& mut self) -> Ot12W < '_ , OtyperSpec > { Ot12W :: new (self , 12) }
#[doc = "Bit 13 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot13 (& mut self) -> Ot13W < '_ , OtyperSpec > { Ot13W :: new (self , 13) }
#[doc = "Bit 14 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot14 (& mut self) -> Ot14W < '_ , OtyperSpec > { Ot14W :: new (self , 14) }
#[doc = "Bit 15 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot15 (& mut self) -> Ot15W < '_ , OtyperSpec > { Ot15W :: new (self , 15) } }
#[doc = "GPIO port output type register\n\nYou can [`read`](crate::Reg::read) this register and get [`otyper::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`otyper::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OtyperSpec ; impl crate :: RegisterSpec for OtyperSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`otyper::R`](R) reader structure"] impl crate :: Readable for OtyperSpec { }
#[doc = "`write(|w| ..)` method takes [`otyper::W`](W) writer structure"] impl crate :: Writable for OtyperSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OTYPER to value 0"] impl crate :: Resettable for OtyperSpec { } }
#[doc = "OSPEEDR (rw) register accessor: GPIO port output speed register\n\nYou can [`read`](crate::Reg::read) this register and get [`ospeedr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ospeedr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ospeedr`] module"]
#[doc (alias = "OSPEEDR")] pub type Ospeedr = crate :: Reg < ospeedr :: OspeedrSpec > ;
#[doc = "GPIO port output speed register"] pub mod ospeedr {
#[doc = "Register `OSPEEDR` reader"] pub type R = crate :: R < OspeedrSpec > ;
#[doc = "Register `OSPEEDR` writer"] pub type W = crate :: W < OspeedrSpec > ;
#[doc = "Field `OSPEEDR0` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr0R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR0` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR1` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr1R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR1` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR2` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr2R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR2` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR3` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr3R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR3` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR4` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr4R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR4` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR5` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr5R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR5` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR6` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr6R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR6` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR7` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr7R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR7` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR8` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr8R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR8` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR9` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr9R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR9` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR10` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr10R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR10` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR11` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr11R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR11` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR12` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr12R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR12` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR13` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr13R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR13` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR14` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr14R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR14` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR15` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr15R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR15` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr0 (& self) -> Ospeedr0R { Ospeedr0R :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr1 (& self) -> Ospeedr1R { Ospeedr1R :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr2 (& self) -> Ospeedr2R { Ospeedr2R :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr3 (& self) -> Ospeedr3R { Ospeedr3R :: new (((self . bits >> 6) & 3) as u8) }
#[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr4 (& self) -> Ospeedr4R { Ospeedr4R :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr5 (& self) -> Ospeedr5R { Ospeedr5R :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr6 (& self) -> Ospeedr6R { Ospeedr6R :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr7 (& self) -> Ospeedr7R { Ospeedr7R :: new (((self . bits >> 14) & 3) as u8) }
#[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr8 (& self) -> Ospeedr8R { Ospeedr8R :: new (((self . bits >> 16) & 3) as u8) }
#[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr9 (& self) -> Ospeedr9R { Ospeedr9R :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr10 (& self) -> Ospeedr10R { Ospeedr10R :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr11 (& self) -> Ospeedr11R { Ospeedr11R :: new (((self . bits >> 22) & 3) as u8) }
#[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr12 (& self) -> Ospeedr12R { Ospeedr12R :: new (((self . bits >> 24) & 3) as u8) }
#[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr13 (& self) -> Ospeedr13R { Ospeedr13R :: new (((self . bits >> 26) & 3) as u8) }
#[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr14 (& self) -> Ospeedr14R { Ospeedr14R :: new (((self . bits >> 28) & 3) as u8) }
#[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr15 (& self) -> Ospeedr15R { Ospeedr15R :: new (((self . bits >> 30) & 3) as u8) } } impl W {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr0 (& mut self) -> Ospeedr0W < '_ , OspeedrSpec > { Ospeedr0W :: new (self , 0) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr1 (& mut self) -> Ospeedr1W < '_ , OspeedrSpec > { Ospeedr1W :: new (self , 2) }
#[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr2 (& mut self) -> Ospeedr2W < '_ , OspeedrSpec > { Ospeedr2W :: new (self , 4) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr3 (& mut self) -> Ospeedr3W < '_ , OspeedrSpec > { Ospeedr3W :: new (self , 6) }
#[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr4 (& mut self) -> Ospeedr4W < '_ , OspeedrSpec > { Ospeedr4W :: new (self , 8) }
#[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr5 (& mut self) -> Ospeedr5W < '_ , OspeedrSpec > { Ospeedr5W :: new (self , 10) }
#[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr6 (& mut self) -> Ospeedr6W < '_ , OspeedrSpec > { Ospeedr6W :: new (self , 12) }
#[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr7 (& mut self) -> Ospeedr7W < '_ , OspeedrSpec > { Ospeedr7W :: new (self , 14) }
#[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr8 (& mut self) -> Ospeedr8W < '_ , OspeedrSpec > { Ospeedr8W :: new (self , 16) }
#[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr9 (& mut self) -> Ospeedr9W < '_ , OspeedrSpec > { Ospeedr9W :: new (self , 18) }
#[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr10 (& mut self) -> Ospeedr10W < '_ , OspeedrSpec > { Ospeedr10W :: new (self , 20) }
#[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr11 (& mut self) -> Ospeedr11W < '_ , OspeedrSpec > { Ospeedr11W :: new (self , 22) }
#[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr12 (& mut self) -> Ospeedr12W < '_ , OspeedrSpec > { Ospeedr12W :: new (self , 24) }
#[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr13 (& mut self) -> Ospeedr13W < '_ , OspeedrSpec > { Ospeedr13W :: new (self , 26) }
#[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr14 (& mut self) -> Ospeedr14W < '_ , OspeedrSpec > { Ospeedr14W :: new (self , 28) }
#[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr15 (& mut self) -> Ospeedr15W < '_ , OspeedrSpec > { Ospeedr15W :: new (self , 30) } }
#[doc = "GPIO port output speed register\n\nYou can [`read`](crate::Reg::read) this register and get [`ospeedr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ospeedr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OspeedrSpec ; impl crate :: RegisterSpec for OspeedrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ospeedr::R`](R) reader structure"] impl crate :: Readable for OspeedrSpec { }
#[doc = "`write(|w| ..)` method takes [`ospeedr::W`](W) writer structure"] impl crate :: Writable for OspeedrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OSPEEDR to value 0xc0"] impl crate :: Resettable for OspeedrSpec { const RESET_VALUE : u32 = 0xc0 ; } }
#[doc = "PUPDR (rw) register accessor: GPIO port pull-up/pull-down register\n\nYou can [`read`](crate::Reg::read) this register and get [`pupdr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pupdr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pupdr`] module"]
#[doc (alias = "PUPDR")] pub type Pupdr = crate :: Reg < pupdr :: PupdrSpec > ;
#[doc = "GPIO port pull-up/pull-down register"] pub mod pupdr {
#[doc = "Register `PUPDR` reader"] pub type R = crate :: R < PupdrSpec > ;
#[doc = "Register `PUPDR` writer"] pub type W = crate :: W < PupdrSpec > ;
#[doc = "Field `PUPDR0` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr0R = crate :: FieldReader ;
#[doc = "Field `PUPDR0` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR1` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr1R = crate :: FieldReader ;
#[doc = "Field `PUPDR1` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR2` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr2R = crate :: FieldReader ;
#[doc = "Field `PUPDR2` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR3` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr3R = crate :: FieldReader ;
#[doc = "Field `PUPDR3` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR4` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr4R = crate :: FieldReader ;
#[doc = "Field `PUPDR4` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR5` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr5R = crate :: FieldReader ;
#[doc = "Field `PUPDR5` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR6` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr6R = crate :: FieldReader ;
#[doc = "Field `PUPDR6` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR7` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr7R = crate :: FieldReader ;
#[doc = "Field `PUPDR7` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR8` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr8R = crate :: FieldReader ;
#[doc = "Field `PUPDR8` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR9` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr9R = crate :: FieldReader ;
#[doc = "Field `PUPDR9` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR10` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr10R = crate :: FieldReader ;
#[doc = "Field `PUPDR10` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR11` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr11R = crate :: FieldReader ;
#[doc = "Field `PUPDR11` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR12` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr12R = crate :: FieldReader ;
#[doc = "Field `PUPDR12` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR13` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr13R = crate :: FieldReader ;
#[doc = "Field `PUPDR13` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR14` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr14R = crate :: FieldReader ;
#[doc = "Field `PUPDR14` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR15` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr15R = crate :: FieldReader ;
#[doc = "Field `PUPDR15` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr0 (& self) -> Pupdr0R { Pupdr0R :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr1 (& self) -> Pupdr1R { Pupdr1R :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr2 (& self) -> Pupdr2R { Pupdr2R :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr3 (& self) -> Pupdr3R { Pupdr3R :: new (((self . bits >> 6) & 3) as u8) }
#[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr4 (& self) -> Pupdr4R { Pupdr4R :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr5 (& self) -> Pupdr5R { Pupdr5R :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr6 (& self) -> Pupdr6R { Pupdr6R :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr7 (& self) -> Pupdr7R { Pupdr7R :: new (((self . bits >> 14) & 3) as u8) }
#[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr8 (& self) -> Pupdr8R { Pupdr8R :: new (((self . bits >> 16) & 3) as u8) }
#[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr9 (& self) -> Pupdr9R { Pupdr9R :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr10 (& self) -> Pupdr10R { Pupdr10R :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr11 (& self) -> Pupdr11R { Pupdr11R :: new (((self . bits >> 22) & 3) as u8) }
#[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr12 (& self) -> Pupdr12R { Pupdr12R :: new (((self . bits >> 24) & 3) as u8) }
#[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr13 (& self) -> Pupdr13R { Pupdr13R :: new (((self . bits >> 26) & 3) as u8) }
#[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr14 (& self) -> Pupdr14R { Pupdr14R :: new (((self . bits >> 28) & 3) as u8) }
#[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr15 (& self) -> Pupdr15R { Pupdr15R :: new (((self . bits >> 30) & 3) as u8) } } impl W {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr0 (& mut self) -> Pupdr0W < '_ , PupdrSpec > { Pupdr0W :: new (self , 0) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr1 (& mut self) -> Pupdr1W < '_ , PupdrSpec > { Pupdr1W :: new (self , 2) }
#[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr2 (& mut self) -> Pupdr2W < '_ , PupdrSpec > { Pupdr2W :: new (self , 4) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr3 (& mut self) -> Pupdr3W < '_ , PupdrSpec > { Pupdr3W :: new (self , 6) }
#[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr4 (& mut self) -> Pupdr4W < '_ , PupdrSpec > { Pupdr4W :: new (self , 8) }
#[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr5 (& mut self) -> Pupdr5W < '_ , PupdrSpec > { Pupdr5W :: new (self , 10) }
#[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr6 (& mut self) -> Pupdr6W < '_ , PupdrSpec > { Pupdr6W :: new (self , 12) }
#[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr7 (& mut self) -> Pupdr7W < '_ , PupdrSpec > { Pupdr7W :: new (self , 14) }
#[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr8 (& mut self) -> Pupdr8W < '_ , PupdrSpec > { Pupdr8W :: new (self , 16) }
#[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr9 (& mut self) -> Pupdr9W < '_ , PupdrSpec > { Pupdr9W :: new (self , 18) }
#[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr10 (& mut self) -> Pupdr10W < '_ , PupdrSpec > { Pupdr10W :: new (self , 20) }
#[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr11 (& mut self) -> Pupdr11W < '_ , PupdrSpec > { Pupdr11W :: new (self , 22) }
#[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr12 (& mut self) -> Pupdr12W < '_ , PupdrSpec > { Pupdr12W :: new (self , 24) }
#[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr13 (& mut self) -> Pupdr13W < '_ , PupdrSpec > { Pupdr13W :: new (self , 26) }
#[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr14 (& mut self) -> Pupdr14W < '_ , PupdrSpec > { Pupdr14W :: new (self , 28) }
#[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr15 (& mut self) -> Pupdr15W < '_ , PupdrSpec > { Pupdr15W :: new (self , 30) } }
#[doc = "GPIO port pull-up/pull-down register\n\nYou can [`read`](crate::Reg::read) this register and get [`pupdr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pupdr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PupdrSpec ; impl crate :: RegisterSpec for PupdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pupdr::R`](R) reader structure"] impl crate :: Readable for PupdrSpec { }
#[doc = "`write(|w| ..)` method takes [`pupdr::W`](W) writer structure"] impl crate :: Writable for PupdrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PUPDR to value 0x0100"] impl crate :: Resettable for PupdrSpec { const RESET_VALUE : u32 = 0x0100 ; } }
#[doc = "IDR (r) register accessor: GPIO port input data register\n\nYou can [`read`](crate::Reg::read) this register and get [`idr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@idr`] module"]
#[doc (alias = "IDR")] pub type Idr = crate :: Reg < idr :: IdrSpec > ;
#[doc = "GPIO port input data register"] pub mod idr {
#[doc = "Register `IDR` reader"] pub type R = crate :: R < IdrSpec > ;
#[doc = "Field `IDR0` reader - Port input data (y = 0..15)"] pub type Idr0R = crate :: BitReader ;
#[doc = "Field `IDR1` reader - Port input data (y = 0..15)"] pub type Idr1R = crate :: BitReader ;
#[doc = "Field `IDR2` reader - Port input data (y = 0..15)"] pub type Idr2R = crate :: BitReader ;
#[doc = "Field `IDR3` reader - Port input data (y = 0..15)"] pub type Idr3R = crate :: BitReader ;
#[doc = "Field `IDR4` reader - Port input data (y = 0..15)"] pub type Idr4R = crate :: BitReader ;
#[doc = "Field `IDR5` reader - Port input data (y = 0..15)"] pub type Idr5R = crate :: BitReader ;
#[doc = "Field `IDR6` reader - Port input data (y = 0..15)"] pub type Idr6R = crate :: BitReader ;
#[doc = "Field `IDR7` reader - Port input data (y = 0..15)"] pub type Idr7R = crate :: BitReader ;
#[doc = "Field `IDR8` reader - Port input data (y = 0..15)"] pub type Idr8R = crate :: BitReader ;
#[doc = "Field `IDR9` reader - Port input data (y = 0..15)"] pub type Idr9R = crate :: BitReader ;
#[doc = "Field `IDR10` reader - Port input data (y = 0..15)"] pub type Idr10R = crate :: BitReader ;
#[doc = "Field `IDR11` reader - Port input data (y = 0..15)"] pub type Idr11R = crate :: BitReader ;
#[doc = "Field `IDR12` reader - Port input data (y = 0..15)"] pub type Idr12R = crate :: BitReader ;
#[doc = "Field `IDR13` reader - Port input data (y = 0..15)"] pub type Idr13R = crate :: BitReader ;
#[doc = "Field `IDR14` reader - Port input data (y = 0..15)"] pub type Idr14R = crate :: BitReader ;
#[doc = "Field `IDR15` reader - Port input data (y = 0..15)"] pub type Idr15R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr0 (& self) -> Idr0R { Idr0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr1 (& self) -> Idr1R { Idr1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr2 (& self) -> Idr2R { Idr2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr3 (& self) -> Idr3R { Idr3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr4 (& self) -> Idr4R { Idr4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr5 (& self) -> Idr5R { Idr5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr6 (& self) -> Idr6R { Idr6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr7 (& self) -> Idr7R { Idr7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr8 (& self) -> Idr8R { Idr8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr9 (& self) -> Idr9R { Idr9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr10 (& self) -> Idr10R { Idr10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr11 (& self) -> Idr11R { Idr11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr12 (& self) -> Idr12R { Idr12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr13 (& self) -> Idr13R { Idr13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr14 (& self) -> Idr14R { Idr14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr15 (& self) -> Idr15R { Idr15R :: new (((self . bits >> 15) & 1) != 0) } }
#[doc = "GPIO port input data register\n\nYou can [`read`](crate::Reg::read) this register and get [`idr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IdrSpec ; impl crate :: RegisterSpec for IdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`idr::R`](R) reader structure"] impl crate :: Readable for IdrSpec { }
#[doc = "`reset()` method sets IDR to value 0"] impl crate :: Resettable for IdrSpec { } }
#[doc = "ODR (rw) register accessor: GPIO port output data register\n\nYou can [`read`](crate::Reg::read) this register and get [`odr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`odr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@odr`] module"]
#[doc (alias = "ODR")] pub type Odr = crate :: Reg < odr :: OdrSpec > ;
#[doc = "GPIO port output data register"] pub mod odr {
#[doc = "Register `ODR` reader"] pub type R = crate :: R < OdrSpec > ;
#[doc = "Register `ODR` writer"] pub type W = crate :: W < OdrSpec > ;
#[doc = "Field `ODR0` reader - Port output data (y = 0..15)"] pub type Odr0R = crate :: BitReader ;
#[doc = "Field `ODR0` writer - Port output data (y = 0..15)"] pub type Odr0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR1` reader - Port output data (y = 0..15)"] pub type Odr1R = crate :: BitReader ;
#[doc = "Field `ODR1` writer - Port output data (y = 0..15)"] pub type Odr1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR2` reader - Port output data (y = 0..15)"] pub type Odr2R = crate :: BitReader ;
#[doc = "Field `ODR2` writer - Port output data (y = 0..15)"] pub type Odr2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR3` reader - Port output data (y = 0..15)"] pub type Odr3R = crate :: BitReader ;
#[doc = "Field `ODR3` writer - Port output data (y = 0..15)"] pub type Odr3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR4` reader - Port output data (y = 0..15)"] pub type Odr4R = crate :: BitReader ;
#[doc = "Field `ODR4` writer - Port output data (y = 0..15)"] pub type Odr4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR5` reader - Port output data (y = 0..15)"] pub type Odr5R = crate :: BitReader ;
#[doc = "Field `ODR5` writer - Port output data (y = 0..15)"] pub type Odr5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR6` reader - Port output data (y = 0..15)"] pub type Odr6R = crate :: BitReader ;
#[doc = "Field `ODR6` writer - Port output data (y = 0..15)"] pub type Odr6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR7` reader - Port output data (y = 0..15)"] pub type Odr7R = crate :: BitReader ;
#[doc = "Field `ODR7` writer - Port output data (y = 0..15)"] pub type Odr7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR8` reader - Port output data (y = 0..15)"] pub type Odr8R = crate :: BitReader ;
#[doc = "Field `ODR8` writer - Port output data (y = 0..15)"] pub type Odr8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR9` reader - Port output data (y = 0..15)"] pub type Odr9R = crate :: BitReader ;
#[doc = "Field `ODR9` writer - Port output data (y = 0..15)"] pub type Odr9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR10` reader - Port output data (y = 0..15)"] pub type Odr10R = crate :: BitReader ;
#[doc = "Field `ODR10` writer - Port output data (y = 0..15)"] pub type Odr10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR11` reader - Port output data (y = 0..15)"] pub type Odr11R = crate :: BitReader ;
#[doc = "Field `ODR11` writer - Port output data (y = 0..15)"] pub type Odr11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR12` reader - Port output data (y = 0..15)"] pub type Odr12R = crate :: BitReader ;
#[doc = "Field `ODR12` writer - Port output data (y = 0..15)"] pub type Odr12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR13` reader - Port output data (y = 0..15)"] pub type Odr13R = crate :: BitReader ;
#[doc = "Field `ODR13` writer - Port output data (y = 0..15)"] pub type Odr13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR14` reader - Port output data (y = 0..15)"] pub type Odr14R = crate :: BitReader ;
#[doc = "Field `ODR14` writer - Port output data (y = 0..15)"] pub type Odr14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR15` reader - Port output data (y = 0..15)"] pub type Odr15R = crate :: BitReader ;
#[doc = "Field `ODR15` writer - Port output data (y = 0..15)"] pub type Odr15W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr0 (& self) -> Odr0R { Odr0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr1 (& self) -> Odr1R { Odr1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr2 (& self) -> Odr2R { Odr2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr3 (& self) -> Odr3R { Odr3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr4 (& self) -> Odr4R { Odr4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr5 (& self) -> Odr5R { Odr5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr6 (& self) -> Odr6R { Odr6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr7 (& self) -> Odr7R { Odr7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr8 (& self) -> Odr8R { Odr8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr9 (& self) -> Odr9R { Odr9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr10 (& self) -> Odr10R { Odr10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr11 (& self) -> Odr11R { Odr11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr12 (& self) -> Odr12R { Odr12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr13 (& self) -> Odr13R { Odr13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr14 (& self) -> Odr14R { Odr14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr15 (& self) -> Odr15R { Odr15R :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr0 (& mut self) -> Odr0W < '_ , OdrSpec > { Odr0W :: new (self , 0) }
#[doc = "Bit 1 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr1 (& mut self) -> Odr1W < '_ , OdrSpec > { Odr1W :: new (self , 1) }
#[doc = "Bit 2 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr2 (& mut self) -> Odr2W < '_ , OdrSpec > { Odr2W :: new (self , 2) }
#[doc = "Bit 3 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr3 (& mut self) -> Odr3W < '_ , OdrSpec > { Odr3W :: new (self , 3) }
#[doc = "Bit 4 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr4 (& mut self) -> Odr4W < '_ , OdrSpec > { Odr4W :: new (self , 4) }
#[doc = "Bit 5 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr5 (& mut self) -> Odr5W < '_ , OdrSpec > { Odr5W :: new (self , 5) }
#[doc = "Bit 6 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr6 (& mut self) -> Odr6W < '_ , OdrSpec > { Odr6W :: new (self , 6) }
#[doc = "Bit 7 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr7 (& mut self) -> Odr7W < '_ , OdrSpec > { Odr7W :: new (self , 7) }
#[doc = "Bit 8 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr8 (& mut self) -> Odr8W < '_ , OdrSpec > { Odr8W :: new (self , 8) }
#[doc = "Bit 9 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr9 (& mut self) -> Odr9W < '_ , OdrSpec > { Odr9W :: new (self , 9) }
#[doc = "Bit 10 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr10 (& mut self) -> Odr10W < '_ , OdrSpec > { Odr10W :: new (self , 10) }
#[doc = "Bit 11 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr11 (& mut self) -> Odr11W < '_ , OdrSpec > { Odr11W :: new (self , 11) }
#[doc = "Bit 12 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr12 (& mut self) -> Odr12W < '_ , OdrSpec > { Odr12W :: new (self , 12) }
#[doc = "Bit 13 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr13 (& mut self) -> Odr13W < '_ , OdrSpec > { Odr13W :: new (self , 13) }
#[doc = "Bit 14 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr14 (& mut self) -> Odr14W < '_ , OdrSpec > { Odr14W :: new (self , 14) }
#[doc = "Bit 15 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr15 (& mut self) -> Odr15W < '_ , OdrSpec > { Odr15W :: new (self , 15) } }
#[doc = "GPIO port output data register\n\nYou can [`read`](crate::Reg::read) this register and get [`odr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`odr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OdrSpec ; impl crate :: RegisterSpec for OdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`odr::R`](R) reader structure"] impl crate :: Readable for OdrSpec { }
#[doc = "`write(|w| ..)` method takes [`odr::W`](W) writer structure"] impl crate :: Writable for OdrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ODR to value 0"] impl crate :: Resettable for OdrSpec { } }
#[doc = "BSRR (w) register accessor: GPIO port bit set/reset register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bsrr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bsrr`] module"]
#[doc (alias = "BSRR")] pub type Bsrr = crate :: Reg < bsrr :: BsrrSpec > ;
#[doc = "GPIO port bit set/reset register"] pub mod bsrr {
#[doc = "Register `BSRR` writer"] pub type W = crate :: W < BsrrSpec > ;
#[doc = "Field `BS0` writer - Port x set bit y (y= 0..15)"] pub type Bs0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS1` writer - Port x set bit y (y= 0..15)"] pub type Bs1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS2` writer - Port x set bit y (y= 0..15)"] pub type Bs2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS3` writer - Port x set bit y (y= 0..15)"] pub type Bs3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS4` writer - Port x set bit y (y= 0..15)"] pub type Bs4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS5` writer - Port x set bit y (y= 0..15)"] pub type Bs5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS6` writer - Port x set bit y (y= 0..15)"] pub type Bs6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS7` writer - Port x set bit y (y= 0..15)"] pub type Bs7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS8` writer - Port x set bit y (y= 0..15)"] pub type Bs8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS9` writer - Port x set bit y (y= 0..15)"] pub type Bs9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS10` writer - Port x set bit y (y= 0..15)"] pub type Bs10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS11` writer - Port x set bit y (y= 0..15)"] pub type Bs11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS12` writer - Port x set bit y (y= 0..15)"] pub type Bs12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS13` writer - Port x set bit y (y= 0..15)"] pub type Bs13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS14` writer - Port x set bit y (y= 0..15)"] pub type Bs14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS15` writer - Port x set bit y (y= 0..15)"] pub type Bs15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR0` writer - Port x set bit y (y= 0..15)"] pub type Br0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR1` writer - Port x reset bit y (y = 0..15)"] pub type Br1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR2` writer - Port x reset bit y (y = 0..15)"] pub type Br2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR3` writer - Port x reset bit y (y = 0..15)"] pub type Br3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR4` writer - Port x reset bit y (y = 0..15)"] pub type Br4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR5` writer - Port x reset bit y (y = 0..15)"] pub type Br5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR6` writer - Port x reset bit y (y = 0..15)"] pub type Br6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR7` writer - Port x reset bit y (y = 0..15)"] pub type Br7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR8` writer - Port x reset bit y (y = 0..15)"] pub type Br8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR9` writer - Port x reset bit y (y = 0..15)"] pub type Br9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR10` writer - Port x reset bit y (y = 0..15)"] pub type Br10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR11` writer - Port x reset bit y (y = 0..15)"] pub type Br11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR12` writer - Port x reset bit y (y = 0..15)"] pub type Br12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR13` writer - Port x reset bit y (y = 0..15)"] pub type Br13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR14` writer - Port x reset bit y (y = 0..15)"] pub type Br14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR15` writer - Port x reset bit y (y = 0..15)"] pub type Br15W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs0 (& mut self) -> Bs0W < '_ , BsrrSpec > { Bs0W :: new (self , 0) }
#[doc = "Bit 1 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs1 (& mut self) -> Bs1W < '_ , BsrrSpec > { Bs1W :: new (self , 1) }
#[doc = "Bit 2 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs2 (& mut self) -> Bs2W < '_ , BsrrSpec > { Bs2W :: new (self , 2) }
#[doc = "Bit 3 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs3 (& mut self) -> Bs3W < '_ , BsrrSpec > { Bs3W :: new (self , 3) }
#[doc = "Bit 4 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs4 (& mut self) -> Bs4W < '_ , BsrrSpec > { Bs4W :: new (self , 4) }
#[doc = "Bit 5 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs5 (& mut self) -> Bs5W < '_ , BsrrSpec > { Bs5W :: new (self , 5) }
#[doc = "Bit 6 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs6 (& mut self) -> Bs6W < '_ , BsrrSpec > { Bs6W :: new (self , 6) }
#[doc = "Bit 7 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs7 (& mut self) -> Bs7W < '_ , BsrrSpec > { Bs7W :: new (self , 7) }
#[doc = "Bit 8 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs8 (& mut self) -> Bs8W < '_ , BsrrSpec > { Bs8W :: new (self , 8) }
#[doc = "Bit 9 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs9 (& mut self) -> Bs9W < '_ , BsrrSpec > { Bs9W :: new (self , 9) }
#[doc = "Bit 10 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs10 (& mut self) -> Bs10W < '_ , BsrrSpec > { Bs10W :: new (self , 10) }
#[doc = "Bit 11 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs11 (& mut self) -> Bs11W < '_ , BsrrSpec > { Bs11W :: new (self , 11) }
#[doc = "Bit 12 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs12 (& mut self) -> Bs12W < '_ , BsrrSpec > { Bs12W :: new (self , 12) }
#[doc = "Bit 13 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs13 (& mut self) -> Bs13W < '_ , BsrrSpec > { Bs13W :: new (self , 13) }
#[doc = "Bit 14 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs14 (& mut self) -> Bs14W < '_ , BsrrSpec > { Bs14W :: new (self , 14) }
#[doc = "Bit 15 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs15 (& mut self) -> Bs15W < '_ , BsrrSpec > { Bs15W :: new (self , 15) }
#[doc = "Bit 16 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn br0 (& mut self) -> Br0W < '_ , BsrrSpec > { Br0W :: new (self , 16) }
#[doc = "Bit 17 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br1 (& mut self) -> Br1W < '_ , BsrrSpec > { Br1W :: new (self , 17) }
#[doc = "Bit 18 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br2 (& mut self) -> Br2W < '_ , BsrrSpec > { Br2W :: new (self , 18) }
#[doc = "Bit 19 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br3 (& mut self) -> Br3W < '_ , BsrrSpec > { Br3W :: new (self , 19) }
#[doc = "Bit 20 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br4 (& mut self) -> Br4W < '_ , BsrrSpec > { Br4W :: new (self , 20) }
#[doc = "Bit 21 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br5 (& mut self) -> Br5W < '_ , BsrrSpec > { Br5W :: new (self , 21) }
#[doc = "Bit 22 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br6 (& mut self) -> Br6W < '_ , BsrrSpec > { Br6W :: new (self , 22) }
#[doc = "Bit 23 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br7 (& mut self) -> Br7W < '_ , BsrrSpec > { Br7W :: new (self , 23) }
#[doc = "Bit 24 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br8 (& mut self) -> Br8W < '_ , BsrrSpec > { Br8W :: new (self , 24) }
#[doc = "Bit 25 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br9 (& mut self) -> Br9W < '_ , BsrrSpec > { Br9W :: new (self , 25) }
#[doc = "Bit 26 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br10 (& mut self) -> Br10W < '_ , BsrrSpec > { Br10W :: new (self , 26) }
#[doc = "Bit 27 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br11 (& mut self) -> Br11W < '_ , BsrrSpec > { Br11W :: new (self , 27) }
#[doc = "Bit 28 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br12 (& mut self) -> Br12W < '_ , BsrrSpec > { Br12W :: new (self , 28) }
#[doc = "Bit 29 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br13 (& mut self) -> Br13W < '_ , BsrrSpec > { Br13W :: new (self , 29) }
#[doc = "Bit 30 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br14 (& mut self) -> Br14W < '_ , BsrrSpec > { Br14W :: new (self , 30) }
#[doc = "Bit 31 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br15 (& mut self) -> Br15W < '_ , BsrrSpec > { Br15W :: new (self , 31) } }
#[doc = "GPIO port bit set/reset register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bsrr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BsrrSpec ; impl crate :: RegisterSpec for BsrrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`bsrr::W`](W) writer structure"] impl crate :: Writable for BsrrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BSRR to value 0"] impl crate :: Resettable for BsrrSpec { } }
#[doc = "LCKR (rw) register accessor: GPIO port configuration lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`lckr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lckr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lckr`] module"]
#[doc (alias = "LCKR")] pub type Lckr = crate :: Reg < lckr :: LckrSpec > ;
#[doc = "GPIO port configuration lock register"] pub mod lckr {
#[doc = "Register `LCKR` reader"] pub type R = crate :: R < LckrSpec > ;
#[doc = "Register `LCKR` writer"] pub type W = crate :: W < LckrSpec > ;
#[doc = "Field `LCK0` reader - Port x lock bit y (y= 0..15)"] pub type Lck0R = crate :: BitReader ;
#[doc = "Field `LCK0` writer - Port x lock bit y (y= 0..15)"] pub type Lck0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK1` reader - Port x lock bit y (y= 0..15)"] pub type Lck1R = crate :: BitReader ;
#[doc = "Field `LCK1` writer - Port x lock bit y (y= 0..15)"] pub type Lck1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK2` reader - Port x lock bit y (y= 0..15)"] pub type Lck2R = crate :: BitReader ;
#[doc = "Field `LCK2` writer - Port x lock bit y (y= 0..15)"] pub type Lck2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK3` reader - Port x lock bit y (y= 0..15)"] pub type Lck3R = crate :: BitReader ;
#[doc = "Field `LCK3` writer - Port x lock bit y (y= 0..15)"] pub type Lck3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK4` reader - Port x lock bit y (y= 0..15)"] pub type Lck4R = crate :: BitReader ;
#[doc = "Field `LCK4` writer - Port x lock bit y (y= 0..15)"] pub type Lck4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK5` reader - Port x lock bit y (y= 0..15)"] pub type Lck5R = crate :: BitReader ;
#[doc = "Field `LCK5` writer - Port x lock bit y (y= 0..15)"] pub type Lck5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK6` reader - Port x lock bit y (y= 0..15)"] pub type Lck6R = crate :: BitReader ;
#[doc = "Field `LCK6` writer - Port x lock bit y (y= 0..15)"] pub type Lck6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK7` reader - Port x lock bit y (y= 0..15)"] pub type Lck7R = crate :: BitReader ;
#[doc = "Field `LCK7` writer - Port x lock bit y (y= 0..15)"] pub type Lck7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK8` reader - Port x lock bit y (y= 0..15)"] pub type Lck8R = crate :: BitReader ;
#[doc = "Field `LCK8` writer - Port x lock bit y (y= 0..15)"] pub type Lck8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK9` reader - Port x lock bit y (y= 0..15)"] pub type Lck9R = crate :: BitReader ;
#[doc = "Field `LCK9` writer - Port x lock bit y (y= 0..15)"] pub type Lck9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK10` reader - Port x lock bit y (y= 0..15)"] pub type Lck10R = crate :: BitReader ;
#[doc = "Field `LCK10` writer - Port x lock bit y (y= 0..15)"] pub type Lck10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK11` reader - Port x lock bit y (y= 0..15)"] pub type Lck11R = crate :: BitReader ;
#[doc = "Field `LCK11` writer - Port x lock bit y (y= 0..15)"] pub type Lck11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK12` reader - Port x lock bit y (y= 0..15)"] pub type Lck12R = crate :: BitReader ;
#[doc = "Field `LCK12` writer - Port x lock bit y (y= 0..15)"] pub type Lck12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK13` reader - Port x lock bit y (y= 0..15)"] pub type Lck13R = crate :: BitReader ;
#[doc = "Field `LCK13` writer - Port x lock bit y (y= 0..15)"] pub type Lck13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK14` reader - Port x lock bit y (y= 0..15)"] pub type Lck14R = crate :: BitReader ;
#[doc = "Field `LCK14` writer - Port x lock bit y (y= 0..15)"] pub type Lck14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK15` reader - Port x lock bit y (y= 0..15)"] pub type Lck15R = crate :: BitReader ;
#[doc = "Field `LCK15` writer - Port x lock bit y (y= 0..15)"] pub type Lck15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCKK` reader - Port x lock bit y (y= 0..15)"] pub type LckkR = crate :: BitReader ;
#[doc = "Field `LCKK` writer - Port x lock bit y (y= 0..15)"] pub type LckkW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck0 (& self) -> Lck0R { Lck0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck1 (& self) -> Lck1R { Lck1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck2 (& self) -> Lck2R { Lck2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck3 (& self) -> Lck3R { Lck3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck4 (& self) -> Lck4R { Lck4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck5 (& self) -> Lck5R { Lck5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck6 (& self) -> Lck6R { Lck6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck7 (& self) -> Lck7R { Lck7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck8 (& self) -> Lck8R { Lck8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck9 (& self) -> Lck9R { Lck9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck10 (& self) -> Lck10R { Lck10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck11 (& self) -> Lck11R { Lck11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck12 (& self) -> Lck12R { Lck12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck13 (& self) -> Lck13R { Lck13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck14 (& self) -> Lck14R { Lck14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck15 (& self) -> Lck15R { Lck15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lckk (& self) -> LckkR { LckkR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck0 (& mut self) -> Lck0W < '_ , LckrSpec > { Lck0W :: new (self , 0) }
#[doc = "Bit 1 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck1 (& mut self) -> Lck1W < '_ , LckrSpec > { Lck1W :: new (self , 1) }
#[doc = "Bit 2 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck2 (& mut self) -> Lck2W < '_ , LckrSpec > { Lck2W :: new (self , 2) }
#[doc = "Bit 3 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck3 (& mut self) -> Lck3W < '_ , LckrSpec > { Lck3W :: new (self , 3) }
#[doc = "Bit 4 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck4 (& mut self) -> Lck4W < '_ , LckrSpec > { Lck4W :: new (self , 4) }
#[doc = "Bit 5 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck5 (& mut self) -> Lck5W < '_ , LckrSpec > { Lck5W :: new (self , 5) }
#[doc = "Bit 6 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck6 (& mut self) -> Lck6W < '_ , LckrSpec > { Lck6W :: new (self , 6) }
#[doc = "Bit 7 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck7 (& mut self) -> Lck7W < '_ , LckrSpec > { Lck7W :: new (self , 7) }
#[doc = "Bit 8 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck8 (& mut self) -> Lck8W < '_ , LckrSpec > { Lck8W :: new (self , 8) }
#[doc = "Bit 9 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck9 (& mut self) -> Lck9W < '_ , LckrSpec > { Lck9W :: new (self , 9) }
#[doc = "Bit 10 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck10 (& mut self) -> Lck10W < '_ , LckrSpec > { Lck10W :: new (self , 10) }
#[doc = "Bit 11 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck11 (& mut self) -> Lck11W < '_ , LckrSpec > { Lck11W :: new (self , 11) }
#[doc = "Bit 12 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck12 (& mut self) -> Lck12W < '_ , LckrSpec > { Lck12W :: new (self , 12) }
#[doc = "Bit 13 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck13 (& mut self) -> Lck13W < '_ , LckrSpec > { Lck13W :: new (self , 13) }
#[doc = "Bit 14 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck14 (& mut self) -> Lck14W < '_ , LckrSpec > { Lck14W :: new (self , 14) }
#[doc = "Bit 15 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck15 (& mut self) -> Lck15W < '_ , LckrSpec > { Lck15W :: new (self , 15) }
#[doc = "Bit 16 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lckk (& mut self) -> LckkW < '_ , LckrSpec > { LckkW :: new (self , 16) } }
#[doc = "GPIO port configuration lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`lckr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lckr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct LckrSpec ; impl crate :: RegisterSpec for LckrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`lckr::R`](R) reader structure"] impl crate :: Readable for LckrSpec { }
#[doc = "`write(|w| ..)` method takes [`lckr::W`](W) writer structure"] impl crate :: Writable for LckrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets LCKR to value 0"] impl crate :: Resettable for LckrSpec { } }
#[doc = "AFRL (rw) register accessor: GPIO alternate function low register\n\nYou can [`read`](crate::Reg::read) this register and get [`afrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@afrl`] module"]
#[doc (alias = "AFRL")] pub type Afrl = crate :: Reg < afrl :: AfrlSpec > ;
#[doc = "GPIO alternate function low register"] pub mod afrl {
#[doc = "Register `AFRL` reader"] pub type R = crate :: R < AfrlSpec > ;
#[doc = "Register `AFRL` writer"] pub type W = crate :: W < AfrlSpec > ;
#[doc = "Field `AFSEL0` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel0R = crate :: FieldReader ;
#[doc = "Field `AFSEL0` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL1` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel1R = crate :: FieldReader ;
#[doc = "Field `AFSEL1` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL2` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel2R = crate :: FieldReader ;
#[doc = "Field `AFSEL2` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL3` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel3R = crate :: FieldReader ;
#[doc = "Field `AFSEL3` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL4` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel4R = crate :: FieldReader ;
#[doc = "Field `AFSEL4` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL5` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel5R = crate :: FieldReader ;
#[doc = "Field `AFSEL5` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL6` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel6R = crate :: FieldReader ;
#[doc = "Field `AFSEL6` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL7` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel7R = crate :: FieldReader ;
#[doc = "Field `AFSEL7` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel0 (& self) -> Afsel0R { Afsel0R :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel1 (& self) -> Afsel1R { Afsel1R :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel2 (& self) -> Afsel2R { Afsel2R :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel3 (& self) -> Afsel3R { Afsel3R :: new (((self . bits >> 12) & 0x0f) as u8) }
#[doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel4 (& self) -> Afsel4R { Afsel4R :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel5 (& self) -> Afsel5R { Afsel5R :: new (((self . bits >> 20) & 0x0f) as u8) }
#[doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel6 (& self) -> Afsel6R { Afsel6R :: new (((self . bits >> 24) & 0x0f) as u8) }
#[doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel7 (& self) -> Afsel7R { Afsel7R :: new (((self . bits >> 28) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel0 (& mut self) -> Afsel0W < '_ , AfrlSpec > { Afsel0W :: new (self , 0) }
#[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel1 (& mut self) -> Afsel1W < '_ , AfrlSpec > { Afsel1W :: new (self , 4) }
#[doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel2 (& mut self) -> Afsel2W < '_ , AfrlSpec > { Afsel2W :: new (self , 8) }
#[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel3 (& mut self) -> Afsel3W < '_ , AfrlSpec > { Afsel3W :: new (self , 12) }
#[doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel4 (& mut self) -> Afsel4W < '_ , AfrlSpec > { Afsel4W :: new (self , 16) }
#[doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel5 (& mut self) -> Afsel5W < '_ , AfrlSpec > { Afsel5W :: new (self , 20) }
#[doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel6 (& mut self) -> Afsel6W < '_ , AfrlSpec > { Afsel6W :: new (self , 24) }
#[doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel7 (& mut self) -> Afsel7W < '_ , AfrlSpec > { Afsel7W :: new (self , 28) } }
#[doc = "GPIO alternate function low register\n\nYou can [`read`](crate::Reg::read) this register and get [`afrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AfrlSpec ; impl crate :: RegisterSpec for AfrlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`afrl::R`](R) reader structure"] impl crate :: Readable for AfrlSpec { }
#[doc = "`write(|w| ..)` method takes [`afrl::W`](W) writer structure"] impl crate :: Writable for AfrlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AFRL to value 0"] impl crate :: Resettable for AfrlSpec { } }
#[doc = "AFRH (rw) register accessor: GPIO alternate function high register\n\nYou can [`read`](crate::Reg::read) this register and get [`afrh::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrh::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@afrh`] module"]
#[doc (alias = "AFRH")] pub type Afrh = crate :: Reg < afrh :: AfrhSpec > ;
#[doc = "GPIO alternate function high register"] pub mod afrh {
#[doc = "Register `AFRH` reader"] pub type R = crate :: R < AfrhSpec > ;
#[doc = "Register `AFRH` writer"] pub type W = crate :: W < AfrhSpec > ;
#[doc = "Field `AFSEL8` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel8R = crate :: FieldReader ;
#[doc = "Field `AFSEL8` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL9` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel9R = crate :: FieldReader ;
#[doc = "Field `AFSEL9` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL10` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel10R = crate :: FieldReader ;
#[doc = "Field `AFSEL10` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL11` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel11R = crate :: FieldReader ;
#[doc = "Field `AFSEL11` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL12` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel12R = crate :: FieldReader ;
#[doc = "Field `AFSEL12` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL13` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel13R = crate :: FieldReader ;
#[doc = "Field `AFSEL13` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL14` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel14R = crate :: FieldReader ;
#[doc = "Field `AFSEL14` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL15` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel15R = crate :: FieldReader ;
#[doc = "Field `AFSEL15` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel8 (& self) -> Afsel8R { Afsel8R :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel9 (& self) -> Afsel9R { Afsel9R :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel10 (& self) -> Afsel10R { Afsel10R :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel11 (& self) -> Afsel11R { Afsel11R :: new (((self . bits >> 12) & 0x0f) as u8) }
#[doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel12 (& self) -> Afsel12R { Afsel12R :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel13 (& self) -> Afsel13R { Afsel13R :: new (((self . bits >> 20) & 0x0f) as u8) }
#[doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel14 (& self) -> Afsel14R { Afsel14R :: new (((self . bits >> 24) & 0x0f) as u8) }
#[doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel15 (& self) -> Afsel15R { Afsel15R :: new (((self . bits >> 28) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel8 (& mut self) -> Afsel8W < '_ , AfrhSpec > { Afsel8W :: new (self , 0) }
#[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel9 (& mut self) -> Afsel9W < '_ , AfrhSpec > { Afsel9W :: new (self , 4) }
#[doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel10 (& mut self) -> Afsel10W < '_ , AfrhSpec > { Afsel10W :: new (self , 8) }
#[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel11 (& mut self) -> Afsel11W < '_ , AfrhSpec > { Afsel11W :: new (self , 12) }
#[doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel12 (& mut self) -> Afsel12W < '_ , AfrhSpec > { Afsel12W :: new (self , 16) }
#[doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel13 (& mut self) -> Afsel13W < '_ , AfrhSpec > { Afsel13W :: new (self , 20) }
#[doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel14 (& mut self) -> Afsel14W < '_ , AfrhSpec > { Afsel14W :: new (self , 24) }
#[doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel15 (& mut self) -> Afsel15W < '_ , AfrhSpec > { Afsel15W :: new (self , 28) } }
#[doc = "GPIO alternate function high register\n\nYou can [`read`](crate::Reg::read) this register and get [`afrh::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrh::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AfrhSpec ; impl crate :: RegisterSpec for AfrhSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`afrh::R`](R) reader structure"] impl crate :: Readable for AfrhSpec { }
#[doc = "`write(|w| ..)` method takes [`afrh::W`](W) writer structure"] impl crate :: Writable for AfrhSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AFRH to value 0"] impl crate :: Resettable for AfrhSpec { } }
#[doc = "BRR (w) register accessor: port bit reset register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@brr`] module"]
#[doc (alias = "BRR")] pub type Brr = crate :: Reg < brr :: BrrSpec > ;
#[doc = "port bit reset register"] pub mod brr {
#[doc = "Register `BRR` writer"] pub type W = crate :: W < BrrSpec > ;
#[doc = "Field `BR0` writer - Port Reset bit"] pub type Br0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR1` writer - Port Reset bit"] pub type Br1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR2` writer - Port Reset bit"] pub type Br2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR3` writer - Port Reset bit"] pub type Br3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR4` writer - Port Reset bit"] pub type Br4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR5` writer - Port Reset bit"] pub type Br5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR6` writer - Port Reset bit"] pub type Br6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR7` writer - Port Reset bit"] pub type Br7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR8` writer - Port Reset bit"] pub type Br8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR9` writer - Port Reset bit"] pub type Br9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR10` writer - Port Reset bit"] pub type Br10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR11` writer - Port Reset bit"] pub type Br11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR12` writer - Port Reset bit"] pub type Br12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR13` writer - Port Reset bit"] pub type Br13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR14` writer - Port Reset bit"] pub type Br14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR15` writer - Port Reset bit"] pub type Br15W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Port Reset bit"]
#[inline (always)] pub fn br0 (& mut self) -> Br0W < '_ , BrrSpec > { Br0W :: new (self , 0) }
#[doc = "Bit 1 - Port Reset bit"]
#[inline (always)] pub fn br1 (& mut self) -> Br1W < '_ , BrrSpec > { Br1W :: new (self , 1) }
#[doc = "Bit 2 - Port Reset bit"]
#[inline (always)] pub fn br2 (& mut self) -> Br2W < '_ , BrrSpec > { Br2W :: new (self , 2) }
#[doc = "Bit 3 - Port Reset bit"]
#[inline (always)] pub fn br3 (& mut self) -> Br3W < '_ , BrrSpec > { Br3W :: new (self , 3) }
#[doc = "Bit 4 - Port Reset bit"]
#[inline (always)] pub fn br4 (& mut self) -> Br4W < '_ , BrrSpec > { Br4W :: new (self , 4) }
#[doc = "Bit 5 - Port Reset bit"]
#[inline (always)] pub fn br5 (& mut self) -> Br5W < '_ , BrrSpec > { Br5W :: new (self , 5) }
#[doc = "Bit 6 - Port Reset bit"]
#[inline (always)] pub fn br6 (& mut self) -> Br6W < '_ , BrrSpec > { Br6W :: new (self , 6) }
#[doc = "Bit 7 - Port Reset bit"]
#[inline (always)] pub fn br7 (& mut self) -> Br7W < '_ , BrrSpec > { Br7W :: new (self , 7) }
#[doc = "Bit 8 - Port Reset bit"]
#[inline (always)] pub fn br8 (& mut self) -> Br8W < '_ , BrrSpec > { Br8W :: new (self , 8) }
#[doc = "Bit 9 - Port Reset bit"]
#[inline (always)] pub fn br9 (& mut self) -> Br9W < '_ , BrrSpec > { Br9W :: new (self , 9) }
#[doc = "Bit 10 - Port Reset bit"]
#[inline (always)] pub fn br10 (& mut self) -> Br10W < '_ , BrrSpec > { Br10W :: new (self , 10) }
#[doc = "Bit 11 - Port Reset bit"]
#[inline (always)] pub fn br11 (& mut self) -> Br11W < '_ , BrrSpec > { Br11W :: new (self , 11) }
#[doc = "Bit 12 - Port Reset bit"]
#[inline (always)] pub fn br12 (& mut self) -> Br12W < '_ , BrrSpec > { Br12W :: new (self , 12) }
#[doc = "Bit 13 - Port Reset bit"]
#[inline (always)] pub fn br13 (& mut self) -> Br13W < '_ , BrrSpec > { Br13W :: new (self , 13) }
#[doc = "Bit 14 - Port Reset bit"]
#[inline (always)] pub fn br14 (& mut self) -> Br14W < '_ , BrrSpec > { Br14W :: new (self , 14) }
#[doc = "Bit 15 - Port Reset bit"]
#[inline (always)] pub fn br15 (& mut self) -> Br15W < '_ , BrrSpec > { Br15W :: new (self , 15) } }
#[doc = "port bit reset register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BrrSpec ; impl crate :: RegisterSpec for BrrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`brr::W`](W) writer structure"] impl crate :: Writable for BrrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BRR to value 0"] impl crate :: Resettable for BrrSpec { } } }
#[doc = "General-purpose I/Os"] pub type Gpioc = crate :: Periph < gpioc :: RegisterBlock , 0x4800_0800 > ; impl core :: fmt :: Debug for Gpioc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpioc") . finish () } }
#[doc = "General-purpose I/Os"] pub mod gpioc {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { moder : Moder , otyper : Otyper , ospeedr : Ospeedr , pupdr : Pupdr , idr : Idr , odr : Odr , bsrr : Bsrr , lckr : Lckr , afrl : Afrl , afrh : Afrh , brr : Brr , } impl RegisterBlock {
#[doc = "0x00 - GPIO port mode register"]
#[inline (always)] pub const fn moder (& self) -> & Moder { & self . moder }
#[doc = "0x04 - GPIO port output type register"]
#[inline (always)] pub const fn otyper (& self) -> & Otyper { & self . otyper }
#[doc = "0x08 - GPIO port output speed register"]
#[inline (always)] pub const fn ospeedr (& self) -> & Ospeedr { & self . ospeedr }
#[doc = "0x0c - GPIO port pull-up/pull-down register"]
#[inline (always)] pub const fn pupdr (& self) -> & Pupdr { & self . pupdr }
#[doc = "0x10 - GPIO port input data register"]
#[inline (always)] pub const fn idr (& self) -> & Idr { & self . idr }
#[doc = "0x14 - GPIO port output data register"]
#[inline (always)] pub const fn odr (& self) -> & Odr { & self . odr }
#[doc = "0x18 - GPIO port bit set/reset register"]
#[inline (always)] pub const fn bsrr (& self) -> & Bsrr { & self . bsrr }
#[doc = "0x1c - GPIO port configuration lock register"]
#[inline (always)] pub const fn lckr (& self) -> & Lckr { & self . lckr }
#[doc = "0x20 - GPIO alternate function low register"]
#[inline (always)] pub const fn afrl (& self) -> & Afrl { & self . afrl }
#[doc = "0x24 - GPIO alternate function high register"]
#[inline (always)] pub const fn afrh (& self) -> & Afrh { & self . afrh }
#[doc = "0x28 - port bit reset register"]
#[inline (always)] pub const fn brr (& self) -> & Brr { & self . brr } }
#[doc = "MODER (rw) register accessor: GPIO port mode register\n\nYou can [`read`](crate::Reg::read) this register and get [`moder::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`moder::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@moder`] module"]
#[doc (alias = "MODER")] pub type Moder = crate :: Reg < moder :: ModerSpec > ;
#[doc = "GPIO port mode register"] pub mod moder {
#[doc = "Register `MODER` reader"] pub type R = crate :: R < ModerSpec > ;
#[doc = "Register `MODER` writer"] pub type W = crate :: W < ModerSpec > ;
#[doc = "Field `MODER0` reader - Port x configuration bits (y = 0..15)"] pub type Moder0R = crate :: FieldReader ;
#[doc = "Field `MODER0` writer - Port x configuration bits (y = 0..15)"] pub type Moder0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER1` reader - Port x configuration bits (y = 0..15)"] pub type Moder1R = crate :: FieldReader ;
#[doc = "Field `MODER1` writer - Port x configuration bits (y = 0..15)"] pub type Moder1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER2` reader - Port x configuration bits (y = 0..15)"] pub type Moder2R = crate :: FieldReader ;
#[doc = "Field `MODER2` writer - Port x configuration bits (y = 0..15)"] pub type Moder2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER3` reader - Port x configuration bits (y = 0..15)"] pub type Moder3R = crate :: FieldReader ;
#[doc = "Field `MODER3` writer - Port x configuration bits (y = 0..15)"] pub type Moder3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER4` reader - Port x configuration bits (y = 0..15)"] pub type Moder4R = crate :: FieldReader ;
#[doc = "Field `MODER4` writer - Port x configuration bits (y = 0..15)"] pub type Moder4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER5` reader - Port x configuration bits (y = 0..15)"] pub type Moder5R = crate :: FieldReader ;
#[doc = "Field `MODER5` writer - Port x configuration bits (y = 0..15)"] pub type Moder5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER6` reader - Port x configuration bits (y = 0..15)"] pub type Moder6R = crate :: FieldReader ;
#[doc = "Field `MODER6` writer - Port x configuration bits (y = 0..15)"] pub type Moder6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER7` reader - Port x configuration bits (y = 0..15)"] pub type Moder7R = crate :: FieldReader ;
#[doc = "Field `MODER7` writer - Port x configuration bits (y = 0..15)"] pub type Moder7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER8` reader - Port x configuration bits (y = 0..15)"] pub type Moder8R = crate :: FieldReader ;
#[doc = "Field `MODER8` writer - Port x configuration bits (y = 0..15)"] pub type Moder8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER9` reader - Port x configuration bits (y = 0..15)"] pub type Moder9R = crate :: FieldReader ;
#[doc = "Field `MODER9` writer - Port x configuration bits (y = 0..15)"] pub type Moder9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER10` reader - Port x configuration bits (y = 0..15)"] pub type Moder10R = crate :: FieldReader ;
#[doc = "Field `MODER10` writer - Port x configuration bits (y = 0..15)"] pub type Moder10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER11` reader - Port x configuration bits (y = 0..15)"] pub type Moder11R = crate :: FieldReader ;
#[doc = "Field `MODER11` writer - Port x configuration bits (y = 0..15)"] pub type Moder11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER12` reader - Port x configuration bits (y = 0..15)"] pub type Moder12R = crate :: FieldReader ;
#[doc = "Field `MODER12` writer - Port x configuration bits (y = 0..15)"] pub type Moder12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER13` reader - Port x configuration bits (y = 0..15)"] pub type Moder13R = crate :: FieldReader ;
#[doc = "Field `MODER13` writer - Port x configuration bits (y = 0..15)"] pub type Moder13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER14` reader - Port x configuration bits (y = 0..15)"] pub type Moder14R = crate :: FieldReader ;
#[doc = "Field `MODER14` writer - Port x configuration bits (y = 0..15)"] pub type Moder14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER15` reader - Port x configuration bits (y = 0..15)"] pub type Moder15R = crate :: FieldReader ;
#[doc = "Field `MODER15` writer - Port x configuration bits (y = 0..15)"] pub type Moder15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder0 (& self) -> Moder0R { Moder0R :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder1 (& self) -> Moder1R { Moder1R :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder2 (& self) -> Moder2R { Moder2R :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder3 (& self) -> Moder3R { Moder3R :: new (((self . bits >> 6) & 3) as u8) }
#[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder4 (& self) -> Moder4R { Moder4R :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder5 (& self) -> Moder5R { Moder5R :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder6 (& self) -> Moder6R { Moder6R :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder7 (& self) -> Moder7R { Moder7R :: new (((self . bits >> 14) & 3) as u8) }
#[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder8 (& self) -> Moder8R { Moder8R :: new (((self . bits >> 16) & 3) as u8) }
#[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder9 (& self) -> Moder9R { Moder9R :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder10 (& self) -> Moder10R { Moder10R :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder11 (& self) -> Moder11R { Moder11R :: new (((self . bits >> 22) & 3) as u8) }
#[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder12 (& self) -> Moder12R { Moder12R :: new (((self . bits >> 24) & 3) as u8) }
#[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder13 (& self) -> Moder13R { Moder13R :: new (((self . bits >> 26) & 3) as u8) }
#[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder14 (& self) -> Moder14R { Moder14R :: new (((self . bits >> 28) & 3) as u8) }
#[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder15 (& self) -> Moder15R { Moder15R :: new (((self . bits >> 30) & 3) as u8) } } impl W {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder0 (& mut self) -> Moder0W < '_ , ModerSpec > { Moder0W :: new (self , 0) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder1 (& mut self) -> Moder1W < '_ , ModerSpec > { Moder1W :: new (self , 2) }
#[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder2 (& mut self) -> Moder2W < '_ , ModerSpec > { Moder2W :: new (self , 4) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder3 (& mut self) -> Moder3W < '_ , ModerSpec > { Moder3W :: new (self , 6) }
#[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder4 (& mut self) -> Moder4W < '_ , ModerSpec > { Moder4W :: new (self , 8) }
#[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder5 (& mut self) -> Moder5W < '_ , ModerSpec > { Moder5W :: new (self , 10) }
#[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder6 (& mut self) -> Moder6W < '_ , ModerSpec > { Moder6W :: new (self , 12) }
#[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder7 (& mut self) -> Moder7W < '_ , ModerSpec > { Moder7W :: new (self , 14) }
#[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder8 (& mut self) -> Moder8W < '_ , ModerSpec > { Moder8W :: new (self , 16) }
#[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder9 (& mut self) -> Moder9W < '_ , ModerSpec > { Moder9W :: new (self , 18) }
#[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder10 (& mut self) -> Moder10W < '_ , ModerSpec > { Moder10W :: new (self , 20) }
#[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder11 (& mut self) -> Moder11W < '_ , ModerSpec > { Moder11W :: new (self , 22) }
#[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder12 (& mut self) -> Moder12W < '_ , ModerSpec > { Moder12W :: new (self , 24) }
#[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder13 (& mut self) -> Moder13W < '_ , ModerSpec > { Moder13W :: new (self , 26) }
#[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder14 (& mut self) -> Moder14W < '_ , ModerSpec > { Moder14W :: new (self , 28) }
#[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder15 (& mut self) -> Moder15W < '_ , ModerSpec > { Moder15W :: new (self , 30) } }
#[doc = "GPIO port mode register\n\nYou can [`read`](crate::Reg::read) this register and get [`moder::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`moder::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ModerSpec ; impl crate :: RegisterSpec for ModerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`moder::R`](R) reader structure"] impl crate :: Readable for ModerSpec { }
#[doc = "`write(|w| ..)` method takes [`moder::W`](W) writer structure"] impl crate :: Writable for ModerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MODER to value 0xffff_ffff"] impl crate :: Resettable for ModerSpec { const RESET_VALUE : u32 = 0xffff_ffff ; } }
#[doc = "OTYPER (rw) register accessor: GPIO port output type register\n\nYou can [`read`](crate::Reg::read) this register and get [`otyper::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`otyper::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@otyper`] module"]
#[doc (alias = "OTYPER")] pub type Otyper = crate :: Reg < otyper :: OtyperSpec > ;
#[doc = "GPIO port output type register"] pub mod otyper {
#[doc = "Register `OTYPER` reader"] pub type R = crate :: R < OtyperSpec > ;
#[doc = "Register `OTYPER` writer"] pub type W = crate :: W < OtyperSpec > ;
#[doc = "Field `OT0` reader - Port x configuration bits (y = 0..15)"] pub type Ot0R = crate :: BitReader ;
#[doc = "Field `OT0` writer - Port x configuration bits (y = 0..15)"] pub type Ot0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT1` reader - Port x configuration bits (y = 0..15)"] pub type Ot1R = crate :: BitReader ;
#[doc = "Field `OT1` writer - Port x configuration bits (y = 0..15)"] pub type Ot1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT2` reader - Port x configuration bits (y = 0..15)"] pub type Ot2R = crate :: BitReader ;
#[doc = "Field `OT2` writer - Port x configuration bits (y = 0..15)"] pub type Ot2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT3` reader - Port x configuration bits (y = 0..15)"] pub type Ot3R = crate :: BitReader ;
#[doc = "Field `OT3` writer - Port x configuration bits (y = 0..15)"] pub type Ot3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT4` reader - Port x configuration bits (y = 0..15)"] pub type Ot4R = crate :: BitReader ;
#[doc = "Field `OT4` writer - Port x configuration bits (y = 0..15)"] pub type Ot4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT5` reader - Port x configuration bits (y = 0..15)"] pub type Ot5R = crate :: BitReader ;
#[doc = "Field `OT5` writer - Port x configuration bits (y = 0..15)"] pub type Ot5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT6` reader - Port x configuration bits (y = 0..15)"] pub type Ot6R = crate :: BitReader ;
#[doc = "Field `OT6` writer - Port x configuration bits (y = 0..15)"] pub type Ot6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT7` reader - Port x configuration bits (y = 0..15)"] pub type Ot7R = crate :: BitReader ;
#[doc = "Field `OT7` writer - Port x configuration bits (y = 0..15)"] pub type Ot7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT8` reader - Port x configuration bits (y = 0..15)"] pub type Ot8R = crate :: BitReader ;
#[doc = "Field `OT8` writer - Port x configuration bits (y = 0..15)"] pub type Ot8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT9` reader - Port x configuration bits (y = 0..15)"] pub type Ot9R = crate :: BitReader ;
#[doc = "Field `OT9` writer - Port x configuration bits (y = 0..15)"] pub type Ot9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT10` reader - Port x configuration bits (y = 0..15)"] pub type Ot10R = crate :: BitReader ;
#[doc = "Field `OT10` writer - Port x configuration bits (y = 0..15)"] pub type Ot10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT11` reader - Port x configuration bits (y = 0..15)"] pub type Ot11R = crate :: BitReader ;
#[doc = "Field `OT11` writer - Port x configuration bits (y = 0..15)"] pub type Ot11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT12` reader - Port x configuration bits (y = 0..15)"] pub type Ot12R = crate :: BitReader ;
#[doc = "Field `OT12` writer - Port x configuration bits (y = 0..15)"] pub type Ot12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT13` reader - Port x configuration bits (y = 0..15)"] pub type Ot13R = crate :: BitReader ;
#[doc = "Field `OT13` writer - Port x configuration bits (y = 0..15)"] pub type Ot13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT14` reader - Port x configuration bits (y = 0..15)"] pub type Ot14R = crate :: BitReader ;
#[doc = "Field `OT14` writer - Port x configuration bits (y = 0..15)"] pub type Ot14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT15` reader - Port x configuration bits (y = 0..15)"] pub type Ot15R = crate :: BitReader ;
#[doc = "Field `OT15` writer - Port x configuration bits (y = 0..15)"] pub type Ot15W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot0 (& self) -> Ot0R { Ot0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot1 (& self) -> Ot1R { Ot1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot2 (& self) -> Ot2R { Ot2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot3 (& self) -> Ot3R { Ot3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot4 (& self) -> Ot4R { Ot4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot5 (& self) -> Ot5R { Ot5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot6 (& self) -> Ot6R { Ot6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot7 (& self) -> Ot7R { Ot7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot8 (& self) -> Ot8R { Ot8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot9 (& self) -> Ot9R { Ot9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot10 (& self) -> Ot10R { Ot10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot11 (& self) -> Ot11R { Ot11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot12 (& self) -> Ot12R { Ot12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot13 (& self) -> Ot13R { Ot13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot14 (& self) -> Ot14R { Ot14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot15 (& self) -> Ot15R { Ot15R :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot0 (& mut self) -> Ot0W < '_ , OtyperSpec > { Ot0W :: new (self , 0) }
#[doc = "Bit 1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot1 (& mut self) -> Ot1W < '_ , OtyperSpec > { Ot1W :: new (self , 1) }
#[doc = "Bit 2 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot2 (& mut self) -> Ot2W < '_ , OtyperSpec > { Ot2W :: new (self , 2) }
#[doc = "Bit 3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot3 (& mut self) -> Ot3W < '_ , OtyperSpec > { Ot3W :: new (self , 3) }
#[doc = "Bit 4 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot4 (& mut self) -> Ot4W < '_ , OtyperSpec > { Ot4W :: new (self , 4) }
#[doc = "Bit 5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot5 (& mut self) -> Ot5W < '_ , OtyperSpec > { Ot5W :: new (self , 5) }
#[doc = "Bit 6 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot6 (& mut self) -> Ot6W < '_ , OtyperSpec > { Ot6W :: new (self , 6) }
#[doc = "Bit 7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot7 (& mut self) -> Ot7W < '_ , OtyperSpec > { Ot7W :: new (self , 7) }
#[doc = "Bit 8 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot8 (& mut self) -> Ot8W < '_ , OtyperSpec > { Ot8W :: new (self , 8) }
#[doc = "Bit 9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot9 (& mut self) -> Ot9W < '_ , OtyperSpec > { Ot9W :: new (self , 9) }
#[doc = "Bit 10 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot10 (& mut self) -> Ot10W < '_ , OtyperSpec > { Ot10W :: new (self , 10) }
#[doc = "Bit 11 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot11 (& mut self) -> Ot11W < '_ , OtyperSpec > { Ot11W :: new (self , 11) }
#[doc = "Bit 12 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot12 (& mut self) -> Ot12W < '_ , OtyperSpec > { Ot12W :: new (self , 12) }
#[doc = "Bit 13 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot13 (& mut self) -> Ot13W < '_ , OtyperSpec > { Ot13W :: new (self , 13) }
#[doc = "Bit 14 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot14 (& mut self) -> Ot14W < '_ , OtyperSpec > { Ot14W :: new (self , 14) }
#[doc = "Bit 15 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot15 (& mut self) -> Ot15W < '_ , OtyperSpec > { Ot15W :: new (self , 15) } }
#[doc = "GPIO port output type register\n\nYou can [`read`](crate::Reg::read) this register and get [`otyper::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`otyper::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OtyperSpec ; impl crate :: RegisterSpec for OtyperSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`otyper::R`](R) reader structure"] impl crate :: Readable for OtyperSpec { }
#[doc = "`write(|w| ..)` method takes [`otyper::W`](W) writer structure"] impl crate :: Writable for OtyperSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OTYPER to value 0"] impl crate :: Resettable for OtyperSpec { } }
#[doc = "OSPEEDR (rw) register accessor: GPIO port output speed register\n\nYou can [`read`](crate::Reg::read) this register and get [`ospeedr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ospeedr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ospeedr`] module"]
#[doc (alias = "OSPEEDR")] pub type Ospeedr = crate :: Reg < ospeedr :: OspeedrSpec > ;
#[doc = "GPIO port output speed register"] pub mod ospeedr {
#[doc = "Register `OSPEEDR` reader"] pub type R = crate :: R < OspeedrSpec > ;
#[doc = "Register `OSPEEDR` writer"] pub type W = crate :: W < OspeedrSpec > ;
#[doc = "Field `OSPEEDR0` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr0R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR0` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR1` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr1R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR1` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR2` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr2R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR2` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR3` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr3R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR3` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR4` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr4R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR4` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR5` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr5R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR5` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR6` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr6R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR6` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR7` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr7R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR7` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR8` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr8R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR8` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR9` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr9R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR9` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR10` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr10R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR10` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR11` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr11R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR11` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR12` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr12R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR12` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR13` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr13R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR13` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR14` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr14R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR14` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR15` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr15R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR15` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr0 (& self) -> Ospeedr0R { Ospeedr0R :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr1 (& self) -> Ospeedr1R { Ospeedr1R :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr2 (& self) -> Ospeedr2R { Ospeedr2R :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr3 (& self) -> Ospeedr3R { Ospeedr3R :: new (((self . bits >> 6) & 3) as u8) }
#[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr4 (& self) -> Ospeedr4R { Ospeedr4R :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr5 (& self) -> Ospeedr5R { Ospeedr5R :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr6 (& self) -> Ospeedr6R { Ospeedr6R :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr7 (& self) -> Ospeedr7R { Ospeedr7R :: new (((self . bits >> 14) & 3) as u8) }
#[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr8 (& self) -> Ospeedr8R { Ospeedr8R :: new (((self . bits >> 16) & 3) as u8) }
#[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr9 (& self) -> Ospeedr9R { Ospeedr9R :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr10 (& self) -> Ospeedr10R { Ospeedr10R :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr11 (& self) -> Ospeedr11R { Ospeedr11R :: new (((self . bits >> 22) & 3) as u8) }
#[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr12 (& self) -> Ospeedr12R { Ospeedr12R :: new (((self . bits >> 24) & 3) as u8) }
#[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr13 (& self) -> Ospeedr13R { Ospeedr13R :: new (((self . bits >> 26) & 3) as u8) }
#[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr14 (& self) -> Ospeedr14R { Ospeedr14R :: new (((self . bits >> 28) & 3) as u8) }
#[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr15 (& self) -> Ospeedr15R { Ospeedr15R :: new (((self . bits >> 30) & 3) as u8) } } impl W {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr0 (& mut self) -> Ospeedr0W < '_ , OspeedrSpec > { Ospeedr0W :: new (self , 0) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr1 (& mut self) -> Ospeedr1W < '_ , OspeedrSpec > { Ospeedr1W :: new (self , 2) }
#[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr2 (& mut self) -> Ospeedr2W < '_ , OspeedrSpec > { Ospeedr2W :: new (self , 4) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr3 (& mut self) -> Ospeedr3W < '_ , OspeedrSpec > { Ospeedr3W :: new (self , 6) }
#[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr4 (& mut self) -> Ospeedr4W < '_ , OspeedrSpec > { Ospeedr4W :: new (self , 8) }
#[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr5 (& mut self) -> Ospeedr5W < '_ , OspeedrSpec > { Ospeedr5W :: new (self , 10) }
#[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr6 (& mut self) -> Ospeedr6W < '_ , OspeedrSpec > { Ospeedr6W :: new (self , 12) }
#[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr7 (& mut self) -> Ospeedr7W < '_ , OspeedrSpec > { Ospeedr7W :: new (self , 14) }
#[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr8 (& mut self) -> Ospeedr8W < '_ , OspeedrSpec > { Ospeedr8W :: new (self , 16) }
#[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr9 (& mut self) -> Ospeedr9W < '_ , OspeedrSpec > { Ospeedr9W :: new (self , 18) }
#[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr10 (& mut self) -> Ospeedr10W < '_ , OspeedrSpec > { Ospeedr10W :: new (self , 20) }
#[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr11 (& mut self) -> Ospeedr11W < '_ , OspeedrSpec > { Ospeedr11W :: new (self , 22) }
#[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr12 (& mut self) -> Ospeedr12W < '_ , OspeedrSpec > { Ospeedr12W :: new (self , 24) }
#[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr13 (& mut self) -> Ospeedr13W < '_ , OspeedrSpec > { Ospeedr13W :: new (self , 26) }
#[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr14 (& mut self) -> Ospeedr14W < '_ , OspeedrSpec > { Ospeedr14W :: new (self , 28) }
#[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr15 (& mut self) -> Ospeedr15W < '_ , OspeedrSpec > { Ospeedr15W :: new (self , 30) } }
#[doc = "GPIO port output speed register\n\nYou can [`read`](crate::Reg::read) this register and get [`ospeedr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ospeedr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OspeedrSpec ; impl crate :: RegisterSpec for OspeedrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ospeedr::R`](R) reader structure"] impl crate :: Readable for OspeedrSpec { }
#[doc = "`write(|w| ..)` method takes [`ospeedr::W`](W) writer structure"] impl crate :: Writable for OspeedrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OSPEEDR to value 0xc0"] impl crate :: Resettable for OspeedrSpec { const RESET_VALUE : u32 = 0xc0 ; } }
#[doc = "PUPDR (rw) register accessor: GPIO port pull-up/pull-down register\n\nYou can [`read`](crate::Reg::read) this register and get [`pupdr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pupdr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pupdr`] module"]
#[doc (alias = "PUPDR")] pub type Pupdr = crate :: Reg < pupdr :: PupdrSpec > ;
#[doc = "GPIO port pull-up/pull-down register"] pub mod pupdr {
#[doc = "Register `PUPDR` reader"] pub type R = crate :: R < PupdrSpec > ;
#[doc = "Register `PUPDR` writer"] pub type W = crate :: W < PupdrSpec > ;
#[doc = "Field `PUPDR0` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr0R = crate :: FieldReader ;
#[doc = "Field `PUPDR0` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR1` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr1R = crate :: FieldReader ;
#[doc = "Field `PUPDR1` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR2` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr2R = crate :: FieldReader ;
#[doc = "Field `PUPDR2` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR3` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr3R = crate :: FieldReader ;
#[doc = "Field `PUPDR3` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR4` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr4R = crate :: FieldReader ;
#[doc = "Field `PUPDR4` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR5` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr5R = crate :: FieldReader ;
#[doc = "Field `PUPDR5` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR6` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr6R = crate :: FieldReader ;
#[doc = "Field `PUPDR6` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR7` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr7R = crate :: FieldReader ;
#[doc = "Field `PUPDR7` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR8` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr8R = crate :: FieldReader ;
#[doc = "Field `PUPDR8` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR9` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr9R = crate :: FieldReader ;
#[doc = "Field `PUPDR9` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR10` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr10R = crate :: FieldReader ;
#[doc = "Field `PUPDR10` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR11` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr11R = crate :: FieldReader ;
#[doc = "Field `PUPDR11` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR12` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr12R = crate :: FieldReader ;
#[doc = "Field `PUPDR12` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR13` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr13R = crate :: FieldReader ;
#[doc = "Field `PUPDR13` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR14` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr14R = crate :: FieldReader ;
#[doc = "Field `PUPDR14` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR15` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr15R = crate :: FieldReader ;
#[doc = "Field `PUPDR15` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr0 (& self) -> Pupdr0R { Pupdr0R :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr1 (& self) -> Pupdr1R { Pupdr1R :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr2 (& self) -> Pupdr2R { Pupdr2R :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr3 (& self) -> Pupdr3R { Pupdr3R :: new (((self . bits >> 6) & 3) as u8) }
#[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr4 (& self) -> Pupdr4R { Pupdr4R :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr5 (& self) -> Pupdr5R { Pupdr5R :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr6 (& self) -> Pupdr6R { Pupdr6R :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr7 (& self) -> Pupdr7R { Pupdr7R :: new (((self . bits >> 14) & 3) as u8) }
#[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr8 (& self) -> Pupdr8R { Pupdr8R :: new (((self . bits >> 16) & 3) as u8) }
#[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr9 (& self) -> Pupdr9R { Pupdr9R :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr10 (& self) -> Pupdr10R { Pupdr10R :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr11 (& self) -> Pupdr11R { Pupdr11R :: new (((self . bits >> 22) & 3) as u8) }
#[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr12 (& self) -> Pupdr12R { Pupdr12R :: new (((self . bits >> 24) & 3) as u8) }
#[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr13 (& self) -> Pupdr13R { Pupdr13R :: new (((self . bits >> 26) & 3) as u8) }
#[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr14 (& self) -> Pupdr14R { Pupdr14R :: new (((self . bits >> 28) & 3) as u8) }
#[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr15 (& self) -> Pupdr15R { Pupdr15R :: new (((self . bits >> 30) & 3) as u8) } } impl W {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr0 (& mut self) -> Pupdr0W < '_ , PupdrSpec > { Pupdr0W :: new (self , 0) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr1 (& mut self) -> Pupdr1W < '_ , PupdrSpec > { Pupdr1W :: new (self , 2) }
#[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr2 (& mut self) -> Pupdr2W < '_ , PupdrSpec > { Pupdr2W :: new (self , 4) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr3 (& mut self) -> Pupdr3W < '_ , PupdrSpec > { Pupdr3W :: new (self , 6) }
#[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr4 (& mut self) -> Pupdr4W < '_ , PupdrSpec > { Pupdr4W :: new (self , 8) }
#[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr5 (& mut self) -> Pupdr5W < '_ , PupdrSpec > { Pupdr5W :: new (self , 10) }
#[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr6 (& mut self) -> Pupdr6W < '_ , PupdrSpec > { Pupdr6W :: new (self , 12) }
#[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr7 (& mut self) -> Pupdr7W < '_ , PupdrSpec > { Pupdr7W :: new (self , 14) }
#[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr8 (& mut self) -> Pupdr8W < '_ , PupdrSpec > { Pupdr8W :: new (self , 16) }
#[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr9 (& mut self) -> Pupdr9W < '_ , PupdrSpec > { Pupdr9W :: new (self , 18) }
#[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr10 (& mut self) -> Pupdr10W < '_ , PupdrSpec > { Pupdr10W :: new (self , 20) }
#[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr11 (& mut self) -> Pupdr11W < '_ , PupdrSpec > { Pupdr11W :: new (self , 22) }
#[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr12 (& mut self) -> Pupdr12W < '_ , PupdrSpec > { Pupdr12W :: new (self , 24) }
#[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr13 (& mut self) -> Pupdr13W < '_ , PupdrSpec > { Pupdr13W :: new (self , 26) }
#[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr14 (& mut self) -> Pupdr14W < '_ , PupdrSpec > { Pupdr14W :: new (self , 28) }
#[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr15 (& mut self) -> Pupdr15W < '_ , PupdrSpec > { Pupdr15W :: new (self , 30) } }
#[doc = "GPIO port pull-up/pull-down register\n\nYou can [`read`](crate::Reg::read) this register and get [`pupdr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pupdr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PupdrSpec ; impl crate :: RegisterSpec for PupdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pupdr::R`](R) reader structure"] impl crate :: Readable for PupdrSpec { }
#[doc = "`write(|w| ..)` method takes [`pupdr::W`](W) writer structure"] impl crate :: Writable for PupdrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PUPDR to value 0x0100"] impl crate :: Resettable for PupdrSpec { const RESET_VALUE : u32 = 0x0100 ; } }
#[doc = "IDR (r) register accessor: GPIO port input data register\n\nYou can [`read`](crate::Reg::read) this register and get [`idr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@idr`] module"]
#[doc (alias = "IDR")] pub type Idr = crate :: Reg < idr :: IdrSpec > ;
#[doc = "GPIO port input data register"] pub mod idr {
#[doc = "Register `IDR` reader"] pub type R = crate :: R < IdrSpec > ;
#[doc = "Field `IDR0` reader - Port input data (y = 0..15)"] pub type Idr0R = crate :: BitReader ;
#[doc = "Field `IDR1` reader - Port input data (y = 0..15)"] pub type Idr1R = crate :: BitReader ;
#[doc = "Field `IDR2` reader - Port input data (y = 0..15)"] pub type Idr2R = crate :: BitReader ;
#[doc = "Field `IDR3` reader - Port input data (y = 0..15)"] pub type Idr3R = crate :: BitReader ;
#[doc = "Field `IDR4` reader - Port input data (y = 0..15)"] pub type Idr4R = crate :: BitReader ;
#[doc = "Field `IDR5` reader - Port input data (y = 0..15)"] pub type Idr5R = crate :: BitReader ;
#[doc = "Field `IDR6` reader - Port input data (y = 0..15)"] pub type Idr6R = crate :: BitReader ;
#[doc = "Field `IDR7` reader - Port input data (y = 0..15)"] pub type Idr7R = crate :: BitReader ;
#[doc = "Field `IDR8` reader - Port input data (y = 0..15)"] pub type Idr8R = crate :: BitReader ;
#[doc = "Field `IDR9` reader - Port input data (y = 0..15)"] pub type Idr9R = crate :: BitReader ;
#[doc = "Field `IDR10` reader - Port input data (y = 0..15)"] pub type Idr10R = crate :: BitReader ;
#[doc = "Field `IDR11` reader - Port input data (y = 0..15)"] pub type Idr11R = crate :: BitReader ;
#[doc = "Field `IDR12` reader - Port input data (y = 0..15)"] pub type Idr12R = crate :: BitReader ;
#[doc = "Field `IDR13` reader - Port input data (y = 0..15)"] pub type Idr13R = crate :: BitReader ;
#[doc = "Field `IDR14` reader - Port input data (y = 0..15)"] pub type Idr14R = crate :: BitReader ;
#[doc = "Field `IDR15` reader - Port input data (y = 0..15)"] pub type Idr15R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr0 (& self) -> Idr0R { Idr0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr1 (& self) -> Idr1R { Idr1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr2 (& self) -> Idr2R { Idr2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr3 (& self) -> Idr3R { Idr3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr4 (& self) -> Idr4R { Idr4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr5 (& self) -> Idr5R { Idr5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr6 (& self) -> Idr6R { Idr6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr7 (& self) -> Idr7R { Idr7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr8 (& self) -> Idr8R { Idr8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr9 (& self) -> Idr9R { Idr9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr10 (& self) -> Idr10R { Idr10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr11 (& self) -> Idr11R { Idr11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr12 (& self) -> Idr12R { Idr12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr13 (& self) -> Idr13R { Idr13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr14 (& self) -> Idr14R { Idr14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr15 (& self) -> Idr15R { Idr15R :: new (((self . bits >> 15) & 1) != 0) } }
#[doc = "GPIO port input data register\n\nYou can [`read`](crate::Reg::read) this register and get [`idr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IdrSpec ; impl crate :: RegisterSpec for IdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`idr::R`](R) reader structure"] impl crate :: Readable for IdrSpec { }
#[doc = "`reset()` method sets IDR to value 0"] impl crate :: Resettable for IdrSpec { } }
#[doc = "ODR (rw) register accessor: GPIO port output data register\n\nYou can [`read`](crate::Reg::read) this register and get [`odr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`odr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@odr`] module"]
#[doc (alias = "ODR")] pub type Odr = crate :: Reg < odr :: OdrSpec > ;
#[doc = "GPIO port output data register"] pub mod odr {
#[doc = "Register `ODR` reader"] pub type R = crate :: R < OdrSpec > ;
#[doc = "Register `ODR` writer"] pub type W = crate :: W < OdrSpec > ;
#[doc = "Field `ODR0` reader - Port output data (y = 0..15)"] pub type Odr0R = crate :: BitReader ;
#[doc = "Field `ODR0` writer - Port output data (y = 0..15)"] pub type Odr0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR1` reader - Port output data (y = 0..15)"] pub type Odr1R = crate :: BitReader ;
#[doc = "Field `ODR1` writer - Port output data (y = 0..15)"] pub type Odr1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR2` reader - Port output data (y = 0..15)"] pub type Odr2R = crate :: BitReader ;
#[doc = "Field `ODR2` writer - Port output data (y = 0..15)"] pub type Odr2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR3` reader - Port output data (y = 0..15)"] pub type Odr3R = crate :: BitReader ;
#[doc = "Field `ODR3` writer - Port output data (y = 0..15)"] pub type Odr3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR4` reader - Port output data (y = 0..15)"] pub type Odr4R = crate :: BitReader ;
#[doc = "Field `ODR4` writer - Port output data (y = 0..15)"] pub type Odr4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR5` reader - Port output data (y = 0..15)"] pub type Odr5R = crate :: BitReader ;
#[doc = "Field `ODR5` writer - Port output data (y = 0..15)"] pub type Odr5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR6` reader - Port output data (y = 0..15)"] pub type Odr6R = crate :: BitReader ;
#[doc = "Field `ODR6` writer - Port output data (y = 0..15)"] pub type Odr6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR7` reader - Port output data (y = 0..15)"] pub type Odr7R = crate :: BitReader ;
#[doc = "Field `ODR7` writer - Port output data (y = 0..15)"] pub type Odr7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR8` reader - Port output data (y = 0..15)"] pub type Odr8R = crate :: BitReader ;
#[doc = "Field `ODR8` writer - Port output data (y = 0..15)"] pub type Odr8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR9` reader - Port output data (y = 0..15)"] pub type Odr9R = crate :: BitReader ;
#[doc = "Field `ODR9` writer - Port output data (y = 0..15)"] pub type Odr9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR10` reader - Port output data (y = 0..15)"] pub type Odr10R = crate :: BitReader ;
#[doc = "Field `ODR10` writer - Port output data (y = 0..15)"] pub type Odr10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR11` reader - Port output data (y = 0..15)"] pub type Odr11R = crate :: BitReader ;
#[doc = "Field `ODR11` writer - Port output data (y = 0..15)"] pub type Odr11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR12` reader - Port output data (y = 0..15)"] pub type Odr12R = crate :: BitReader ;
#[doc = "Field `ODR12` writer - Port output data (y = 0..15)"] pub type Odr12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR13` reader - Port output data (y = 0..15)"] pub type Odr13R = crate :: BitReader ;
#[doc = "Field `ODR13` writer - Port output data (y = 0..15)"] pub type Odr13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR14` reader - Port output data (y = 0..15)"] pub type Odr14R = crate :: BitReader ;
#[doc = "Field `ODR14` writer - Port output data (y = 0..15)"] pub type Odr14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR15` reader - Port output data (y = 0..15)"] pub type Odr15R = crate :: BitReader ;
#[doc = "Field `ODR15` writer - Port output data (y = 0..15)"] pub type Odr15W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr0 (& self) -> Odr0R { Odr0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr1 (& self) -> Odr1R { Odr1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr2 (& self) -> Odr2R { Odr2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr3 (& self) -> Odr3R { Odr3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr4 (& self) -> Odr4R { Odr4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr5 (& self) -> Odr5R { Odr5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr6 (& self) -> Odr6R { Odr6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr7 (& self) -> Odr7R { Odr7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr8 (& self) -> Odr8R { Odr8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr9 (& self) -> Odr9R { Odr9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr10 (& self) -> Odr10R { Odr10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr11 (& self) -> Odr11R { Odr11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr12 (& self) -> Odr12R { Odr12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr13 (& self) -> Odr13R { Odr13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr14 (& self) -> Odr14R { Odr14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr15 (& self) -> Odr15R { Odr15R :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr0 (& mut self) -> Odr0W < '_ , OdrSpec > { Odr0W :: new (self , 0) }
#[doc = "Bit 1 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr1 (& mut self) -> Odr1W < '_ , OdrSpec > { Odr1W :: new (self , 1) }
#[doc = "Bit 2 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr2 (& mut self) -> Odr2W < '_ , OdrSpec > { Odr2W :: new (self , 2) }
#[doc = "Bit 3 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr3 (& mut self) -> Odr3W < '_ , OdrSpec > { Odr3W :: new (self , 3) }
#[doc = "Bit 4 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr4 (& mut self) -> Odr4W < '_ , OdrSpec > { Odr4W :: new (self , 4) }
#[doc = "Bit 5 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr5 (& mut self) -> Odr5W < '_ , OdrSpec > { Odr5W :: new (self , 5) }
#[doc = "Bit 6 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr6 (& mut self) -> Odr6W < '_ , OdrSpec > { Odr6W :: new (self , 6) }
#[doc = "Bit 7 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr7 (& mut self) -> Odr7W < '_ , OdrSpec > { Odr7W :: new (self , 7) }
#[doc = "Bit 8 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr8 (& mut self) -> Odr8W < '_ , OdrSpec > { Odr8W :: new (self , 8) }
#[doc = "Bit 9 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr9 (& mut self) -> Odr9W < '_ , OdrSpec > { Odr9W :: new (self , 9) }
#[doc = "Bit 10 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr10 (& mut self) -> Odr10W < '_ , OdrSpec > { Odr10W :: new (self , 10) }
#[doc = "Bit 11 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr11 (& mut self) -> Odr11W < '_ , OdrSpec > { Odr11W :: new (self , 11) }
#[doc = "Bit 12 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr12 (& mut self) -> Odr12W < '_ , OdrSpec > { Odr12W :: new (self , 12) }
#[doc = "Bit 13 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr13 (& mut self) -> Odr13W < '_ , OdrSpec > { Odr13W :: new (self , 13) }
#[doc = "Bit 14 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr14 (& mut self) -> Odr14W < '_ , OdrSpec > { Odr14W :: new (self , 14) }
#[doc = "Bit 15 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr15 (& mut self) -> Odr15W < '_ , OdrSpec > { Odr15W :: new (self , 15) } }
#[doc = "GPIO port output data register\n\nYou can [`read`](crate::Reg::read) this register and get [`odr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`odr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OdrSpec ; impl crate :: RegisterSpec for OdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`odr::R`](R) reader structure"] impl crate :: Readable for OdrSpec { }
#[doc = "`write(|w| ..)` method takes [`odr::W`](W) writer structure"] impl crate :: Writable for OdrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ODR to value 0"] impl crate :: Resettable for OdrSpec { } }
#[doc = "BSRR (w) register accessor: GPIO port bit set/reset register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bsrr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bsrr`] module"]
#[doc (alias = "BSRR")] pub type Bsrr = crate :: Reg < bsrr :: BsrrSpec > ;
#[doc = "GPIO port bit set/reset register"] pub mod bsrr {
#[doc = "Register `BSRR` writer"] pub type W = crate :: W < BsrrSpec > ;
#[doc = "Field `BS0` writer - Port x set bit y (y= 0..15)"] pub type Bs0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS1` writer - Port x set bit y (y= 0..15)"] pub type Bs1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS2` writer - Port x set bit y (y= 0..15)"] pub type Bs2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS3` writer - Port x set bit y (y= 0..15)"] pub type Bs3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS4` writer - Port x set bit y (y= 0..15)"] pub type Bs4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS5` writer - Port x set bit y (y= 0..15)"] pub type Bs5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS6` writer - Port x set bit y (y= 0..15)"] pub type Bs6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS7` writer - Port x set bit y (y= 0..15)"] pub type Bs7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS8` writer - Port x set bit y (y= 0..15)"] pub type Bs8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS9` writer - Port x set bit y (y= 0..15)"] pub type Bs9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS10` writer - Port x set bit y (y= 0..15)"] pub type Bs10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS11` writer - Port x set bit y (y= 0..15)"] pub type Bs11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS12` writer - Port x set bit y (y= 0..15)"] pub type Bs12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS13` writer - Port x set bit y (y= 0..15)"] pub type Bs13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS14` writer - Port x set bit y (y= 0..15)"] pub type Bs14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS15` writer - Port x set bit y (y= 0..15)"] pub type Bs15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR0` writer - Port x set bit y (y= 0..15)"] pub type Br0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR1` writer - Port x reset bit y (y = 0..15)"] pub type Br1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR2` writer - Port x reset bit y (y = 0..15)"] pub type Br2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR3` writer - Port x reset bit y (y = 0..15)"] pub type Br3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR4` writer - Port x reset bit y (y = 0..15)"] pub type Br4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR5` writer - Port x reset bit y (y = 0..15)"] pub type Br5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR6` writer - Port x reset bit y (y = 0..15)"] pub type Br6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR7` writer - Port x reset bit y (y = 0..15)"] pub type Br7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR8` writer - Port x reset bit y (y = 0..15)"] pub type Br8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR9` writer - Port x reset bit y (y = 0..15)"] pub type Br9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR10` writer - Port x reset bit y (y = 0..15)"] pub type Br10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR11` writer - Port x reset bit y (y = 0..15)"] pub type Br11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR12` writer - Port x reset bit y (y = 0..15)"] pub type Br12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR13` writer - Port x reset bit y (y = 0..15)"] pub type Br13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR14` writer - Port x reset bit y (y = 0..15)"] pub type Br14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR15` writer - Port x reset bit y (y = 0..15)"] pub type Br15W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs0 (& mut self) -> Bs0W < '_ , BsrrSpec > { Bs0W :: new (self , 0) }
#[doc = "Bit 1 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs1 (& mut self) -> Bs1W < '_ , BsrrSpec > { Bs1W :: new (self , 1) }
#[doc = "Bit 2 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs2 (& mut self) -> Bs2W < '_ , BsrrSpec > { Bs2W :: new (self , 2) }
#[doc = "Bit 3 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs3 (& mut self) -> Bs3W < '_ , BsrrSpec > { Bs3W :: new (self , 3) }
#[doc = "Bit 4 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs4 (& mut self) -> Bs4W < '_ , BsrrSpec > { Bs4W :: new (self , 4) }
#[doc = "Bit 5 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs5 (& mut self) -> Bs5W < '_ , BsrrSpec > { Bs5W :: new (self , 5) }
#[doc = "Bit 6 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs6 (& mut self) -> Bs6W < '_ , BsrrSpec > { Bs6W :: new (self , 6) }
#[doc = "Bit 7 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs7 (& mut self) -> Bs7W < '_ , BsrrSpec > { Bs7W :: new (self , 7) }
#[doc = "Bit 8 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs8 (& mut self) -> Bs8W < '_ , BsrrSpec > { Bs8W :: new (self , 8) }
#[doc = "Bit 9 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs9 (& mut self) -> Bs9W < '_ , BsrrSpec > { Bs9W :: new (self , 9) }
#[doc = "Bit 10 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs10 (& mut self) -> Bs10W < '_ , BsrrSpec > { Bs10W :: new (self , 10) }
#[doc = "Bit 11 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs11 (& mut self) -> Bs11W < '_ , BsrrSpec > { Bs11W :: new (self , 11) }
#[doc = "Bit 12 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs12 (& mut self) -> Bs12W < '_ , BsrrSpec > { Bs12W :: new (self , 12) }
#[doc = "Bit 13 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs13 (& mut self) -> Bs13W < '_ , BsrrSpec > { Bs13W :: new (self , 13) }
#[doc = "Bit 14 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs14 (& mut self) -> Bs14W < '_ , BsrrSpec > { Bs14W :: new (self , 14) }
#[doc = "Bit 15 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs15 (& mut self) -> Bs15W < '_ , BsrrSpec > { Bs15W :: new (self , 15) }
#[doc = "Bit 16 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn br0 (& mut self) -> Br0W < '_ , BsrrSpec > { Br0W :: new (self , 16) }
#[doc = "Bit 17 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br1 (& mut self) -> Br1W < '_ , BsrrSpec > { Br1W :: new (self , 17) }
#[doc = "Bit 18 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br2 (& mut self) -> Br2W < '_ , BsrrSpec > { Br2W :: new (self , 18) }
#[doc = "Bit 19 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br3 (& mut self) -> Br3W < '_ , BsrrSpec > { Br3W :: new (self , 19) }
#[doc = "Bit 20 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br4 (& mut self) -> Br4W < '_ , BsrrSpec > { Br4W :: new (self , 20) }
#[doc = "Bit 21 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br5 (& mut self) -> Br5W < '_ , BsrrSpec > { Br5W :: new (self , 21) }
#[doc = "Bit 22 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br6 (& mut self) -> Br6W < '_ , BsrrSpec > { Br6W :: new (self , 22) }
#[doc = "Bit 23 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br7 (& mut self) -> Br7W < '_ , BsrrSpec > { Br7W :: new (self , 23) }
#[doc = "Bit 24 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br8 (& mut self) -> Br8W < '_ , BsrrSpec > { Br8W :: new (self , 24) }
#[doc = "Bit 25 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br9 (& mut self) -> Br9W < '_ , BsrrSpec > { Br9W :: new (self , 25) }
#[doc = "Bit 26 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br10 (& mut self) -> Br10W < '_ , BsrrSpec > { Br10W :: new (self , 26) }
#[doc = "Bit 27 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br11 (& mut self) -> Br11W < '_ , BsrrSpec > { Br11W :: new (self , 27) }
#[doc = "Bit 28 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br12 (& mut self) -> Br12W < '_ , BsrrSpec > { Br12W :: new (self , 28) }
#[doc = "Bit 29 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br13 (& mut self) -> Br13W < '_ , BsrrSpec > { Br13W :: new (self , 29) }
#[doc = "Bit 30 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br14 (& mut self) -> Br14W < '_ , BsrrSpec > { Br14W :: new (self , 30) }
#[doc = "Bit 31 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br15 (& mut self) -> Br15W < '_ , BsrrSpec > { Br15W :: new (self , 31) } }
#[doc = "GPIO port bit set/reset register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bsrr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BsrrSpec ; impl crate :: RegisterSpec for BsrrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`bsrr::W`](W) writer structure"] impl crate :: Writable for BsrrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BSRR to value 0"] impl crate :: Resettable for BsrrSpec { } }
#[doc = "LCKR (rw) register accessor: GPIO port configuration lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`lckr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lckr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lckr`] module"]
#[doc (alias = "LCKR")] pub type Lckr = crate :: Reg < lckr :: LckrSpec > ;
#[doc = "GPIO port configuration lock register"] pub mod lckr {
#[doc = "Register `LCKR` reader"] pub type R = crate :: R < LckrSpec > ;
#[doc = "Register `LCKR` writer"] pub type W = crate :: W < LckrSpec > ;
#[doc = "Field `LCK0` reader - Port x lock bit y (y= 0..15)"] pub type Lck0R = crate :: BitReader ;
#[doc = "Field `LCK0` writer - Port x lock bit y (y= 0..15)"] pub type Lck0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK1` reader - Port x lock bit y (y= 0..15)"] pub type Lck1R = crate :: BitReader ;
#[doc = "Field `LCK1` writer - Port x lock bit y (y= 0..15)"] pub type Lck1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK2` reader - Port x lock bit y (y= 0..15)"] pub type Lck2R = crate :: BitReader ;
#[doc = "Field `LCK2` writer - Port x lock bit y (y= 0..15)"] pub type Lck2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK3` reader - Port x lock bit y (y= 0..15)"] pub type Lck3R = crate :: BitReader ;
#[doc = "Field `LCK3` writer - Port x lock bit y (y= 0..15)"] pub type Lck3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK4` reader - Port x lock bit y (y= 0..15)"] pub type Lck4R = crate :: BitReader ;
#[doc = "Field `LCK4` writer - Port x lock bit y (y= 0..15)"] pub type Lck4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK5` reader - Port x lock bit y (y= 0..15)"] pub type Lck5R = crate :: BitReader ;
#[doc = "Field `LCK5` writer - Port x lock bit y (y= 0..15)"] pub type Lck5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK6` reader - Port x lock bit y (y= 0..15)"] pub type Lck6R = crate :: BitReader ;
#[doc = "Field `LCK6` writer - Port x lock bit y (y= 0..15)"] pub type Lck6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK7` reader - Port x lock bit y (y= 0..15)"] pub type Lck7R = crate :: BitReader ;
#[doc = "Field `LCK7` writer - Port x lock bit y (y= 0..15)"] pub type Lck7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK8` reader - Port x lock bit y (y= 0..15)"] pub type Lck8R = crate :: BitReader ;
#[doc = "Field `LCK8` writer - Port x lock bit y (y= 0..15)"] pub type Lck8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK9` reader - Port x lock bit y (y= 0..15)"] pub type Lck9R = crate :: BitReader ;
#[doc = "Field `LCK9` writer - Port x lock bit y (y= 0..15)"] pub type Lck9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK10` reader - Port x lock bit y (y= 0..15)"] pub type Lck10R = crate :: BitReader ;
#[doc = "Field `LCK10` writer - Port x lock bit y (y= 0..15)"] pub type Lck10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK11` reader - Port x lock bit y (y= 0..15)"] pub type Lck11R = crate :: BitReader ;
#[doc = "Field `LCK11` writer - Port x lock bit y (y= 0..15)"] pub type Lck11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK12` reader - Port x lock bit y (y= 0..15)"] pub type Lck12R = crate :: BitReader ;
#[doc = "Field `LCK12` writer - Port x lock bit y (y= 0..15)"] pub type Lck12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK13` reader - Port x lock bit y (y= 0..15)"] pub type Lck13R = crate :: BitReader ;
#[doc = "Field `LCK13` writer - Port x lock bit y (y= 0..15)"] pub type Lck13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK14` reader - Port x lock bit y (y= 0..15)"] pub type Lck14R = crate :: BitReader ;
#[doc = "Field `LCK14` writer - Port x lock bit y (y= 0..15)"] pub type Lck14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK15` reader - Port x lock bit y (y= 0..15)"] pub type Lck15R = crate :: BitReader ;
#[doc = "Field `LCK15` writer - Port x lock bit y (y= 0..15)"] pub type Lck15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCKK` reader - Port x lock bit y (y= 0..15)"] pub type LckkR = crate :: BitReader ;
#[doc = "Field `LCKK` writer - Port x lock bit y (y= 0..15)"] pub type LckkW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck0 (& self) -> Lck0R { Lck0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck1 (& self) -> Lck1R { Lck1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck2 (& self) -> Lck2R { Lck2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck3 (& self) -> Lck3R { Lck3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck4 (& self) -> Lck4R { Lck4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck5 (& self) -> Lck5R { Lck5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck6 (& self) -> Lck6R { Lck6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck7 (& self) -> Lck7R { Lck7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck8 (& self) -> Lck8R { Lck8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck9 (& self) -> Lck9R { Lck9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck10 (& self) -> Lck10R { Lck10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck11 (& self) -> Lck11R { Lck11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck12 (& self) -> Lck12R { Lck12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck13 (& self) -> Lck13R { Lck13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck14 (& self) -> Lck14R { Lck14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck15 (& self) -> Lck15R { Lck15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lckk (& self) -> LckkR { LckkR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck0 (& mut self) -> Lck0W < '_ , LckrSpec > { Lck0W :: new (self , 0) }
#[doc = "Bit 1 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck1 (& mut self) -> Lck1W < '_ , LckrSpec > { Lck1W :: new (self , 1) }
#[doc = "Bit 2 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck2 (& mut self) -> Lck2W < '_ , LckrSpec > { Lck2W :: new (self , 2) }
#[doc = "Bit 3 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck3 (& mut self) -> Lck3W < '_ , LckrSpec > { Lck3W :: new (self , 3) }
#[doc = "Bit 4 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck4 (& mut self) -> Lck4W < '_ , LckrSpec > { Lck4W :: new (self , 4) }
#[doc = "Bit 5 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck5 (& mut self) -> Lck5W < '_ , LckrSpec > { Lck5W :: new (self , 5) }
#[doc = "Bit 6 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck6 (& mut self) -> Lck6W < '_ , LckrSpec > { Lck6W :: new (self , 6) }
#[doc = "Bit 7 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck7 (& mut self) -> Lck7W < '_ , LckrSpec > { Lck7W :: new (self , 7) }
#[doc = "Bit 8 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck8 (& mut self) -> Lck8W < '_ , LckrSpec > { Lck8W :: new (self , 8) }
#[doc = "Bit 9 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck9 (& mut self) -> Lck9W < '_ , LckrSpec > { Lck9W :: new (self , 9) }
#[doc = "Bit 10 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck10 (& mut self) -> Lck10W < '_ , LckrSpec > { Lck10W :: new (self , 10) }
#[doc = "Bit 11 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck11 (& mut self) -> Lck11W < '_ , LckrSpec > { Lck11W :: new (self , 11) }
#[doc = "Bit 12 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck12 (& mut self) -> Lck12W < '_ , LckrSpec > { Lck12W :: new (self , 12) }
#[doc = "Bit 13 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck13 (& mut self) -> Lck13W < '_ , LckrSpec > { Lck13W :: new (self , 13) }
#[doc = "Bit 14 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck14 (& mut self) -> Lck14W < '_ , LckrSpec > { Lck14W :: new (self , 14) }
#[doc = "Bit 15 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck15 (& mut self) -> Lck15W < '_ , LckrSpec > { Lck15W :: new (self , 15) }
#[doc = "Bit 16 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lckk (& mut self) -> LckkW < '_ , LckrSpec > { LckkW :: new (self , 16) } }
#[doc = "GPIO port configuration lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`lckr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lckr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct LckrSpec ; impl crate :: RegisterSpec for LckrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`lckr::R`](R) reader structure"] impl crate :: Readable for LckrSpec { }
#[doc = "`write(|w| ..)` method takes [`lckr::W`](W) writer structure"] impl crate :: Writable for LckrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets LCKR to value 0"] impl crate :: Resettable for LckrSpec { } }
#[doc = "AFRL (rw) register accessor: GPIO alternate function low register\n\nYou can [`read`](crate::Reg::read) this register and get [`afrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@afrl`] module"]
#[doc (alias = "AFRL")] pub type Afrl = crate :: Reg < afrl :: AfrlSpec > ;
#[doc = "GPIO alternate function low register"] pub mod afrl {
#[doc = "Register `AFRL` reader"] pub type R = crate :: R < AfrlSpec > ;
#[doc = "Register `AFRL` writer"] pub type W = crate :: W < AfrlSpec > ;
#[doc = "Field `AFSEL0` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel0R = crate :: FieldReader ;
#[doc = "Field `AFSEL0` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL1` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel1R = crate :: FieldReader ;
#[doc = "Field `AFSEL1` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL2` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel2R = crate :: FieldReader ;
#[doc = "Field `AFSEL2` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL3` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel3R = crate :: FieldReader ;
#[doc = "Field `AFSEL3` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL4` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel4R = crate :: FieldReader ;
#[doc = "Field `AFSEL4` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL5` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel5R = crate :: FieldReader ;
#[doc = "Field `AFSEL5` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL6` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel6R = crate :: FieldReader ;
#[doc = "Field `AFSEL6` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL7` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel7R = crate :: FieldReader ;
#[doc = "Field `AFSEL7` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel0 (& self) -> Afsel0R { Afsel0R :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel1 (& self) -> Afsel1R { Afsel1R :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel2 (& self) -> Afsel2R { Afsel2R :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel3 (& self) -> Afsel3R { Afsel3R :: new (((self . bits >> 12) & 0x0f) as u8) }
#[doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel4 (& self) -> Afsel4R { Afsel4R :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel5 (& self) -> Afsel5R { Afsel5R :: new (((self . bits >> 20) & 0x0f) as u8) }
#[doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel6 (& self) -> Afsel6R { Afsel6R :: new (((self . bits >> 24) & 0x0f) as u8) }
#[doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel7 (& self) -> Afsel7R { Afsel7R :: new (((self . bits >> 28) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel0 (& mut self) -> Afsel0W < '_ , AfrlSpec > { Afsel0W :: new (self , 0) }
#[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel1 (& mut self) -> Afsel1W < '_ , AfrlSpec > { Afsel1W :: new (self , 4) }
#[doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel2 (& mut self) -> Afsel2W < '_ , AfrlSpec > { Afsel2W :: new (self , 8) }
#[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel3 (& mut self) -> Afsel3W < '_ , AfrlSpec > { Afsel3W :: new (self , 12) }
#[doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel4 (& mut self) -> Afsel4W < '_ , AfrlSpec > { Afsel4W :: new (self , 16) }
#[doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel5 (& mut self) -> Afsel5W < '_ , AfrlSpec > { Afsel5W :: new (self , 20) }
#[doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel6 (& mut self) -> Afsel6W < '_ , AfrlSpec > { Afsel6W :: new (self , 24) }
#[doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel7 (& mut self) -> Afsel7W < '_ , AfrlSpec > { Afsel7W :: new (self , 28) } }
#[doc = "GPIO alternate function low register\n\nYou can [`read`](crate::Reg::read) this register and get [`afrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AfrlSpec ; impl crate :: RegisterSpec for AfrlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`afrl::R`](R) reader structure"] impl crate :: Readable for AfrlSpec { }
#[doc = "`write(|w| ..)` method takes [`afrl::W`](W) writer structure"] impl crate :: Writable for AfrlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AFRL to value 0"] impl crate :: Resettable for AfrlSpec { } }
#[doc = "AFRH (rw) register accessor: GPIO alternate function high register\n\nYou can [`read`](crate::Reg::read) this register and get [`afrh::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrh::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@afrh`] module"]
#[doc (alias = "AFRH")] pub type Afrh = crate :: Reg < afrh :: AfrhSpec > ;
#[doc = "GPIO alternate function high register"] pub mod afrh {
#[doc = "Register `AFRH` reader"] pub type R = crate :: R < AfrhSpec > ;
#[doc = "Register `AFRH` writer"] pub type W = crate :: W < AfrhSpec > ;
#[doc = "Field `AFSEL8` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel8R = crate :: FieldReader ;
#[doc = "Field `AFSEL8` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL9` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel9R = crate :: FieldReader ;
#[doc = "Field `AFSEL9` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL10` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel10R = crate :: FieldReader ;
#[doc = "Field `AFSEL10` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL11` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel11R = crate :: FieldReader ;
#[doc = "Field `AFSEL11` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL12` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel12R = crate :: FieldReader ;
#[doc = "Field `AFSEL12` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL13` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel13R = crate :: FieldReader ;
#[doc = "Field `AFSEL13` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL14` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel14R = crate :: FieldReader ;
#[doc = "Field `AFSEL14` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL15` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel15R = crate :: FieldReader ;
#[doc = "Field `AFSEL15` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel8 (& self) -> Afsel8R { Afsel8R :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel9 (& self) -> Afsel9R { Afsel9R :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel10 (& self) -> Afsel10R { Afsel10R :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel11 (& self) -> Afsel11R { Afsel11R :: new (((self . bits >> 12) & 0x0f) as u8) }
#[doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel12 (& self) -> Afsel12R { Afsel12R :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel13 (& self) -> Afsel13R { Afsel13R :: new (((self . bits >> 20) & 0x0f) as u8) }
#[doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel14 (& self) -> Afsel14R { Afsel14R :: new (((self . bits >> 24) & 0x0f) as u8) }
#[doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel15 (& self) -> Afsel15R { Afsel15R :: new (((self . bits >> 28) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel8 (& mut self) -> Afsel8W < '_ , AfrhSpec > { Afsel8W :: new (self , 0) }
#[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel9 (& mut self) -> Afsel9W < '_ , AfrhSpec > { Afsel9W :: new (self , 4) }
#[doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel10 (& mut self) -> Afsel10W < '_ , AfrhSpec > { Afsel10W :: new (self , 8) }
#[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel11 (& mut self) -> Afsel11W < '_ , AfrhSpec > { Afsel11W :: new (self , 12) }
#[doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel12 (& mut self) -> Afsel12W < '_ , AfrhSpec > { Afsel12W :: new (self , 16) }
#[doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel13 (& mut self) -> Afsel13W < '_ , AfrhSpec > { Afsel13W :: new (self , 20) }
#[doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel14 (& mut self) -> Afsel14W < '_ , AfrhSpec > { Afsel14W :: new (self , 24) }
#[doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel15 (& mut self) -> Afsel15W < '_ , AfrhSpec > { Afsel15W :: new (self , 28) } }
#[doc = "GPIO alternate function high register\n\nYou can [`read`](crate::Reg::read) this register and get [`afrh::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrh::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AfrhSpec ; impl crate :: RegisterSpec for AfrhSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`afrh::R`](R) reader structure"] impl crate :: Readable for AfrhSpec { }
#[doc = "`write(|w| ..)` method takes [`afrh::W`](W) writer structure"] impl crate :: Writable for AfrhSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AFRH to value 0"] impl crate :: Resettable for AfrhSpec { } }
#[doc = "BRR (w) register accessor: port bit reset register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@brr`] module"]
#[doc (alias = "BRR")] pub type Brr = crate :: Reg < brr :: BrrSpec > ;
#[doc = "port bit reset register"] pub mod brr {
#[doc = "Register `BRR` writer"] pub type W = crate :: W < BrrSpec > ;
#[doc = "Field `BR0` writer - Port Reset bit"] pub type Br0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR1` writer - Port Reset bit"] pub type Br1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR2` writer - Port Reset bit"] pub type Br2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR3` writer - Port Reset bit"] pub type Br3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR4` writer - Port Reset bit"] pub type Br4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR5` writer - Port Reset bit"] pub type Br5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR6` writer - Port Reset bit"] pub type Br6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR7` writer - Port Reset bit"] pub type Br7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR8` writer - Port Reset bit"] pub type Br8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR9` writer - Port Reset bit"] pub type Br9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR10` writer - Port Reset bit"] pub type Br10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR11` writer - Port Reset bit"] pub type Br11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR12` writer - Port Reset bit"] pub type Br12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR13` writer - Port Reset bit"] pub type Br13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR14` writer - Port Reset bit"] pub type Br14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR15` writer - Port Reset bit"] pub type Br15W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Port Reset bit"]
#[inline (always)] pub fn br0 (& mut self) -> Br0W < '_ , BrrSpec > { Br0W :: new (self , 0) }
#[doc = "Bit 1 - Port Reset bit"]
#[inline (always)] pub fn br1 (& mut self) -> Br1W < '_ , BrrSpec > { Br1W :: new (self , 1) }
#[doc = "Bit 2 - Port Reset bit"]
#[inline (always)] pub fn br2 (& mut self) -> Br2W < '_ , BrrSpec > { Br2W :: new (self , 2) }
#[doc = "Bit 3 - Port Reset bit"]
#[inline (always)] pub fn br3 (& mut self) -> Br3W < '_ , BrrSpec > { Br3W :: new (self , 3) }
#[doc = "Bit 4 - Port Reset bit"]
#[inline (always)] pub fn br4 (& mut self) -> Br4W < '_ , BrrSpec > { Br4W :: new (self , 4) }
#[doc = "Bit 5 - Port Reset bit"]
#[inline (always)] pub fn br5 (& mut self) -> Br5W < '_ , BrrSpec > { Br5W :: new (self , 5) }
#[doc = "Bit 6 - Port Reset bit"]
#[inline (always)] pub fn br6 (& mut self) -> Br6W < '_ , BrrSpec > { Br6W :: new (self , 6) }
#[doc = "Bit 7 - Port Reset bit"]
#[inline (always)] pub fn br7 (& mut self) -> Br7W < '_ , BrrSpec > { Br7W :: new (self , 7) }
#[doc = "Bit 8 - Port Reset bit"]
#[inline (always)] pub fn br8 (& mut self) -> Br8W < '_ , BrrSpec > { Br8W :: new (self , 8) }
#[doc = "Bit 9 - Port Reset bit"]
#[inline (always)] pub fn br9 (& mut self) -> Br9W < '_ , BrrSpec > { Br9W :: new (self , 9) }
#[doc = "Bit 10 - Port Reset bit"]
#[inline (always)] pub fn br10 (& mut self) -> Br10W < '_ , BrrSpec > { Br10W :: new (self , 10) }
#[doc = "Bit 11 - Port Reset bit"]
#[inline (always)] pub fn br11 (& mut self) -> Br11W < '_ , BrrSpec > { Br11W :: new (self , 11) }
#[doc = "Bit 12 - Port Reset bit"]
#[inline (always)] pub fn br12 (& mut self) -> Br12W < '_ , BrrSpec > { Br12W :: new (self , 12) }
#[doc = "Bit 13 - Port Reset bit"]
#[inline (always)] pub fn br13 (& mut self) -> Br13W < '_ , BrrSpec > { Br13W :: new (self , 13) }
#[doc = "Bit 14 - Port Reset bit"]
#[inline (always)] pub fn br14 (& mut self) -> Br14W < '_ , BrrSpec > { Br14W :: new (self , 14) }
#[doc = "Bit 15 - Port Reset bit"]
#[inline (always)] pub fn br15 (& mut self) -> Br15W < '_ , BrrSpec > { Br15W :: new (self , 15) } }
#[doc = "port bit reset register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BrrSpec ; impl crate :: RegisterSpec for BrrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`brr::W`](W) writer structure"] impl crate :: Writable for BrrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BRR to value 0"] impl crate :: Resettable for BrrSpec { } } }
#[doc = "General-purpose I/Os"] pub type Gpiod = crate :: Periph < gpioc :: RegisterBlock , 0x4800_0c00 > ; impl core :: fmt :: Debug for Gpiod { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpiod") . finish () } }
#[doc = "General-purpose I/Os"] pub use self :: gpioc as gpiod ;
#[doc = "General-purpose I/Os"] pub type Gpioe = crate :: Periph < gpioe :: RegisterBlock , 0x4800_1000 > ; impl core :: fmt :: Debug for Gpioe { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpioe") . finish () } }
#[doc = "General-purpose I/Os"] pub mod gpioe {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { moder : Moder , otyper : Otyper , ospeedr : Ospeedr , pupdr : Pupdr , idr : Idr , odr : Odr , bsrr : Bsrr , lckr : Lckr , afrl : Afrl , afrh : Afrh , brr : Brr , } impl RegisterBlock {
#[doc = "0x00 - GPIO port mode register"]
#[inline (always)] pub const fn moder (& self) -> & Moder { & self . moder }
#[doc = "0x04 - GPIO port output type register"]
#[inline (always)] pub const fn otyper (& self) -> & Otyper { & self . otyper }
#[doc = "0x08 - GPIO port output speed register"]
#[inline (always)] pub const fn ospeedr (& self) -> & Ospeedr { & self . ospeedr }
#[doc = "0x0c - GPIO port pull-up/pull-down register"]
#[inline (always)] pub const fn pupdr (& self) -> & Pupdr { & self . pupdr }
#[doc = "0x10 - GPIO port input data register"]
#[inline (always)] pub const fn idr (& self) -> & Idr { & self . idr }
#[doc = "0x14 - GPIO port output data register"]
#[inline (always)] pub const fn odr (& self) -> & Odr { & self . odr }
#[doc = "0x18 - GPIO port bit set/reset register"]
#[inline (always)] pub const fn bsrr (& self) -> & Bsrr { & self . bsrr }
#[doc = "0x1c - GPIO port configuration lock register"]
#[inline (always)] pub const fn lckr (& self) -> & Lckr { & self . lckr }
#[doc = "0x20 - GPIO alternate function low register"]
#[inline (always)] pub const fn afrl (& self) -> & Afrl { & self . afrl }
#[doc = "0x24 - GPIO alternate function high register"]
#[inline (always)] pub const fn afrh (& self) -> & Afrh { & self . afrh }
#[doc = "0x28 - port bit reset register"]
#[inline (always)] pub const fn brr (& self) -> & Brr { & self . brr } }
#[doc = "MODER (rw) register accessor: GPIO port mode register\n\nYou can [`read`](crate::Reg::read) this register and get [`moder::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`moder::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@moder`] module"]
#[doc (alias = "MODER")] pub type Moder = crate :: Reg < moder :: ModerSpec > ;
#[doc = "GPIO port mode register"] pub mod moder {
#[doc = "Register `MODER` reader"] pub type R = crate :: R < ModerSpec > ;
#[doc = "Register `MODER` writer"] pub type W = crate :: W < ModerSpec > ;
#[doc = "Field `MODER0` reader - Port x configuration bits (y = 0..15)"] pub type Moder0R = crate :: FieldReader ;
#[doc = "Field `MODER0` writer - Port x configuration bits (y = 0..15)"] pub type Moder0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER1` reader - Port x configuration bits (y = 0..15)"] pub type Moder1R = crate :: FieldReader ;
#[doc = "Field `MODER1` writer - Port x configuration bits (y = 0..15)"] pub type Moder1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER2` reader - Port x configuration bits (y = 0..15)"] pub type Moder2R = crate :: FieldReader ;
#[doc = "Field `MODER2` writer - Port x configuration bits (y = 0..15)"] pub type Moder2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER3` reader - Port x configuration bits (y = 0..15)"] pub type Moder3R = crate :: FieldReader ;
#[doc = "Field `MODER3` writer - Port x configuration bits (y = 0..15)"] pub type Moder3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER4` reader - Port x configuration bits (y = 0..15)"] pub type Moder4R = crate :: FieldReader ;
#[doc = "Field `MODER4` writer - Port x configuration bits (y = 0..15)"] pub type Moder4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder0 (& self) -> Moder0R { Moder0R :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder1 (& self) -> Moder1R { Moder1R :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder2 (& self) -> Moder2R { Moder2R :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder3 (& self) -> Moder3R { Moder3R :: new (((self . bits >> 6) & 3) as u8) }
#[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder4 (& self) -> Moder4R { Moder4R :: new (((self . bits >> 8) & 3) as u8) } } impl W {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder0 (& mut self) -> Moder0W < '_ , ModerSpec > { Moder0W :: new (self , 0) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder1 (& mut self) -> Moder1W < '_ , ModerSpec > { Moder1W :: new (self , 2) }
#[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder2 (& mut self) -> Moder2W < '_ , ModerSpec > { Moder2W :: new (self , 4) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder3 (& mut self) -> Moder3W < '_ , ModerSpec > { Moder3W :: new (self , 6) }
#[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder4 (& mut self) -> Moder4W < '_ , ModerSpec > { Moder4W :: new (self , 8) } }
#[doc = "GPIO port mode register\n\nYou can [`read`](crate::Reg::read) this register and get [`moder::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`moder::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ModerSpec ; impl crate :: RegisterSpec for ModerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`moder::R`](R) reader structure"] impl crate :: Readable for ModerSpec { }
#[doc = "`write(|w| ..)` method takes [`moder::W`](W) writer structure"] impl crate :: Writable for ModerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MODER to value 0x03ff"] impl crate :: Resettable for ModerSpec { const RESET_VALUE : u32 = 0x03ff ; } }
#[doc = "OTYPER (rw) register accessor: GPIO port output type register\n\nYou can [`read`](crate::Reg::read) this register and get [`otyper::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`otyper::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@otyper`] module"]
#[doc (alias = "OTYPER")] pub type Otyper = crate :: Reg < otyper :: OtyperSpec > ;
#[doc = "GPIO port output type register"] pub mod otyper {
#[doc = "Register `OTYPER` reader"] pub type R = crate :: R < OtyperSpec > ;
#[doc = "Register `OTYPER` writer"] pub type W = crate :: W < OtyperSpec > ;
#[doc = "Field `OT0` reader - Port x configuration bits (y = 0..15)"] pub type Ot0R = crate :: BitReader ;
#[doc = "Field `OT0` writer - Port x configuration bits (y = 0..15)"] pub type Ot0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT1` reader - Port x configuration bits (y = 0..15)"] pub type Ot1R = crate :: BitReader ;
#[doc = "Field `OT1` writer - Port x configuration bits (y = 0..15)"] pub type Ot1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT2` reader - Port x configuration bits (y = 0..15)"] pub type Ot2R = crate :: BitReader ;
#[doc = "Field `OT2` writer - Port x configuration bits (y = 0..15)"] pub type Ot2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT3` reader - Port x configuration bits (y = 0..15)"] pub type Ot3R = crate :: BitReader ;
#[doc = "Field `OT3` writer - Port x configuration bits (y = 0..15)"] pub type Ot3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT4` reader - Port x configuration bits (y = 0..15)"] pub type Ot4R = crate :: BitReader ;
#[doc = "Field `OT4` writer - Port x configuration bits (y = 0..15)"] pub type Ot4W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot0 (& self) -> Ot0R { Ot0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot1 (& self) -> Ot1R { Ot1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot2 (& self) -> Ot2R { Ot2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot3 (& self) -> Ot3R { Ot3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot4 (& self) -> Ot4R { Ot4R :: new (((self . bits >> 4) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot0 (& mut self) -> Ot0W < '_ , OtyperSpec > { Ot0W :: new (self , 0) }
#[doc = "Bit 1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot1 (& mut self) -> Ot1W < '_ , OtyperSpec > { Ot1W :: new (self , 1) }
#[doc = "Bit 2 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot2 (& mut self) -> Ot2W < '_ , OtyperSpec > { Ot2W :: new (self , 2) }
#[doc = "Bit 3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot3 (& mut self) -> Ot3W < '_ , OtyperSpec > { Ot3W :: new (self , 3) }
#[doc = "Bit 4 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot4 (& mut self) -> Ot4W < '_ , OtyperSpec > { Ot4W :: new (self , 4) } }
#[doc = "GPIO port output type register\n\nYou can [`read`](crate::Reg::read) this register and get [`otyper::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`otyper::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OtyperSpec ; impl crate :: RegisterSpec for OtyperSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`otyper::R`](R) reader structure"] impl crate :: Readable for OtyperSpec { }
#[doc = "`write(|w| ..)` method takes [`otyper::W`](W) writer structure"] impl crate :: Writable for OtyperSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OTYPER to value 0"] impl crate :: Resettable for OtyperSpec { } }
#[doc = "OSPEEDR (rw) register accessor: GPIO port output speed register\n\nYou can [`read`](crate::Reg::read) this register and get [`ospeedr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ospeedr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ospeedr`] module"]
#[doc (alias = "OSPEEDR")] pub type Ospeedr = crate :: Reg < ospeedr :: OspeedrSpec > ;
#[doc = "GPIO port output speed register"] pub mod ospeedr {
#[doc = "Register `OSPEEDR` reader"] pub type R = crate :: R < OspeedrSpec > ;
#[doc = "Register `OSPEEDR` writer"] pub type W = crate :: W < OspeedrSpec > ;
#[doc = "Field `OSPEEDR0` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr0R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR0` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR1` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr1R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR1` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR2` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr2R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR2` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR3` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr3R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR3` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR4` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr4R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR4` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr0 (& self) -> Ospeedr0R { Ospeedr0R :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr1 (& self) -> Ospeedr1R { Ospeedr1R :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr2 (& self) -> Ospeedr2R { Ospeedr2R :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr3 (& self) -> Ospeedr3R { Ospeedr3R :: new (((self . bits >> 6) & 3) as u8) }
#[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr4 (& self) -> Ospeedr4R { Ospeedr4R :: new (((self . bits >> 8) & 3) as u8) } } impl W {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr0 (& mut self) -> Ospeedr0W < '_ , OspeedrSpec > { Ospeedr0W :: new (self , 0) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr1 (& mut self) -> Ospeedr1W < '_ , OspeedrSpec > { Ospeedr1W :: new (self , 2) }
#[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr2 (& mut self) -> Ospeedr2W < '_ , OspeedrSpec > { Ospeedr2W :: new (self , 4) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr3 (& mut self) -> Ospeedr3W < '_ , OspeedrSpec > { Ospeedr3W :: new (self , 6) }
#[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr4 (& mut self) -> Ospeedr4W < '_ , OspeedrSpec > { Ospeedr4W :: new (self , 8) } }
#[doc = "GPIO port output speed register\n\nYou can [`read`](crate::Reg::read) this register and get [`ospeedr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ospeedr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OspeedrSpec ; impl crate :: RegisterSpec for OspeedrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ospeedr::R`](R) reader structure"] impl crate :: Readable for OspeedrSpec { }
#[doc = "`write(|w| ..)` method takes [`ospeedr::W`](W) writer structure"] impl crate :: Writable for OspeedrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OSPEEDR to value 0xc0"] impl crate :: Resettable for OspeedrSpec { const RESET_VALUE : u32 = 0xc0 ; } }
#[doc = "PUPDR (rw) register accessor: GPIO port pull-up/pull-down register\n\nYou can [`read`](crate::Reg::read) this register and get [`pupdr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pupdr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pupdr`] module"]
#[doc (alias = "PUPDR")] pub type Pupdr = crate :: Reg < pupdr :: PupdrSpec > ;
#[doc = "GPIO port pull-up/pull-down register"] pub mod pupdr {
#[doc = "Register `PUPDR` reader"] pub type R = crate :: R < PupdrSpec > ;
#[doc = "Register `PUPDR` writer"] pub type W = crate :: W < PupdrSpec > ;
#[doc = "Field `PUPDR0` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr0R = crate :: FieldReader ;
#[doc = "Field `PUPDR0` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR1` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr1R = crate :: FieldReader ;
#[doc = "Field `PUPDR1` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR2` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr2R = crate :: FieldReader ;
#[doc = "Field `PUPDR2` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR3` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr3R = crate :: FieldReader ;
#[doc = "Field `PUPDR3` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR4` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr4R = crate :: FieldReader ;
#[doc = "Field `PUPDR4` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr0 (& self) -> Pupdr0R { Pupdr0R :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr1 (& self) -> Pupdr1R { Pupdr1R :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr2 (& self) -> Pupdr2R { Pupdr2R :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr3 (& self) -> Pupdr3R { Pupdr3R :: new (((self . bits >> 6) & 3) as u8) }
#[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr4 (& self) -> Pupdr4R { Pupdr4R :: new (((self . bits >> 8) & 3) as u8) } } impl W {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr0 (& mut self) -> Pupdr0W < '_ , PupdrSpec > { Pupdr0W :: new (self , 0) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr1 (& mut self) -> Pupdr1W < '_ , PupdrSpec > { Pupdr1W :: new (self , 2) }
#[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr2 (& mut self) -> Pupdr2W < '_ , PupdrSpec > { Pupdr2W :: new (self , 4) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr3 (& mut self) -> Pupdr3W < '_ , PupdrSpec > { Pupdr3W :: new (self , 6) }
#[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr4 (& mut self) -> Pupdr4W < '_ , PupdrSpec > { Pupdr4W :: new (self , 8) } }
#[doc = "GPIO port pull-up/pull-down register\n\nYou can [`read`](crate::Reg::read) this register and get [`pupdr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pupdr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PupdrSpec ; impl crate :: RegisterSpec for PupdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pupdr::R`](R) reader structure"] impl crate :: Readable for PupdrSpec { }
#[doc = "`write(|w| ..)` method takes [`pupdr::W`](W) writer structure"] impl crate :: Writable for PupdrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PUPDR to value 0"] impl crate :: Resettable for PupdrSpec { } }
#[doc = "IDR (r) register accessor: GPIO port input data register\n\nYou can [`read`](crate::Reg::read) this register and get [`idr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@idr`] module"]
#[doc (alias = "IDR")] pub type Idr = crate :: Reg < idr :: IdrSpec > ;
#[doc = "GPIO port input data register"] pub mod idr {
#[doc = "Register `IDR` reader"] pub type R = crate :: R < IdrSpec > ;
#[doc = "Field `IDR0` reader - Port input data (y = 0..15)"] pub type Idr0R = crate :: BitReader ;
#[doc = "Field `IDR1` reader - Port input data (y = 0..15)"] pub type Idr1R = crate :: BitReader ;
#[doc = "Field `IDR2` reader - Port input data (y = 0..15)"] pub type Idr2R = crate :: BitReader ;
#[doc = "Field `IDR3` reader - Port input data (y = 0..15)"] pub type Idr3R = crate :: BitReader ;
#[doc = "Field `IDR4` reader - Port input data (y = 0..15)"] pub type Idr4R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr0 (& self) -> Idr0R { Idr0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr1 (& self) -> Idr1R { Idr1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr2 (& self) -> Idr2R { Idr2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr3 (& self) -> Idr3R { Idr3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr4 (& self) -> Idr4R { Idr4R :: new (((self . bits >> 4) & 1) != 0) } }
#[doc = "GPIO port input data register\n\nYou can [`read`](crate::Reg::read) this register and get [`idr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IdrSpec ; impl crate :: RegisterSpec for IdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`idr::R`](R) reader structure"] impl crate :: Readable for IdrSpec { }
#[doc = "`reset()` method sets IDR to value 0"] impl crate :: Resettable for IdrSpec { } }
#[doc = "ODR (rw) register accessor: GPIO port output data register\n\nYou can [`read`](crate::Reg::read) this register and get [`odr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`odr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@odr`] module"]
#[doc (alias = "ODR")] pub type Odr = crate :: Reg < odr :: OdrSpec > ;
#[doc = "GPIO port output data register"] pub mod odr {
#[doc = "Register `ODR` reader"] pub type R = crate :: R < OdrSpec > ;
#[doc = "Register `ODR` writer"] pub type W = crate :: W < OdrSpec > ;
#[doc = "Field `ODR0` reader - Port output data (y = 0..15)"] pub type Odr0R = crate :: BitReader ;
#[doc = "Field `ODR0` writer - Port output data (y = 0..15)"] pub type Odr0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR1` reader - Port output data (y = 0..15)"] pub type Odr1R = crate :: BitReader ;
#[doc = "Field `ODR1` writer - Port output data (y = 0..15)"] pub type Odr1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR2` reader - Port output data (y = 0..15)"] pub type Odr2R = crate :: BitReader ;
#[doc = "Field `ODR2` writer - Port output data (y = 0..15)"] pub type Odr2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR3` reader - Port output data (y = 0..15)"] pub type Odr3R = crate :: BitReader ;
#[doc = "Field `ODR3` writer - Port output data (y = 0..15)"] pub type Odr3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR4` reader - Port output data (y = 0..15)"] pub type Odr4R = crate :: BitReader ;
#[doc = "Field `ODR4` writer - Port output data (y = 0..15)"] pub type Odr4W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr0 (& self) -> Odr0R { Odr0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr1 (& self) -> Odr1R { Odr1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr2 (& self) -> Odr2R { Odr2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr3 (& self) -> Odr3R { Odr3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr4 (& self) -> Odr4R { Odr4R :: new (((self . bits >> 4) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr0 (& mut self) -> Odr0W < '_ , OdrSpec > { Odr0W :: new (self , 0) }
#[doc = "Bit 1 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr1 (& mut self) -> Odr1W < '_ , OdrSpec > { Odr1W :: new (self , 1) }
#[doc = "Bit 2 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr2 (& mut self) -> Odr2W < '_ , OdrSpec > { Odr2W :: new (self , 2) }
#[doc = "Bit 3 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr3 (& mut self) -> Odr3W < '_ , OdrSpec > { Odr3W :: new (self , 3) }
#[doc = "Bit 4 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr4 (& mut self) -> Odr4W < '_ , OdrSpec > { Odr4W :: new (self , 4) } }
#[doc = "GPIO port output data register\n\nYou can [`read`](crate::Reg::read) this register and get [`odr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`odr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OdrSpec ; impl crate :: RegisterSpec for OdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`odr::R`](R) reader structure"] impl crate :: Readable for OdrSpec { }
#[doc = "`write(|w| ..)` method takes [`odr::W`](W) writer structure"] impl crate :: Writable for OdrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ODR to value 0"] impl crate :: Resettable for OdrSpec { } }
#[doc = "BSRR (w) register accessor: GPIO port bit set/reset register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bsrr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bsrr`] module"]
#[doc (alias = "BSRR")] pub type Bsrr = crate :: Reg < bsrr :: BsrrSpec > ;
#[doc = "GPIO port bit set/reset register"] pub mod bsrr {
#[doc = "Register `BSRR` writer"] pub type W = crate :: W < BsrrSpec > ;
#[doc = "Field `BS0` writer - Port x set bit y (y= 0..15)"] pub type Bs0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS1` writer - Port x set bit y (y= 0..15)"] pub type Bs1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS2` writer - Port x set bit y (y= 0..15)"] pub type Bs2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS3` writer - Port x set bit y (y= 0..15)"] pub type Bs3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS4` writer - Port x set bit y (y= 0..15)"] pub type Bs4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR0` writer - Port x set bit y (y= 0..15)"] pub type Br0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR1` writer - Port x reset bit y (y = 0..15)"] pub type Br1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR2` writer - Port x reset bit y (y = 0..15)"] pub type Br2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR3` writer - Port x reset bit y (y = 0..15)"] pub type Br3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR4` writer - Port x reset bit y (y = 0..15)"] pub type Br4W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs0 (& mut self) -> Bs0W < '_ , BsrrSpec > { Bs0W :: new (self , 0) }
#[doc = "Bit 1 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs1 (& mut self) -> Bs1W < '_ , BsrrSpec > { Bs1W :: new (self , 1) }
#[doc = "Bit 2 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs2 (& mut self) -> Bs2W < '_ , BsrrSpec > { Bs2W :: new (self , 2) }
#[doc = "Bit 3 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs3 (& mut self) -> Bs3W < '_ , BsrrSpec > { Bs3W :: new (self , 3) }
#[doc = "Bit 4 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs4 (& mut self) -> Bs4W < '_ , BsrrSpec > { Bs4W :: new (self , 4) }
#[doc = "Bit 16 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn br0 (& mut self) -> Br0W < '_ , BsrrSpec > { Br0W :: new (self , 16) }
#[doc = "Bit 17 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br1 (& mut self) -> Br1W < '_ , BsrrSpec > { Br1W :: new (self , 17) }
#[doc = "Bit 18 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br2 (& mut self) -> Br2W < '_ , BsrrSpec > { Br2W :: new (self , 18) }
#[doc = "Bit 19 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br3 (& mut self) -> Br3W < '_ , BsrrSpec > { Br3W :: new (self , 19) }
#[doc = "Bit 20 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br4 (& mut self) -> Br4W < '_ , BsrrSpec > { Br4W :: new (self , 20) } }
#[doc = "GPIO port bit set/reset register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bsrr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BsrrSpec ; impl crate :: RegisterSpec for BsrrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`bsrr::W`](W) writer structure"] impl crate :: Writable for BsrrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BSRR to value 0"] impl crate :: Resettable for BsrrSpec { } }
#[doc = "LCKR (rw) register accessor: GPIO port configuration lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`lckr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lckr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lckr`] module"]
#[doc (alias = "LCKR")] pub type Lckr = crate :: Reg < lckr :: LckrSpec > ;
#[doc = "GPIO port configuration lock register"] pub mod lckr {
#[doc = "Register `LCKR` reader"] pub type R = crate :: R < LckrSpec > ;
#[doc = "Register `LCKR` writer"] pub type W = crate :: W < LckrSpec > ;
#[doc = "Field `LCK0` reader - Port x lock bit y (y= 0..15)"] pub type Lck0R = crate :: BitReader ;
#[doc = "Field `LCK0` writer - Port x lock bit y (y= 0..15)"] pub type Lck0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK1` reader - Port x lock bit y (y= 0..15)"] pub type Lck1R = crate :: BitReader ;
#[doc = "Field `LCK1` writer - Port x lock bit y (y= 0..15)"] pub type Lck1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK2` reader - Port x lock bit y (y= 0..15)"] pub type Lck2R = crate :: BitReader ;
#[doc = "Field `LCK2` writer - Port x lock bit y (y= 0..15)"] pub type Lck2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK3` reader - Port x lock bit y (y= 0..15)"] pub type Lck3R = crate :: BitReader ;
#[doc = "Field `LCK3` writer - Port x lock bit y (y= 0..15)"] pub type Lck3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK4` reader - Port x lock bit y (y= 0..15)"] pub type Lck4R = crate :: BitReader ;
#[doc = "Field `LCK4` writer - Port x lock bit y (y= 0..15)"] pub type Lck4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCKK` reader - Port x lock bit y (y= 0..15)"] pub type LckkR = crate :: BitReader ;
#[doc = "Field `LCKK` writer - Port x lock bit y (y= 0..15)"] pub type LckkW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck0 (& self) -> Lck0R { Lck0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck1 (& self) -> Lck1R { Lck1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck2 (& self) -> Lck2R { Lck2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck3 (& self) -> Lck3R { Lck3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck4 (& self) -> Lck4R { Lck4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 16 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lckk (& self) -> LckkR { LckkR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck0 (& mut self) -> Lck0W < '_ , LckrSpec > { Lck0W :: new (self , 0) }
#[doc = "Bit 1 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck1 (& mut self) -> Lck1W < '_ , LckrSpec > { Lck1W :: new (self , 1) }
#[doc = "Bit 2 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck2 (& mut self) -> Lck2W < '_ , LckrSpec > { Lck2W :: new (self , 2) }
#[doc = "Bit 3 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck3 (& mut self) -> Lck3W < '_ , LckrSpec > { Lck3W :: new (self , 3) }
#[doc = "Bit 4 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck4 (& mut self) -> Lck4W < '_ , LckrSpec > { Lck4W :: new (self , 4) }
#[doc = "Bit 16 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lckk (& mut self) -> LckkW < '_ , LckrSpec > { LckkW :: new (self , 16) } }
#[doc = "GPIO port configuration lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`lckr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lckr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct LckrSpec ; impl crate :: RegisterSpec for LckrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`lckr::R`](R) reader structure"] impl crate :: Readable for LckrSpec { }
#[doc = "`write(|w| ..)` method takes [`lckr::W`](W) writer structure"] impl crate :: Writable for LckrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets LCKR to value 0"] impl crate :: Resettable for LckrSpec { } }
#[doc = "AFRL (rw) register accessor: GPIO alternate function low register\n\nYou can [`read`](crate::Reg::read) this register and get [`afrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@afrl`] module"]
#[doc (alias = "AFRL")] pub type Afrl = crate :: Reg < afrl :: AfrlSpec > ;
#[doc = "GPIO alternate function low register"] pub mod afrl {
#[doc = "Register `AFRL` reader"] pub type R = crate :: R < AfrlSpec > ;
#[doc = "Register `AFRL` writer"] pub type W = crate :: W < AfrlSpec > ;
#[doc = "Field `AFSEL0` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel0R = crate :: FieldReader ;
#[doc = "Field `AFSEL0` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL1` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel1R = crate :: FieldReader ;
#[doc = "Field `AFSEL1` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL2` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel2R = crate :: FieldReader ;
#[doc = "Field `AFSEL2` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL3` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel3R = crate :: FieldReader ;
#[doc = "Field `AFSEL3` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL4` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel4R = crate :: FieldReader ;
#[doc = "Field `AFSEL4` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel0 (& self) -> Afsel0R { Afsel0R :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel1 (& self) -> Afsel1R { Afsel1R :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel2 (& self) -> Afsel2R { Afsel2R :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel3 (& self) -> Afsel3R { Afsel3R :: new (((self . bits >> 12) & 0x0f) as u8) }
#[doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel4 (& self) -> Afsel4R { Afsel4R :: new (((self . bits >> 16) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel0 (& mut self) -> Afsel0W < '_ , AfrlSpec > { Afsel0W :: new (self , 0) }
#[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel1 (& mut self) -> Afsel1W < '_ , AfrlSpec > { Afsel1W :: new (self , 4) }
#[doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel2 (& mut self) -> Afsel2W < '_ , AfrlSpec > { Afsel2W :: new (self , 8) }
#[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel3 (& mut self) -> Afsel3W < '_ , AfrlSpec > { Afsel3W :: new (self , 12) }
#[doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel4 (& mut self) -> Afsel4W < '_ , AfrlSpec > { Afsel4W :: new (self , 16) } }
#[doc = "GPIO alternate function low register\n\nYou can [`read`](crate::Reg::read) this register and get [`afrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AfrlSpec ; impl crate :: RegisterSpec for AfrlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`afrl::R`](R) reader structure"] impl crate :: Readable for AfrlSpec { }
#[doc = "`write(|w| ..)` method takes [`afrl::W`](W) writer structure"] impl crate :: Writable for AfrlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AFRL to value 0"] impl crate :: Resettable for AfrlSpec { } }
#[doc = "AFRH (rw) register accessor: GPIO alternate function high register\n\nYou can [`read`](crate::Reg::read) this register and get [`afrh::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrh::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@afrh`] module"]
#[doc (alias = "AFRH")] pub type Afrh = crate :: Reg < afrh :: AfrhSpec > ;
#[doc = "GPIO alternate function high register"] pub mod afrh {
#[doc = "Register `AFRH` reader"] pub type R = crate :: R < AfrhSpec > ;
#[doc = "Register `AFRH` writer"] pub type W = crate :: W < AfrhSpec > ;
#[doc = "Field `AFSEL8` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel8R = crate :: FieldReader ;
#[doc = "Field `AFSEL8` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL9` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel9R = crate :: FieldReader ;
#[doc = "Field `AFSEL9` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL10` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel10R = crate :: FieldReader ;
#[doc = "Field `AFSEL10` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL11` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel11R = crate :: FieldReader ;
#[doc = "Field `AFSEL11` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL12` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel12R = crate :: FieldReader ;
#[doc = "Field `AFSEL12` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL13` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel13R = crate :: FieldReader ;
#[doc = "Field `AFSEL13` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL14` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel14R = crate :: FieldReader ;
#[doc = "Field `AFSEL14` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL15` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel15R = crate :: FieldReader ;
#[doc = "Field `AFSEL15` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel8 (& self) -> Afsel8R { Afsel8R :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel9 (& self) -> Afsel9R { Afsel9R :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel10 (& self) -> Afsel10R { Afsel10R :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel11 (& self) -> Afsel11R { Afsel11R :: new (((self . bits >> 12) & 0x0f) as u8) }
#[doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel12 (& self) -> Afsel12R { Afsel12R :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel13 (& self) -> Afsel13R { Afsel13R :: new (((self . bits >> 20) & 0x0f) as u8) }
#[doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel14 (& self) -> Afsel14R { Afsel14R :: new (((self . bits >> 24) & 0x0f) as u8) }
#[doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel15 (& self) -> Afsel15R { Afsel15R :: new (((self . bits >> 28) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel8 (& mut self) -> Afsel8W < '_ , AfrhSpec > { Afsel8W :: new (self , 0) }
#[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel9 (& mut self) -> Afsel9W < '_ , AfrhSpec > { Afsel9W :: new (self , 4) }
#[doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel10 (& mut self) -> Afsel10W < '_ , AfrhSpec > { Afsel10W :: new (self , 8) }
#[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel11 (& mut self) -> Afsel11W < '_ , AfrhSpec > { Afsel11W :: new (self , 12) }
#[doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel12 (& mut self) -> Afsel12W < '_ , AfrhSpec > { Afsel12W :: new (self , 16) }
#[doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel13 (& mut self) -> Afsel13W < '_ , AfrhSpec > { Afsel13W :: new (self , 20) }
#[doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel14 (& mut self) -> Afsel14W < '_ , AfrhSpec > { Afsel14W :: new (self , 24) }
#[doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel15 (& mut self) -> Afsel15W < '_ , AfrhSpec > { Afsel15W :: new (self , 28) } }
#[doc = "GPIO alternate function high register\n\nYou can [`read`](crate::Reg::read) this register and get [`afrh::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrh::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AfrhSpec ; impl crate :: RegisterSpec for AfrhSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`afrh::R`](R) reader structure"] impl crate :: Readable for AfrhSpec { }
#[doc = "`write(|w| ..)` method takes [`afrh::W`](W) writer structure"] impl crate :: Writable for AfrhSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AFRH to value 0"] impl crate :: Resettable for AfrhSpec { } }
#[doc = "BRR (w) register accessor: port bit reset register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@brr`] module"]
#[doc (alias = "BRR")] pub type Brr = crate :: Reg < brr :: BrrSpec > ;
#[doc = "port bit reset register"] pub mod brr {
#[doc = "Register `BRR` writer"] pub type W = crate :: W < BrrSpec > ;
#[doc = "Field `BR0` writer - Port Reset bit"] pub type Br0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR1` writer - Port Reset bit"] pub type Br1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR2` writer - Port Reset bit"] pub type Br2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR3` writer - Port Reset bit"] pub type Br3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR4` writer - Port Reset bit"] pub type Br4W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Port Reset bit"]
#[inline (always)] pub fn br0 (& mut self) -> Br0W < '_ , BrrSpec > { Br0W :: new (self , 0) }
#[doc = "Bit 1 - Port Reset bit"]
#[inline (always)] pub fn br1 (& mut self) -> Br1W < '_ , BrrSpec > { Br1W :: new (self , 1) }
#[doc = "Bit 2 - Port Reset bit"]
#[inline (always)] pub fn br2 (& mut self) -> Br2W < '_ , BrrSpec > { Br2W :: new (self , 2) }
#[doc = "Bit 3 - Port Reset bit"]
#[inline (always)] pub fn br3 (& mut self) -> Br3W < '_ , BrrSpec > { Br3W :: new (self , 3) }
#[doc = "Bit 4 - Port Reset bit"]
#[inline (always)] pub fn br4 (& mut self) -> Br4W < '_ , BrrSpec > { Br4W :: new (self , 4) } }
#[doc = "port bit reset register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BrrSpec ; impl crate :: RegisterSpec for BrrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`brr::W`](W) writer structure"] impl crate :: Writable for BrrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BRR to value 0"] impl crate :: Resettable for BrrSpec { } } }
#[doc = "General-purpose I/Os"] pub type Gpioh = crate :: Periph < gpioh :: RegisterBlock , 0x4800_1c00 > ; impl core :: fmt :: Debug for Gpioh { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpioh") . finish () } }
#[doc = "General-purpose I/Os"] pub mod gpioh {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { moder : Moder , otyper : Otyper , ospeedr : Ospeedr , pupdr : Pupdr , idr : Idr , odr : Odr , bsrr : Bsrr , lckr : Lckr , afrl : Afrl , afrh : Afrh , brr : Brr , } impl RegisterBlock {
#[doc = "0x00 - GPIO port mode register"]
#[inline (always)] pub const fn moder (& self) -> & Moder { & self . moder }
#[doc = "0x04 - GPIO port output type register"]
#[inline (always)] pub const fn otyper (& self) -> & Otyper { & self . otyper }
#[doc = "0x08 - GPIO port output speed register"]
#[inline (always)] pub const fn ospeedr (& self) -> & Ospeedr { & self . ospeedr }
#[doc = "0x0c - GPIO port pull-up/pull-down register"]
#[inline (always)] pub const fn pupdr (& self) -> & Pupdr { & self . pupdr }
#[doc = "0x10 - GPIO port input data register"]
#[inline (always)] pub const fn idr (& self) -> & Idr { & self . idr }
#[doc = "0x14 - GPIO port output data register"]
#[inline (always)] pub const fn odr (& self) -> & Odr { & self . odr }
#[doc = "0x18 - GPIO port bit set/reset register"]
#[inline (always)] pub const fn bsrr (& self) -> & Bsrr { & self . bsrr }
#[doc = "0x1c - GPIO port configuration lock register"]
#[inline (always)] pub const fn lckr (& self) -> & Lckr { & self . lckr }
#[doc = "0x20 - GPIO alternate function low register"]
#[inline (always)] pub const fn afrl (& self) -> & Afrl { & self . afrl }
#[doc = "0x24 - GPIO alternate function high register"]
#[inline (always)] pub const fn afrh (& self) -> & Afrh { & self . afrh }
#[doc = "0x28 - port bit reset register"]
#[inline (always)] pub const fn brr (& self) -> & Brr { & self . brr } }
#[doc = "MODER (rw) register accessor: GPIO port mode register\n\nYou can [`read`](crate::Reg::read) this register and get [`moder::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`moder::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@moder`] module"]
#[doc (alias = "MODER")] pub type Moder = crate :: Reg < moder :: ModerSpec > ;
#[doc = "GPIO port mode register"] pub mod moder {
#[doc = "Register `MODER` reader"] pub type R = crate :: R < ModerSpec > ;
#[doc = "Register `MODER` writer"] pub type W = crate :: W < ModerSpec > ;
#[doc = "Field `MODER0` reader - Port x configuration bits (y = 0..15)"] pub type Moder0R = crate :: FieldReader ;
#[doc = "Field `MODER0` writer - Port x configuration bits (y = 0..15)"] pub type Moder0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER1` reader - Port x configuration bits (y = 0..15)"] pub type Moder1R = crate :: FieldReader ;
#[doc = "Field `MODER1` writer - Port x configuration bits (y = 0..15)"] pub type Moder1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODER3` reader - Port x configuration bits (y = 0..15)"] pub type Moder3R = crate :: FieldReader ;
#[doc = "Field `MODER3` writer - Port x configuration bits (y = 0..15)"] pub type Moder3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder0 (& self) -> Moder0R { Moder0R :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder1 (& self) -> Moder1R { Moder1R :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder3 (& self) -> Moder3R { Moder3R :: new (((self . bits >> 6) & 3) as u8) } } impl W {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder0 (& mut self) -> Moder0W < '_ , ModerSpec > { Moder0W :: new (self , 0) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder1 (& mut self) -> Moder1W < '_ , ModerSpec > { Moder1W :: new (self , 2) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn moder3 (& mut self) -> Moder3W < '_ , ModerSpec > { Moder3W :: new (self , 6) } }
#[doc = "GPIO port mode register\n\nYou can [`read`](crate::Reg::read) this register and get [`moder::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`moder::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ModerSpec ; impl crate :: RegisterSpec for ModerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`moder::R`](R) reader structure"] impl crate :: Readable for ModerSpec { }
#[doc = "`write(|w| ..)` method takes [`moder::W`](W) writer structure"] impl crate :: Writable for ModerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MODER to value 0xcf"] impl crate :: Resettable for ModerSpec { const RESET_VALUE : u32 = 0xcf ; } }
#[doc = "OTYPER (rw) register accessor: GPIO port output type register\n\nYou can [`read`](crate::Reg::read) this register and get [`otyper::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`otyper::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@otyper`] module"]
#[doc (alias = "OTYPER")] pub type Otyper = crate :: Reg < otyper :: OtyperSpec > ;
#[doc = "GPIO port output type register"] pub mod otyper {
#[doc = "Register `OTYPER` reader"] pub type R = crate :: R < OtyperSpec > ;
#[doc = "Register `OTYPER` writer"] pub type W = crate :: W < OtyperSpec > ;
#[doc = "Field `OT0` reader - Port x configuration bits (y = 0..15)"] pub type Ot0R = crate :: BitReader ;
#[doc = "Field `OT0` writer - Port x configuration bits (y = 0..15)"] pub type Ot0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT1` reader - Port x configuration bits (y = 0..15)"] pub type Ot1R = crate :: BitReader ;
#[doc = "Field `OT1` writer - Port x configuration bits (y = 0..15)"] pub type Ot1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OT3` reader - Port x configuration bits (y = 0..15)"] pub type Ot3R = crate :: BitReader ;
#[doc = "Field `OT3` writer - Port x configuration bits (y = 0..15)"] pub type Ot3W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot0 (& self) -> Ot0R { Ot0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot1 (& self) -> Ot1R { Ot1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot3 (& self) -> Ot3R { Ot3R :: new (((self . bits >> 3) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot0 (& mut self) -> Ot0W < '_ , OtyperSpec > { Ot0W :: new (self , 0) }
#[doc = "Bit 1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot1 (& mut self) -> Ot1W < '_ , OtyperSpec > { Ot1W :: new (self , 1) }
#[doc = "Bit 3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ot3 (& mut self) -> Ot3W < '_ , OtyperSpec > { Ot3W :: new (self , 3) } }
#[doc = "GPIO port output type register\n\nYou can [`read`](crate::Reg::read) this register and get [`otyper::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`otyper::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OtyperSpec ; impl crate :: RegisterSpec for OtyperSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`otyper::R`](R) reader structure"] impl crate :: Readable for OtyperSpec { }
#[doc = "`write(|w| ..)` method takes [`otyper::W`](W) writer structure"] impl crate :: Writable for OtyperSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OTYPER to value 0"] impl crate :: Resettable for OtyperSpec { } }
#[doc = "OSPEEDR (rw) register accessor: GPIO port output speed register\n\nYou can [`read`](crate::Reg::read) this register and get [`ospeedr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ospeedr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ospeedr`] module"]
#[doc (alias = "OSPEEDR")] pub type Ospeedr = crate :: Reg < ospeedr :: OspeedrSpec > ;
#[doc = "GPIO port output speed register"] pub mod ospeedr {
#[doc = "Register `OSPEEDR` reader"] pub type R = crate :: R < OspeedrSpec > ;
#[doc = "Register `OSPEEDR` writer"] pub type W = crate :: W < OspeedrSpec > ;
#[doc = "Field `OSPEEDR0` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr0R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR0` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR1` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr1R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR1` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSPEEDR3` reader - Port x configuration bits (y = 0..15)"] pub type Ospeedr3R = crate :: FieldReader ;
#[doc = "Field `OSPEEDR3` writer - Port x configuration bits (y = 0..15)"] pub type Ospeedr3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr0 (& self) -> Ospeedr0R { Ospeedr0R :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr1 (& self) -> Ospeedr1R { Ospeedr1R :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr3 (& self) -> Ospeedr3R { Ospeedr3R :: new (((self . bits >> 6) & 3) as u8) } } impl W {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr0 (& mut self) -> Ospeedr0W < '_ , OspeedrSpec > { Ospeedr0W :: new (self , 0) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr1 (& mut self) -> Ospeedr1W < '_ , OspeedrSpec > { Ospeedr1W :: new (self , 2) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn ospeedr3 (& mut self) -> Ospeedr3W < '_ , OspeedrSpec > { Ospeedr3W :: new (self , 6) } }
#[doc = "GPIO port output speed register\n\nYou can [`read`](crate::Reg::read) this register and get [`ospeedr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ospeedr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OspeedrSpec ; impl crate :: RegisterSpec for OspeedrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ospeedr::R`](R) reader structure"] impl crate :: Readable for OspeedrSpec { }
#[doc = "`write(|w| ..)` method takes [`ospeedr::W`](W) writer structure"] impl crate :: Writable for OspeedrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OSPEEDR to value 0"] impl crate :: Resettable for OspeedrSpec { } }
#[doc = "PUPDR (rw) register accessor: GPIO port pull-up/pull-down register\n\nYou can [`read`](crate::Reg::read) this register and get [`pupdr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pupdr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pupdr`] module"]
#[doc (alias = "PUPDR")] pub type Pupdr = crate :: Reg < pupdr :: PupdrSpec > ;
#[doc = "GPIO port pull-up/pull-down register"] pub mod pupdr {
#[doc = "Register `PUPDR` reader"] pub type R = crate :: R < PupdrSpec > ;
#[doc = "Register `PUPDR` writer"] pub type W = crate :: W < PupdrSpec > ;
#[doc = "Field `PUPDR0` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr0R = crate :: FieldReader ;
#[doc = "Field `PUPDR0` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR1` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr1R = crate :: FieldReader ;
#[doc = "Field `PUPDR1` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PUPDR3` reader - Port x configuration bits (y = 0..15)"] pub type Pupdr3R = crate :: FieldReader ;
#[doc = "Field `PUPDR3` writer - Port x configuration bits (y = 0..15)"] pub type Pupdr3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr0 (& self) -> Pupdr0R { Pupdr0R :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr1 (& self) -> Pupdr1R { Pupdr1R :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr3 (& self) -> Pupdr3R { Pupdr3R :: new (((self . bits >> 6) & 3) as u8) } } impl W {
#[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr0 (& mut self) -> Pupdr0W < '_ , PupdrSpec > { Pupdr0W :: new (self , 0) }
#[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr1 (& mut self) -> Pupdr1W < '_ , PupdrSpec > { Pupdr1W :: new (self , 2) }
#[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
#[inline (always)] pub fn pupdr3 (& mut self) -> Pupdr3W < '_ , PupdrSpec > { Pupdr3W :: new (self , 6) } }
#[doc = "GPIO port pull-up/pull-down register\n\nYou can [`read`](crate::Reg::read) this register and get [`pupdr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pupdr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PupdrSpec ; impl crate :: RegisterSpec for PupdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pupdr::R`](R) reader structure"] impl crate :: Readable for PupdrSpec { }
#[doc = "`write(|w| ..)` method takes [`pupdr::W`](W) writer structure"] impl crate :: Writable for PupdrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PUPDR to value 0"] impl crate :: Resettable for PupdrSpec { } }
#[doc = "IDR (r) register accessor: GPIO port input data register\n\nYou can [`read`](crate::Reg::read) this register and get [`idr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@idr`] module"]
#[doc (alias = "IDR")] pub type Idr = crate :: Reg < idr :: IdrSpec > ;
#[doc = "GPIO port input data register"] pub mod idr {
#[doc = "Register `IDR` reader"] pub type R = crate :: R < IdrSpec > ;
#[doc = "Field `IDR0` reader - Port input data (y = 0..15)"] pub type Idr0R = crate :: BitReader ;
#[doc = "Field `IDR1` reader - Port input data (y = 0..15)"] pub type Idr1R = crate :: BitReader ;
#[doc = "Field `IDR3` reader - Port input data (y = 0..15)"] pub type Idr3R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr0 (& self) -> Idr0R { Idr0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr1 (& self) -> Idr1R { Idr1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - Port input data (y = 0..15)"]
#[inline (always)] pub fn idr3 (& self) -> Idr3R { Idr3R :: new (((self . bits >> 3) & 1) != 0) } }
#[doc = "GPIO port input data register\n\nYou can [`read`](crate::Reg::read) this register and get [`idr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IdrSpec ; impl crate :: RegisterSpec for IdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`idr::R`](R) reader structure"] impl crate :: Readable for IdrSpec { }
#[doc = "`reset()` method sets IDR to value 0"] impl crate :: Resettable for IdrSpec { } }
#[doc = "ODR (rw) register accessor: GPIO port output data register\n\nYou can [`read`](crate::Reg::read) this register and get [`odr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`odr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@odr`] module"]
#[doc (alias = "ODR")] pub type Odr = crate :: Reg < odr :: OdrSpec > ;
#[doc = "GPIO port output data register"] pub mod odr {
#[doc = "Register `ODR` reader"] pub type R = crate :: R < OdrSpec > ;
#[doc = "Register `ODR` writer"] pub type W = crate :: W < OdrSpec > ;
#[doc = "Field `ODR0` reader - Port output data (y = 0..15)"] pub type Odr0R = crate :: BitReader ;
#[doc = "Field `ODR0` writer - Port output data (y = 0..15)"] pub type Odr0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR1` reader - Port output data (y = 0..15)"] pub type Odr1R = crate :: BitReader ;
#[doc = "Field `ODR1` writer - Port output data (y = 0..15)"] pub type Odr1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR3` reader - Port output data (y = 0..15)"] pub type Odr3R = crate :: BitReader ;
#[doc = "Field `ODR3` writer - Port output data (y = 0..15)"] pub type Odr3W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr0 (& self) -> Odr0R { Odr0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr1 (& self) -> Odr1R { Odr1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr3 (& self) -> Odr3R { Odr3R :: new (((self . bits >> 3) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr0 (& mut self) -> Odr0W < '_ , OdrSpec > { Odr0W :: new (self , 0) }
#[doc = "Bit 1 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr1 (& mut self) -> Odr1W < '_ , OdrSpec > { Odr1W :: new (self , 1) }
#[doc = "Bit 3 - Port output data (y = 0..15)"]
#[inline (always)] pub fn odr3 (& mut self) -> Odr3W < '_ , OdrSpec > { Odr3W :: new (self , 3) } }
#[doc = "GPIO port output data register\n\nYou can [`read`](crate::Reg::read) this register and get [`odr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`odr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OdrSpec ; impl crate :: RegisterSpec for OdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`odr::R`](R) reader structure"] impl crate :: Readable for OdrSpec { }
#[doc = "`write(|w| ..)` method takes [`odr::W`](W) writer structure"] impl crate :: Writable for OdrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ODR to value 0"] impl crate :: Resettable for OdrSpec { } }
#[doc = "BSRR (w) register accessor: GPIO port bit set/reset register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bsrr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bsrr`] module"]
#[doc (alias = "BSRR")] pub type Bsrr = crate :: Reg < bsrr :: BsrrSpec > ;
#[doc = "GPIO port bit set/reset register"] pub mod bsrr {
#[doc = "Register `BSRR` writer"] pub type W = crate :: W < BsrrSpec > ;
#[doc = "Field `BS0` writer - Port x set bit y (y= 0..15)"] pub type Bs0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS1` writer - Port x set bit y (y= 0..15)"] pub type Bs1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS3` writer - Port x set bit y (y= 0..15)"] pub type Bs3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR0` writer - Port x set bit y (y= 0..15)"] pub type Br0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR1` writer - Port x reset bit y (y = 0..15)"] pub type Br1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR3` writer - Port x reset bit y (y = 0..15)"] pub type Br3W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs0 (& mut self) -> Bs0W < '_ , BsrrSpec > { Bs0W :: new (self , 0) }
#[doc = "Bit 1 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs1 (& mut self) -> Bs1W < '_ , BsrrSpec > { Bs1W :: new (self , 1) }
#[doc = "Bit 3 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn bs3 (& mut self) -> Bs3W < '_ , BsrrSpec > { Bs3W :: new (self , 3) }
#[doc = "Bit 16 - Port x set bit y (y= 0..15)"]
#[inline (always)] pub fn br0 (& mut self) -> Br0W < '_ , BsrrSpec > { Br0W :: new (self , 16) }
#[doc = "Bit 17 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br1 (& mut self) -> Br1W < '_ , BsrrSpec > { Br1W :: new (self , 17) }
#[doc = "Bit 19 - Port x reset bit y (y = 0..15)"]
#[inline (always)] pub fn br3 (& mut self) -> Br3W < '_ , BsrrSpec > { Br3W :: new (self , 19) } }
#[doc = "GPIO port bit set/reset register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bsrr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BsrrSpec ; impl crate :: RegisterSpec for BsrrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`bsrr::W`](W) writer structure"] impl crate :: Writable for BsrrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BSRR to value 0"] impl crate :: Resettable for BsrrSpec { } }
#[doc = "LCKR (rw) register accessor: GPIO port configuration lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`lckr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lckr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lckr`] module"]
#[doc (alias = "LCKR")] pub type Lckr = crate :: Reg < lckr :: LckrSpec > ;
#[doc = "GPIO port configuration lock register"] pub mod lckr {
#[doc = "Register `LCKR` reader"] pub type R = crate :: R < LckrSpec > ;
#[doc = "Register `LCKR` writer"] pub type W = crate :: W < LckrSpec > ;
#[doc = "Field `LCK0` reader - Port x lock bit y (y= 0..15)"] pub type Lck0R = crate :: BitReader ;
#[doc = "Field `LCK0` writer - Port x lock bit y (y= 0..15)"] pub type Lck0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK1` reader - Port x lock bit y (y= 0..15)"] pub type Lck1R = crate :: BitReader ;
#[doc = "Field `LCK1` writer - Port x lock bit y (y= 0..15)"] pub type Lck1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK3` reader - Port x lock bit y (y= 0..15)"] pub type Lck3R = crate :: BitReader ;
#[doc = "Field `LCK3` writer - Port x lock bit y (y= 0..15)"] pub type Lck3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCKK` reader - Port x lock bit y (y= 0..15)"] pub type LckkR = crate :: BitReader ;
#[doc = "Field `LCKK` writer - Port x lock bit y (y= 0..15)"] pub type LckkW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck0 (& self) -> Lck0R { Lck0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck1 (& self) -> Lck1R { Lck1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck3 (& self) -> Lck3R { Lck3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 16 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lckk (& self) -> LckkR { LckkR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck0 (& mut self) -> Lck0W < '_ , LckrSpec > { Lck0W :: new (self , 0) }
#[doc = "Bit 1 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck1 (& mut self) -> Lck1W < '_ , LckrSpec > { Lck1W :: new (self , 1) }
#[doc = "Bit 3 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lck3 (& mut self) -> Lck3W < '_ , LckrSpec > { Lck3W :: new (self , 3) }
#[doc = "Bit 16 - Port x lock bit y (y= 0..15)"]
#[inline (always)] pub fn lckk (& mut self) -> LckkW < '_ , LckrSpec > { LckkW :: new (self , 16) } }
#[doc = "GPIO port configuration lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`lckr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lckr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct LckrSpec ; impl crate :: RegisterSpec for LckrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`lckr::R`](R) reader structure"] impl crate :: Readable for LckrSpec { }
#[doc = "`write(|w| ..)` method takes [`lckr::W`](W) writer structure"] impl crate :: Writable for LckrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets LCKR to value 0"] impl crate :: Resettable for LckrSpec { } }
#[doc = "AFRL (rw) register accessor: GPIO alternate function low register\n\nYou can [`read`](crate::Reg::read) this register and get [`afrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@afrl`] module"]
#[doc (alias = "AFRL")] pub type Afrl = crate :: Reg < afrl :: AfrlSpec > ;
#[doc = "GPIO alternate function low register"] pub mod afrl {
#[doc = "Register `AFRL` reader"] pub type R = crate :: R < AfrlSpec > ;
#[doc = "Register `AFRL` writer"] pub type W = crate :: W < AfrlSpec > ;
#[doc = "Field `AFSEL0` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel0R = crate :: FieldReader ;
#[doc = "Field `AFSEL0` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL1` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel1R = crate :: FieldReader ;
#[doc = "Field `AFSEL1` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL3` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel3R = crate :: FieldReader ;
#[doc = "Field `AFSEL3` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type Afsel3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel0 (& self) -> Afsel0R { Afsel0R :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel1 (& self) -> Afsel1R { Afsel1R :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel3 (& self) -> Afsel3R { Afsel3R :: new (((self . bits >> 12) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel0 (& mut self) -> Afsel0W < '_ , AfrlSpec > { Afsel0W :: new (self , 0) }
#[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel1 (& mut self) -> Afsel1W < '_ , AfrlSpec > { Afsel1W :: new (self , 4) }
#[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 0..7)"]
#[inline (always)] pub fn afsel3 (& mut self) -> Afsel3W < '_ , AfrlSpec > { Afsel3W :: new (self , 12) } }
#[doc = "GPIO alternate function low register\n\nYou can [`read`](crate::Reg::read) this register and get [`afrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AfrlSpec ; impl crate :: RegisterSpec for AfrlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`afrl::R`](R) reader structure"] impl crate :: Readable for AfrlSpec { }
#[doc = "`write(|w| ..)` method takes [`afrl::W`](W) writer structure"] impl crate :: Writable for AfrlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AFRL to value 0"] impl crate :: Resettable for AfrlSpec { } }
#[doc = "AFRH (rw) register accessor: GPIO alternate function high register\n\nYou can [`read`](crate::Reg::read) this register and get [`afrh::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrh::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@afrh`] module"]
#[doc (alias = "AFRH")] pub type Afrh = crate :: Reg < afrh :: AfrhSpec > ;
#[doc = "GPIO alternate function high register"] pub mod afrh {
#[doc = "Register `AFRH` reader"] pub type R = crate :: R < AfrhSpec > ;
#[doc = "Register `AFRH` writer"] pub type W = crate :: W < AfrhSpec > ;
#[doc = "Field `AFSEL8` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel8R = crate :: FieldReader ;
#[doc = "Field `AFSEL8` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL9` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel9R = crate :: FieldReader ;
#[doc = "Field `AFSEL9` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL10` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel10R = crate :: FieldReader ;
#[doc = "Field `AFSEL10` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL11` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel11R = crate :: FieldReader ;
#[doc = "Field `AFSEL11` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL12` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel12R = crate :: FieldReader ;
#[doc = "Field `AFSEL12` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL13` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel13R = crate :: FieldReader ;
#[doc = "Field `AFSEL13` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL14` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel14R = crate :: FieldReader ;
#[doc = "Field `AFSEL14` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFSEL15` reader - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel15R = crate :: FieldReader ;
#[doc = "Field `AFSEL15` writer - Alternate function selection for port x bit y (y = 8..15)"] pub type Afsel15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel8 (& self) -> Afsel8R { Afsel8R :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel9 (& self) -> Afsel9R { Afsel9R :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel10 (& self) -> Afsel10R { Afsel10R :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel11 (& self) -> Afsel11R { Afsel11R :: new (((self . bits >> 12) & 0x0f) as u8) }
#[doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel12 (& self) -> Afsel12R { Afsel12R :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel13 (& self) -> Afsel13R { Afsel13R :: new (((self . bits >> 20) & 0x0f) as u8) }
#[doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel14 (& self) -> Afsel14R { Afsel14R :: new (((self . bits >> 24) & 0x0f) as u8) }
#[doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel15 (& self) -> Afsel15R { Afsel15R :: new (((self . bits >> 28) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel8 (& mut self) -> Afsel8W < '_ , AfrhSpec > { Afsel8W :: new (self , 0) }
#[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel9 (& mut self) -> Afsel9W < '_ , AfrhSpec > { Afsel9W :: new (self , 4) }
#[doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel10 (& mut self) -> Afsel10W < '_ , AfrhSpec > { Afsel10W :: new (self , 8) }
#[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel11 (& mut self) -> Afsel11W < '_ , AfrhSpec > { Afsel11W :: new (self , 12) }
#[doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel12 (& mut self) -> Afsel12W < '_ , AfrhSpec > { Afsel12W :: new (self , 16) }
#[doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel13 (& mut self) -> Afsel13W < '_ , AfrhSpec > { Afsel13W :: new (self , 20) }
#[doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel14 (& mut self) -> Afsel14W < '_ , AfrhSpec > { Afsel14W :: new (self , 24) }
#[doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 8..15)"]
#[inline (always)] pub fn afsel15 (& mut self) -> Afsel15W < '_ , AfrhSpec > { Afsel15W :: new (self , 28) } }
#[doc = "GPIO alternate function high register\n\nYou can [`read`](crate::Reg::read) this register and get [`afrh::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrh::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AfrhSpec ; impl crate :: RegisterSpec for AfrhSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`afrh::R`](R) reader structure"] impl crate :: Readable for AfrhSpec { }
#[doc = "`write(|w| ..)` method takes [`afrh::W`](W) writer structure"] impl crate :: Writable for AfrhSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AFRH to value 0"] impl crate :: Resettable for AfrhSpec { } }
#[doc = "BRR (w) register accessor: port bit reset register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@brr`] module"]
#[doc (alias = "BRR")] pub type Brr = crate :: Reg < brr :: BrrSpec > ;
#[doc = "port bit reset register"] pub mod brr {
#[doc = "Register `BRR` writer"] pub type W = crate :: W < BrrSpec > ;
#[doc = "Field `BR0` writer - Port Reset bit"] pub type Br0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR1` writer - Port Reset bit"] pub type Br1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR3` writer - Port Reset bit"] pub type Br3W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Port Reset bit"]
#[inline (always)] pub fn br0 (& mut self) -> Br0W < '_ , BrrSpec > { Br0W :: new (self , 0) }
#[doc = "Bit 1 - Port Reset bit"]
#[inline (always)] pub fn br1 (& mut self) -> Br1W < '_ , BrrSpec > { Br1W :: new (self , 1) }
#[doc = "Bit 3 - Port Reset bit"]
#[inline (always)] pub fn br3 (& mut self) -> Br3W < '_ , BrrSpec > { Br3W :: new (self , 3) } }
#[doc = "port bit reset register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BrrSpec ; impl crate :: RegisterSpec for BrrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`brr::W`](W) writer structure"] impl crate :: Writable for BrrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BRR to value 0"] impl crate :: Resettable for BrrSpec { } } }
#[doc = "Serial audio interface"] pub type Sai1 = crate :: Periph < sai1 :: RegisterBlock , 0x4001_5400 > ; impl core :: fmt :: Debug for Sai1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Sai1") . finish () } }
#[doc = "Serial audio interface"] pub mod sai1 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { gcr : Gcr , acr1 : Acr1 , acr2 : Acr2 , afrcr : Afrcr , aslotr : Aslotr , aim : Aim , asr : Asr , aclrfr : Aclrfr , adr : Adr , bcr1 : Bcr1 , bcr2 : Bcr2 , bfrcr : Bfrcr , bslotr : Bslotr , bim : Bim , bsr : Bsr , bclrfr : Bclrfr , bdr : Bdr , pdmcr : Pdmcr , pdmdly : Pdmdly , } impl RegisterBlock {
#[doc = "0x00 - Global configuration register"]
#[inline (always)] pub const fn gcr (& self) -> & Gcr { & self . gcr }
#[doc = "0x04 - AConfiguration register 1"]
#[inline (always)] pub const fn acr1 (& self) -> & Acr1 { & self . acr1 }
#[doc = "0x08 - AConfiguration register 2"]
#[inline (always)] pub const fn acr2 (& self) -> & Acr2 { & self . acr2 }
#[doc = "0x0c - AFRCR"]
#[inline (always)] pub const fn afrcr (& self) -> & Afrcr { & self . afrcr }
#[doc = "0x10 - ASlot register"]
#[inline (always)] pub const fn aslotr (& self) -> & Aslotr { & self . aslotr }
#[doc = "0x14 - AInterrupt mask register2"]
#[inline (always)] pub const fn aim (& self) -> & Aim { & self . aim }
#[doc = "0x18 - AStatus register"]
#[inline (always)] pub const fn asr (& self) -> & Asr { & self . asr }
#[doc = "0x1c - AClear flag register"]
#[inline (always)] pub const fn aclrfr (& self) -> & Aclrfr { & self . aclrfr }
#[doc = "0x20 - AData register"]
#[inline (always)] pub const fn adr (& self) -> & Adr { & self . adr }
#[doc = "0x24 - BConfiguration register 1"]
#[inline (always)] pub const fn bcr1 (& self) -> & Bcr1 { & self . bcr1 }
#[doc = "0x28 - BConfiguration register 2"]
#[inline (always)] pub const fn bcr2 (& self) -> & Bcr2 { & self . bcr2 }
#[doc = "0x2c - BFRCR"]
#[inline (always)] pub const fn bfrcr (& self) -> & Bfrcr { & self . bfrcr }
#[doc = "0x30 - BSlot register"]
#[inline (always)] pub const fn bslotr (& self) -> & Bslotr { & self . bslotr }
#[doc = "0x34 - BInterrupt mask register2"]
#[inline (always)] pub const fn bim (& self) -> & Bim { & self . bim }
#[doc = "0x38 - BStatus register"]
#[inline (always)] pub const fn bsr (& self) -> & Bsr { & self . bsr }
#[doc = "0x3c - BClear flag register"]
#[inline (always)] pub const fn bclrfr (& self) -> & Bclrfr { & self . bclrfr }
#[doc = "0x40 - BData register"]
#[inline (always)] pub const fn bdr (& self) -> & Bdr { & self . bdr }
#[doc = "0x44 - PDM control register"]
#[inline (always)] pub const fn pdmcr (& self) -> & Pdmcr { & self . pdmcr }
#[doc = "0x48 - PDM delay register"]
#[inline (always)] pub const fn pdmdly (& self) -> & Pdmdly { & self . pdmdly } }
#[doc = "GCR (rw) register accessor: Global configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`gcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gcr`] module"]
#[doc (alias = "GCR")] pub type Gcr = crate :: Reg < gcr :: GcrSpec > ;
#[doc = "Global configuration register"] pub mod gcr {
#[doc = "Register `GCR` reader"] pub type R = crate :: R < GcrSpec > ;
#[doc = "Register `GCR` writer"] pub type W = crate :: W < GcrSpec > ;
#[doc = "Field `SYNCIN` reader - Synchronization inputs"] pub type SyncinR = crate :: FieldReader ;
#[doc = "Field `SYNCIN` writer - Synchronization inputs"] pub type SyncinW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SYNCOUT` reader - Synchronization outputs"] pub type SyncoutR = crate :: FieldReader ;
#[doc = "Field `SYNCOUT` writer - Synchronization outputs"] pub type SyncoutW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:1 - Synchronization inputs"]
#[inline (always)] pub fn syncin (& self) -> SyncinR { SyncinR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 4:5 - Synchronization outputs"]
#[inline (always)] pub fn syncout (& self) -> SyncoutR { SyncoutR :: new (((self . bits >> 4) & 3) as u8) } } impl W {
#[doc = "Bits 0:1 - Synchronization inputs"]
#[inline (always)] pub fn syncin (& mut self) -> SyncinW < '_ , GcrSpec > { SyncinW :: new (self , 0) }
#[doc = "Bits 4:5 - Synchronization outputs"]
#[inline (always)] pub fn syncout (& mut self) -> SyncoutW < '_ , GcrSpec > { SyncoutW :: new (self , 4) } }
#[doc = "Global configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`gcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct GcrSpec ; impl crate :: RegisterSpec for GcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`gcr::R`](R) reader structure"] impl crate :: Readable for GcrSpec { }
#[doc = "`write(|w| ..)` method takes [`gcr::W`](W) writer structure"] impl crate :: Writable for GcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets GCR to value 0"] impl crate :: Resettable for GcrSpec { } }
#[doc = "BCR1 (rw) register accessor: BConfiguration register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`bcr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bcr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bcr1`] module"]
#[doc (alias = "BCR1")] pub type Bcr1 = crate :: Reg < bcr1 :: Bcr1Spec > ;
#[doc = "BConfiguration register 1"] pub mod bcr1 {
#[doc = "Register `BCR1` reader"] pub type R = crate :: R < Bcr1Spec > ;
#[doc = "Register `BCR1` writer"] pub type W = crate :: W < Bcr1Spec > ;
#[doc = "Field `MODE` reader - Audio block mode"] pub type ModeR = crate :: FieldReader ;
#[doc = "Field `MODE` writer - Audio block mode"] pub type ModeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PRTCFG` reader - Protocol configuration"] pub type PrtcfgR = crate :: FieldReader ;
#[doc = "Field `PRTCFG` writer - Protocol configuration"] pub type PrtcfgW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DS` reader - Data size"] pub type DsR = crate :: FieldReader ;
#[doc = "Field `DS` writer - Data size"] pub type DsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `LSBFIRST` reader - Least significant bit first"] pub type LsbfirstR = crate :: BitReader ;
#[doc = "Field `LSBFIRST` writer - Least significant bit first"] pub type LsbfirstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CKSTR` reader - Clock strobing edge"] pub type CkstrR = crate :: BitReader ;
#[doc = "Field `CKSTR` writer - Clock strobing edge"] pub type CkstrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SYNCEN` reader - Synchronization enable"] pub type SyncenR = crate :: FieldReader ;
#[doc = "Field `SYNCEN` writer - Synchronization enable"] pub type SyncenW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MONO` reader - Mono mode"] pub type MonoR = crate :: BitReader ;
#[doc = "Field `MONO` writer - Mono mode"] pub type MonoW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OutDri` reader - Output drive"] pub type OutDriR = crate :: BitReader ;
#[doc = "Field `OutDri` writer - Output drive"] pub type OutDriW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SAIBEN` reader - Audio block B enable"] pub type SaibenR = crate :: BitReader ;
#[doc = "Field `SAIBEN` writer - Audio block B enable"] pub type SaibenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMAEN` reader - DMA enable"] pub type DmaenR = crate :: BitReader ;
#[doc = "Field `DMAEN` writer - DMA enable"] pub type DmaenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NODIV` reader - No divider"] pub type NodivR = crate :: BitReader ;
#[doc = "Field `NODIV` writer - No divider"] pub type NodivW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MCJDIV` reader - Master clock divider"] pub type McjdivR = crate :: FieldReader ;
#[doc = "Field `MCJDIV` writer - Master clock divider"] pub type McjdivW < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 > ;
#[doc = "Field `OSR` reader - Oversampling ratio for master clock"] pub type OsrR = crate :: BitReader ;
#[doc = "Field `OSR` writer - Oversampling ratio for master clock"] pub type OsrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MCKEN` reader - Master clock generation enable"] pub type MckenR = crate :: BitReader ;
#[doc = "Field `MCKEN` writer - Master clock generation enable"] pub type MckenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - Audio block mode"]
#[inline (always)] pub fn mode (& self) -> ModeR { ModeR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Protocol configuration"]
#[inline (always)] pub fn prtcfg (& self) -> PrtcfgR { PrtcfgR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 5:7 - Data size"]
#[inline (always)] pub fn ds (& self) -> DsR { DsR :: new (((self . bits >> 5) & 7) as u8) }
#[doc = "Bit 8 - Least significant bit first"]
#[inline (always)] pub fn lsbfirst (& self) -> LsbfirstR { LsbfirstR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Clock strobing edge"]
#[inline (always)] pub fn ckstr (& self) -> CkstrR { CkstrR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bits 10:11 - Synchronization enable"]
#[inline (always)] pub fn syncen (& self) -> SyncenR { SyncenR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bit 12 - Mono mode"]
#[inline (always)] pub fn mono (& self) -> MonoR { MonoR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Output drive"]
#[inline (always)] pub fn out_dri (& self) -> OutDriR { OutDriR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 16 - Audio block B enable"]
#[inline (always)] pub fn saiben (& self) -> SaibenR { SaibenR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - DMA enable"]
#[inline (always)] pub fn dmaen (& self) -> DmaenR { DmaenR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 19 - No divider"]
#[inline (always)] pub fn nodiv (& self) -> NodivR { NodivR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bits 20:25 - Master clock divider"]
#[inline (always)] pub fn mcjdiv (& self) -> McjdivR { McjdivR :: new (((self . bits >> 20) & 0x3f) as u8) }
#[doc = "Bit 26 - Oversampling ratio for master clock"]
#[inline (always)] pub fn osr (& self) -> OsrR { OsrR :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Master clock generation enable"]
#[inline (always)] pub fn mcken (& self) -> MckenR { MckenR :: new (((self . bits >> 27) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - Audio block mode"]
#[inline (always)] pub fn mode (& mut self) -> ModeW < '_ , Bcr1Spec > { ModeW :: new (self , 0) }
#[doc = "Bits 2:3 - Protocol configuration"]
#[inline (always)] pub fn prtcfg (& mut self) -> PrtcfgW < '_ , Bcr1Spec > { PrtcfgW :: new (self , 2) }
#[doc = "Bits 5:7 - Data size"]
#[inline (always)] pub fn ds (& mut self) -> DsW < '_ , Bcr1Spec > { DsW :: new (self , 5) }
#[doc = "Bit 8 - Least significant bit first"]
#[inline (always)] pub fn lsbfirst (& mut self) -> LsbfirstW < '_ , Bcr1Spec > { LsbfirstW :: new (self , 8) }
#[doc = "Bit 9 - Clock strobing edge"]
#[inline (always)] pub fn ckstr (& mut self) -> CkstrW < '_ , Bcr1Spec > { CkstrW :: new (self , 9) }
#[doc = "Bits 10:11 - Synchronization enable"]
#[inline (always)] pub fn syncen (& mut self) -> SyncenW < '_ , Bcr1Spec > { SyncenW :: new (self , 10) }
#[doc = "Bit 12 - Mono mode"]
#[inline (always)] pub fn mono (& mut self) -> MonoW < '_ , Bcr1Spec > { MonoW :: new (self , 12) }
#[doc = "Bit 13 - Output drive"]
#[inline (always)] pub fn out_dri (& mut self) -> OutDriW < '_ , Bcr1Spec > { OutDriW :: new (self , 13) }
#[doc = "Bit 16 - Audio block B enable"]
#[inline (always)] pub fn saiben (& mut self) -> SaibenW < '_ , Bcr1Spec > { SaibenW :: new (self , 16) }
#[doc = "Bit 17 - DMA enable"]
#[inline (always)] pub fn dmaen (& mut self) -> DmaenW < '_ , Bcr1Spec > { DmaenW :: new (self , 17) }
#[doc = "Bit 19 - No divider"]
#[inline (always)] pub fn nodiv (& mut self) -> NodivW < '_ , Bcr1Spec > { NodivW :: new (self , 19) }
#[doc = "Bits 20:25 - Master clock divider"]
#[inline (always)] pub fn mcjdiv (& mut self) -> McjdivW < '_ , Bcr1Spec > { McjdivW :: new (self , 20) }
#[doc = "Bit 26 - Oversampling ratio for master clock"]
#[inline (always)] pub fn osr (& mut self) -> OsrW < '_ , Bcr1Spec > { OsrW :: new (self , 26) }
#[doc = "Bit 27 - Master clock generation enable"]
#[inline (always)] pub fn mcken (& mut self) -> MckenW < '_ , Bcr1Spec > { MckenW :: new (self , 27) } }
#[doc = "BConfiguration register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`bcr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bcr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bcr1Spec ; impl crate :: RegisterSpec for Bcr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bcr1::R`](R) reader structure"] impl crate :: Readable for Bcr1Spec { }
#[doc = "`write(|w| ..)` method takes [`bcr1::W`](W) writer structure"] impl crate :: Writable for Bcr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BCR1 to value 0x40"] impl crate :: Resettable for Bcr1Spec { const RESET_VALUE : u32 = 0x40 ; } }
#[doc = "BCR2 (rw) register accessor: BConfiguration register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`bcr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bcr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bcr2`] module"]
#[doc (alias = "BCR2")] pub type Bcr2 = crate :: Reg < bcr2 :: Bcr2Spec > ;
#[doc = "BConfiguration register 2"] pub mod bcr2 {
#[doc = "Register `BCR2` reader"] pub type R = crate :: R < Bcr2Spec > ;
#[doc = "Register `BCR2` writer"] pub type W = crate :: W < Bcr2Spec > ;
#[doc = "Field `FTH` reader - FIFO threshold"] pub type FthR = crate :: FieldReader ;
#[doc = "Field `FTH` writer - FIFO threshold"] pub type FthW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `FFLUS` reader - FIFO flush"] pub type FflusR = crate :: BitReader ;
#[doc = "Field `FFLUS` writer - FIFO flush"] pub type FflusW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TRIS` reader - Tristate management on data line"] pub type TrisR = crate :: BitReader ;
#[doc = "Field `TRIS` writer - Tristate management on data line"] pub type TrisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MUTE` reader - Mute"] pub type MuteR = crate :: BitReader ;
#[doc = "Field `MUTE` writer - Mute"] pub type MuteW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MUTEVAL` reader - Mute value"] pub type MutevalR = crate :: BitReader ;
#[doc = "Field `MUTEVAL` writer - Mute value"] pub type MutevalW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MUTECN` reader - Mute counter"] pub type MutecnR = crate :: FieldReader ;
#[doc = "Field `MUTECN` writer - Mute counter"] pub type MutecnW < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 > ;
#[doc = "Field `CPL` reader - Complement bit"] pub type CplR = crate :: BitReader ;
#[doc = "Field `CPL` writer - Complement bit"] pub type CplW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMP` reader - Companding mode"] pub type CompR = crate :: FieldReader ;
#[doc = "Field `COMP` writer - Companding mode"] pub type CompW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:2 - FIFO threshold"]
#[inline (always)] pub fn fth (& self) -> FthR { FthR :: new ((self . bits & 7) as u8) }
#[doc = "Bit 3 - FIFO flush"]
#[inline (always)] pub fn fflus (& self) -> FflusR { FflusR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Tristate management on data line"]
#[inline (always)] pub fn tris (& self) -> TrisR { TrisR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Mute"]
#[inline (always)] pub fn mute (& self) -> MuteR { MuteR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Mute value"]
#[inline (always)] pub fn muteval (& self) -> MutevalR { MutevalR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bits 7:12 - Mute counter"]
#[inline (always)] pub fn mutecn (& self) -> MutecnR { MutecnR :: new (((self . bits >> 7) & 0x3f) as u8) }
#[doc = "Bit 13 - Complement bit"]
#[inline (always)] pub fn cpl (& self) -> CplR { CplR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bits 14:15 - Companding mode"]
#[inline (always)] pub fn comp (& self) -> CompR { CompR :: new (((self . bits >> 14) & 3) as u8) } } impl W {
#[doc = "Bits 0:2 - FIFO threshold"]
#[inline (always)] pub fn fth (& mut self) -> FthW < '_ , Bcr2Spec > { FthW :: new (self , 0) }
#[doc = "Bit 3 - FIFO flush"]
#[inline (always)] pub fn fflus (& mut self) -> FflusW < '_ , Bcr2Spec > { FflusW :: new (self , 3) }
#[doc = "Bit 4 - Tristate management on data line"]
#[inline (always)] pub fn tris (& mut self) -> TrisW < '_ , Bcr2Spec > { TrisW :: new (self , 4) }
#[doc = "Bit 5 - Mute"]
#[inline (always)] pub fn mute (& mut self) -> MuteW < '_ , Bcr2Spec > { MuteW :: new (self , 5) }
#[doc = "Bit 6 - Mute value"]
#[inline (always)] pub fn muteval (& mut self) -> MutevalW < '_ , Bcr2Spec > { MutevalW :: new (self , 6) }
#[doc = "Bits 7:12 - Mute counter"]
#[inline (always)] pub fn mutecn (& mut self) -> MutecnW < '_ , Bcr2Spec > { MutecnW :: new (self , 7) }
#[doc = "Bit 13 - Complement bit"]
#[inline (always)] pub fn cpl (& mut self) -> CplW < '_ , Bcr2Spec > { CplW :: new (self , 13) }
#[doc = "Bits 14:15 - Companding mode"]
#[inline (always)] pub fn comp (& mut self) -> CompW < '_ , Bcr2Spec > { CompW :: new (self , 14) } }
#[doc = "BConfiguration register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`bcr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bcr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bcr2Spec ; impl crate :: RegisterSpec for Bcr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bcr2::R`](R) reader structure"] impl crate :: Readable for Bcr2Spec { }
#[doc = "`write(|w| ..)` method takes [`bcr2::W`](W) writer structure"] impl crate :: Writable for Bcr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BCR2 to value 0"] impl crate :: Resettable for Bcr2Spec { } }
#[doc = "BFRCR (rw) register accessor: BFRCR\n\nYou can [`read`](crate::Reg::read) this register and get [`bfrcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bfrcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bfrcr`] module"]
#[doc (alias = "BFRCR")] pub type Bfrcr = crate :: Reg < bfrcr :: BfrcrSpec > ;
#[doc = "BFRCR"] pub mod bfrcr {
#[doc = "Register `BFRCR` reader"] pub type R = crate :: R < BfrcrSpec > ;
#[doc = "Register `BFRCR` writer"] pub type W = crate :: W < BfrcrSpec > ;
#[doc = "Field `FRL` reader - Frame length"] pub type FrlR = crate :: FieldReader ;
#[doc = "Field `FRL` writer - Frame length"] pub type FrlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `FSALL` reader - Frame synchronization active level length"] pub type FsallR = crate :: FieldReader ;
#[doc = "Field `FSALL` writer - Frame synchronization active level length"] pub type FsallW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `FSDEF` reader - Frame synchronization definition"] pub type FsdefR = crate :: BitReader ;
#[doc = "Field `FSDEF` writer - Frame synchronization definition"] pub type FsdefW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FSPOL` reader - Frame synchronization polarity"] pub type FspolR = crate :: BitReader ;
#[doc = "Field `FSPOL` writer - Frame synchronization polarity"] pub type FspolW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FSOFF` reader - Frame synchronization offset"] pub type FsoffR = crate :: BitReader ;
#[doc = "Field `FSOFF` writer - Frame synchronization offset"] pub type FsoffW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Frame length"]
#[inline (always)] pub fn frl (& self) -> FrlR { FrlR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:14 - Frame synchronization active level length"]
#[inline (always)] pub fn fsall (& self) -> FsallR { FsallR :: new (((self . bits >> 8) & 0x7f) as u8) }
#[doc = "Bit 16 - Frame synchronization definition"]
#[inline (always)] pub fn fsdef (& self) -> FsdefR { FsdefR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Frame synchronization polarity"]
#[inline (always)] pub fn fspol (& self) -> FspolR { FspolR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Frame synchronization offset"]
#[inline (always)] pub fn fsoff (& self) -> FsoffR { FsoffR :: new (((self . bits >> 18) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Frame length"]
#[inline (always)] pub fn frl (& mut self) -> FrlW < '_ , BfrcrSpec > { FrlW :: new (self , 0) }
#[doc = "Bits 8:14 - Frame synchronization active level length"]
#[inline (always)] pub fn fsall (& mut self) -> FsallW < '_ , BfrcrSpec > { FsallW :: new (self , 8) }
#[doc = "Bit 16 - Frame synchronization definition"]
#[inline (always)] pub fn fsdef (& mut self) -> FsdefW < '_ , BfrcrSpec > { FsdefW :: new (self , 16) }
#[doc = "Bit 17 - Frame synchronization polarity"]
#[inline (always)] pub fn fspol (& mut self) -> FspolW < '_ , BfrcrSpec > { FspolW :: new (self , 17) }
#[doc = "Bit 18 - Frame synchronization offset"]
#[inline (always)] pub fn fsoff (& mut self) -> FsoffW < '_ , BfrcrSpec > { FsoffW :: new (self , 18) } }
#[doc = "BFRCR\n\nYou can [`read`](crate::Reg::read) this register and get [`bfrcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bfrcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BfrcrSpec ; impl crate :: RegisterSpec for BfrcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bfrcr::R`](R) reader structure"] impl crate :: Readable for BfrcrSpec { }
#[doc = "`write(|w| ..)` method takes [`bfrcr::W`](W) writer structure"] impl crate :: Writable for BfrcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BFRCR to value 0x07"] impl crate :: Resettable for BfrcrSpec { const RESET_VALUE : u32 = 0x07 ; } }
#[doc = "BSLOTR (rw) register accessor: BSlot register\n\nYou can [`read`](crate::Reg::read) this register and get [`bslotr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bslotr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bslotr`] module"]
#[doc (alias = "BSLOTR")] pub type Bslotr = crate :: Reg < bslotr :: BslotrSpec > ;
#[doc = "BSlot register"] pub mod bslotr {
#[doc = "Register `BSLOTR` reader"] pub type R = crate :: R < BslotrSpec > ;
#[doc = "Register `BSLOTR` writer"] pub type W = crate :: W < BslotrSpec > ;
#[doc = "Field `FBOFF` reader - First bit offset"] pub type FboffR = crate :: FieldReader ;
#[doc = "Field `FBOFF` writer - First bit offset"] pub type FboffW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SLOTSZ` reader - Slot size"] pub type SlotszR = crate :: FieldReader ;
#[doc = "Field `SLOTSZ` writer - Slot size"] pub type SlotszW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `NBSLOT` reader - Number of slots in an audio frame"] pub type NbslotR = crate :: FieldReader ;
#[doc = "Field `NBSLOT` writer - Number of slots in an audio frame"] pub type NbslotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `SLOTEN` reader - Slot enable"] pub type SlotenR = crate :: FieldReader < u16 > ;
#[doc = "Field `SLOTEN` writer - Slot enable"] pub type SlotenW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:4 - First bit offset"]
#[inline (always)] pub fn fboff (& self) -> FboffR { FboffR :: new ((self . bits & 0x1f) as u8) }
#[doc = "Bits 6:7 - Slot size"]
#[inline (always)] pub fn slotsz (& self) -> SlotszR { SlotszR :: new (((self . bits >> 6) & 3) as u8) }
#[doc = "Bits 8:11 - Number of slots in an audio frame"]
#[inline (always)] pub fn nbslot (& self) -> NbslotR { NbslotR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 16:31 - Slot enable"]
#[inline (always)] pub fn sloten (& self) -> SlotenR { SlotenR :: new (((self . bits >> 16) & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:4 - First bit offset"]
#[inline (always)] pub fn fboff (& mut self) -> FboffW < '_ , BslotrSpec > { FboffW :: new (self , 0) }
#[doc = "Bits 6:7 - Slot size"]
#[inline (always)] pub fn slotsz (& mut self) -> SlotszW < '_ , BslotrSpec > { SlotszW :: new (self , 6) }
#[doc = "Bits 8:11 - Number of slots in an audio frame"]
#[inline (always)] pub fn nbslot (& mut self) -> NbslotW < '_ , BslotrSpec > { NbslotW :: new (self , 8) }
#[doc = "Bits 16:31 - Slot enable"]
#[inline (always)] pub fn sloten (& mut self) -> SlotenW < '_ , BslotrSpec > { SlotenW :: new (self , 16) } }
#[doc = "BSlot register\n\nYou can [`read`](crate::Reg::read) this register and get [`bslotr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bslotr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BslotrSpec ; impl crate :: RegisterSpec for BslotrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bslotr::R`](R) reader structure"] impl crate :: Readable for BslotrSpec { }
#[doc = "`write(|w| ..)` method takes [`bslotr::W`](W) writer structure"] impl crate :: Writable for BslotrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BSLOTR to value 0"] impl crate :: Resettable for BslotrSpec { } }
#[doc = "BIM (rw) register accessor: BInterrupt mask register2\n\nYou can [`read`](crate::Reg::read) this register and get [`bim::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bim::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bim`] module"]
#[doc (alias = "BIM")] pub type Bim = crate :: Reg < bim :: BimSpec > ;
#[doc = "BInterrupt mask register2"] pub mod bim {
#[doc = "Register `BIM` reader"] pub type R = crate :: R < BimSpec > ;
#[doc = "Register `BIM` writer"] pub type W = crate :: W < BimSpec > ;
#[doc = "Field `OVRUDRIE` reader - Overrun/underrun interrupt enable"] pub type OvrudrieR = crate :: BitReader ;
#[doc = "Field `OVRUDRIE` writer - Overrun/underrun interrupt enable"] pub type OvrudrieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MUTEDET` reader - Mute detection interrupt enable"] pub type MutedetR = crate :: BitReader ;
#[doc = "Field `MUTEDET` writer - Mute detection interrupt enable"] pub type MutedetW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WCKCFG` reader - Wrong clock configuration interrupt enable"] pub type WckcfgR = crate :: BitReader ;
#[doc = "Field `WCKCFG` writer - Wrong clock configuration interrupt enable"] pub type WckcfgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FREQIE` reader - FIFO request interrupt enable"] pub type FreqieR = crate :: BitReader ;
#[doc = "Field `FREQIE` writer - FIFO request interrupt enable"] pub type FreqieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CNRDYIE` reader - Codec not ready interrupt enable"] pub type CnrdyieR = crate :: BitReader ;
#[doc = "Field `CNRDYIE` writer - Codec not ready interrupt enable"] pub type CnrdyieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AFSDETIE` reader - Anticipated frame synchronization detection interrupt enable"] pub type AfsdetieR = crate :: BitReader ;
#[doc = "Field `AFSDETIE` writer - Anticipated frame synchronization detection interrupt enable"] pub type AfsdetieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LFSDETIE` reader - Late frame synchronization detection interrupt enable"] pub type LfsdetieR = crate :: BitReader ;
#[doc = "Field `LFSDETIE` writer - Late frame synchronization detection interrupt enable"] pub type LfsdetieW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Overrun/underrun interrupt enable"]
#[inline (always)] pub fn ovrudrie (& self) -> OvrudrieR { OvrudrieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Mute detection interrupt enable"]
#[inline (always)] pub fn mutedet (& self) -> MutedetR { MutedetR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Wrong clock configuration interrupt enable"]
#[inline (always)] pub fn wckcfg (& self) -> WckcfgR { WckcfgR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - FIFO request interrupt enable"]
#[inline (always)] pub fn freqie (& self) -> FreqieR { FreqieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Codec not ready interrupt enable"]
#[inline (always)] pub fn cnrdyie (& self) -> CnrdyieR { CnrdyieR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Anticipated frame synchronization detection interrupt enable"]
#[inline (always)] pub fn afsdetie (& self) -> AfsdetieR { AfsdetieR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Late frame synchronization detection interrupt enable"]
#[inline (always)] pub fn lfsdetie (& self) -> LfsdetieR { LfsdetieR :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Overrun/underrun interrupt enable"]
#[inline (always)] pub fn ovrudrie (& mut self) -> OvrudrieW < '_ , BimSpec > { OvrudrieW :: new (self , 0) }
#[doc = "Bit 1 - Mute detection interrupt enable"]
#[inline (always)] pub fn mutedet (& mut self) -> MutedetW < '_ , BimSpec > { MutedetW :: new (self , 1) }
#[doc = "Bit 2 - Wrong clock configuration interrupt enable"]
#[inline (always)] pub fn wckcfg (& mut self) -> WckcfgW < '_ , BimSpec > { WckcfgW :: new (self , 2) }
#[doc = "Bit 3 - FIFO request interrupt enable"]
#[inline (always)] pub fn freqie (& mut self) -> FreqieW < '_ , BimSpec > { FreqieW :: new (self , 3) }
#[doc = "Bit 4 - Codec not ready interrupt enable"]
#[inline (always)] pub fn cnrdyie (& mut self) -> CnrdyieW < '_ , BimSpec > { CnrdyieW :: new (self , 4) }
#[doc = "Bit 5 - Anticipated frame synchronization detection interrupt enable"]
#[inline (always)] pub fn afsdetie (& mut self) -> AfsdetieW < '_ , BimSpec > { AfsdetieW :: new (self , 5) }
#[doc = "Bit 6 - Late frame synchronization detection interrupt enable"]
#[inline (always)] pub fn lfsdetie (& mut self) -> LfsdetieW < '_ , BimSpec > { LfsdetieW :: new (self , 6) } }
#[doc = "BInterrupt mask register2\n\nYou can [`read`](crate::Reg::read) this register and get [`bim::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bim::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BimSpec ; impl crate :: RegisterSpec for BimSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bim::R`](R) reader structure"] impl crate :: Readable for BimSpec { }
#[doc = "`write(|w| ..)` method takes [`bim::W`](W) writer structure"] impl crate :: Writable for BimSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BIM to value 0"] impl crate :: Resettable for BimSpec { } }
#[doc = "BSR (r) register accessor: BStatus register\n\nYou can [`read`](crate::Reg::read) this register and get [`bsr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bsr`] module"]
#[doc (alias = "BSR")] pub type Bsr = crate :: Reg < bsr :: BsrSpec > ;
#[doc = "BStatus register"] pub mod bsr {
#[doc = "Register `BSR` reader"] pub type R = crate :: R < BsrSpec > ;
#[doc = "Field `OVRUDR` reader - Overrun / underrun"] pub type OvrudrR = crate :: BitReader ;
#[doc = "Field `MUTEDET` reader - Mute detection"] pub type MutedetR = crate :: BitReader ;
#[doc = "Field `WCKCFG` reader - Wrong clock configuration flag"] pub type WckcfgR = crate :: BitReader ;
#[doc = "Field `FREQ` reader - FIFO request"] pub type FreqR = crate :: BitReader ;
#[doc = "Field `CNRDY` reader - Codec not ready"] pub type CnrdyR = crate :: BitReader ;
#[doc = "Field `AFSDET` reader - Anticipated frame synchronization detection"] pub type AfsdetR = crate :: BitReader ;
#[doc = "Field `LFSDET` reader - Late frame synchronization detection"] pub type LfsdetR = crate :: BitReader ;
#[doc = "Field `FLVL` reader - FIFO level threshold"] pub type FlvlR = crate :: FieldReader ; impl R {
#[doc = "Bit 0 - Overrun / underrun"]
#[inline (always)] pub fn ovrudr (& self) -> OvrudrR { OvrudrR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Mute detection"]
#[inline (always)] pub fn mutedet (& self) -> MutedetR { MutedetR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Wrong clock configuration flag"]
#[inline (always)] pub fn wckcfg (& self) -> WckcfgR { WckcfgR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - FIFO request"]
#[inline (always)] pub fn freq (& self) -> FreqR { FreqR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Codec not ready"]
#[inline (always)] pub fn cnrdy (& self) -> CnrdyR { CnrdyR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Anticipated frame synchronization detection"]
#[inline (always)] pub fn afsdet (& self) -> AfsdetR { AfsdetR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Late frame synchronization detection"]
#[inline (always)] pub fn lfsdet (& self) -> LfsdetR { LfsdetR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bits 16:18 - FIFO level threshold"]
#[inline (always)] pub fn flvl (& self) -> FlvlR { FlvlR :: new (((self . bits >> 16) & 7) as u8) } }
#[doc = "BStatus register\n\nYou can [`read`](crate::Reg::read) this register and get [`bsr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BsrSpec ; impl crate :: RegisterSpec for BsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bsr::R`](R) reader structure"] impl crate :: Readable for BsrSpec { }
#[doc = "`reset()` method sets BSR to value 0x08"] impl crate :: Resettable for BsrSpec { const RESET_VALUE : u32 = 0x08 ; } }
#[doc = "BCLRFR (w) register accessor: BClear flag register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bclrfr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bclrfr`] module"]
#[doc (alias = "BCLRFR")] pub type Bclrfr = crate :: Reg < bclrfr :: BclrfrSpec > ;
#[doc = "BClear flag register"] pub mod bclrfr {
#[doc = "Register `BCLRFR` writer"] pub type W = crate :: W < BclrfrSpec > ;
#[doc = "Field `OVRUDR` writer - Clear overrun / underrun"] pub type OvrudrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MUTEDET` writer - Mute detection flag"] pub type MutedetW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WCKCFG` writer - Clear wrong clock configuration flag"] pub type WckcfgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CNRDY` writer - Clear codec not ready flag"] pub type CnrdyW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CAFSDET` writer - Clear anticipated frame synchronization detection flag"] pub type CafsdetW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LFSDET` writer - Clear late frame synchronization detection flag"] pub type LfsdetW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Clear overrun / underrun"]
#[inline (always)] pub fn ovrudr (& mut self) -> OvrudrW < '_ , BclrfrSpec > { OvrudrW :: new (self , 0) }
#[doc = "Bit 1 - Mute detection flag"]
#[inline (always)] pub fn mutedet (& mut self) -> MutedetW < '_ , BclrfrSpec > { MutedetW :: new (self , 1) }
#[doc = "Bit 2 - Clear wrong clock configuration flag"]
#[inline (always)] pub fn wckcfg (& mut self) -> WckcfgW < '_ , BclrfrSpec > { WckcfgW :: new (self , 2) }
#[doc = "Bit 4 - Clear codec not ready flag"]
#[inline (always)] pub fn cnrdy (& mut self) -> CnrdyW < '_ , BclrfrSpec > { CnrdyW :: new (self , 4) }
#[doc = "Bit 5 - Clear anticipated frame synchronization detection flag"]
#[inline (always)] pub fn cafsdet (& mut self) -> CafsdetW < '_ , BclrfrSpec > { CafsdetW :: new (self , 5) }
#[doc = "Bit 6 - Clear late frame synchronization detection flag"]
#[inline (always)] pub fn lfsdet (& mut self) -> LfsdetW < '_ , BclrfrSpec > { LfsdetW :: new (self , 6) } }
#[doc = "BClear flag register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bclrfr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BclrfrSpec ; impl crate :: RegisterSpec for BclrfrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`bclrfr::W`](W) writer structure"] impl crate :: Writable for BclrfrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BCLRFR to value 0"] impl crate :: Resettable for BclrfrSpec { } }
#[doc = "BDR (rw) register accessor: BData register\n\nYou can [`read`](crate::Reg::read) this register and get [`bdr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bdr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bdr`] module"]
#[doc (alias = "BDR")] pub type Bdr = crate :: Reg < bdr :: BdrSpec > ;
#[doc = "BData register"] pub mod bdr {
#[doc = "Register `BDR` reader"] pub type R = crate :: R < BdrSpec > ;
#[doc = "Register `BDR` writer"] pub type W = crate :: W < BdrSpec > ;
#[doc = "Field `DATA` reader - Data"] pub type DataR = crate :: FieldReader < u32 > ;
#[doc = "Field `DATA` writer - Data"] pub type DataW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Data"]
#[inline (always)] pub fn data (& self) -> DataR { DataR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Data"]
#[inline (always)] pub fn data (& mut self) -> DataW < '_ , BdrSpec > { DataW :: new (self , 0) } }
#[doc = "BData register\n\nYou can [`read`](crate::Reg::read) this register and get [`bdr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bdr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BdrSpec ; impl crate :: RegisterSpec for BdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bdr::R`](R) reader structure"] impl crate :: Readable for BdrSpec { }
#[doc = "`write(|w| ..)` method takes [`bdr::W`](W) writer structure"] impl crate :: Writable for BdrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BDR to value 0"] impl crate :: Resettable for BdrSpec { } }
#[doc = "ACR1 (rw) register accessor: AConfiguration register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`acr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`acr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@acr1`] module"]
#[doc (alias = "ACR1")] pub type Acr1 = crate :: Reg < acr1 :: Acr1Spec > ;
#[doc = "AConfiguration register 1"] pub mod acr1 {
#[doc = "Register `ACR1` reader"] pub type R = crate :: R < Acr1Spec > ;
#[doc = "Register `ACR1` writer"] pub type W = crate :: W < Acr1Spec > ;
#[doc = "Field `MODE` reader - Audio block mode"] pub type ModeR = crate :: FieldReader ;
#[doc = "Field `MODE` writer - Audio block mode"] pub type ModeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PRTCFG` reader - Protocol configuration"] pub type PrtcfgR = crate :: FieldReader ;
#[doc = "Field `PRTCFG` writer - Protocol configuration"] pub type PrtcfgW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DS` reader - Data size"] pub type DsR = crate :: FieldReader ;
#[doc = "Field `DS` writer - Data size"] pub type DsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `LSBFIRST` reader - Least significant bit first"] pub type LsbfirstR = crate :: BitReader ;
#[doc = "Field `LSBFIRST` writer - Least significant bit first"] pub type LsbfirstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CKSTR` reader - Clock strobing edge"] pub type CkstrR = crate :: BitReader ;
#[doc = "Field `CKSTR` writer - Clock strobing edge"] pub type CkstrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SYNCEN` reader - Synchronization enable"] pub type SyncenR = crate :: FieldReader ;
#[doc = "Field `SYNCEN` writer - Synchronization enable"] pub type SyncenW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MONO` reader - Mono mode"] pub type MonoR = crate :: BitReader ;
#[doc = "Field `MONO` writer - Mono mode"] pub type MonoW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OutDri` reader - Output drive"] pub type OutDriR = crate :: BitReader ;
#[doc = "Field `OutDri` writer - Output drive"] pub type OutDriW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SAIBEN` reader - Audio block B enable"] pub type SaibenR = crate :: BitReader ;
#[doc = "Field `SAIBEN` writer - Audio block B enable"] pub type SaibenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMAEN` reader - DMA enable"] pub type DmaenR = crate :: BitReader ;
#[doc = "Field `DMAEN` writer - DMA enable"] pub type DmaenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NODIV` reader - No divider"] pub type NodivR = crate :: BitReader ;
#[doc = "Field `NODIV` writer - No divider"] pub type NodivW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MCJDIV` reader - Master clock divider"] pub type McjdivR = crate :: FieldReader ;
#[doc = "Field `MCJDIV` writer - Master clock divider"] pub type McjdivW < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 > ;
#[doc = "Field `OSR` reader - Oversampling ratio for master clock"] pub type OsrR = crate :: BitReader ;
#[doc = "Field `OSR` writer - Oversampling ratio for master clock"] pub type OsrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MCKEN` reader - Master clock generation enable"] pub type MckenR = crate :: BitReader ;
#[doc = "Field `MCKEN` writer - Master clock generation enable"] pub type MckenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - Audio block mode"]
#[inline (always)] pub fn mode (& self) -> ModeR { ModeR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Protocol configuration"]
#[inline (always)] pub fn prtcfg (& self) -> PrtcfgR { PrtcfgR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 5:7 - Data size"]
#[inline (always)] pub fn ds (& self) -> DsR { DsR :: new (((self . bits >> 5) & 7) as u8) }
#[doc = "Bit 8 - Least significant bit first"]
#[inline (always)] pub fn lsbfirst (& self) -> LsbfirstR { LsbfirstR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Clock strobing edge"]
#[inline (always)] pub fn ckstr (& self) -> CkstrR { CkstrR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bits 10:11 - Synchronization enable"]
#[inline (always)] pub fn syncen (& self) -> SyncenR { SyncenR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bit 12 - Mono mode"]
#[inline (always)] pub fn mono (& self) -> MonoR { MonoR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Output drive"]
#[inline (always)] pub fn out_dri (& self) -> OutDriR { OutDriR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 16 - Audio block B enable"]
#[inline (always)] pub fn saiben (& self) -> SaibenR { SaibenR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - DMA enable"]
#[inline (always)] pub fn dmaen (& self) -> DmaenR { DmaenR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 19 - No divider"]
#[inline (always)] pub fn nodiv (& self) -> NodivR { NodivR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bits 20:25 - Master clock divider"]
#[inline (always)] pub fn mcjdiv (& self) -> McjdivR { McjdivR :: new (((self . bits >> 20) & 0x3f) as u8) }
#[doc = "Bit 26 - Oversampling ratio for master clock"]
#[inline (always)] pub fn osr (& self) -> OsrR { OsrR :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Master clock generation enable"]
#[inline (always)] pub fn mcken (& self) -> MckenR { MckenR :: new (((self . bits >> 27) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - Audio block mode"]
#[inline (always)] pub fn mode (& mut self) -> ModeW < '_ , Acr1Spec > { ModeW :: new (self , 0) }
#[doc = "Bits 2:3 - Protocol configuration"]
#[inline (always)] pub fn prtcfg (& mut self) -> PrtcfgW < '_ , Acr1Spec > { PrtcfgW :: new (self , 2) }
#[doc = "Bits 5:7 - Data size"]
#[inline (always)] pub fn ds (& mut self) -> DsW < '_ , Acr1Spec > { DsW :: new (self , 5) }
#[doc = "Bit 8 - Least significant bit first"]
#[inline (always)] pub fn lsbfirst (& mut self) -> LsbfirstW < '_ , Acr1Spec > { LsbfirstW :: new (self , 8) }
#[doc = "Bit 9 - Clock strobing edge"]
#[inline (always)] pub fn ckstr (& mut self) -> CkstrW < '_ , Acr1Spec > { CkstrW :: new (self , 9) }
#[doc = "Bits 10:11 - Synchronization enable"]
#[inline (always)] pub fn syncen (& mut self) -> SyncenW < '_ , Acr1Spec > { SyncenW :: new (self , 10) }
#[doc = "Bit 12 - Mono mode"]
#[inline (always)] pub fn mono (& mut self) -> MonoW < '_ , Acr1Spec > { MonoW :: new (self , 12) }
#[doc = "Bit 13 - Output drive"]
#[inline (always)] pub fn out_dri (& mut self) -> OutDriW < '_ , Acr1Spec > { OutDriW :: new (self , 13) }
#[doc = "Bit 16 - Audio block B enable"]
#[inline (always)] pub fn saiben (& mut self) -> SaibenW < '_ , Acr1Spec > { SaibenW :: new (self , 16) }
#[doc = "Bit 17 - DMA enable"]
#[inline (always)] pub fn dmaen (& mut self) -> DmaenW < '_ , Acr1Spec > { DmaenW :: new (self , 17) }
#[doc = "Bit 19 - No divider"]
#[inline (always)] pub fn nodiv (& mut self) -> NodivW < '_ , Acr1Spec > { NodivW :: new (self , 19) }
#[doc = "Bits 20:25 - Master clock divider"]
#[inline (always)] pub fn mcjdiv (& mut self) -> McjdivW < '_ , Acr1Spec > { McjdivW :: new (self , 20) }
#[doc = "Bit 26 - Oversampling ratio for master clock"]
#[inline (always)] pub fn osr (& mut self) -> OsrW < '_ , Acr1Spec > { OsrW :: new (self , 26) }
#[doc = "Bit 27 - Master clock generation enable"]
#[inline (always)] pub fn mcken (& mut self) -> MckenW < '_ , Acr1Spec > { MckenW :: new (self , 27) } }
#[doc = "AConfiguration register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`acr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`acr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Acr1Spec ; impl crate :: RegisterSpec for Acr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`acr1::R`](R) reader structure"] impl crate :: Readable for Acr1Spec { }
#[doc = "`write(|w| ..)` method takes [`acr1::W`](W) writer structure"] impl crate :: Writable for Acr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ACR1 to value 0x40"] impl crate :: Resettable for Acr1Spec { const RESET_VALUE : u32 = 0x40 ; } }
#[doc = "ACR2 (rw) register accessor: AConfiguration register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`acr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`acr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@acr2`] module"]
#[doc (alias = "ACR2")] pub type Acr2 = crate :: Reg < acr2 :: Acr2Spec > ;
#[doc = "AConfiguration register 2"] pub mod acr2 {
#[doc = "Register `ACR2` reader"] pub type R = crate :: R < Acr2Spec > ;
#[doc = "Register `ACR2` writer"] pub type W = crate :: W < Acr2Spec > ;
#[doc = "Field `FTH` reader - FIFO threshold"] pub type FthR = crate :: FieldReader ;
#[doc = "Field `FTH` writer - FIFO threshold"] pub type FthW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `FFLUS` reader - FIFO flush"] pub type FflusR = crate :: BitReader ;
#[doc = "Field `FFLUS` writer - FIFO flush"] pub type FflusW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TRIS` reader - Tristate management on data line"] pub type TrisR = crate :: BitReader ;
#[doc = "Field `TRIS` writer - Tristate management on data line"] pub type TrisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MUTE` reader - Mute"] pub type MuteR = crate :: BitReader ;
#[doc = "Field `MUTE` writer - Mute"] pub type MuteW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MUTEVAL` reader - Mute value"] pub type MutevalR = crate :: BitReader ;
#[doc = "Field `MUTEVAL` writer - Mute value"] pub type MutevalW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MUTECN` reader - Mute counter"] pub type MutecnR = crate :: FieldReader ;
#[doc = "Field `MUTECN` writer - Mute counter"] pub type MutecnW < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 > ;
#[doc = "Field `CPL` reader - Complement bit"] pub type CplR = crate :: BitReader ;
#[doc = "Field `CPL` writer - Complement bit"] pub type CplW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMP` reader - Companding mode"] pub type CompR = crate :: FieldReader ;
#[doc = "Field `COMP` writer - Companding mode"] pub type CompW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:2 - FIFO threshold"]
#[inline (always)] pub fn fth (& self) -> FthR { FthR :: new ((self . bits & 7) as u8) }
#[doc = "Bit 3 - FIFO flush"]
#[inline (always)] pub fn fflus (& self) -> FflusR { FflusR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Tristate management on data line"]
#[inline (always)] pub fn tris (& self) -> TrisR { TrisR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Mute"]
#[inline (always)] pub fn mute (& self) -> MuteR { MuteR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Mute value"]
#[inline (always)] pub fn muteval (& self) -> MutevalR { MutevalR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bits 7:12 - Mute counter"]
#[inline (always)] pub fn mutecn (& self) -> MutecnR { MutecnR :: new (((self . bits >> 7) & 0x3f) as u8) }
#[doc = "Bit 13 - Complement bit"]
#[inline (always)] pub fn cpl (& self) -> CplR { CplR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bits 14:15 - Companding mode"]
#[inline (always)] pub fn comp (& self) -> CompR { CompR :: new (((self . bits >> 14) & 3) as u8) } } impl W {
#[doc = "Bits 0:2 - FIFO threshold"]
#[inline (always)] pub fn fth (& mut self) -> FthW < '_ , Acr2Spec > { FthW :: new (self , 0) }
#[doc = "Bit 3 - FIFO flush"]
#[inline (always)] pub fn fflus (& mut self) -> FflusW < '_ , Acr2Spec > { FflusW :: new (self , 3) }
#[doc = "Bit 4 - Tristate management on data line"]
#[inline (always)] pub fn tris (& mut self) -> TrisW < '_ , Acr2Spec > { TrisW :: new (self , 4) }
#[doc = "Bit 5 - Mute"]
#[inline (always)] pub fn mute (& mut self) -> MuteW < '_ , Acr2Spec > { MuteW :: new (self , 5) }
#[doc = "Bit 6 - Mute value"]
#[inline (always)] pub fn muteval (& mut self) -> MutevalW < '_ , Acr2Spec > { MutevalW :: new (self , 6) }
#[doc = "Bits 7:12 - Mute counter"]
#[inline (always)] pub fn mutecn (& mut self) -> MutecnW < '_ , Acr2Spec > { MutecnW :: new (self , 7) }
#[doc = "Bit 13 - Complement bit"]
#[inline (always)] pub fn cpl (& mut self) -> CplW < '_ , Acr2Spec > { CplW :: new (self , 13) }
#[doc = "Bits 14:15 - Companding mode"]
#[inline (always)] pub fn comp (& mut self) -> CompW < '_ , Acr2Spec > { CompW :: new (self , 14) } }
#[doc = "AConfiguration register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`acr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`acr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Acr2Spec ; impl crate :: RegisterSpec for Acr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`acr2::R`](R) reader structure"] impl crate :: Readable for Acr2Spec { }
#[doc = "`write(|w| ..)` method takes [`acr2::W`](W) writer structure"] impl crate :: Writable for Acr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ACR2 to value 0"] impl crate :: Resettable for Acr2Spec { } }
#[doc = "AFRCR (rw) register accessor: AFRCR\n\nYou can [`read`](crate::Reg::read) this register and get [`afrcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@afrcr`] module"]
#[doc (alias = "AFRCR")] pub type Afrcr = crate :: Reg < afrcr :: AfrcrSpec > ;
#[doc = "AFRCR"] pub mod afrcr {
#[doc = "Register `AFRCR` reader"] pub type R = crate :: R < AfrcrSpec > ;
#[doc = "Register `AFRCR` writer"] pub type W = crate :: W < AfrcrSpec > ;
#[doc = "Field `FRL` reader - Frame length"] pub type FrlR = crate :: FieldReader ;
#[doc = "Field `FRL` writer - Frame length"] pub type FrlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `FSALL` reader - Frame synchronization active level length"] pub type FsallR = crate :: FieldReader ;
#[doc = "Field `FSALL` writer - Frame synchronization active level length"] pub type FsallW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `FSDEF` reader - Frame synchronization definition"] pub type FsdefR = crate :: BitReader ;
#[doc = "Field `FSDEF` writer - Frame synchronization definition"] pub type FsdefW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FSPOL` reader - Frame synchronization polarity"] pub type FspolR = crate :: BitReader ;
#[doc = "Field `FSPOL` writer - Frame synchronization polarity"] pub type FspolW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FSOFF` reader - Frame synchronization offset"] pub type FsoffR = crate :: BitReader ;
#[doc = "Field `FSOFF` writer - Frame synchronization offset"] pub type FsoffW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Frame length"]
#[inline (always)] pub fn frl (& self) -> FrlR { FrlR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:14 - Frame synchronization active level length"]
#[inline (always)] pub fn fsall (& self) -> FsallR { FsallR :: new (((self . bits >> 8) & 0x7f) as u8) }
#[doc = "Bit 16 - Frame synchronization definition"]
#[inline (always)] pub fn fsdef (& self) -> FsdefR { FsdefR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Frame synchronization polarity"]
#[inline (always)] pub fn fspol (& self) -> FspolR { FspolR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Frame synchronization offset"]
#[inline (always)] pub fn fsoff (& self) -> FsoffR { FsoffR :: new (((self . bits >> 18) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Frame length"]
#[inline (always)] pub fn frl (& mut self) -> FrlW < '_ , AfrcrSpec > { FrlW :: new (self , 0) }
#[doc = "Bits 8:14 - Frame synchronization active level length"]
#[inline (always)] pub fn fsall (& mut self) -> FsallW < '_ , AfrcrSpec > { FsallW :: new (self , 8) }
#[doc = "Bit 16 - Frame synchronization definition"]
#[inline (always)] pub fn fsdef (& mut self) -> FsdefW < '_ , AfrcrSpec > { FsdefW :: new (self , 16) }
#[doc = "Bit 17 - Frame synchronization polarity"]
#[inline (always)] pub fn fspol (& mut self) -> FspolW < '_ , AfrcrSpec > { FspolW :: new (self , 17) }
#[doc = "Bit 18 - Frame synchronization offset"]
#[inline (always)] pub fn fsoff (& mut self) -> FsoffW < '_ , AfrcrSpec > { FsoffW :: new (self , 18) } }
#[doc = "AFRCR\n\nYou can [`read`](crate::Reg::read) this register and get [`afrcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AfrcrSpec ; impl crate :: RegisterSpec for AfrcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`afrcr::R`](R) reader structure"] impl crate :: Readable for AfrcrSpec { }
#[doc = "`write(|w| ..)` method takes [`afrcr::W`](W) writer structure"] impl crate :: Writable for AfrcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AFRCR to value 0x07"] impl crate :: Resettable for AfrcrSpec { const RESET_VALUE : u32 = 0x07 ; } }
#[doc = "ASLOTR (rw) register accessor: ASlot register\n\nYou can [`read`](crate::Reg::read) this register and get [`aslotr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`aslotr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@aslotr`] module"]
#[doc (alias = "ASLOTR")] pub type Aslotr = crate :: Reg < aslotr :: AslotrSpec > ;
#[doc = "ASlot register"] pub mod aslotr {
#[doc = "Register `ASLOTR` reader"] pub type R = crate :: R < AslotrSpec > ;
#[doc = "Register `ASLOTR` writer"] pub type W = crate :: W < AslotrSpec > ;
#[doc = "Field `FBOFF` reader - First bit offset"] pub type FboffR = crate :: FieldReader ;
#[doc = "Field `FBOFF` writer - First bit offset"] pub type FboffW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SLOTSZ` reader - Slot size"] pub type SlotszR = crate :: FieldReader ;
#[doc = "Field `SLOTSZ` writer - Slot size"] pub type SlotszW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `NBSLOT` reader - Number of slots in an audio frame"] pub type NbslotR = crate :: FieldReader ;
#[doc = "Field `NBSLOT` writer - Number of slots in an audio frame"] pub type NbslotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `SLOTEN` reader - Slot enable"] pub type SlotenR = crate :: FieldReader < u16 > ;
#[doc = "Field `SLOTEN` writer - Slot enable"] pub type SlotenW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:4 - First bit offset"]
#[inline (always)] pub fn fboff (& self) -> FboffR { FboffR :: new ((self . bits & 0x1f) as u8) }
#[doc = "Bits 6:7 - Slot size"]
#[inline (always)] pub fn slotsz (& self) -> SlotszR { SlotszR :: new (((self . bits >> 6) & 3) as u8) }
#[doc = "Bits 8:11 - Number of slots in an audio frame"]
#[inline (always)] pub fn nbslot (& self) -> NbslotR { NbslotR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 16:31 - Slot enable"]
#[inline (always)] pub fn sloten (& self) -> SlotenR { SlotenR :: new (((self . bits >> 16) & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:4 - First bit offset"]
#[inline (always)] pub fn fboff (& mut self) -> FboffW < '_ , AslotrSpec > { FboffW :: new (self , 0) }
#[doc = "Bits 6:7 - Slot size"]
#[inline (always)] pub fn slotsz (& mut self) -> SlotszW < '_ , AslotrSpec > { SlotszW :: new (self , 6) }
#[doc = "Bits 8:11 - Number of slots in an audio frame"]
#[inline (always)] pub fn nbslot (& mut self) -> NbslotW < '_ , AslotrSpec > { NbslotW :: new (self , 8) }
#[doc = "Bits 16:31 - Slot enable"]
#[inline (always)] pub fn sloten (& mut self) -> SlotenW < '_ , AslotrSpec > { SlotenW :: new (self , 16) } }
#[doc = "ASlot register\n\nYou can [`read`](crate::Reg::read) this register and get [`aslotr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`aslotr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AslotrSpec ; impl crate :: RegisterSpec for AslotrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`aslotr::R`](R) reader structure"] impl crate :: Readable for AslotrSpec { }
#[doc = "`write(|w| ..)` method takes [`aslotr::W`](W) writer structure"] impl crate :: Writable for AslotrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ASLOTR to value 0"] impl crate :: Resettable for AslotrSpec { } }
#[doc = "AIM (rw) register accessor: AInterrupt mask register2\n\nYou can [`read`](crate::Reg::read) this register and get [`aim::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`aim::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@aim`] module"]
#[doc (alias = "AIM")] pub type Aim = crate :: Reg < aim :: AimSpec > ;
#[doc = "AInterrupt mask register2"] pub mod aim {
#[doc = "Register `AIM` reader"] pub type R = crate :: R < AimSpec > ;
#[doc = "Register `AIM` writer"] pub type W = crate :: W < AimSpec > ;
#[doc = "Field `OVRUDRIE` reader - Overrun/underrun interrupt enable"] pub type OvrudrieR = crate :: BitReader ;
#[doc = "Field `OVRUDRIE` writer - Overrun/underrun interrupt enable"] pub type OvrudrieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MUTEDET` reader - Mute detection interrupt enable"] pub type MutedetR = crate :: BitReader ;
#[doc = "Field `MUTEDET` writer - Mute detection interrupt enable"] pub type MutedetW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WCKCFG` reader - Wrong clock configuration interrupt enable"] pub type WckcfgR = crate :: BitReader ;
#[doc = "Field `WCKCFG` writer - Wrong clock configuration interrupt enable"] pub type WckcfgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FREQIE` reader - FIFO request interrupt enable"] pub type FreqieR = crate :: BitReader ;
#[doc = "Field `FREQIE` writer - FIFO request interrupt enable"] pub type FreqieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CNRDYIE` reader - Codec not ready interrupt enable"] pub type CnrdyieR = crate :: BitReader ;
#[doc = "Field `CNRDYIE` writer - Codec not ready interrupt enable"] pub type CnrdyieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AFSDETIE` reader - Anticipated frame synchronization detection interrupt enable"] pub type AfsdetieR = crate :: BitReader ;
#[doc = "Field `AFSDETIE` writer - Anticipated frame synchronization detection interrupt enable"] pub type AfsdetieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LFSDET` reader - Late frame synchronization detection interrupt enable"] pub type LfsdetR = crate :: BitReader ;
#[doc = "Field `LFSDET` writer - Late frame synchronization detection interrupt enable"] pub type LfsdetW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Overrun/underrun interrupt enable"]
#[inline (always)] pub fn ovrudrie (& self) -> OvrudrieR { OvrudrieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Mute detection interrupt enable"]
#[inline (always)] pub fn mutedet (& self) -> MutedetR { MutedetR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Wrong clock configuration interrupt enable"]
#[inline (always)] pub fn wckcfg (& self) -> WckcfgR { WckcfgR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - FIFO request interrupt enable"]
#[inline (always)] pub fn freqie (& self) -> FreqieR { FreqieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Codec not ready interrupt enable"]
#[inline (always)] pub fn cnrdyie (& self) -> CnrdyieR { CnrdyieR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Anticipated frame synchronization detection interrupt enable"]
#[inline (always)] pub fn afsdetie (& self) -> AfsdetieR { AfsdetieR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Late frame synchronization detection interrupt enable"]
#[inline (always)] pub fn lfsdet (& self) -> LfsdetR { LfsdetR :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Overrun/underrun interrupt enable"]
#[inline (always)] pub fn ovrudrie (& mut self) -> OvrudrieW < '_ , AimSpec > { OvrudrieW :: new (self , 0) }
#[doc = "Bit 1 - Mute detection interrupt enable"]
#[inline (always)] pub fn mutedet (& mut self) -> MutedetW < '_ , AimSpec > { MutedetW :: new (self , 1) }
#[doc = "Bit 2 - Wrong clock configuration interrupt enable"]
#[inline (always)] pub fn wckcfg (& mut self) -> WckcfgW < '_ , AimSpec > { WckcfgW :: new (self , 2) }
#[doc = "Bit 3 - FIFO request interrupt enable"]
#[inline (always)] pub fn freqie (& mut self) -> FreqieW < '_ , AimSpec > { FreqieW :: new (self , 3) }
#[doc = "Bit 4 - Codec not ready interrupt enable"]
#[inline (always)] pub fn cnrdyie (& mut self) -> CnrdyieW < '_ , AimSpec > { CnrdyieW :: new (self , 4) }
#[doc = "Bit 5 - Anticipated frame synchronization detection interrupt enable"]
#[inline (always)] pub fn afsdetie (& mut self) -> AfsdetieW < '_ , AimSpec > { AfsdetieW :: new (self , 5) }
#[doc = "Bit 6 - Late frame synchronization detection interrupt enable"]
#[inline (always)] pub fn lfsdet (& mut self) -> LfsdetW < '_ , AimSpec > { LfsdetW :: new (self , 6) } }
#[doc = "AInterrupt mask register2\n\nYou can [`read`](crate::Reg::read) this register and get [`aim::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`aim::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AimSpec ; impl crate :: RegisterSpec for AimSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`aim::R`](R) reader structure"] impl crate :: Readable for AimSpec { }
#[doc = "`write(|w| ..)` method takes [`aim::W`](W) writer structure"] impl crate :: Writable for AimSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AIM to value 0"] impl crate :: Resettable for AimSpec { } }
#[doc = "ASR (r) register accessor: AStatus register\n\nYou can [`read`](crate::Reg::read) this register and get [`asr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@asr`] module"]
#[doc (alias = "ASR")] pub type Asr = crate :: Reg < asr :: AsrSpec > ;
#[doc = "AStatus register"] pub mod asr {
#[doc = "Register `ASR` reader"] pub type R = crate :: R < AsrSpec > ;
#[doc = "Field `OVRUDR` reader - Overrun / underrun"] pub type OvrudrR = crate :: BitReader ;
#[doc = "Field `MUTEDET` reader - Mute detection"] pub type MutedetR = crate :: BitReader ;
#[doc = "Field `WCKCFG` reader - Wrong clock configuration flag. This bit is read only"] pub type WckcfgR = crate :: BitReader ;
#[doc = "Field `FREQ` reader - FIFO request"] pub type FreqR = crate :: BitReader ;
#[doc = "Field `CNRDY` reader - Codec not ready"] pub type CnrdyR = crate :: BitReader ;
#[doc = "Field `AFSDET` reader - Anticipated frame synchronization detection"] pub type AfsdetR = crate :: BitReader ;
#[doc = "Field `LFSDET` reader - Late frame synchronization detection"] pub type LfsdetR = crate :: BitReader ;
#[doc = "Field `FLVL` reader - FIFO level threshold"] pub type FlvlR = crate :: FieldReader ; impl R {
#[doc = "Bit 0 - Overrun / underrun"]
#[inline (always)] pub fn ovrudr (& self) -> OvrudrR { OvrudrR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Mute detection"]
#[inline (always)] pub fn mutedet (& self) -> MutedetR { MutedetR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Wrong clock configuration flag. This bit is read only"]
#[inline (always)] pub fn wckcfg (& self) -> WckcfgR { WckcfgR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - FIFO request"]
#[inline (always)] pub fn freq (& self) -> FreqR { FreqR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Codec not ready"]
#[inline (always)] pub fn cnrdy (& self) -> CnrdyR { CnrdyR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Anticipated frame synchronization detection"]
#[inline (always)] pub fn afsdet (& self) -> AfsdetR { AfsdetR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Late frame synchronization detection"]
#[inline (always)] pub fn lfsdet (& self) -> LfsdetR { LfsdetR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bits 16:18 - FIFO level threshold"]
#[inline (always)] pub fn flvl (& self) -> FlvlR { FlvlR :: new (((self . bits >> 16) & 7) as u8) } }
#[doc = "AStatus register\n\nYou can [`read`](crate::Reg::read) this register and get [`asr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AsrSpec ; impl crate :: RegisterSpec for AsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`asr::R`](R) reader structure"] impl crate :: Readable for AsrSpec { }
#[doc = "`reset()` method sets ASR to value 0x08"] impl crate :: Resettable for AsrSpec { const RESET_VALUE : u32 = 0x08 ; } }
#[doc = "ACLRFR (w) register accessor: AClear flag register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`aclrfr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@aclrfr`] module"]
#[doc (alias = "ACLRFR")] pub type Aclrfr = crate :: Reg < aclrfr :: AclrfrSpec > ;
#[doc = "AClear flag register"] pub mod aclrfr {
#[doc = "Register `ACLRFR` writer"] pub type W = crate :: W < AclrfrSpec > ;
#[doc = "Field `OVRUDR` writer - Clear overrun / underrun"] pub type OvrudrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MUTEDET` writer - Mute detection flag"] pub type MutedetW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WCKCFG` writer - Clear wrong clock configuration flag"] pub type WckcfgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CNRDY` writer - Clear codec not ready flag"] pub type CnrdyW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CAFSDET` writer - Clear anticipated frame synchronization detection flag"] pub type CafsdetW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LFSDET` writer - Clear late frame synchronization detection flag"] pub type LfsdetW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Clear overrun / underrun"]
#[inline (always)] pub fn ovrudr (& mut self) -> OvrudrW < '_ , AclrfrSpec > { OvrudrW :: new (self , 0) }
#[doc = "Bit 1 - Mute detection flag"]
#[inline (always)] pub fn mutedet (& mut self) -> MutedetW < '_ , AclrfrSpec > { MutedetW :: new (self , 1) }
#[doc = "Bit 2 - Clear wrong clock configuration flag"]
#[inline (always)] pub fn wckcfg (& mut self) -> WckcfgW < '_ , AclrfrSpec > { WckcfgW :: new (self , 2) }
#[doc = "Bit 4 - Clear codec not ready flag"]
#[inline (always)] pub fn cnrdy (& mut self) -> CnrdyW < '_ , AclrfrSpec > { CnrdyW :: new (self , 4) }
#[doc = "Bit 5 - Clear anticipated frame synchronization detection flag"]
#[inline (always)] pub fn cafsdet (& mut self) -> CafsdetW < '_ , AclrfrSpec > { CafsdetW :: new (self , 5) }
#[doc = "Bit 6 - Clear late frame synchronization detection flag"]
#[inline (always)] pub fn lfsdet (& mut self) -> LfsdetW < '_ , AclrfrSpec > { LfsdetW :: new (self , 6) } }
#[doc = "AClear flag register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`aclrfr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AclrfrSpec ; impl crate :: RegisterSpec for AclrfrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`aclrfr::W`](W) writer structure"] impl crate :: Writable for AclrfrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ACLRFR to value 0"] impl crate :: Resettable for AclrfrSpec { } }
#[doc = "ADR (rw) register accessor: AData register\n\nYou can [`read`](crate::Reg::read) this register and get [`adr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@adr`] module"]
#[doc (alias = "ADR")] pub type Adr = crate :: Reg < adr :: AdrSpec > ;
#[doc = "AData register"] pub mod adr {
#[doc = "Register `ADR` reader"] pub type R = crate :: R < AdrSpec > ;
#[doc = "Register `ADR` writer"] pub type W = crate :: W < AdrSpec > ;
#[doc = "Field `DATA` reader - Data"] pub type DataR = crate :: FieldReader < u32 > ;
#[doc = "Field `DATA` writer - Data"] pub type DataW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Data"]
#[inline (always)] pub fn data (& self) -> DataR { DataR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Data"]
#[inline (always)] pub fn data (& mut self) -> DataW < '_ , AdrSpec > { DataW :: new (self , 0) } }
#[doc = "AData register\n\nYou can [`read`](crate::Reg::read) this register and get [`adr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AdrSpec ; impl crate :: RegisterSpec for AdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`adr::R`](R) reader structure"] impl crate :: Readable for AdrSpec { }
#[doc = "`write(|w| ..)` method takes [`adr::W`](W) writer structure"] impl crate :: Writable for AdrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ADR to value 0"] impl crate :: Resettable for AdrSpec { } }
#[doc = "PDMCR (rw) register accessor: PDM control register\n\nYou can [`read`](crate::Reg::read) this register and get [`pdmcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pdmcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pdmcr`] module"]
#[doc (alias = "PDMCR")] pub type Pdmcr = crate :: Reg < pdmcr :: PdmcrSpec > ;
#[doc = "PDM control register"] pub mod pdmcr {
#[doc = "Register `PDMCR` reader"] pub type R = crate :: R < PdmcrSpec > ;
#[doc = "Register `PDMCR` writer"] pub type W = crate :: W < PdmcrSpec > ;
#[doc = "Field `PDMEN` reader - PDM enable"] pub type PdmenR = crate :: BitReader ;
#[doc = "Field `PDMEN` writer - PDM enable"] pub type PdmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MICNBR` reader - Number of microphones"] pub type MicnbrR = crate :: FieldReader ;
#[doc = "Field `MICNBR` writer - Number of microphones"] pub type MicnbrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CKEN1` reader - Clock enable of bitstream clock number 1"] pub type Cken1R = crate :: BitReader ;
#[doc = "Field `CKEN1` writer - Clock enable of bitstream clock number 1"] pub type Cken1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CKEN2` reader - Clock enable of bitstream clock number 2"] pub type Cken2R = crate :: BitReader ;
#[doc = "Field `CKEN2` writer - Clock enable of bitstream clock number 2"] pub type Cken2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CKEN3` reader - Clock enable of bitstream clock number 3"] pub type Cken3R = crate :: BitReader ;
#[doc = "Field `CKEN3` writer - Clock enable of bitstream clock number 3"] pub type Cken3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CKEN4` reader - Clock enable of bitstream clock number 4"] pub type Cken4R = crate :: BitReader ;
#[doc = "Field `CKEN4` writer - Clock enable of bitstream clock number 4"] pub type Cken4W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - PDM enable"]
#[inline (always)] pub fn pdmen (& self) -> PdmenR { PdmenR :: new ((self . bits & 1) != 0) }
#[doc = "Bits 4:5 - Number of microphones"]
#[inline (always)] pub fn micnbr (& self) -> MicnbrR { MicnbrR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 8 - Clock enable of bitstream clock number 1"]
#[inline (always)] pub fn cken1 (& self) -> Cken1R { Cken1R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Clock enable of bitstream clock number 2"]
#[inline (always)] pub fn cken2 (& self) -> Cken2R { Cken2R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Clock enable of bitstream clock number 3"]
#[inline (always)] pub fn cken3 (& self) -> Cken3R { Cken3R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Clock enable of bitstream clock number 4"]
#[inline (always)] pub fn cken4 (& self) -> Cken4R { Cken4R :: new (((self . bits >> 11) & 1) != 0) } } impl W {
#[doc = "Bit 0 - PDM enable"]
#[inline (always)] pub fn pdmen (& mut self) -> PdmenW < '_ , PdmcrSpec > { PdmenW :: new (self , 0) }
#[doc = "Bits 4:5 - Number of microphones"]
#[inline (always)] pub fn micnbr (& mut self) -> MicnbrW < '_ , PdmcrSpec > { MicnbrW :: new (self , 4) }
#[doc = "Bit 8 - Clock enable of bitstream clock number 1"]
#[inline (always)] pub fn cken1 (& mut self) -> Cken1W < '_ , PdmcrSpec > { Cken1W :: new (self , 8) }
#[doc = "Bit 9 - Clock enable of bitstream clock number 2"]
#[inline (always)] pub fn cken2 (& mut self) -> Cken2W < '_ , PdmcrSpec > { Cken2W :: new (self , 9) }
#[doc = "Bit 10 - Clock enable of bitstream clock number 3"]
#[inline (always)] pub fn cken3 (& mut self) -> Cken3W < '_ , PdmcrSpec > { Cken3W :: new (self , 10) }
#[doc = "Bit 11 - Clock enable of bitstream clock number 4"]
#[inline (always)] pub fn cken4 (& mut self) -> Cken4W < '_ , PdmcrSpec > { Cken4W :: new (self , 11) } }
#[doc = "PDM control register\n\nYou can [`read`](crate::Reg::read) this register and get [`pdmcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pdmcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PdmcrSpec ; impl crate :: RegisterSpec for PdmcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pdmcr::R`](R) reader structure"] impl crate :: Readable for PdmcrSpec { }
#[doc = "`write(|w| ..)` method takes [`pdmcr::W`](W) writer structure"] impl crate :: Writable for PdmcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PDMCR to value 0"] impl crate :: Resettable for PdmcrSpec { } }
#[doc = "PDMDLY (rw) register accessor: PDM delay register\n\nYou can [`read`](crate::Reg::read) this register and get [`pdmdly::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pdmdly::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pdmdly`] module"]
#[doc (alias = "PDMDLY")] pub type Pdmdly = crate :: Reg < pdmdly :: PdmdlySpec > ;
#[doc = "PDM delay register"] pub mod pdmdly {
#[doc = "Register `PDMDLY` reader"] pub type R = crate :: R < PdmdlySpec > ;
#[doc = "Register `PDMDLY` writer"] pub type W = crate :: W < PdmdlySpec > ;
#[doc = "Field `DLYM1L` reader - Delay line for first microphone of pair 1"] pub type Dlym1lR = crate :: FieldReader ;
#[doc = "Field `DLYM1L` writer - Delay line for first microphone of pair 1"] pub type Dlym1lW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `DLYM1R` reader - Delay line for second microphone of pair 1"] pub type Dlym1rR = crate :: FieldReader ;
#[doc = "Field `DLYM1R` writer - Delay line for second microphone of pair 1"] pub type Dlym1rW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `DLYM2L` reader - Delay line for first microphone of pair 2"] pub type Dlym2lR = crate :: FieldReader ;
#[doc = "Field `DLYM2L` writer - Delay line for first microphone of pair 2"] pub type Dlym2lW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `DLYM2R` reader - Delay line for second microphone of pair 2"] pub type Dlym2rR = crate :: FieldReader ;
#[doc = "Field `DLYM2R` writer - Delay line for second microphone of pair 2"] pub type Dlym2rW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `DLYM3L` reader - Delay line for first microphone of pair 3"] pub type Dlym3lR = crate :: FieldReader ;
#[doc = "Field `DLYM3L` writer - Delay line for first microphone of pair 3"] pub type Dlym3lW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `DLYM3R` reader - Delay line for second microphone of pair 3"] pub type Dlym3rR = crate :: FieldReader ;
#[doc = "Field `DLYM3R` writer - Delay line for second microphone of pair 3"] pub type Dlym3rW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `DLYM4L` reader - Delay line for first microphone of pair 4"] pub type Dlym4lR = crate :: FieldReader ;
#[doc = "Field `DLYM4L` writer - Delay line for first microphone of pair 4"] pub type Dlym4lW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `DLYM4R` reader - Delay line for second microphone of pair 4"] pub type Dlym4rR = crate :: FieldReader ;
#[doc = "Field `DLYM4R` writer - Delay line for second microphone of pair 4"] pub type Dlym4rW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:2 - Delay line for first microphone of pair 1"]
#[inline (always)] pub fn dlym1l (& self) -> Dlym1lR { Dlym1lR :: new ((self . bits & 7) as u8) }
#[doc = "Bits 4:6 - Delay line for second microphone of pair 1"]
#[inline (always)] pub fn dlym1r (& self) -> Dlym1rR { Dlym1rR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bits 8:10 - Delay line for first microphone of pair 2"]
#[inline (always)] pub fn dlym2l (& self) -> Dlym2lR { Dlym2lR :: new (((self . bits >> 8) & 7) as u8) }
#[doc = "Bits 12:14 - Delay line for second microphone of pair 2"]
#[inline (always)] pub fn dlym2r (& self) -> Dlym2rR { Dlym2rR :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bits 16:18 - Delay line for first microphone of pair 3"]
#[inline (always)] pub fn dlym3l (& self) -> Dlym3lR { Dlym3lR :: new (((self . bits >> 16) & 7) as u8) }
#[doc = "Bits 20:22 - Delay line for second microphone of pair 3"]
#[inline (always)] pub fn dlym3r (& self) -> Dlym3rR { Dlym3rR :: new (((self . bits >> 20) & 7) as u8) }
#[doc = "Bits 24:26 - Delay line for first microphone of pair 4"]
#[inline (always)] pub fn dlym4l (& self) -> Dlym4lR { Dlym4lR :: new (((self . bits >> 24) & 7) as u8) }
#[doc = "Bits 28:30 - Delay line for second microphone of pair 4"]
#[inline (always)] pub fn dlym4r (& self) -> Dlym4rR { Dlym4rR :: new (((self . bits >> 28) & 7) as u8) } } impl W {
#[doc = "Bits 0:2 - Delay line for first microphone of pair 1"]
#[inline (always)] pub fn dlym1l (& mut self) -> Dlym1lW < '_ , PdmdlySpec > { Dlym1lW :: new (self , 0) }
#[doc = "Bits 4:6 - Delay line for second microphone of pair 1"]
#[inline (always)] pub fn dlym1r (& mut self) -> Dlym1rW < '_ , PdmdlySpec > { Dlym1rW :: new (self , 4) }
#[doc = "Bits 8:10 - Delay line for first microphone of pair 2"]
#[inline (always)] pub fn dlym2l (& mut self) -> Dlym2lW < '_ , PdmdlySpec > { Dlym2lW :: new (self , 8) }
#[doc = "Bits 12:14 - Delay line for second microphone of pair 2"]
#[inline (always)] pub fn dlym2r (& mut self) -> Dlym2rW < '_ , PdmdlySpec > { Dlym2rW :: new (self , 12) }
#[doc = "Bits 16:18 - Delay line for first microphone of pair 3"]
#[inline (always)] pub fn dlym3l (& mut self) -> Dlym3lW < '_ , PdmdlySpec > { Dlym3lW :: new (self , 16) }
#[doc = "Bits 20:22 - Delay line for second microphone of pair 3"]
#[inline (always)] pub fn dlym3r (& mut self) -> Dlym3rW < '_ , PdmdlySpec > { Dlym3rW :: new (self , 20) }
#[doc = "Bits 24:26 - Delay line for first microphone of pair 4"]
#[inline (always)] pub fn dlym4l (& mut self) -> Dlym4lW < '_ , PdmdlySpec > { Dlym4lW :: new (self , 24) }
#[doc = "Bits 28:30 - Delay line for second microphone of pair 4"]
#[inline (always)] pub fn dlym4r (& mut self) -> Dlym4rW < '_ , PdmdlySpec > { Dlym4rW :: new (self , 28) } }
#[doc = "PDM delay register\n\nYou can [`read`](crate::Reg::read) this register and get [`pdmdly::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pdmdly::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PdmdlySpec ; impl crate :: RegisterSpec for PdmdlySpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pdmdly::R`](R) reader structure"] impl crate :: Readable for PdmdlySpec { }
#[doc = "`write(|w| ..)` method takes [`pdmdly::W`](W) writer structure"] impl crate :: Writable for PdmdlySpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PDMDLY to value 0"] impl crate :: Resettable for PdmdlySpec { } } }
#[doc = "General-purpose-timers"] pub type Tim2 = crate :: Periph < tim2 :: RegisterBlock , 0x4000_0000 > ; impl core :: fmt :: Debug for Tim2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim2") . finish () } }
#[doc = "General-purpose-timers"] pub mod tim2 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr1 : Cr1 , cr2 : Cr2 , smcr : Smcr , dier : Dier , sr : Sr , egr : Egr , _reserved_6_ccmr1 : [u8 ; 0x04] , _reserved_7_ccmr2 : [u8 ; 0x04] , ccer : Ccer , cnt : Cnt , psc : Psc , arr : Arr , _reserved12 : [u8 ; 0x04] , ccr1 : Ccr1 , ccr2 : Ccr2 , ccr3 : Ccr3 , ccr4 : Ccr4 , _reserved16 : [u8 ; 0x04] , dcr : Dcr , dmar : Dmar , or : Or , _reserved19 : [u8 ; 0x0c] , af : Af , } impl RegisterBlock {
#[doc = "0x00 - control register 1"]
#[inline (always)] pub const fn cr1 (& self) -> & Cr1 { & self . cr1 }
#[doc = "0x04 - control register 2"]
#[inline (always)] pub const fn cr2 (& self) -> & Cr2 { & self . cr2 }
#[doc = "0x08 - slave mode control register"]
#[inline (always)] pub const fn smcr (& self) -> & Smcr { & self . smcr }
#[doc = "0x0c - DMA/Interrupt enable register"]
#[inline (always)] pub const fn dier (& self) -> & Dier { & self . dier }
#[doc = "0x10 - status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x14 - event generation register"]
#[inline (always)] pub const fn egr (& self) -> & Egr { & self . egr }
#[doc = "0x18 - capture/compare mode register 1 (input mode)"]
#[inline (always)] pub const fn ccmr1_input (& self) -> & Ccmr1Input { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x18 - capture/compare mode register 1 (output mode)"]
#[inline (always)] pub const fn ccmr1_output (& self) -> & Ccmr1Output { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x1c - capture/compare mode register 2 (input mode)"]
#[inline (always)] pub const fn ccmr2_input (& self) -> & Ccmr2Input { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (28) . cast () } }
#[doc = "0x1c - capture/compare mode register 2 (output mode)"]
#[inline (always)] pub const fn ccmr2_output (& self) -> & Ccmr2Output { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (28) . cast () } }
#[doc = "0x20 - capture/compare enable register"]
#[inline (always)] pub const fn ccer (& self) -> & Ccer { & self . ccer }
#[doc = "0x24 - counter"]
#[inline (always)] pub const fn cnt (& self) -> & Cnt { & self . cnt }
#[doc = "0x28 - prescaler"]
#[inline (always)] pub const fn psc (& self) -> & Psc { & self . psc }
#[doc = "0x2c - auto-reload register"]
#[inline (always)] pub const fn arr (& self) -> & Arr { & self . arr }
#[doc = "0x34 - capture/compare register 1"]
#[inline (always)] pub const fn ccr1 (& self) -> & Ccr1 { & self . ccr1 }
#[doc = "0x38 - capture/compare register 2"]
#[inline (always)] pub const fn ccr2 (& self) -> & Ccr2 { & self . ccr2 }
#[doc = "0x3c - capture/compare register 3"]
#[inline (always)] pub const fn ccr3 (& self) -> & Ccr3 { & self . ccr3 }
#[doc = "0x40 - capture/compare register 4"]
#[inline (always)] pub const fn ccr4 (& self) -> & Ccr4 { & self . ccr4 }
#[doc = "0x48 - DMA control register"]
#[inline (always)] pub const fn dcr (& self) -> & Dcr { & self . dcr }
#[doc = "0x4c - DMA address for full transfer"]
#[inline (always)] pub const fn dmar (& self) -> & Dmar { & self . dmar }
#[doc = "0x50 - TIM2 option register"]
#[inline (always)] pub const fn or (& self) -> & Or { & self . or }
#[doc = "0x60 - TIM2 alternate function option register 1"]
#[inline (always)] pub const fn af (& self) -> & Af { & self . af } }
#[doc = "CR1 (rw) register accessor: control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
#[doc (alias = "CR1")] pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ;
#[doc = "control register 1"] pub mod cr1 {
#[doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ;
#[doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ;
#[doc = "Field `CEN` reader - Counter enable"] pub type CenR = crate :: BitReader ;
#[doc = "Field `CEN` writer - Counter enable"] pub type CenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDIS` reader - Update disable"] pub type UdisR = crate :: BitReader ;
#[doc = "Field `UDIS` writer - Update disable"] pub type UdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `URS` reader - Update request source"] pub type UrsR = crate :: BitReader ;
#[doc = "Field `URS` writer - Update request source"] pub type UrsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OPM` reader - One-pulse mode"] pub type OpmR = crate :: BitReader ;
#[doc = "Field `OPM` writer - One-pulse mode"] pub type OpmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CMS` reader - Center-aligned mode selection"] pub type CmsR = crate :: FieldReader ;
#[doc = "Field `CMS` writer - Center-aligned mode selection"] pub type CmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ARPE` reader - Auto-reload preload enable"] pub type ArpeR = crate :: BitReader ;
#[doc = "Field `ARPE` writer - Auto-reload preload enable"] pub type ArpeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CKD` reader - Clock division"] pub type CkdR = crate :: FieldReader ;
#[doc = "Field `CKD` writer - Clock division"] pub type CkdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UIFREMAP` reader - UIF status bit remapping"] pub type UifremapR = crate :: BitReader ;
#[doc = "Field `UIFREMAP` writer - UIF status bit remapping"] pub type UifremapW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& self) -> CenR { CenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& self) -> UdisR { UdisR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& self) -> UrsR { UrsR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - One-pulse mode"]
#[inline (always)] pub fn opm (& self) -> OpmR { OpmR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bits 5:6 - Center-aligned mode selection"]
#[inline (always)] pub fn cms (& self) -> CmsR { CmsR :: new (((self . bits >> 5) & 3) as u8) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& self) -> ArpeR { ArpeR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Clock division"]
#[inline (always)] pub fn ckd (& self) -> CkdR { CkdR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 11 - UIF status bit remapping"]
#[inline (always)] pub fn uifremap (& self) -> UifremapR { UifremapR :: new (((self . bits >> 11) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& mut self) -> CenW < '_ , Cr1Spec > { CenW :: new (self , 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& mut self) -> UdisW < '_ , Cr1Spec > { UdisW :: new (self , 1) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& mut self) -> UrsW < '_ , Cr1Spec > { UrsW :: new (self , 2) }
#[doc = "Bit 3 - One-pulse mode"]
#[inline (always)] pub fn opm (& mut self) -> OpmW < '_ , Cr1Spec > { OpmW :: new (self , 3) }
#[doc = "Bit 4 - Direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Cr1Spec > { DirW :: new (self , 4) }
#[doc = "Bits 5:6 - Center-aligned mode selection"]
#[inline (always)] pub fn cms (& mut self) -> CmsW < '_ , Cr1Spec > { CmsW :: new (self , 5) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& mut self) -> ArpeW < '_ , Cr1Spec > { ArpeW :: new (self , 7) }
#[doc = "Bits 8:9 - Clock division"]
#[inline (always)] pub fn ckd (& mut self) -> CkdW < '_ , Cr1Spec > { CkdW :: new (self , 8) }
#[doc = "Bit 11 - UIF status bit remapping"]
#[inline (always)] pub fn uifremap (& mut self) -> UifremapW < '_ , Cr1Spec > { UifremapW :: new (self , 11) } }
#[doc = "control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { } }
#[doc = "CR2 (rw) register accessor: control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`] module"]
#[doc (alias = "CR2")] pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ;
#[doc = "control register 2"] pub mod cr2 {
#[doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ;
#[doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ;
#[doc = "Field `CCDS` reader - Capture/compare DMA selection"] pub type CcdsR = crate :: BitReader ;
#[doc = "Field `CCDS` writer - Capture/compare DMA selection"] pub type CcdsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MMS` reader - Master mode selection"] pub type MmsR = crate :: FieldReader ;
#[doc = "Field `MMS` writer - Master mode selection"] pub type MmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `TI1S` reader - TI1 selection"] pub type Ti1sR = crate :: BitReader ;
#[doc = "Field `TI1S` writer - TI1 selection"] pub type Ti1sW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 3 - Capture/compare DMA selection"]
#[inline (always)] pub fn ccds (& self) -> CcdsR { CcdsR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Master mode selection"]
#[inline (always)] pub fn mms (& self) -> MmsR { MmsR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - TI1 selection"]
#[inline (always)] pub fn ti1s (& self) -> Ti1sR { Ti1sR :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 3 - Capture/compare DMA selection"]
#[inline (always)] pub fn ccds (& mut self) -> CcdsW < '_ , Cr2Spec > { CcdsW :: new (self , 3) }
#[doc = "Bits 4:6 - Master mode selection"]
#[inline (always)] pub fn mms (& mut self) -> MmsW < '_ , Cr2Spec > { MmsW :: new (self , 4) }
#[doc = "Bit 7 - TI1 selection"]
#[inline (always)] pub fn ti1s (& mut self) -> Ti1sW < '_ , Cr2Spec > { Ti1sW :: new (self , 7) } }
#[doc = "control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR2 to value 0"] impl crate :: Resettable for Cr2Spec { } }
#[doc = "SMCR (rw) register accessor: slave mode control register\n\nYou can [`read`](crate::Reg::read) this register and get [`smcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@smcr`] module"]
#[doc (alias = "SMCR")] pub type Smcr = crate :: Reg < smcr :: SmcrSpec > ;
#[doc = "slave mode control register"] pub mod smcr {
#[doc = "Register `SMCR` reader"] pub type R = crate :: R < SmcrSpec > ;
#[doc = "Register `SMCR` writer"] pub type W = crate :: W < SmcrSpec > ;
#[doc = "Field `SMS` reader - Slave mode selection"] pub type SmsR = crate :: FieldReader ;
#[doc = "Field `SMS` writer - Slave mode selection"] pub type SmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OCCS` reader - OCREF clear selection"] pub type OccsR = crate :: BitReader ;
#[doc = "Field `OCCS` writer - OCREF clear selection"] pub type OccsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TS` reader - Trigger selection"] pub type TsR = crate :: FieldReader ;
#[doc = "Field `TS` writer - Trigger selection"] pub type TsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `MSM` reader - Master/Slave mode"] pub type MsmR = crate :: BitReader ;
#[doc = "Field `MSM` writer - Master/Slave mode"] pub type MsmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ETF` reader - External trigger filter"] pub type EtfR = crate :: FieldReader ;
#[doc = "Field `ETF` writer - External trigger filter"] pub type EtfW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ETPS` reader - External trigger prescaler"] pub type EtpsR = crate :: FieldReader ;
#[doc = "Field `ETPS` writer - External trigger prescaler"] pub type EtpsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ECE` reader - External clock enable"] pub type EceR = crate :: BitReader ;
#[doc = "Field `ECE` writer - External clock enable"] pub type EceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ETP` reader - External trigger polarity"] pub type EtpR = crate :: BitReader ;
#[doc = "Field `ETP` writer - External trigger polarity"] pub type EtpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SMS_3` reader - Slave mode selection - bit 3"] pub type Sms3R = crate :: BitReader ;
#[doc = "Field `SMS_3` writer - Slave mode selection - bit 3"] pub type Sms3W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:2 - Slave mode selection"]
#[inline (always)] pub fn sms (& self) -> SmsR { SmsR :: new ((self . bits & 7) as u8) }
#[doc = "Bit 3 - OCREF clear selection"]
#[inline (always)] pub fn occs (& self) -> OccsR { OccsR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Trigger selection"]
#[inline (always)] pub fn ts (& self) -> TsR { TsR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Master/Slave mode"]
#[inline (always)] pub fn msm (& self) -> MsmR { MsmR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:11 - External trigger filter"]
#[inline (always)] pub fn etf (& self) -> EtfR { EtfR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:13 - External trigger prescaler"]
#[inline (always)] pub fn etps (& self) -> EtpsR { EtpsR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - External clock enable"]
#[inline (always)] pub fn ece (& self) -> EceR { EceR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - External trigger polarity"]
#[inline (always)] pub fn etp (& self) -> EtpR { EtpR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Slave mode selection - bit 3"]
#[inline (always)] pub fn sms_3 (& self) -> Sms3R { Sms3R :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bits 0:2 - Slave mode selection"]
#[inline (always)] pub fn sms (& mut self) -> SmsW < '_ , SmcrSpec > { SmsW :: new (self , 0) }
#[doc = "Bit 3 - OCREF clear selection"]
#[inline (always)] pub fn occs (& mut self) -> OccsW < '_ , SmcrSpec > { OccsW :: new (self , 3) }
#[doc = "Bits 4:6 - Trigger selection"]
#[inline (always)] pub fn ts (& mut self) -> TsW < '_ , SmcrSpec > { TsW :: new (self , 4) }
#[doc = "Bit 7 - Master/Slave mode"]
#[inline (always)] pub fn msm (& mut self) -> MsmW < '_ , SmcrSpec > { MsmW :: new (self , 7) }
#[doc = "Bits 8:11 - External trigger filter"]
#[inline (always)] pub fn etf (& mut self) -> EtfW < '_ , SmcrSpec > { EtfW :: new (self , 8) }
#[doc = "Bits 12:13 - External trigger prescaler"]
#[inline (always)] pub fn etps (& mut self) -> EtpsW < '_ , SmcrSpec > { EtpsW :: new (self , 12) }
#[doc = "Bit 14 - External clock enable"]
#[inline (always)] pub fn ece (& mut self) -> EceW < '_ , SmcrSpec > { EceW :: new (self , 14) }
#[doc = "Bit 15 - External trigger polarity"]
#[inline (always)] pub fn etp (& mut self) -> EtpW < '_ , SmcrSpec > { EtpW :: new (self , 15) }
#[doc = "Bit 16 - Slave mode selection - bit 3"]
#[inline (always)] pub fn sms_3 (& mut self) -> Sms3W < '_ , SmcrSpec > { Sms3W :: new (self , 16) } }
#[doc = "slave mode control register\n\nYou can [`read`](crate::Reg::read) this register and get [`smcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SmcrSpec ; impl crate :: RegisterSpec for SmcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`smcr::R`](R) reader structure"] impl crate :: Readable for SmcrSpec { }
#[doc = "`write(|w| ..)` method takes [`smcr::W`](W) writer structure"] impl crate :: Writable for SmcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SMCR to value 0"] impl crate :: Resettable for SmcrSpec { } }
#[doc = "DIER (rw) register accessor: DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dier`] module"]
#[doc (alias = "DIER")] pub type Dier = crate :: Reg < dier :: DierSpec > ;
#[doc = "DMA/Interrupt enable register"] pub mod dier {
#[doc = "Register `DIER` reader"] pub type R = crate :: R < DierSpec > ;
#[doc = "Register `DIER` writer"] pub type W = crate :: W < DierSpec > ;
#[doc = "Field `UIE` reader - Update interrupt enable"] pub type UieR = crate :: BitReader ;
#[doc = "Field `UIE` writer - Update interrupt enable"] pub type UieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1IE` reader - Capture/Compare 1 interrupt enable"] pub type Cc1ieR = crate :: BitReader ;
#[doc = "Field `CC1IE` writer - Capture/Compare 1 interrupt enable"] pub type Cc1ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2IE` reader - Capture/Compare 2 interrupt enable"] pub type Cc2ieR = crate :: BitReader ;
#[doc = "Field `CC2IE` writer - Capture/Compare 2 interrupt enable"] pub type Cc2ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3IE` reader - Capture/Compare 3 interrupt enable"] pub type Cc3ieR = crate :: BitReader ;
#[doc = "Field `CC3IE` writer - Capture/Compare 3 interrupt enable"] pub type Cc3ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4IE` reader - Capture/Compare 4 interrupt enable"] pub type Cc4ieR = crate :: BitReader ;
#[doc = "Field `CC4IE` writer - Capture/Compare 4 interrupt enable"] pub type Cc4ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIE` reader - Trigger interrupt enable"] pub type TieR = crate :: BitReader ;
#[doc = "Field `TIE` writer - Trigger interrupt enable"] pub type TieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDE` reader - Update DMA request enable"] pub type UdeR = crate :: BitReader ;
#[doc = "Field `UDE` writer - Update DMA request enable"] pub type UdeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1DE` reader - Capture/Compare 1 DMA request enable"] pub type Cc1deR = crate :: BitReader ;
#[doc = "Field `CC1DE` writer - Capture/Compare 1 DMA request enable"] pub type Cc1deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2DE` reader - Capture/Compare 2 DMA request enable"] pub type Cc2deR = crate :: BitReader ;
#[doc = "Field `CC2DE` writer - Capture/Compare 2 DMA request enable"] pub type Cc2deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3DE` reader - Capture/Compare 3 DMA request enable"] pub type Cc3deR = crate :: BitReader ;
#[doc = "Field `CC3DE` writer - Capture/Compare 3 DMA request enable"] pub type Cc3deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4DE` reader - Capture/Compare 4 DMA request enable"] pub type Cc4deR = crate :: BitReader ;
#[doc = "Field `CC4DE` writer - Capture/Compare 4 DMA request enable"] pub type Cc4deW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& self) -> UieR { UieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
#[inline (always)] pub fn cc1ie (& self) -> Cc1ieR { Cc1ieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
#[inline (always)] pub fn cc2ie (& self) -> Cc2ieR { Cc2ieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
#[inline (always)] pub fn cc3ie (& self) -> Cc3ieR { Cc3ieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
#[inline (always)] pub fn cc4ie (& self) -> Cc4ieR { Cc4ieR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - Trigger interrupt enable"]
#[inline (always)] pub fn tie (& self) -> TieR { TieR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 8 - Update DMA request enable"]
#[inline (always)] pub fn ude (& self) -> UdeR { UdeR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
#[inline (always)] pub fn cc1de (& self) -> Cc1deR { Cc1deR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
#[inline (always)] pub fn cc2de (& self) -> Cc2deR { Cc2deR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
#[inline (always)] pub fn cc3de (& self) -> Cc3deR { Cc3deR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
#[inline (always)] pub fn cc4de (& self) -> Cc4deR { Cc4deR :: new (((self . bits >> 12) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& mut self) -> UieW < '_ , DierSpec > { UieW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
#[inline (always)] pub fn cc1ie (& mut self) -> Cc1ieW < '_ , DierSpec > { Cc1ieW :: new (self , 1) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
#[inline (always)] pub fn cc2ie (& mut self) -> Cc2ieW < '_ , DierSpec > { Cc2ieW :: new (self , 2) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
#[inline (always)] pub fn cc3ie (& mut self) -> Cc3ieW < '_ , DierSpec > { Cc3ieW :: new (self , 3) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
#[inline (always)] pub fn cc4ie (& mut self) -> Cc4ieW < '_ , DierSpec > { Cc4ieW :: new (self , 4) }
#[doc = "Bit 6 - Trigger interrupt enable"]
#[inline (always)] pub fn tie (& mut self) -> TieW < '_ , DierSpec > { TieW :: new (self , 6) }
#[doc = "Bit 8 - Update DMA request enable"]
#[inline (always)] pub fn ude (& mut self) -> UdeW < '_ , DierSpec > { UdeW :: new (self , 8) }
#[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
#[inline (always)] pub fn cc1de (& mut self) -> Cc1deW < '_ , DierSpec > { Cc1deW :: new (self , 9) }
#[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
#[inline (always)] pub fn cc2de (& mut self) -> Cc2deW < '_ , DierSpec > { Cc2deW :: new (self , 10) }
#[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
#[inline (always)] pub fn cc3de (& mut self) -> Cc3deW < '_ , DierSpec > { Cc3deW :: new (self , 11) }
#[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
#[inline (always)] pub fn cc4de (& mut self) -> Cc4deW < '_ , DierSpec > { Cc4deW :: new (self , 12) } }
#[doc = "DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DierSpec ; impl crate :: RegisterSpec for DierSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dier::R`](R) reader structure"] impl crate :: Readable for DierSpec { }
#[doc = "`write(|w| ..)` method takes [`dier::W`](W) writer structure"] impl crate :: Writable for DierSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIER to value 0"] impl crate :: Resettable for DierSpec { } }
#[doc = "SR (rw) register accessor: status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `UIF` reader - Update interrupt flag"] pub type UifR = crate :: BitReader ;
#[doc = "Field `UIF` writer - Update interrupt flag"] pub type UifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1IF` reader - Capture/compare 1 interrupt flag"] pub type Cc1ifR = crate :: BitReader ;
#[doc = "Field `CC1IF` writer - Capture/compare 1 interrupt flag"] pub type Cc1ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2IF` reader - Capture/Compare 2 interrupt flag"] pub type Cc2ifR = crate :: BitReader ;
#[doc = "Field `CC2IF` writer - Capture/Compare 2 interrupt flag"] pub type Cc2ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3IF` reader - Capture/Compare 3 interrupt flag"] pub type Cc3ifR = crate :: BitReader ;
#[doc = "Field `CC3IF` writer - Capture/Compare 3 interrupt flag"] pub type Cc3ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4IF` reader - Capture/Compare 4 interrupt flag"] pub type Cc4ifR = crate :: BitReader ;
#[doc = "Field `CC4IF` writer - Capture/Compare 4 interrupt flag"] pub type Cc4ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIF` reader - Trigger interrupt flag"] pub type TifR = crate :: BitReader ;
#[doc = "Field `TIF` writer - Trigger interrupt flag"] pub type TifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1OF` reader - Capture/Compare 1 overcapture flag"] pub type Cc1ofR = crate :: BitReader ;
#[doc = "Field `CC1OF` writer - Capture/Compare 1 overcapture flag"] pub type Cc1ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2OF` reader - Capture/compare 2 overcapture flag"] pub type Cc2ofR = crate :: BitReader ;
#[doc = "Field `CC2OF` writer - Capture/compare 2 overcapture flag"] pub type Cc2ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3OF` reader - Capture/Compare 3 overcapture flag"] pub type Cc3ofR = crate :: BitReader ;
#[doc = "Field `CC3OF` writer - Capture/Compare 3 overcapture flag"] pub type Cc3ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4OF` reader - Capture/Compare 4 overcapture flag"] pub type Cc4ofR = crate :: BitReader ;
#[doc = "Field `CC4OF` writer - Capture/Compare 4 overcapture flag"] pub type Cc4ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& self) -> UifR { UifR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
#[inline (always)] pub fn cc1if (& self) -> Cc1ifR { Cc1ifR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
#[inline (always)] pub fn cc2if (& self) -> Cc2ifR { Cc2ifR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
#[inline (always)] pub fn cc3if (& self) -> Cc3ifR { Cc3ifR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
#[inline (always)] pub fn cc4if (& self) -> Cc4ifR { Cc4ifR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - Trigger interrupt flag"]
#[inline (always)] pub fn tif (& self) -> TifR { TifR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
#[inline (always)] pub fn cc1of (& self) -> Cc1ofR { Cc1ofR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
#[inline (always)] pub fn cc2of (& self) -> Cc2ofR { Cc2ofR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
#[inline (always)] pub fn cc3of (& self) -> Cc3ofR { Cc3ofR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
#[inline (always)] pub fn cc4of (& self) -> Cc4ofR { Cc4ofR :: new (((self . bits >> 12) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& mut self) -> UifW < '_ , SrSpec > { UifW :: new (self , 0) }
#[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
#[inline (always)] pub fn cc1if (& mut self) -> Cc1ifW < '_ , SrSpec > { Cc1ifW :: new (self , 1) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
#[inline (always)] pub fn cc2if (& mut self) -> Cc2ifW < '_ , SrSpec > { Cc2ifW :: new (self , 2) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
#[inline (always)] pub fn cc3if (& mut self) -> Cc3ifW < '_ , SrSpec > { Cc3ifW :: new (self , 3) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
#[inline (always)] pub fn cc4if (& mut self) -> Cc4ifW < '_ , SrSpec > { Cc4ifW :: new (self , 4) }
#[doc = "Bit 6 - Trigger interrupt flag"]
#[inline (always)] pub fn tif (& mut self) -> TifW < '_ , SrSpec > { TifW :: new (self , 6) }
#[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
#[inline (always)] pub fn cc1of (& mut self) -> Cc1ofW < '_ , SrSpec > { Cc1ofW :: new (self , 9) }
#[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
#[inline (always)] pub fn cc2of (& mut self) -> Cc2ofW < '_ , SrSpec > { Cc2ofW :: new (self , 10) }
#[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
#[inline (always)] pub fn cc3of (& mut self) -> Cc3ofW < '_ , SrSpec > { Cc3ofW :: new (self , 11) }
#[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
#[inline (always)] pub fn cc4of (& mut self) -> Cc4ofW < '_ , SrSpec > { Cc4ofW :: new (self , 12) } }
#[doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "EGR (w) register accessor: event generation register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@egr`] module"]
#[doc (alias = "EGR")] pub type Egr = crate :: Reg < egr :: EgrSpec > ;
#[doc = "event generation register"] pub mod egr {
#[doc = "Register `EGR` writer"] pub type W = crate :: W < EgrSpec > ;
#[doc = "Field `UG` writer - Update generation"] pub type UgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1G` writer - Capture/compare 1 generation"] pub type Cc1gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2G` writer - Capture/compare 2 generation"] pub type Cc2gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3G` writer - Capture/compare 3 generation"] pub type Cc3gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4G` writer - Capture/compare 4 generation"] pub type Cc4gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TG` writer - Trigger generation"] pub type TgW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Update generation"]
#[inline (always)] pub fn ug (& mut self) -> UgW < '_ , EgrSpec > { UgW :: new (self , 0) }
#[doc = "Bit 1 - Capture/compare 1 generation"]
#[inline (always)] pub fn cc1g (& mut self) -> Cc1gW < '_ , EgrSpec > { Cc1gW :: new (self , 1) }
#[doc = "Bit 2 - Capture/compare 2 generation"]
#[inline (always)] pub fn cc2g (& mut self) -> Cc2gW < '_ , EgrSpec > { Cc2gW :: new (self , 2) }
#[doc = "Bit 3 - Capture/compare 3 generation"]
#[inline (always)] pub fn cc3g (& mut self) -> Cc3gW < '_ , EgrSpec > { Cc3gW :: new (self , 3) }
#[doc = "Bit 4 - Capture/compare 4 generation"]
#[inline (always)] pub fn cc4g (& mut self) -> Cc4gW < '_ , EgrSpec > { Cc4gW :: new (self , 4) }
#[doc = "Bit 6 - Trigger generation"]
#[inline (always)] pub fn tg (& mut self) -> TgW < '_ , EgrSpec > { TgW :: new (self , 6) } }
#[doc = "event generation register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct EgrSpec ; impl crate :: RegisterSpec for EgrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`egr::W`](W) writer structure"] impl crate :: Writable for EgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EGR to value 0"] impl crate :: Resettable for EgrSpec { } }
#[doc = "CCMR1_Output (rw) register accessor: capture/compare mode register 1 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_output::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_output::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr1_output`] module"]
#[doc (alias = "CCMR1_Output")] pub type Ccmr1Output = crate :: Reg < ccmr1_output :: Ccmr1OutputSpec > ;
#[doc = "capture/compare mode register 1 (output mode)"] pub mod ccmr1_output {
#[doc = "Register `CCMR1_Output` reader"] pub type R = crate :: R < Ccmr1OutputSpec > ;
#[doc = "Register `CCMR1_Output` writer"] pub type W = crate :: W < Ccmr1OutputSpec > ;
#[doc = "Field `CC1S` reader - Capture/Compare 1 selection"] pub type Cc1sR = crate :: FieldReader ;
#[doc = "Field `CC1S` writer - Capture/Compare 1 selection"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC1FE` reader - Output compare 1 fast enable"] pub type Oc1feR = crate :: BitReader ;
#[doc = "Field `OC1FE` writer - Output compare 1 fast enable"] pub type Oc1feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1PE` reader - Output compare 1 preload enable"] pub type Oc1peR = crate :: BitReader ;
#[doc = "Field `OC1PE` writer - Output compare 1 preload enable"] pub type Oc1peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1M` reader - Output compare 1 mode"] pub type Oc1mR = crate :: FieldReader ;
#[doc = "Field `OC1M` writer - Output compare 1 mode"] pub type Oc1mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC1CE` reader - Output compare 1 clear enable"] pub type Oc1ceR = crate :: BitReader ;
#[doc = "Field `OC1CE` writer - Output compare 1 clear enable"] pub type Oc1ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2S` reader - Capture/Compare 2 selection"] pub type Cc2sR = crate :: FieldReader ;
#[doc = "Field `CC2S` writer - Capture/Compare 2 selection"] pub type Cc2sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC2FE` reader - Output compare 2 fast enable"] pub type Oc2feR = crate :: BitReader ;
#[doc = "Field `OC2FE` writer - Output compare 2 fast enable"] pub type Oc2feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC2PE` reader - Output compare 2 preload enable"] pub type Oc2peR = crate :: BitReader ;
#[doc = "Field `OC2PE` writer - Output compare 2 preload enable"] pub type Oc2peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC2M` reader - Output compare 2 mode"] pub type Oc2mR = crate :: FieldReader ;
#[doc = "Field `OC2M` writer - Output compare 2 mode"] pub type Oc2mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC2CE` reader - Output compare 2 clear enable"] pub type Oc2ceR = crate :: BitReader ;
#[doc = "Field `OC2CE` writer - Output compare 2 clear enable"] pub type Oc2ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1M_3` reader - Output Compare 1 mode - bit 3"] pub type Oc1m3R = crate :: BitReader ;
#[doc = "Field `OC1M_3` writer - Output Compare 1 mode - bit 3"] pub type Oc1m3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC2M_3` reader - Output Compare 2 mode - bit 3"] pub type Oc2m3R = crate :: BitReader ;
#[doc = "Field `OC2M_3` writer - Output Compare 2 mode - bit 3"] pub type Oc2m3W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) }
#[doc = "Bit 2 - Output compare 1 fast enable"]
#[inline (always)] pub fn oc1fe (& self) -> Oc1feR { Oc1feR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Output compare 1 preload enable"]
#[inline (always)] pub fn oc1pe (& self) -> Oc1peR { Oc1peR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Output compare 1 mode"]
#[inline (always)] pub fn oc1m (& self) -> Oc1mR { Oc1mR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Output compare 1 clear enable"]
#[inline (always)] pub fn oc1ce (& self) -> Oc1ceR { Oc1ceR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Capture/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& self) -> Cc2sR { Cc2sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 10 - Output compare 2 fast enable"]
#[inline (always)] pub fn oc2fe (& self) -> Oc2feR { Oc2feR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Output compare 2 preload enable"]
#[inline (always)] pub fn oc2pe (& self) -> Oc2peR { Oc2peR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:14 - Output compare 2 mode"]
#[inline (always)] pub fn oc2m (& self) -> Oc2mR { Oc2mR :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bit 15 - Output compare 2 clear enable"]
#[inline (always)] pub fn oc2ce (& self) -> Oc2ceR { Oc2ceR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Output Compare 1 mode - bit 3"]
#[inline (always)] pub fn oc1m_3 (& self) -> Oc1m3R { Oc1m3R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 24 - Output Compare 2 mode - bit 3"]
#[inline (always)] pub fn oc2m_3 (& self) -> Oc2m3R { Oc2m3R :: new (((self . bits >> 24) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& mut self) -> Cc1sW < '_ , Ccmr1OutputSpec > { Cc1sW :: new (self , 0) }
#[doc = "Bit 2 - Output compare 1 fast enable"]
#[inline (always)] pub fn oc1fe (& mut self) -> Oc1feW < '_ , Ccmr1OutputSpec > { Oc1feW :: new (self , 2) }
#[doc = "Bit 3 - Output compare 1 preload enable"]
#[inline (always)] pub fn oc1pe (& mut self) -> Oc1peW < '_ , Ccmr1OutputSpec > { Oc1peW :: new (self , 3) }
#[doc = "Bits 4:6 - Output compare 1 mode"]
#[inline (always)] pub fn oc1m (& mut self) -> Oc1mW < '_ , Ccmr1OutputSpec > { Oc1mW :: new (self , 4) }
#[doc = "Bit 7 - Output compare 1 clear enable"]
#[inline (always)] pub fn oc1ce (& mut self) -> Oc1ceW < '_ , Ccmr1OutputSpec > { Oc1ceW :: new (self , 7) }
#[doc = "Bits 8:9 - Capture/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& mut self) -> Cc2sW < '_ , Ccmr1OutputSpec > { Cc2sW :: new (self , 8) }
#[doc = "Bit 10 - Output compare 2 fast enable"]
#[inline (always)] pub fn oc2fe (& mut self) -> Oc2feW < '_ , Ccmr1OutputSpec > { Oc2feW :: new (self , 10) }
#[doc = "Bit 11 - Output compare 2 preload enable"]
#[inline (always)] pub fn oc2pe (& mut self) -> Oc2peW < '_ , Ccmr1OutputSpec > { Oc2peW :: new (self , 11) }
#[doc = "Bits 12:14 - Output compare 2 mode"]
#[inline (always)] pub fn oc2m (& mut self) -> Oc2mW < '_ , Ccmr1OutputSpec > { Oc2mW :: new (self , 12) }
#[doc = "Bit 15 - Output compare 2 clear enable"]
#[inline (always)] pub fn oc2ce (& mut self) -> Oc2ceW < '_ , Ccmr1OutputSpec > { Oc2ceW :: new (self , 15) }
#[doc = "Bit 16 - Output Compare 1 mode - bit 3"]
#[inline (always)] pub fn oc1m_3 (& mut self) -> Oc1m3W < '_ , Ccmr1OutputSpec > { Oc1m3W :: new (self , 16) }
#[doc = "Bit 24 - Output Compare 2 mode - bit 3"]
#[inline (always)] pub fn oc2m_3 (& mut self) -> Oc2m3W < '_ , Ccmr1OutputSpec > { Oc2m3W :: new (self , 24) } }
#[doc = "capture/compare mode register 1 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_output::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_output::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1OutputSpec ; impl crate :: RegisterSpec for Ccmr1OutputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr1_output::R`](R) reader structure"] impl crate :: Readable for Ccmr1OutputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr1_output::W`](W) writer structure"] impl crate :: Writable for Ccmr1OutputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR1_Output to value 0"] impl crate :: Resettable for Ccmr1OutputSpec { } }
#[doc = "CCMR1_Input (rw) register accessor: capture/compare mode register 1 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr1_input`] module"]
#[doc (alias = "CCMR1_Input")] pub type Ccmr1Input = crate :: Reg < ccmr1_input :: Ccmr1InputSpec > ;
#[doc = "capture/compare mode register 1 (input mode)"] pub mod ccmr1_input {
#[doc = "Register `CCMR1_Input` reader"] pub type R = crate :: R < Ccmr1InputSpec > ;
#[doc = "Register `CCMR1_Input` writer"] pub type W = crate :: W < Ccmr1InputSpec > ;
#[doc = "Field `CC1S` reader - Capture/Compare 1 selection"] pub type Cc1sR = crate :: FieldReader ;
#[doc = "Field `CC1S` writer - Capture/Compare 1 selection"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC1PSC` reader - Input capture 1 prescaler"] pub type Ic1pscR = crate :: FieldReader ;
#[doc = "Field `IC1PSC` writer - Input capture 1 prescaler"] pub type Ic1pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC1F` reader - Input capture 1 filter"] pub type Ic1fR = crate :: FieldReader ;
#[doc = "Field `IC1F` writer - Input capture 1 filter"] pub type Ic1fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `CC2S` reader - Capture/compare 2 selection"] pub type Cc2sR = crate :: FieldReader ;
#[doc = "Field `CC2S` writer - Capture/compare 2 selection"] pub type Cc2sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC2PSC` reader - Input capture 2 prescaler"] pub type Ic2pscR = crate :: FieldReader ;
#[doc = "Field `IC2PSC` writer - Input capture 2 prescaler"] pub type Ic2pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC2F` reader - Input capture 2 filter"] pub type Ic2fR = crate :: FieldReader ;
#[doc = "Field `IC2F` writer - Input capture 2 filter"] pub type Ic2fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Input capture 1 prescaler"]
#[inline (always)] pub fn ic1psc (& self) -> Ic1pscR { Ic1pscR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:7 - Input capture 1 filter"]
#[inline (always)] pub fn ic1f (& self) -> Ic1fR { Ic1fR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:9 - Capture/compare 2 selection"]
#[inline (always)] pub fn cc2s (& self) -> Cc2sR { Cc2sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Input capture 2 prescaler"]
#[inline (always)] pub fn ic2psc (& self) -> Ic2pscR { Ic2pscR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:15 - Input capture 2 filter"]
#[inline (always)] pub fn ic2f (& self) -> Ic2fR { Ic2fR :: new (((self . bits >> 12) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& mut self) -> Cc1sW < '_ , Ccmr1InputSpec > { Cc1sW :: new (self , 0) }
#[doc = "Bits 2:3 - Input capture 1 prescaler"]
#[inline (always)] pub fn ic1psc (& mut self) -> Ic1pscW < '_ , Ccmr1InputSpec > { Ic1pscW :: new (self , 2) }
#[doc = "Bits 4:7 - Input capture 1 filter"]
#[inline (always)] pub fn ic1f (& mut self) -> Ic1fW < '_ , Ccmr1InputSpec > { Ic1fW :: new (self , 4) }
#[doc = "Bits 8:9 - Capture/compare 2 selection"]
#[inline (always)] pub fn cc2s (& mut self) -> Cc2sW < '_ , Ccmr1InputSpec > { Cc2sW :: new (self , 8) }
#[doc = "Bits 10:11 - Input capture 2 prescaler"]
#[inline (always)] pub fn ic2psc (& mut self) -> Ic2pscW < '_ , Ccmr1InputSpec > { Ic2pscW :: new (self , 10) }
#[doc = "Bits 12:15 - Input capture 2 filter"]
#[inline (always)] pub fn ic2f (& mut self) -> Ic2fW < '_ , Ccmr1InputSpec > { Ic2fW :: new (self , 12) } }
#[doc = "capture/compare mode register 1 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1InputSpec ; impl crate :: RegisterSpec for Ccmr1InputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr1_input::R`](R) reader structure"] impl crate :: Readable for Ccmr1InputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr1_input::W`](W) writer structure"] impl crate :: Writable for Ccmr1InputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR1_Input to value 0"] impl crate :: Resettable for Ccmr1InputSpec { } }
#[doc = "CCMR2_Output (rw) register accessor: capture/compare mode register 2 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_output::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_output::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr2_output`] module"]
#[doc (alias = "CCMR2_Output")] pub type Ccmr2Output = crate :: Reg < ccmr2_output :: Ccmr2OutputSpec > ;
#[doc = "capture/compare mode register 2 (output mode)"] pub mod ccmr2_output {
#[doc = "Register `CCMR2_Output` reader"] pub type R = crate :: R < Ccmr2OutputSpec > ;
#[doc = "Register `CCMR2_Output` writer"] pub type W = crate :: W < Ccmr2OutputSpec > ;
#[doc = "Field `CC3S` reader - Capture/Compare 3 selection"] pub type Cc3sR = crate :: FieldReader ;
#[doc = "Field `CC3S` writer - Capture/Compare 3 selection"] pub type Cc3sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC3FE` reader - Output compare 3 fast enable"] pub type Oc3feR = crate :: BitReader ;
#[doc = "Field `OC3FE` writer - Output compare 3 fast enable"] pub type Oc3feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC3PE` reader - Output compare 3 preload enable"] pub type Oc3peR = crate :: BitReader ;
#[doc = "Field `OC3PE` writer - Output compare 3 preload enable"] pub type Oc3peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC3M` reader - Output compare 3 mode"] pub type Oc3mR = crate :: FieldReader ;
#[doc = "Field `OC3M` writer - Output compare 3 mode"] pub type Oc3mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC3CE` reader - Output compare 3 clear enable"] pub type Oc3ceR = crate :: BitReader ;
#[doc = "Field `OC3CE` writer - Output compare 3 clear enable"] pub type Oc3ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4S` reader - Capture/Compare 4 selection"] pub type Cc4sR = crate :: FieldReader ;
#[doc = "Field `CC4S` writer - Capture/Compare 4 selection"] pub type Cc4sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC4FE` reader - Output compare 4 fast enable"] pub type Oc4feR = crate :: BitReader ;
#[doc = "Field `OC4FE` writer - Output compare 4 fast enable"] pub type Oc4feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC4PE` reader - Output compare 4 preload enable"] pub type Oc4peR = crate :: BitReader ;
#[doc = "Field `OC4PE` writer - Output compare 4 preload enable"] pub type Oc4peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC4M` reader - Output compare 4 mode"] pub type Oc4mR = crate :: FieldReader ;
#[doc = "Field `OC4M` writer - Output compare 4 mode"] pub type Oc4mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC4CE` reader - Output compare 4 clear enable"] pub type Oc4ceR = crate :: BitReader ;
#[doc = "Field `OC4CE` writer - Output compare 4 clear enable"] pub type Oc4ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC3M_3` reader - Output Compare 3 mode - bit 3"] pub type Oc3m3R = crate :: BitReader ;
#[doc = "Field `OC3M_3` writer - Output Compare 3 mode - bit 3"] pub type Oc3m3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC4M_3` reader - Output Compare 4 mode - bit 3"] pub type Oc4m3R = crate :: BitReader ;
#[doc = "Field `OC4M_3` writer - Output Compare 4 mode - bit 3"] pub type Oc4m3W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 3 selection"]
#[inline (always)] pub fn cc3s (& self) -> Cc3sR { Cc3sR :: new ((self . bits & 3) as u8) }
#[doc = "Bit 2 - Output compare 3 fast enable"]
#[inline (always)] pub fn oc3fe (& self) -> Oc3feR { Oc3feR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Output compare 3 preload enable"]
#[inline (always)] pub fn oc3pe (& self) -> Oc3peR { Oc3peR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Output compare 3 mode"]
#[inline (always)] pub fn oc3m (& self) -> Oc3mR { Oc3mR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Output compare 3 clear enable"]
#[inline (always)] pub fn oc3ce (& self) -> Oc3ceR { Oc3ceR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& self) -> Cc4sR { Cc4sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 10 - Output compare 4 fast enable"]
#[inline (always)] pub fn oc4fe (& self) -> Oc4feR { Oc4feR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Output compare 4 preload enable"]
#[inline (always)] pub fn oc4pe (& self) -> Oc4peR { Oc4peR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:14 - Output compare 4 mode"]
#[inline (always)] pub fn oc4m (& self) -> Oc4mR { Oc4mR :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bit 15 - Output compare 4 clear enable"]
#[inline (always)] pub fn oc4ce (& self) -> Oc4ceR { Oc4ceR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Output Compare 3 mode - bit 3"]
#[inline (always)] pub fn oc3m_3 (& self) -> Oc3m3R { Oc3m3R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 24 - Output Compare 4 mode - bit 3"]
#[inline (always)] pub fn oc4m_3 (& self) -> Oc4m3R { Oc4m3R :: new (((self . bits >> 24) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 3 selection"]
#[inline (always)] pub fn cc3s (& mut self) -> Cc3sW < '_ , Ccmr2OutputSpec > { Cc3sW :: new (self , 0) }
#[doc = "Bit 2 - Output compare 3 fast enable"]
#[inline (always)] pub fn oc3fe (& mut self) -> Oc3feW < '_ , Ccmr2OutputSpec > { Oc3feW :: new (self , 2) }
#[doc = "Bit 3 - Output compare 3 preload enable"]
#[inline (always)] pub fn oc3pe (& mut self) -> Oc3peW < '_ , Ccmr2OutputSpec > { Oc3peW :: new (self , 3) }
#[doc = "Bits 4:6 - Output compare 3 mode"]
#[inline (always)] pub fn oc3m (& mut self) -> Oc3mW < '_ , Ccmr2OutputSpec > { Oc3mW :: new (self , 4) }
#[doc = "Bit 7 - Output compare 3 clear enable"]
#[inline (always)] pub fn oc3ce (& mut self) -> Oc3ceW < '_ , Ccmr2OutputSpec > { Oc3ceW :: new (self , 7) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& mut self) -> Cc4sW < '_ , Ccmr2OutputSpec > { Cc4sW :: new (self , 8) }
#[doc = "Bit 10 - Output compare 4 fast enable"]
#[inline (always)] pub fn oc4fe (& mut self) -> Oc4feW < '_ , Ccmr2OutputSpec > { Oc4feW :: new (self , 10) }
#[doc = "Bit 11 - Output compare 4 preload enable"]
#[inline (always)] pub fn oc4pe (& mut self) -> Oc4peW < '_ , Ccmr2OutputSpec > { Oc4peW :: new (self , 11) }
#[doc = "Bits 12:14 - Output compare 4 mode"]
#[inline (always)] pub fn oc4m (& mut self) -> Oc4mW < '_ , Ccmr2OutputSpec > { Oc4mW :: new (self , 12) }
#[doc = "Bit 15 - Output compare 4 clear enable"]
#[inline (always)] pub fn oc4ce (& mut self) -> Oc4ceW < '_ , Ccmr2OutputSpec > { Oc4ceW :: new (self , 15) }
#[doc = "Bit 16 - Output Compare 3 mode - bit 3"]
#[inline (always)] pub fn oc3m_3 (& mut self) -> Oc3m3W < '_ , Ccmr2OutputSpec > { Oc3m3W :: new (self , 16) }
#[doc = "Bit 24 - Output Compare 4 mode - bit 3"]
#[inline (always)] pub fn oc4m_3 (& mut self) -> Oc4m3W < '_ , Ccmr2OutputSpec > { Oc4m3W :: new (self , 24) } }
#[doc = "capture/compare mode register 2 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_output::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_output::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr2OutputSpec ; impl crate :: RegisterSpec for Ccmr2OutputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr2_output::R`](R) reader structure"] impl crate :: Readable for Ccmr2OutputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr2_output::W`](W) writer structure"] impl crate :: Writable for Ccmr2OutputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR2_Output to value 0"] impl crate :: Resettable for Ccmr2OutputSpec { } }
#[doc = "CCMR2_Input (rw) register accessor: capture/compare mode register 2 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_input::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_input::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr2_input`] module"]
#[doc (alias = "CCMR2_Input")] pub type Ccmr2Input = crate :: Reg < ccmr2_input :: Ccmr2InputSpec > ;
#[doc = "capture/compare mode register 2 (input mode)"] pub mod ccmr2_input {
#[doc = "Register `CCMR2_Input` reader"] pub type R = crate :: R < Ccmr2InputSpec > ;
#[doc = "Register `CCMR2_Input` writer"] pub type W = crate :: W < Ccmr2InputSpec > ;
#[doc = "Field `CC3S` reader - Capture/Compare 3 selection"] pub type Cc3sR = crate :: FieldReader ;
#[doc = "Field `CC3S` writer - Capture/Compare 3 selection"] pub type Cc3sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC3PSC` reader - Input capture 3 prescaler"] pub type Ic3pscR = crate :: FieldReader ;
#[doc = "Field `IC3PSC` writer - Input capture 3 prescaler"] pub type Ic3pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC3F` reader - Input capture 3 filter"] pub type Ic3fR = crate :: FieldReader ;
#[doc = "Field `IC3F` writer - Input capture 3 filter"] pub type Ic3fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `CC4S` reader - Capture/Compare 4 selection"] pub type Cc4sR = crate :: FieldReader ;
#[doc = "Field `CC4S` writer - Capture/Compare 4 selection"] pub type Cc4sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC4PSC` reader - Input capture 4 prescaler"] pub type Ic4pscR = crate :: FieldReader ;
#[doc = "Field `IC4PSC` writer - Input capture 4 prescaler"] pub type Ic4pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC4F` reader - Input capture 4 filter"] pub type Ic4fR = crate :: FieldReader ;
#[doc = "Field `IC4F` writer - Input capture 4 filter"] pub type Ic4fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 3 selection"]
#[inline (always)] pub fn cc3s (& self) -> Cc3sR { Cc3sR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Input capture 3 prescaler"]
#[inline (always)] pub fn ic3psc (& self) -> Ic3pscR { Ic3pscR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:7 - Input capture 3 filter"]
#[inline (always)] pub fn ic3f (& self) -> Ic3fR { Ic3fR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& self) -> Cc4sR { Cc4sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Input capture 4 prescaler"]
#[inline (always)] pub fn ic4psc (& self) -> Ic4pscR { Ic4pscR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:15 - Input capture 4 filter"]
#[inline (always)] pub fn ic4f (& self) -> Ic4fR { Ic4fR :: new (((self . bits >> 12) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 3 selection"]
#[inline (always)] pub fn cc3s (& mut self) -> Cc3sW < '_ , Ccmr2InputSpec > { Cc3sW :: new (self , 0) }
#[doc = "Bits 2:3 - Input capture 3 prescaler"]
#[inline (always)] pub fn ic3psc (& mut self) -> Ic3pscW < '_ , Ccmr2InputSpec > { Ic3pscW :: new (self , 2) }
#[doc = "Bits 4:7 - Input capture 3 filter"]
#[inline (always)] pub fn ic3f (& mut self) -> Ic3fW < '_ , Ccmr2InputSpec > { Ic3fW :: new (self , 4) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& mut self) -> Cc4sW < '_ , Ccmr2InputSpec > { Cc4sW :: new (self , 8) }
#[doc = "Bits 10:11 - Input capture 4 prescaler"]
#[inline (always)] pub fn ic4psc (& mut self) -> Ic4pscW < '_ , Ccmr2InputSpec > { Ic4pscW :: new (self , 10) }
#[doc = "Bits 12:15 - Input capture 4 filter"]
#[inline (always)] pub fn ic4f (& mut self) -> Ic4fW < '_ , Ccmr2InputSpec > { Ic4fW :: new (self , 12) } }
#[doc = "capture/compare mode register 2 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_input::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_input::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr2InputSpec ; impl crate :: RegisterSpec for Ccmr2InputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr2_input::R`](R) reader structure"] impl crate :: Readable for Ccmr2InputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr2_input::W`](W) writer structure"] impl crate :: Writable for Ccmr2InputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR2_Input to value 0"] impl crate :: Resettable for Ccmr2InputSpec { } }
#[doc = "CCER (rw) register accessor: capture/compare enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccer::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccer::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccer`] module"]
#[doc (alias = "CCER")] pub type Ccer = crate :: Reg < ccer :: CcerSpec > ;
#[doc = "capture/compare enable register"] pub mod ccer {
#[doc = "Register `CCER` reader"] pub type R = crate :: R < CcerSpec > ;
#[doc = "Register `CCER` writer"] pub type W = crate :: W < CcerSpec > ;
#[doc = "Field `CC1E` reader - Capture/Compare 1 output enable"] pub type Cc1eR = crate :: BitReader ;
#[doc = "Field `CC1E` writer - Capture/Compare 1 output enable"] pub type Cc1eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1P` reader - Capture/Compare 1 output Polarity"] pub type Cc1pR = crate :: BitReader ;
#[doc = "Field `CC1P` writer - Capture/Compare 1 output Polarity"] pub type Cc1pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1NP` reader - Capture/Compare 1 output Polarity"] pub type Cc1npR = crate :: BitReader ;
#[doc = "Field `CC1NP` writer - Capture/Compare 1 output Polarity"] pub type Cc1npW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2E` reader - Capture/Compare 2 output enable"] pub type Cc2eR = crate :: BitReader ;
#[doc = "Field `CC2E` writer - Capture/Compare 2 output enable"] pub type Cc2eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2P` reader - Capture/Compare 2 output Polarity"] pub type Cc2pR = crate :: BitReader ;
#[doc = "Field `CC2P` writer - Capture/Compare 2 output Polarity"] pub type Cc2pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2NP` reader - Capture/Compare 2 output Polarity"] pub type Cc2npR = crate :: BitReader ;
#[doc = "Field `CC2NP` writer - Capture/Compare 2 output Polarity"] pub type Cc2npW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3E` reader - Capture/Compare 3 output enable"] pub type Cc3eR = crate :: BitReader ;
#[doc = "Field `CC3E` writer - Capture/Compare 3 output enable"] pub type Cc3eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3P` reader - Capture/Compare 3 output Polarity"] pub type Cc3pR = crate :: BitReader ;
#[doc = "Field `CC3P` writer - Capture/Compare 3 output Polarity"] pub type Cc3pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3NP` reader - Capture/Compare 3 output Polarity"] pub type Cc3npR = crate :: BitReader ;
#[doc = "Field `CC3NP` writer - Capture/Compare 3 output Polarity"] pub type Cc3npW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4E` reader - Capture/Compare 4 output enable"] pub type Cc4eR = crate :: BitReader ;
#[doc = "Field `CC4E` writer - Capture/Compare 4 output enable"] pub type Cc4eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4P` reader - Capture/Compare 3 output Polarity"] pub type Cc4pR = crate :: BitReader ;
#[doc = "Field `CC4P` writer - Capture/Compare 3 output Polarity"] pub type Cc4pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4NP` reader - Capture/Compare 4 output Polarity"] pub type Cc4npR = crate :: BitReader ;
#[doc = "Field `CC4NP` writer - Capture/Compare 4 output Polarity"] pub type Cc4npW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Capture/Compare 1 output enable"]
#[inline (always)] pub fn cc1e (& self) -> Cc1eR { Cc1eR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1p (& self) -> Cc1pR { Cc1pR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1np (& self) -> Cc1npR { Cc1npR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Capture/Compare 2 output enable"]
#[inline (always)] pub fn cc2e (& self) -> Cc2eR { Cc2eR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
#[inline (always)] pub fn cc2p (& self) -> Cc2pR { Cc2pR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
#[inline (always)] pub fn cc2np (& self) -> Cc2npR { Cc2npR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Capture/Compare 3 output enable"]
#[inline (always)] pub fn cc3e (& self) -> Cc3eR { Cc3eR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 3 output Polarity"]
#[inline (always)] pub fn cc3p (& self) -> Cc3pR { Cc3pR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 11 - Capture/Compare 3 output Polarity"]
#[inline (always)] pub fn cc3np (& self) -> Cc3npR { Cc3npR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Capture/Compare 4 output enable"]
#[inline (always)] pub fn cc4e (& self) -> Cc4eR { Cc4eR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Capture/Compare 3 output Polarity"]
#[inline (always)] pub fn cc4p (& self) -> Cc4pR { Cc4pR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 15 - Capture/Compare 4 output Polarity"]
#[inline (always)] pub fn cc4np (& self) -> Cc4npR { Cc4npR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Capture/Compare 1 output enable"]
#[inline (always)] pub fn cc1e (& mut self) -> Cc1eW < '_ , CcerSpec > { Cc1eW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1p (& mut self) -> Cc1pW < '_ , CcerSpec > { Cc1pW :: new (self , 1) }
#[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1np (& mut self) -> Cc1npW < '_ , CcerSpec > { Cc1npW :: new (self , 3) }
#[doc = "Bit 4 - Capture/Compare 2 output enable"]
#[inline (always)] pub fn cc2e (& mut self) -> Cc2eW < '_ , CcerSpec > { Cc2eW :: new (self , 4) }
#[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
#[inline (always)] pub fn cc2p (& mut self) -> Cc2pW < '_ , CcerSpec > { Cc2pW :: new (self , 5) }
#[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
#[inline (always)] pub fn cc2np (& mut self) -> Cc2npW < '_ , CcerSpec > { Cc2npW :: new (self , 7) }
#[doc = "Bit 8 - Capture/Compare 3 output enable"]
#[inline (always)] pub fn cc3e (& mut self) -> Cc3eW < '_ , CcerSpec > { Cc3eW :: new (self , 8) }
#[doc = "Bit 9 - Capture/Compare 3 output Polarity"]
#[inline (always)] pub fn cc3p (& mut self) -> Cc3pW < '_ , CcerSpec > { Cc3pW :: new (self , 9) }
#[doc = "Bit 11 - Capture/Compare 3 output Polarity"]
#[inline (always)] pub fn cc3np (& mut self) -> Cc3npW < '_ , CcerSpec > { Cc3npW :: new (self , 11) }
#[doc = "Bit 12 - Capture/Compare 4 output enable"]
#[inline (always)] pub fn cc4e (& mut self) -> Cc4eW < '_ , CcerSpec > { Cc4eW :: new (self , 12) }
#[doc = "Bit 13 - Capture/Compare 3 output Polarity"]
#[inline (always)] pub fn cc4p (& mut self) -> Cc4pW < '_ , CcerSpec > { Cc4pW :: new (self , 13) }
#[doc = "Bit 15 - Capture/Compare 4 output Polarity"]
#[inline (always)] pub fn cc4np (& mut self) -> Cc4npW < '_ , CcerSpec > { Cc4npW :: new (self , 15) } }
#[doc = "capture/compare enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccer::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccer::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CcerSpec ; impl crate :: RegisterSpec for CcerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccer::R`](R) reader structure"] impl crate :: Readable for CcerSpec { }
#[doc = "`write(|w| ..)` method takes [`ccer::W`](W) writer structure"] impl crate :: Writable for CcerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCER to value 0"] impl crate :: Resettable for CcerSpec { } }
#[doc = "CNT (rw) register accessor: counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt`] module"]
#[doc (alias = "CNT")] pub type Cnt = crate :: Reg < cnt :: CntSpec > ;
#[doc = "counter"] pub mod cnt {
#[doc = "Register `CNT` reader"] pub type R = crate :: R < CntSpec > ;
#[doc = "Register `CNT` writer"] pub type W = crate :: W < CntSpec > ;
#[doc = "Field `CNT_L` reader - Low counter value"] pub type CntLR = crate :: FieldReader < u16 > ;
#[doc = "Field `CNT_L` writer - Low counter value"] pub type CntLW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `CNT_H` reader - High counter value (TIM2 only)"] pub type CntHR = crate :: FieldReader < u16 > ;
#[doc = "Field `CNT_H` writer - High counter value (TIM2 only)"] pub type CntHW < 'a , REG > = crate :: FieldWriter < 'a , REG , 15 , u16 > ;
#[doc = "Field `UIFCPY` reader - Value depends on IUFREMAP in TIM2_CR1."] pub type UifcpyR = crate :: BitReader ; impl R {
#[doc = "Bits 0:15 - Low counter value"]
#[inline (always)] pub fn cnt_l (& self) -> CntLR { CntLR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bits 16:30 - High counter value (TIM2 only)"]
#[inline (always)] pub fn cnt_h (& self) -> CntHR { CntHR :: new (((self . bits >> 16) & 0x7fff) as u16) }
#[doc = "Bit 31 - Value depends on IUFREMAP in TIM2_CR1."]
#[inline (always)] pub fn uifcpy (& self) -> UifcpyR { UifcpyR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:15 - Low counter value"]
#[inline (always)] pub fn cnt_l (& mut self) -> CntLW < '_ , CntSpec > { CntLW :: new (self , 0) }
#[doc = "Bits 16:30 - High counter value (TIM2 only)"]
#[inline (always)] pub fn cnt_h (& mut self) -> CntHW < '_ , CntSpec > { CntHW :: new (self , 16) } }
#[doc = "counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CntSpec ; impl crate :: RegisterSpec for CntSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cnt::R`](R) reader structure"] impl crate :: Readable for CntSpec { }
#[doc = "`write(|w| ..)` method takes [`cnt::W`](W) writer structure"] impl crate :: Writable for CntSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNT to value 0"] impl crate :: Resettable for CntSpec { } }
#[doc = "PSC (rw) register accessor: prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@psc`] module"]
#[doc (alias = "PSC")] pub type Psc = crate :: Reg < psc :: PscSpec > ;
#[doc = "prescaler"] pub mod psc {
#[doc = "Register `PSC` reader"] pub type R = crate :: R < PscSpec > ;
#[doc = "Register `PSC` writer"] pub type W = crate :: W < PscSpec > ;
#[doc = "Field `PSC` reader - Prescaler value"] pub type PscR = crate :: FieldReader < u16 > ;
#[doc = "Field `PSC` writer - Prescaler value"] pub type PscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& self) -> PscR { PscR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& mut self) -> PscW < '_ , PscSpec > { PscW :: new (self , 0) } }
#[doc = "prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PscSpec ; impl crate :: RegisterSpec for PscSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`psc::R`](R) reader structure"] impl crate :: Readable for PscSpec { }
#[doc = "`write(|w| ..)` method takes [`psc::W`](W) writer structure"] impl crate :: Writable for PscSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PSC to value 0"] impl crate :: Resettable for PscSpec { } }
#[doc = "ARR (rw) register accessor: auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@arr`] module"]
#[doc (alias = "ARR")] pub type Arr = crate :: Reg < arr :: ArrSpec > ;
#[doc = "auto-reload register"] pub mod arr {
#[doc = "Register `ARR` reader"] pub type R = crate :: R < ArrSpec > ;
#[doc = "Register `ARR` writer"] pub type W = crate :: W < ArrSpec > ;
#[doc = "Field `ARR_L` reader - Low Auto-reload value"] pub type ArrLR = crate :: FieldReader < u16 > ;
#[doc = "Field `ARR_L` writer - Low Auto-reload value"] pub type ArrLW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `ARR_H` reader - High Auto-reload value (TIM2 only)"] pub type ArrHR = crate :: FieldReader < u16 > ;
#[doc = "Field `ARR_H` writer - High Auto-reload value (TIM2 only)"] pub type ArrHW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Low Auto-reload value"]
#[inline (always)] pub fn arr_l (& self) -> ArrLR { ArrLR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bits 16:31 - High Auto-reload value (TIM2 only)"]
#[inline (always)] pub fn arr_h (& self) -> ArrHR { ArrHR :: new (((self . bits >> 16) & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Low Auto-reload value"]
#[inline (always)] pub fn arr_l (& mut self) -> ArrLW < '_ , ArrSpec > { ArrLW :: new (self , 0) }
#[doc = "Bits 16:31 - High Auto-reload value (TIM2 only)"]
#[inline (always)] pub fn arr_h (& mut self) -> ArrHW < '_ , ArrSpec > { ArrHW :: new (self , 16) } }
#[doc = "auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ArrSpec ; impl crate :: RegisterSpec for ArrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`arr::R`](R) reader structure"] impl crate :: Readable for ArrSpec { }
#[doc = "`write(|w| ..)` method takes [`arr::W`](W) writer structure"] impl crate :: Writable for ArrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ARR to value 0"] impl crate :: Resettable for ArrSpec { } }
#[doc = "CCR1 (rw) register accessor: capture/compare register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr1`] module"]
#[doc (alias = "CCR1")] pub type Ccr1 = crate :: Reg < ccr1 :: Ccr1Spec > ;
#[doc = "capture/compare register 1"] pub mod ccr1 {
#[doc = "Register `CCR1` reader"] pub type R = crate :: R < Ccr1Spec > ;
#[doc = "Register `CCR1` writer"] pub type W = crate :: W < Ccr1Spec > ;
#[doc = "Field `CCR1_L` reader - Low Capture/Compare 1 value"] pub type Ccr1LR = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR1_L` writer - Low Capture/Compare 1 value"] pub type Ccr1LW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `CCR1_H` reader - High Capture/Compare 1 value (TIM2 only)"] pub type Ccr1HR = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR1_H` writer - High Capture/Compare 1 value (TIM2 only)"] pub type Ccr1HW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Low Capture/Compare 1 value"]
#[inline (always)] pub fn ccr1_l (& self) -> Ccr1LR { Ccr1LR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bits 16:31 - High Capture/Compare 1 value (TIM2 only)"]
#[inline (always)] pub fn ccr1_h (& self) -> Ccr1HR { Ccr1HR :: new (((self . bits >> 16) & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Low Capture/Compare 1 value"]
#[inline (always)] pub fn ccr1_l (& mut self) -> Ccr1LW < '_ , Ccr1Spec > { Ccr1LW :: new (self , 0) }
#[doc = "Bits 16:31 - High Capture/Compare 1 value (TIM2 only)"]
#[inline (always)] pub fn ccr1_h (& mut self) -> Ccr1HW < '_ , Ccr1Spec > { Ccr1HW :: new (self , 16) } }
#[doc = "capture/compare register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr1Spec ; impl crate :: RegisterSpec for Ccr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr1::R`](R) reader structure"] impl crate :: Readable for Ccr1Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr1::W`](W) writer structure"] impl crate :: Writable for Ccr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR1 to value 0"] impl crate :: Resettable for Ccr1Spec { } }
#[doc = "CCR2 (rw) register accessor: capture/compare register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr2`] module"]
#[doc (alias = "CCR2")] pub type Ccr2 = crate :: Reg < ccr2 :: Ccr2Spec > ;
#[doc = "capture/compare register 2"] pub mod ccr2 {
#[doc = "Register `CCR2` reader"] pub type R = crate :: R < Ccr2Spec > ;
#[doc = "Register `CCR2` writer"] pub type W = crate :: W < Ccr2Spec > ;
#[doc = "Field `CCR2_L` reader - Low Capture/Compare 2 value"] pub type Ccr2LR = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR2_L` writer - Low Capture/Compare 2 value"] pub type Ccr2LW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `CCR2_H` reader - High Capture/Compare 2 value (TIM2 only)"] pub type Ccr2HR = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR2_H` writer - High Capture/Compare 2 value (TIM2 only)"] pub type Ccr2HW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Low Capture/Compare 2 value"]
#[inline (always)] pub fn ccr2_l (& self) -> Ccr2LR { Ccr2LR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bits 16:31 - High Capture/Compare 2 value (TIM2 only)"]
#[inline (always)] pub fn ccr2_h (& self) -> Ccr2HR { Ccr2HR :: new (((self . bits >> 16) & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Low Capture/Compare 2 value"]
#[inline (always)] pub fn ccr2_l (& mut self) -> Ccr2LW < '_ , Ccr2Spec > { Ccr2LW :: new (self , 0) }
#[doc = "Bits 16:31 - High Capture/Compare 2 value (TIM2 only)"]
#[inline (always)] pub fn ccr2_h (& mut self) -> Ccr2HW < '_ , Ccr2Spec > { Ccr2HW :: new (self , 16) } }
#[doc = "capture/compare register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr2Spec ; impl crate :: RegisterSpec for Ccr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr2::R`](R) reader structure"] impl crate :: Readable for Ccr2Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr2::W`](W) writer structure"] impl crate :: Writable for Ccr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR2 to value 0"] impl crate :: Resettable for Ccr2Spec { } }
#[doc = "CCR3 (rw) register accessor: capture/compare register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr3`] module"]
#[doc (alias = "CCR3")] pub type Ccr3 = crate :: Reg < ccr3 :: Ccr3Spec > ;
#[doc = "capture/compare register 3"] pub mod ccr3 {
#[doc = "Register `CCR3` reader"] pub type R = crate :: R < Ccr3Spec > ;
#[doc = "Register `CCR3` writer"] pub type W = crate :: W < Ccr3Spec > ;
#[doc = "Field `CCR3_L` reader - Low Capture/Compare value"] pub type Ccr3LR = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR3_L` writer - Low Capture/Compare value"] pub type Ccr3LW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `CCR3_H` reader - High Capture/Compare value (TIM2 only)"] pub type Ccr3HR = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR3_H` writer - High Capture/Compare value (TIM2 only)"] pub type Ccr3HW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Low Capture/Compare value"]
#[inline (always)] pub fn ccr3_l (& self) -> Ccr3LR { Ccr3LR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bits 16:31 - High Capture/Compare value (TIM2 only)"]
#[inline (always)] pub fn ccr3_h (& self) -> Ccr3HR { Ccr3HR :: new (((self . bits >> 16) & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Low Capture/Compare value"]
#[inline (always)] pub fn ccr3_l (& mut self) -> Ccr3LW < '_ , Ccr3Spec > { Ccr3LW :: new (self , 0) }
#[doc = "Bits 16:31 - High Capture/Compare value (TIM2 only)"]
#[inline (always)] pub fn ccr3_h (& mut self) -> Ccr3HW < '_ , Ccr3Spec > { Ccr3HW :: new (self , 16) } }
#[doc = "capture/compare register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr3Spec ; impl crate :: RegisterSpec for Ccr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr3::R`](R) reader structure"] impl crate :: Readable for Ccr3Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr3::W`](W) writer structure"] impl crate :: Writable for Ccr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR3 to value 0"] impl crate :: Resettable for Ccr3Spec { } }
#[doc = "CCR4 (rw) register accessor: capture/compare register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr4`] module"]
#[doc (alias = "CCR4")] pub type Ccr4 = crate :: Reg < ccr4 :: Ccr4Spec > ;
#[doc = "capture/compare register 4"] pub mod ccr4 {
#[doc = "Register `CCR4` reader"] pub type R = crate :: R < Ccr4Spec > ;
#[doc = "Register `CCR4` writer"] pub type W = crate :: W < Ccr4Spec > ;
#[doc = "Field `CCR4_L` reader - Low Capture/Compare value"] pub type Ccr4LR = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR4_L` writer - Low Capture/Compare value"] pub type Ccr4LW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `CCR4_H` reader - High Capture/Compare value (TIM2 only)"] pub type Ccr4HR = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR4_H` writer - High Capture/Compare value (TIM2 only)"] pub type Ccr4HW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Low Capture/Compare value"]
#[inline (always)] pub fn ccr4_l (& self) -> Ccr4LR { Ccr4LR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bits 16:31 - High Capture/Compare value (TIM2 only)"]
#[inline (always)] pub fn ccr4_h (& self) -> Ccr4HR { Ccr4HR :: new (((self . bits >> 16) & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Low Capture/Compare value"]
#[inline (always)] pub fn ccr4_l (& mut self) -> Ccr4LW < '_ , Ccr4Spec > { Ccr4LW :: new (self , 0) }
#[doc = "Bits 16:31 - High Capture/Compare value (TIM2 only)"]
#[inline (always)] pub fn ccr4_h (& mut self) -> Ccr4HW < '_ , Ccr4Spec > { Ccr4HW :: new (self , 16) } }
#[doc = "capture/compare register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr4Spec ; impl crate :: RegisterSpec for Ccr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr4::R`](R) reader structure"] impl crate :: Readable for Ccr4Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr4::W`](W) writer structure"] impl crate :: Writable for Ccr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR4 to value 0"] impl crate :: Resettable for Ccr4Spec { } }
#[doc = "DCR (rw) register accessor: DMA control register\n\nYou can [`read`](crate::Reg::read) this register and get [`dcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dcr`] module"]
#[doc (alias = "DCR")] pub type Dcr = crate :: Reg < dcr :: DcrSpec > ;
#[doc = "DMA control register"] pub mod dcr {
#[doc = "Register `DCR` reader"] pub type R = crate :: R < DcrSpec > ;
#[doc = "Register `DCR` writer"] pub type W = crate :: W < DcrSpec > ;
#[doc = "Field `DBA` reader - DMA base address"] pub type DbaR = crate :: FieldReader ;
#[doc = "Field `DBA` writer - DMA base address"] pub type DbaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `DBL` reader - DMA burst length"] pub type DblR = crate :: FieldReader ;
#[doc = "Field `DBL` writer - DMA burst length"] pub type DblW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:4 - DMA base address"]
#[inline (always)] pub fn dba (& self) -> DbaR { DbaR :: new ((self . bits & 0x1f) as u8) }
#[doc = "Bits 8:12 - DMA burst length"]
#[inline (always)] pub fn dbl (& self) -> DblR { DblR :: new (((self . bits >> 8) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:4 - DMA base address"]
#[inline (always)] pub fn dba (& mut self) -> DbaW < '_ , DcrSpec > { DbaW :: new (self , 0) }
#[doc = "Bits 8:12 - DMA burst length"]
#[inline (always)] pub fn dbl (& mut self) -> DblW < '_ , DcrSpec > { DblW :: new (self , 8) } }
#[doc = "DMA control register\n\nYou can [`read`](crate::Reg::read) this register and get [`dcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DcrSpec ; impl crate :: RegisterSpec for DcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dcr::R`](R) reader structure"] impl crate :: Readable for DcrSpec { }
#[doc = "`write(|w| ..)` method takes [`dcr::W`](W) writer structure"] impl crate :: Writable for DcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DCR to value 0"] impl crate :: Resettable for DcrSpec { } }
#[doc = "DMAR (rw) register accessor: DMA address for full transfer\n\nYou can [`read`](crate::Reg::read) this register and get [`dmar::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmar::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dmar`] module"]
#[doc (alias = "DMAR")] pub type Dmar = crate :: Reg < dmar :: DmarSpec > ;
#[doc = "DMA address for full transfer"] pub mod dmar {
#[doc = "Register `DMAR` reader"] pub type R = crate :: R < DmarSpec > ;
#[doc = "Register `DMAR` writer"] pub type W = crate :: W < DmarSpec > ;
#[doc = "Field `DMAB` reader - DMA register for burst accesses"] pub type DmabR = crate :: FieldReader < u16 > ;
#[doc = "Field `DMAB` writer - DMA register for burst accesses"] pub type DmabW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - DMA register for burst accesses"]
#[inline (always)] pub fn dmab (& self) -> DmabR { DmabR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - DMA register for burst accesses"]
#[inline (always)] pub fn dmab (& mut self) -> DmabW < '_ , DmarSpec > { DmabW :: new (self , 0) } }
#[doc = "DMA address for full transfer\n\nYou can [`read`](crate::Reg::read) this register and get [`dmar::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmar::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DmarSpec ; impl crate :: RegisterSpec for DmarSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dmar::R`](R) reader structure"] impl crate :: Readable for DmarSpec { }
#[doc = "`write(|w| ..)` method takes [`dmar::W`](W) writer structure"] impl crate :: Writable for DmarSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMAR to value 0"] impl crate :: Resettable for DmarSpec { } }
#[doc = "OR (rw) register accessor: TIM2 option register\n\nYou can [`read`](crate::Reg::read) this register and get [`or::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`or::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@or`] module"]
#[doc (alias = "OR")] pub type Or = crate :: Reg < or :: OrSpec > ;
#[doc = "TIM2 option register"] pub mod or {
#[doc = "Register `OR` reader"] pub type R = crate :: R < OrSpec > ;
#[doc = "Register `OR` writer"] pub type W = crate :: W < OrSpec > ;
#[doc = "Field `ITR_RMP` reader - Internal trigger remap"] pub type ItrRmpR = crate :: BitReader ;
#[doc = "Field `ITR_RMP` writer - Internal trigger remap"] pub type ItrRmpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ETR_RMP` reader - External trigger remap"] pub type EtrRmpR = crate :: BitReader ;
#[doc = "Field `ETR_RMP` writer - External trigger remap"] pub type EtrRmpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TI4_RMP` reader - Input capture 4 remap"] pub type Ti4RmpR = crate :: FieldReader ;
#[doc = "Field `TI4_RMP` writer - Input capture 4 remap"] pub type Ti4RmpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bit 0 - Internal trigger remap"]
#[inline (always)] pub fn itr_rmp (& self) -> ItrRmpR { ItrRmpR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - External trigger remap"]
#[inline (always)] pub fn etr_rmp (& self) -> EtrRmpR { EtrRmpR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bits 2:3 - Input capture 4 remap"]
#[inline (always)] pub fn ti4_rmp (& self) -> Ti4RmpR { Ti4RmpR :: new (((self . bits >> 2) & 3) as u8) } } impl W {
#[doc = "Bit 0 - Internal trigger remap"]
#[inline (always)] pub fn itr_rmp (& mut self) -> ItrRmpW < '_ , OrSpec > { ItrRmpW :: new (self , 0) }
#[doc = "Bit 1 - External trigger remap"]
#[inline (always)] pub fn etr_rmp (& mut self) -> EtrRmpW < '_ , OrSpec > { EtrRmpW :: new (self , 1) }
#[doc = "Bits 2:3 - Input capture 4 remap"]
#[inline (always)] pub fn ti4_rmp (& mut self) -> Ti4RmpW < '_ , OrSpec > { Ti4RmpW :: new (self , 2) } }
#[doc = "TIM2 option register\n\nYou can [`read`](crate::Reg::read) this register and get [`or::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`or::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OrSpec ; impl crate :: RegisterSpec for OrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`or::R`](R) reader structure"] impl crate :: Readable for OrSpec { }
#[doc = "`write(|w| ..)` method takes [`or::W`](W) writer structure"] impl crate :: Writable for OrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OR to value 0"] impl crate :: Resettable for OrSpec { } }
#[doc = "AF (rw) register accessor: TIM2 alternate function option register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`af::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`af::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@af`] module"]
#[doc (alias = "AF")] pub type Af = crate :: Reg < af :: AfSpec > ;
#[doc = "TIM2 alternate function option register 1"] pub mod af {
#[doc = "Register `AF` reader"] pub type R = crate :: R < AfSpec > ;
#[doc = "Register `AF` writer"] pub type W = crate :: W < AfSpec > ;
#[doc = "Field `ETRSEL` reader - External trigger source selection"] pub type EtrselR = crate :: FieldReader ;
#[doc = "Field `ETRSEL` writer - External trigger source selection"] pub type EtrselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 14:16 - External trigger source selection"]
#[inline (always)] pub fn etrsel (& self) -> EtrselR { EtrselR :: new (((self . bits >> 14) & 7) as u8) } } impl W {
#[doc = "Bits 14:16 - External trigger source selection"]
#[inline (always)] pub fn etrsel (& mut self) -> EtrselW < '_ , AfSpec > { EtrselW :: new (self , 14) } }
#[doc = "TIM2 alternate function option register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`af::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`af::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AfSpec ; impl crate :: RegisterSpec for AfSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`af::R`](R) reader structure"] impl crate :: Readable for AfSpec { }
#[doc = "`write(|w| ..)` method takes [`af::W`](W) writer structure"] impl crate :: Writable for AfSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AF to value 0"] impl crate :: Resettable for AfSpec { } } }
#[doc = "General purpose timers"] pub type Tim16 = crate :: Periph < tim16 :: RegisterBlock , 0x4001_4400 > ; impl core :: fmt :: Debug for Tim16 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim16") . finish () } }
#[doc = "General purpose timers"] pub mod tim16 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr1 : Cr1 , cr2 : Cr2 , _reserved2 : [u8 ; 0x04] , dier : Dier , sr : Sr , egr : Egr , _reserved_5_ccmr1 : [u8 ; 0x04] , _reserved6 : [u8 ; 0x04] , ccer : Ccer , cnt : Cnt , psc : Psc , arr : Arr , rcr : Rcr , ccr1 : Ccr1 , _reserved12 : [u8 ; 0x0c] , bdtr : Bdtr , dcr : Dcr , dmar : Dmar , or1 : Or1 , _reserved16 : [u8 ; 0x0c] , af1 : Af1 , _reserved17 : [u8 ; 0x04] , tisel : Tisel , } impl RegisterBlock {
#[doc = "0x00 - control register 1"]
#[inline (always)] pub const fn cr1 (& self) -> & Cr1 { & self . cr1 }
#[doc = "0x04 - control register 2"]
#[inline (always)] pub const fn cr2 (& self) -> & Cr2 { & self . cr2 }
#[doc = "0x0c - DMA/Interrupt enable register"]
#[inline (always)] pub const fn dier (& self) -> & Dier { & self . dier }
#[doc = "0x10 - status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x14 - event generation register"]
#[inline (always)] pub const fn egr (& self) -> & Egr { & self . egr }
#[doc = "0x18 - capture/compare mode register 1 (input mode)"]
#[inline (always)] pub const fn ccmr1_input (& self) -> & Ccmr1Input { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x18 - capture/compare mode register (output mode)"]
#[inline (always)] pub const fn ccmr1_output (& self) -> & Ccmr1Output { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x20 - capture/compare enable register"]
#[inline (always)] pub const fn ccer (& self) -> & Ccer { & self . ccer }
#[doc = "0x24 - counter"]
#[inline (always)] pub const fn cnt (& self) -> & Cnt { & self . cnt }
#[doc = "0x28 - prescaler"]
#[inline (always)] pub const fn psc (& self) -> & Psc { & self . psc }
#[doc = "0x2c - auto-reload register"]
#[inline (always)] pub const fn arr (& self) -> & Arr { & self . arr }
#[doc = "0x30 - repetition counter register"]
#[inline (always)] pub const fn rcr (& self) -> & Rcr { & self . rcr }
#[doc = "0x34 - capture/compare register 1"]
#[inline (always)] pub const fn ccr1 (& self) -> & Ccr1 { & self . ccr1 }
#[doc = "0x44 - break and dead-time register"]
#[inline (always)] pub const fn bdtr (& self) -> & Bdtr { & self . bdtr }
#[doc = "0x48 - DMA control register"]
#[inline (always)] pub const fn dcr (& self) -> & Dcr { & self . dcr }
#[doc = "0x4c - DMA address for full transfer"]
#[inline (always)] pub const fn dmar (& self) -> & Dmar { & self . dmar }
#[doc = "0x50 - TIM option register 1"]
#[inline (always)] pub const fn or1 (& self) -> & Or1 { & self . or1 }
#[doc = "0x60 - alternate function register 1"]
#[inline (always)] pub const fn af1 (& self) -> & Af1 { & self . af1 }
#[doc = "0x68 - input selection register"]
#[inline (always)] pub const fn tisel (& self) -> & Tisel { & self . tisel } }
#[doc = "CR1 (rw) register accessor: control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
#[doc (alias = "CR1")] pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ;
#[doc = "control register 1"] pub mod cr1 {
#[doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ;
#[doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ;
#[doc = "Field `CEN` reader - Counter enable"] pub type CenR = crate :: BitReader ;
#[doc = "Field `CEN` writer - Counter enable"] pub type CenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDIS` reader - Update disable"] pub type UdisR = crate :: BitReader ;
#[doc = "Field `UDIS` writer - Update disable"] pub type UdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `URS` reader - Update request source"] pub type UrsR = crate :: BitReader ;
#[doc = "Field `URS` writer - Update request source"] pub type UrsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OPM` reader - One-pulse mode"] pub type OpmR = crate :: BitReader ;
#[doc = "Field `OPM` writer - One-pulse mode"] pub type OpmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ARPE` reader - Auto-reload preload enable"] pub type ArpeR = crate :: BitReader ;
#[doc = "Field `ARPE` writer - Auto-reload preload enable"] pub type ArpeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CKD` reader - Clock division"] pub type CkdR = crate :: FieldReader ;
#[doc = "Field `CKD` writer - Clock division"] pub type CkdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UIFREMAP` reader - UIF status bit remapping"] pub type UifremapR = crate :: BitReader ;
#[doc = "Field `UIFREMAP` writer - UIF status bit remapping"] pub type UifremapW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& self) -> CenR { CenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& self) -> UdisR { UdisR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& self) -> UrsR { UrsR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - One-pulse mode"]
#[inline (always)] pub fn opm (& self) -> OpmR { OpmR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& self) -> ArpeR { ArpeR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Clock division"]
#[inline (always)] pub fn ckd (& self) -> CkdR { CkdR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 11 - UIF status bit remapping"]
#[inline (always)] pub fn uifremap (& self) -> UifremapR { UifremapR :: new (((self . bits >> 11) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& mut self) -> CenW < '_ , Cr1Spec > { CenW :: new (self , 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& mut self) -> UdisW < '_ , Cr1Spec > { UdisW :: new (self , 1) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& mut self) -> UrsW < '_ , Cr1Spec > { UrsW :: new (self , 2) }
#[doc = "Bit 3 - One-pulse mode"]
#[inline (always)] pub fn opm (& mut self) -> OpmW < '_ , Cr1Spec > { OpmW :: new (self , 3) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& mut self) -> ArpeW < '_ , Cr1Spec > { ArpeW :: new (self , 7) }
#[doc = "Bits 8:9 - Clock division"]
#[inline (always)] pub fn ckd (& mut self) -> CkdW < '_ , Cr1Spec > { CkdW :: new (self , 8) }
#[doc = "Bit 11 - UIF status bit remapping"]
#[inline (always)] pub fn uifremap (& mut self) -> UifremapW < '_ , Cr1Spec > { UifremapW :: new (self , 11) } }
#[doc = "control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { } }
#[doc = "CR2 (rw) register accessor: control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`] module"]
#[doc (alias = "CR2")] pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ;
#[doc = "control register 2"] pub mod cr2 {
#[doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ;
#[doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ;
#[doc = "Field `CCPC` reader - Capture/compare preloaded control"] pub type CcpcR = crate :: BitReader ;
#[doc = "Field `CCPC` writer - Capture/compare preloaded control"] pub type CcpcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CCUS` reader - Capture/compare control update selection"] pub type CcusR = crate :: BitReader ;
#[doc = "Field `CCUS` writer - Capture/compare control update selection"] pub type CcusW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CCDS` reader - Capture/compare DMA selection"] pub type CcdsR = crate :: BitReader ;
#[doc = "Field `CCDS` writer - Capture/compare DMA selection"] pub type CcdsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS1` reader - Output Idle state 1"] pub type Ois1R = crate :: BitReader ;
#[doc = "Field `OIS1` writer - Output Idle state 1"] pub type Ois1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS1N` reader - Output Idle state 1"] pub type Ois1nR = crate :: BitReader ;
#[doc = "Field `OIS1N` writer - Output Idle state 1"] pub type Ois1nW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Capture/compare preloaded control"]
#[inline (always)] pub fn ccpc (& self) -> CcpcR { CcpcR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 2 - Capture/compare control update selection"]
#[inline (always)] pub fn ccus (& self) -> CcusR { CcusR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Capture/compare DMA selection"]
#[inline (always)] pub fn ccds (& self) -> CcdsR { CcdsR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 8 - Output Idle state 1"]
#[inline (always)] pub fn ois1 (& self) -> Ois1R { Ois1R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Output Idle state 1"]
#[inline (always)] pub fn ois1n (& self) -> Ois1nR { Ois1nR :: new (((self . bits >> 9) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Capture/compare preloaded control"]
#[inline (always)] pub fn ccpc (& mut self) -> CcpcW < '_ , Cr2Spec > { CcpcW :: new (self , 0) }
#[doc = "Bit 2 - Capture/compare control update selection"]
#[inline (always)] pub fn ccus (& mut self) -> CcusW < '_ , Cr2Spec > { CcusW :: new (self , 2) }
#[doc = "Bit 3 - Capture/compare DMA selection"]
#[inline (always)] pub fn ccds (& mut self) -> CcdsW < '_ , Cr2Spec > { CcdsW :: new (self , 3) }
#[doc = "Bit 8 - Output Idle state 1"]
#[inline (always)] pub fn ois1 (& mut self) -> Ois1W < '_ , Cr2Spec > { Ois1W :: new (self , 8) }
#[doc = "Bit 9 - Output Idle state 1"]
#[inline (always)] pub fn ois1n (& mut self) -> Ois1nW < '_ , Cr2Spec > { Ois1nW :: new (self , 9) } }
#[doc = "control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR2 to value 0"] impl crate :: Resettable for Cr2Spec { } }
#[doc = "DIER (rw) register accessor: DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dier`] module"]
#[doc (alias = "DIER")] pub type Dier = crate :: Reg < dier :: DierSpec > ;
#[doc = "DMA/Interrupt enable register"] pub mod dier {
#[doc = "Register `DIER` reader"] pub type R = crate :: R < DierSpec > ;
#[doc = "Register `DIER` writer"] pub type W = crate :: W < DierSpec > ;
#[doc = "Field `UIE` reader - Update interrupt enable"] pub type UieR = crate :: BitReader ;
#[doc = "Field `UIE` writer - Update interrupt enable"] pub type UieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1IE` reader - Capture/Compare 1 interrupt enable"] pub type Cc1ieR = crate :: BitReader ;
#[doc = "Field `CC1IE` writer - Capture/Compare 1 interrupt enable"] pub type Cc1ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMIE` reader - COM interrupt enable"] pub type ComieR = crate :: BitReader ;
#[doc = "Field `COMIE` writer - COM interrupt enable"] pub type ComieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BIE` reader - Break interrupt enable"] pub type BieR = crate :: BitReader ;
#[doc = "Field `BIE` writer - Break interrupt enable"] pub type BieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDE` reader - Update DMA request enable"] pub type UdeR = crate :: BitReader ;
#[doc = "Field `UDE` writer - Update DMA request enable"] pub type UdeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1DE` reader - Capture/Compare 1 DMA request enable"] pub type Cc1deR = crate :: BitReader ;
#[doc = "Field `CC1DE` writer - Capture/Compare 1 DMA request enable"] pub type Cc1deW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& self) -> UieR { UieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
#[inline (always)] pub fn cc1ie (& self) -> Cc1ieR { Cc1ieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 5 - COM interrupt enable"]
#[inline (always)] pub fn comie (& self) -> ComieR { ComieR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 7 - Break interrupt enable"]
#[inline (always)] pub fn bie (& self) -> BieR { BieR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Update DMA request enable"]
#[inline (always)] pub fn ude (& self) -> UdeR { UdeR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
#[inline (always)] pub fn cc1de (& self) -> Cc1deR { Cc1deR :: new (((self . bits >> 9) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& mut self) -> UieW < '_ , DierSpec > { UieW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
#[inline (always)] pub fn cc1ie (& mut self) -> Cc1ieW < '_ , DierSpec > { Cc1ieW :: new (self , 1) }
#[doc = "Bit 5 - COM interrupt enable"]
#[inline (always)] pub fn comie (& mut self) -> ComieW < '_ , DierSpec > { ComieW :: new (self , 5) }
#[doc = "Bit 7 - Break interrupt enable"]
#[inline (always)] pub fn bie (& mut self) -> BieW < '_ , DierSpec > { BieW :: new (self , 7) }
#[doc = "Bit 8 - Update DMA request enable"]
#[inline (always)] pub fn ude (& mut self) -> UdeW < '_ , DierSpec > { UdeW :: new (self , 8) }
#[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
#[inline (always)] pub fn cc1de (& mut self) -> Cc1deW < '_ , DierSpec > { Cc1deW :: new (self , 9) } }
#[doc = "DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DierSpec ; impl crate :: RegisterSpec for DierSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dier::R`](R) reader structure"] impl crate :: Readable for DierSpec { }
#[doc = "`write(|w| ..)` method takes [`dier::W`](W) writer structure"] impl crate :: Writable for DierSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIER to value 0"] impl crate :: Resettable for DierSpec { } }
#[doc = "SR (rw) register accessor: status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `UIF` reader - Update interrupt flag"] pub type UifR = crate :: BitReader ;
#[doc = "Field `UIF` writer - Update interrupt flag"] pub type UifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1IF` reader - Capture/compare 1 interrupt flag"] pub type Cc1ifR = crate :: BitReader ;
#[doc = "Field `CC1IF` writer - Capture/compare 1 interrupt flag"] pub type Cc1ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMIF` reader - COM interrupt flag"] pub type ComifR = crate :: BitReader ;
#[doc = "Field `COMIF` writer - COM interrupt flag"] pub type ComifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BIF` reader - Break interrupt flag"] pub type BifR = crate :: BitReader ;
#[doc = "Field `BIF` writer - Break interrupt flag"] pub type BifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1OF` reader - Capture/Compare 1 overcapture flag"] pub type Cc1ofR = crate :: BitReader ;
#[doc = "Field `CC1OF` writer - Capture/Compare 1 overcapture flag"] pub type Cc1ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& self) -> UifR { UifR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
#[inline (always)] pub fn cc1if (& self) -> Cc1ifR { Cc1ifR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 5 - COM interrupt flag"]
#[inline (always)] pub fn comif (& self) -> ComifR { ComifR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 7 - Break interrupt flag"]
#[inline (always)] pub fn bif (& self) -> BifR { BifR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
#[inline (always)] pub fn cc1of (& self) -> Cc1ofR { Cc1ofR :: new (((self . bits >> 9) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& mut self) -> UifW < '_ , SrSpec > { UifW :: new (self , 0) }
#[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
#[inline (always)] pub fn cc1if (& mut self) -> Cc1ifW < '_ , SrSpec > { Cc1ifW :: new (self , 1) }
#[doc = "Bit 5 - COM interrupt flag"]
#[inline (always)] pub fn comif (& mut self) -> ComifW < '_ , SrSpec > { ComifW :: new (self , 5) }
#[doc = "Bit 7 - Break interrupt flag"]
#[inline (always)] pub fn bif (& mut self) -> BifW < '_ , SrSpec > { BifW :: new (self , 7) }
#[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
#[inline (always)] pub fn cc1of (& mut self) -> Cc1ofW < '_ , SrSpec > { Cc1ofW :: new (self , 9) } }
#[doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "EGR (w) register accessor: event generation register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@egr`] module"]
#[doc (alias = "EGR")] pub type Egr = crate :: Reg < egr :: EgrSpec > ;
#[doc = "event generation register"] pub mod egr {
#[doc = "Register `EGR` writer"] pub type W = crate :: W < EgrSpec > ;
#[doc = "Field `UG` writer - Update generation"] pub type UgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1G` writer - Capture/compare 1 generation"] pub type Cc1gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMG` writer - Capture/Compare control update generation"] pub type ComgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BG` writer - Break generation"] pub type BgW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Update generation"]
#[inline (always)] pub fn ug (& mut self) -> UgW < '_ , EgrSpec > { UgW :: new (self , 0) }
#[doc = "Bit 1 - Capture/compare 1 generation"]
#[inline (always)] pub fn cc1g (& mut self) -> Cc1gW < '_ , EgrSpec > { Cc1gW :: new (self , 1) }
#[doc = "Bit 5 - Capture/Compare control update generation"]
#[inline (always)] pub fn comg (& mut self) -> ComgW < '_ , EgrSpec > { ComgW :: new (self , 5) }
#[doc = "Bit 7 - Break generation"]
#[inline (always)] pub fn bg (& mut self) -> BgW < '_ , EgrSpec > { BgW :: new (self , 7) } }
#[doc = "event generation register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct EgrSpec ; impl crate :: RegisterSpec for EgrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`egr::W`](W) writer structure"] impl crate :: Writable for EgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EGR to value 0"] impl crate :: Resettable for EgrSpec { } }
#[doc = "CCMR1_Output (rw) register accessor: capture/compare mode register (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_output::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_output::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr1_output`] module"]
#[doc (alias = "CCMR1_Output")] pub type Ccmr1Output = crate :: Reg < ccmr1_output :: Ccmr1OutputSpec > ;
#[doc = "capture/compare mode register (output mode)"] pub mod ccmr1_output {
#[doc = "Register `CCMR1_Output` reader"] pub type R = crate :: R < Ccmr1OutputSpec > ;
#[doc = "Register `CCMR1_Output` writer"] pub type W = crate :: W < Ccmr1OutputSpec > ;
#[doc = "Field `CC1S` reader - Capture/Compare 1 selection"] pub type Cc1sR = crate :: FieldReader ;
#[doc = "Field `CC1S` writer - Capture/Compare 1 selection"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC1FE` reader - Output Compare 1 fast enable"] pub type Oc1feR = crate :: BitReader ;
#[doc = "Field `OC1FE` writer - Output Compare 1 fast enable"] pub type Oc1feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1PE` reader - Output Compare 1 preload enable"] pub type Oc1peR = crate :: BitReader ;
#[doc = "Field `OC1PE` writer - Output Compare 1 preload enable"] pub type Oc1peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1M` reader - Output Compare 1 mode"] pub type Oc1mR = crate :: FieldReader ;
#[doc = "Field `OC1M` writer - Output Compare 1 mode"] pub type Oc1mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC1M_3` reader - Output Compare 1 mode"] pub type Oc1m3R = crate :: BitReader ;
#[doc = "Field `OC1M_3` writer - Output Compare 1 mode"] pub type Oc1m3W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) }
#[doc = "Bit 2 - Output Compare 1 fast enable"]
#[inline (always)] pub fn oc1fe (& self) -> Oc1feR { Oc1feR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Output Compare 1 preload enable"]
#[inline (always)] pub fn oc1pe (& self) -> Oc1peR { Oc1peR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Output Compare 1 mode"]
#[inline (always)] pub fn oc1m (& self) -> Oc1mR { Oc1mR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 16 - Output Compare 1 mode"]
#[inline (always)] pub fn oc1m_3 (& self) -> Oc1m3R { Oc1m3R :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& mut self) -> Cc1sW < '_ , Ccmr1OutputSpec > { Cc1sW :: new (self , 0) }
#[doc = "Bit 2 - Output Compare 1 fast enable"]
#[inline (always)] pub fn oc1fe (& mut self) -> Oc1feW < '_ , Ccmr1OutputSpec > { Oc1feW :: new (self , 2) }
#[doc = "Bit 3 - Output Compare 1 preload enable"]
#[inline (always)] pub fn oc1pe (& mut self) -> Oc1peW < '_ , Ccmr1OutputSpec > { Oc1peW :: new (self , 3) }
#[doc = "Bits 4:6 - Output Compare 1 mode"]
#[inline (always)] pub fn oc1m (& mut self) -> Oc1mW < '_ , Ccmr1OutputSpec > { Oc1mW :: new (self , 4) }
#[doc = "Bit 16 - Output Compare 1 mode"]
#[inline (always)] pub fn oc1m_3 (& mut self) -> Oc1m3W < '_ , Ccmr1OutputSpec > { Oc1m3W :: new (self , 16) } }
#[doc = "capture/compare mode register (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_output::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_output::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1OutputSpec ; impl crate :: RegisterSpec for Ccmr1OutputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr1_output::R`](R) reader structure"] impl crate :: Readable for Ccmr1OutputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr1_output::W`](W) writer structure"] impl crate :: Writable for Ccmr1OutputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR1_Output to value 0"] impl crate :: Resettable for Ccmr1OutputSpec { } }
#[doc = "CCMR1_Input (rw) register accessor: capture/compare mode register 1 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr1_input`] module"]
#[doc (alias = "CCMR1_Input")] pub type Ccmr1Input = crate :: Reg < ccmr1_input :: Ccmr1InputSpec > ;
#[doc = "capture/compare mode register 1 (input mode)"] pub mod ccmr1_input {
#[doc = "Register `CCMR1_Input` reader"] pub type R = crate :: R < Ccmr1InputSpec > ;
#[doc = "Register `CCMR1_Input` writer"] pub type W = crate :: W < Ccmr1InputSpec > ;
#[doc = "Field `CC1S` reader - Capture/Compare 1 selection"] pub type Cc1sR = crate :: FieldReader ;
#[doc = "Field `CC1S` writer - Capture/Compare 1 selection"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC1PSC` reader - Input capture 1 prescaler"] pub type Ic1pscR = crate :: FieldReader ;
#[doc = "Field `IC1PSC` writer - Input capture 1 prescaler"] pub type Ic1pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC1F` reader - Input capture 1 filter"] pub type Ic1fR = crate :: FieldReader ;
#[doc = "Field `IC1F` writer - Input capture 1 filter"] pub type Ic1fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Input capture 1 prescaler"]
#[inline (always)] pub fn ic1psc (& self) -> Ic1pscR { Ic1pscR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:7 - Input capture 1 filter"]
#[inline (always)] pub fn ic1f (& self) -> Ic1fR { Ic1fR :: new (((self . bits >> 4) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& mut self) -> Cc1sW < '_ , Ccmr1InputSpec > { Cc1sW :: new (self , 0) }
#[doc = "Bits 2:3 - Input capture 1 prescaler"]
#[inline (always)] pub fn ic1psc (& mut self) -> Ic1pscW < '_ , Ccmr1InputSpec > { Ic1pscW :: new (self , 2) }
#[doc = "Bits 4:7 - Input capture 1 filter"]
#[inline (always)] pub fn ic1f (& mut self) -> Ic1fW < '_ , Ccmr1InputSpec > { Ic1fW :: new (self , 4) } }
#[doc = "capture/compare mode register 1 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1InputSpec ; impl crate :: RegisterSpec for Ccmr1InputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr1_input::R`](R) reader structure"] impl crate :: Readable for Ccmr1InputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr1_input::W`](W) writer structure"] impl crate :: Writable for Ccmr1InputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR1_Input to value 0"] impl crate :: Resettable for Ccmr1InputSpec { } }
#[doc = "CCER (rw) register accessor: capture/compare enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccer::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccer::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccer`] module"]
#[doc (alias = "CCER")] pub type Ccer = crate :: Reg < ccer :: CcerSpec > ;
#[doc = "capture/compare enable register"] pub mod ccer {
#[doc = "Register `CCER` reader"] pub type R = crate :: R < CcerSpec > ;
#[doc = "Register `CCER` writer"] pub type W = crate :: W < CcerSpec > ;
#[doc = "Field `CC1E` reader - Capture/Compare 1 output enable"] pub type Cc1eR = crate :: BitReader ;
#[doc = "Field `CC1E` writer - Capture/Compare 1 output enable"] pub type Cc1eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1P` reader - Capture/Compare 1 output Polarity"] pub type Cc1pR = crate :: BitReader ;
#[doc = "Field `CC1P` writer - Capture/Compare 1 output Polarity"] pub type Cc1pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1NE` reader - Capture/Compare 1 complementary output enable"] pub type Cc1neR = crate :: BitReader ;
#[doc = "Field `CC1NE` writer - Capture/Compare 1 complementary output enable"] pub type Cc1neW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1NP` reader - Capture/Compare 1 output Polarity"] pub type Cc1npR = crate :: BitReader ;
#[doc = "Field `CC1NP` writer - Capture/Compare 1 output Polarity"] pub type Cc1npW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Capture/Compare 1 output enable"]
#[inline (always)] pub fn cc1e (& self) -> Cc1eR { Cc1eR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1p (& self) -> Cc1pR { Cc1pR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
#[inline (always)] pub fn cc1ne (& self) -> Cc1neR { Cc1neR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1np (& self) -> Cc1npR { Cc1npR :: new (((self . bits >> 3) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Capture/Compare 1 output enable"]
#[inline (always)] pub fn cc1e (& mut self) -> Cc1eW < '_ , CcerSpec > { Cc1eW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1p (& mut self) -> Cc1pW < '_ , CcerSpec > { Cc1pW :: new (self , 1) }
#[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
#[inline (always)] pub fn cc1ne (& mut self) -> Cc1neW < '_ , CcerSpec > { Cc1neW :: new (self , 2) }
#[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1np (& mut self) -> Cc1npW < '_ , CcerSpec > { Cc1npW :: new (self , 3) } }
#[doc = "capture/compare enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccer::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccer::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CcerSpec ; impl crate :: RegisterSpec for CcerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccer::R`](R) reader structure"] impl crate :: Readable for CcerSpec { }
#[doc = "`write(|w| ..)` method takes [`ccer::W`](W) writer structure"] impl crate :: Writable for CcerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCER to value 0"] impl crate :: Resettable for CcerSpec { } }
#[doc = "CNT (rw) register accessor: counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt`] module"]
#[doc (alias = "CNT")] pub type Cnt = crate :: Reg < cnt :: CntSpec > ;
#[doc = "counter"] pub mod cnt {
#[doc = "Register `CNT` reader"] pub type R = crate :: R < CntSpec > ;
#[doc = "Register `CNT` writer"] pub type W = crate :: W < CntSpec > ;
#[doc = "Field `CNT` reader - counter value"] pub type CntR = crate :: FieldReader < u16 > ;
#[doc = "Field `CNT` writer - counter value"] pub type CntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `UIFCPY` reader - UIF Copy"] pub type UifcpyR = crate :: BitReader ; impl R {
#[doc = "Bits 0:15 - counter value"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bit 31 - UIF Copy"]
#[inline (always)] pub fn uifcpy (& self) -> UifcpyR { UifcpyR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:15 - counter value"]
#[inline (always)] pub fn cnt (& mut self) -> CntW < '_ , CntSpec > { CntW :: new (self , 0) } }
#[doc = "counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CntSpec ; impl crate :: RegisterSpec for CntSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cnt::R`](R) reader structure"] impl crate :: Readable for CntSpec { }
#[doc = "`write(|w| ..)` method takes [`cnt::W`](W) writer structure"] impl crate :: Writable for CntSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNT to value 0"] impl crate :: Resettable for CntSpec { } }
#[doc = "PSC (rw) register accessor: prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@psc`] module"]
#[doc (alias = "PSC")] pub type Psc = crate :: Reg < psc :: PscSpec > ;
#[doc = "prescaler"] pub mod psc {
#[doc = "Register `PSC` reader"] pub type R = crate :: R < PscSpec > ;
#[doc = "Register `PSC` writer"] pub type W = crate :: W < PscSpec > ;
#[doc = "Field `PSC` reader - Prescaler value"] pub type PscR = crate :: FieldReader < u16 > ;
#[doc = "Field `PSC` writer - Prescaler value"] pub type PscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& self) -> PscR { PscR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& mut self) -> PscW < '_ , PscSpec > { PscW :: new (self , 0) } }
#[doc = "prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PscSpec ; impl crate :: RegisterSpec for PscSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`psc::R`](R) reader structure"] impl crate :: Readable for PscSpec { }
#[doc = "`write(|w| ..)` method takes [`psc::W`](W) writer structure"] impl crate :: Writable for PscSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PSC to value 0"] impl crate :: Resettable for PscSpec { } }
#[doc = "ARR (rw) register accessor: auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@arr`] module"]
#[doc (alias = "ARR")] pub type Arr = crate :: Reg < arr :: ArrSpec > ;
#[doc = "auto-reload register"] pub mod arr {
#[doc = "Register `ARR` reader"] pub type R = crate :: R < ArrSpec > ;
#[doc = "Register `ARR` writer"] pub type W = crate :: W < ArrSpec > ;
#[doc = "Field `ARR` reader - Auto-reload value"] pub type ArrR = crate :: FieldReader < u16 > ;
#[doc = "Field `ARR` writer - Auto-reload value"] pub type ArrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Auto-reload value"]
#[inline (always)] pub fn arr (& self) -> ArrR { ArrR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Auto-reload value"]
#[inline (always)] pub fn arr (& mut self) -> ArrW < '_ , ArrSpec > { ArrW :: new (self , 0) } }
#[doc = "auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ArrSpec ; impl crate :: RegisterSpec for ArrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`arr::R`](R) reader structure"] impl crate :: Readable for ArrSpec { }
#[doc = "`write(|w| ..)` method takes [`arr::W`](W) writer structure"] impl crate :: Writable for ArrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ARR to value 0xffff"] impl crate :: Resettable for ArrSpec { const RESET_VALUE : u32 = 0xffff ; } }
#[doc = "RCR (rw) register accessor: repetition counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`rcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rcr`] module"]
#[doc (alias = "RCR")] pub type Rcr = crate :: Reg < rcr :: RcrSpec > ;
#[doc = "repetition counter register"] pub mod rcr {
#[doc = "Register `RCR` reader"] pub type R = crate :: R < RcrSpec > ;
#[doc = "Register `RCR` writer"] pub type W = crate :: W < RcrSpec > ;
#[doc = "Field `REP` reader - Repetition counter value"] pub type RepR = crate :: FieldReader ;
#[doc = "Field `REP` writer - Repetition counter value"] pub type RepW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - Repetition counter value"]
#[inline (always)] pub fn rep (& self) -> RepR { RepR :: new ((self . bits & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - Repetition counter value"]
#[inline (always)] pub fn rep (& mut self) -> RepW < '_ , RcrSpec > { RepW :: new (self , 0) } }
#[doc = "repetition counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`rcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RcrSpec ; impl crate :: RegisterSpec for RcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rcr::R`](R) reader structure"] impl crate :: Readable for RcrSpec { }
#[doc = "`write(|w| ..)` method takes [`rcr::W`](W) writer structure"] impl crate :: Writable for RcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RCR to value 0"] impl crate :: Resettable for RcrSpec { } }
#[doc = "CCR1 (rw) register accessor: capture/compare register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr1`] module"]
#[doc (alias = "CCR1")] pub type Ccr1 = crate :: Reg < ccr1 :: Ccr1Spec > ;
#[doc = "capture/compare register 1"] pub mod ccr1 {
#[doc = "Register `CCR1` reader"] pub type R = crate :: R < Ccr1Spec > ;
#[doc = "Register `CCR1` writer"] pub type W = crate :: W < Ccr1Spec > ;
#[doc = "Field `CCR1` reader - Capture/Compare 1 value"] pub type Ccr1R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR1` writer - Capture/Compare 1 value"] pub type Ccr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare 1 value"]
#[inline (always)] pub fn ccr1 (& self) -> Ccr1R { Ccr1R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare 1 value"]
#[inline (always)] pub fn ccr1 (& mut self) -> Ccr1W < '_ , Ccr1Spec > { Ccr1W :: new (self , 0) } }
#[doc = "capture/compare register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr1Spec ; impl crate :: RegisterSpec for Ccr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr1::R`](R) reader structure"] impl crate :: Readable for Ccr1Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr1::W`](W) writer structure"] impl crate :: Writable for Ccr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR1 to value 0"] impl crate :: Resettable for Ccr1Spec { } }
#[doc = "BDTR (rw) register accessor: break and dead-time register\n\nYou can [`read`](crate::Reg::read) this register and get [`bdtr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bdtr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bdtr`] module"]
#[doc (alias = "BDTR")] pub type Bdtr = crate :: Reg < bdtr :: BdtrSpec > ;
#[doc = "break and dead-time register"] pub mod bdtr {
#[doc = "Register `BDTR` reader"] pub type R = crate :: R < BdtrSpec > ;
#[doc = "Register `BDTR` writer"] pub type W = crate :: W < BdtrSpec > ;
#[doc = "Field `DTG` reader - Dead-time generator setup"] pub type DtgR = crate :: FieldReader ;
#[doc = "Field `DTG` writer - Dead-time generator setup"] pub type DtgW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `LOCK` reader - Lock configuration"] pub type LockR = crate :: FieldReader ;
#[doc = "Field `LOCK` writer - Lock configuration"] pub type LockW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSSI` reader - Off-state selection for Idle mode"] pub type OssiR = crate :: BitReader ;
#[doc = "Field `OSSI` writer - Off-state selection for Idle mode"] pub type OssiW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OSSR` reader - Off-state selection for Run mode"] pub type OssrR = crate :: BitReader ;
#[doc = "Field `OSSR` writer - Off-state selection for Run mode"] pub type OssrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKE` reader - Break enable"] pub type BkeR = crate :: BitReader ;
#[doc = "Field `BKE` writer - Break enable"] pub type BkeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKP` reader - Break polarity"] pub type BkpR = crate :: BitReader ;
#[doc = "Field `BKP` writer - Break polarity"] pub type BkpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AOE` reader - Automatic output enable"] pub type AoeR = crate :: BitReader ;
#[doc = "Field `AOE` writer - Automatic output enable"] pub type AoeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MOE` reader - Main output enable"] pub type MoeR = crate :: BitReader ;
#[doc = "Field `MOE` writer - Main output enable"] pub type MoeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKDSRM` reader - Break Disarm"] pub type BkdsrmR = crate :: BitReader ;
#[doc = "Field `BKDSRM` writer - Break Disarm"] pub type BkdsrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKBID` reader - Break Bidirectional"] pub type BkbidR = crate :: BitReader ;
#[doc = "Field `BKBID` writer - Break Bidirectional"] pub type BkbidW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Dead-time generator setup"]
#[inline (always)] pub fn dtg (& self) -> DtgR { DtgR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:9 - Lock configuration"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 10 - Off-state selection for Idle mode"]
#[inline (always)] pub fn ossi (& self) -> OssiR { OssiR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Off-state selection for Run mode"]
#[inline (always)] pub fn ossr (& self) -> OssrR { OssrR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Break enable"]
#[inline (always)] pub fn bke (& self) -> BkeR { BkeR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Break polarity"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Automatic output enable"]
#[inline (always)] pub fn aoe (& self) -> AoeR { AoeR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Main output enable"]
#[inline (always)] pub fn moe (& self) -> MoeR { MoeR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 26 - Break Disarm"]
#[inline (always)] pub fn bkdsrm (& self) -> BkdsrmR { BkdsrmR :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 28 - Break Bidirectional"]
#[inline (always)] pub fn bkbid (& self) -> BkbidR { BkbidR :: new (((self . bits >> 28) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Dead-time generator setup"]
#[inline (always)] pub fn dtg (& mut self) -> DtgW < '_ , BdtrSpec > { DtgW :: new (self , 0) }
#[doc = "Bits 8:9 - Lock configuration"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , BdtrSpec > { LockW :: new (self , 8) }
#[doc = "Bit 10 - Off-state selection for Idle mode"]
#[inline (always)] pub fn ossi (& mut self) -> OssiW < '_ , BdtrSpec > { OssiW :: new (self , 10) }
#[doc = "Bit 11 - Off-state selection for Run mode"]
#[inline (always)] pub fn ossr (& mut self) -> OssrW < '_ , BdtrSpec > { OssrW :: new (self , 11) }
#[doc = "Bit 12 - Break enable"]
#[inline (always)] pub fn bke (& mut self) -> BkeW < '_ , BdtrSpec > { BkeW :: new (self , 12) }
#[doc = "Bit 13 - Break polarity"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , BdtrSpec > { BkpW :: new (self , 13) }
#[doc = "Bit 14 - Automatic output enable"]
#[inline (always)] pub fn aoe (& mut self) -> AoeW < '_ , BdtrSpec > { AoeW :: new (self , 14) }
#[doc = "Bit 15 - Main output enable"]
#[inline (always)] pub fn moe (& mut self) -> MoeW < '_ , BdtrSpec > { MoeW :: new (self , 15) }
#[doc = "Bit 26 - Break Disarm"]
#[inline (always)] pub fn bkdsrm (& mut self) -> BkdsrmW < '_ , BdtrSpec > { BkdsrmW :: new (self , 26) }
#[doc = "Bit 28 - Break Bidirectional"]
#[inline (always)] pub fn bkbid (& mut self) -> BkbidW < '_ , BdtrSpec > { BkbidW :: new (self , 28) } }
#[doc = "break and dead-time register\n\nYou can [`read`](crate::Reg::read) this register and get [`bdtr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bdtr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BdtrSpec ; impl crate :: RegisterSpec for BdtrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bdtr::R`](R) reader structure"] impl crate :: Readable for BdtrSpec { }
#[doc = "`write(|w| ..)` method takes [`bdtr::W`](W) writer structure"] impl crate :: Writable for BdtrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BDTR to value 0"] impl crate :: Resettable for BdtrSpec { } }
#[doc = "DCR (rw) register accessor: DMA control register\n\nYou can [`read`](crate::Reg::read) this register and get [`dcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dcr`] module"]
#[doc (alias = "DCR")] pub type Dcr = crate :: Reg < dcr :: DcrSpec > ;
#[doc = "DMA control register"] pub mod dcr {
#[doc = "Register `DCR` reader"] pub type R = crate :: R < DcrSpec > ;
#[doc = "Register `DCR` writer"] pub type W = crate :: W < DcrSpec > ;
#[doc = "Field `DBA` reader - DMA base address"] pub type DbaR = crate :: FieldReader ;
#[doc = "Field `DBA` writer - DMA base address"] pub type DbaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `DBL` reader - DMA burst length"] pub type DblR = crate :: FieldReader ;
#[doc = "Field `DBL` writer - DMA burst length"] pub type DblW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:4 - DMA base address"]
#[inline (always)] pub fn dba (& self) -> DbaR { DbaR :: new ((self . bits & 0x1f) as u8) }
#[doc = "Bits 8:12 - DMA burst length"]
#[inline (always)] pub fn dbl (& self) -> DblR { DblR :: new (((self . bits >> 8) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:4 - DMA base address"]
#[inline (always)] pub fn dba (& mut self) -> DbaW < '_ , DcrSpec > { DbaW :: new (self , 0) }
#[doc = "Bits 8:12 - DMA burst length"]
#[inline (always)] pub fn dbl (& mut self) -> DblW < '_ , DcrSpec > { DblW :: new (self , 8) } }
#[doc = "DMA control register\n\nYou can [`read`](crate::Reg::read) this register and get [`dcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DcrSpec ; impl crate :: RegisterSpec for DcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dcr::R`](R) reader structure"] impl crate :: Readable for DcrSpec { }
#[doc = "`write(|w| ..)` method takes [`dcr::W`](W) writer structure"] impl crate :: Writable for DcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DCR to value 0"] impl crate :: Resettable for DcrSpec { } }
#[doc = "DMAR (rw) register accessor: DMA address for full transfer\n\nYou can [`read`](crate::Reg::read) this register and get [`dmar::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmar::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dmar`] module"]
#[doc (alias = "DMAR")] pub type Dmar = crate :: Reg < dmar :: DmarSpec > ;
#[doc = "DMA address for full transfer"] pub mod dmar {
#[doc = "Register `DMAR` reader"] pub type R = crate :: R < DmarSpec > ;
#[doc = "Register `DMAR` writer"] pub type W = crate :: W < DmarSpec > ;
#[doc = "Field `DMAB` reader - DMA register for burst accesses"] pub type DmabR = crate :: FieldReader < u16 > ;
#[doc = "Field `DMAB` writer - DMA register for burst accesses"] pub type DmabW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - DMA register for burst accesses"]
#[inline (always)] pub fn dmab (& self) -> DmabR { DmabR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - DMA register for burst accesses"]
#[inline (always)] pub fn dmab (& mut self) -> DmabW < '_ , DmarSpec > { DmabW :: new (self , 0) } }
#[doc = "DMA address for full transfer\n\nYou can [`read`](crate::Reg::read) this register and get [`dmar::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmar::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DmarSpec ; impl crate :: RegisterSpec for DmarSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dmar::R`](R) reader structure"] impl crate :: Readable for DmarSpec { }
#[doc = "`write(|w| ..)` method takes [`dmar::W`](W) writer structure"] impl crate :: Writable for DmarSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMAR to value 0"] impl crate :: Resettable for DmarSpec { } }
#[doc = "OR1 (rw) register accessor: TIM option register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`or1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`or1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@or1`] module"]
#[doc (alias = "OR1")] pub type Or1 = crate :: Reg < or1 :: Or1Spec > ;
#[doc = "TIM option register 1"] pub mod or1 {
#[doc = "Register `OR1` reader"] pub type R = crate :: R < Or1Spec > ;
#[doc = "Register `OR1` writer"] pub type W = crate :: W < Or1Spec > ;
#[doc = "Field `TI1_RMP` reader - Input capture 1 remap"] pub type Ti1RmpR = crate :: FieldReader ;
#[doc = "Field `TI1_RMP` writer - Input capture 1 remap"] pub type Ti1RmpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:1 - Input capture 1 remap"]
#[inline (always)] pub fn ti1_rmp (& self) -> Ti1RmpR { Ti1RmpR :: new ((self . bits & 3) as u8) } } impl W {
#[doc = "Bits 0:1 - Input capture 1 remap"]
#[inline (always)] pub fn ti1_rmp (& mut self) -> Ti1RmpW < '_ , Or1Spec > { Ti1RmpW :: new (self , 0) } }
#[doc = "TIM option register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`or1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`or1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Or1Spec ; impl crate :: RegisterSpec for Or1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`or1::R`](R) reader structure"] impl crate :: Readable for Or1Spec { }
#[doc = "`write(|w| ..)` method takes [`or1::W`](W) writer structure"] impl crate :: Writable for Or1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OR1 to value 0"] impl crate :: Resettable for Or1Spec { } }
#[doc = "AF1 (rw) register accessor: alternate function register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`af1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`af1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@af1`] module"]
#[doc (alias = "AF1")] pub type Af1 = crate :: Reg < af1 :: Af1Spec > ;
#[doc = "alternate function register 1"] pub mod af1 {
#[doc = "Register `AF1` reader"] pub type R = crate :: R < Af1Spec > ;
#[doc = "Register `AF1` writer"] pub type W = crate :: W < Af1Spec > ;
#[doc = "Field `BKINE` reader - BRK BKIN input enable"] pub type BkineR = crate :: BitReader ;
#[doc = "Field `BKINE` writer - BRK BKIN input enable"] pub type BkineW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKCMP1E` reader - BRK COMP1 enable"] pub type Bkcmp1eR = crate :: BitReader ;
#[doc = "Field `BKCMP1E` writer - BRK COMP1 enable"] pub type Bkcmp1eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKCMP2E` reader - BRK COMP2 enable"] pub type Bkcmp2eR = crate :: BitReader ;
#[doc = "Field `BKCMP2E` writer - BRK COMP2 enable"] pub type Bkcmp2eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKINP` reader - BRK BKIN input polarity"] pub type BkinpR = crate :: BitReader ;
#[doc = "Field `BKINP` writer - BRK BKIN input polarity"] pub type BkinpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKCMP1P` reader - BRK COMP1 input polarity"] pub type Bkcmp1pR = crate :: BitReader ;
#[doc = "Field `BKCMP1P` writer - BRK COMP1 input polarity"] pub type Bkcmp1pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKCMP2P` reader - BRK COMP2 input polarit"] pub type Bkcmp2pR = crate :: BitReader ;
#[doc = "Field `BKCMP2P` writer - BRK COMP2 input polarit"] pub type Bkcmp2pW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - BRK BKIN input enable"]
#[inline (always)] pub fn bkine (& self) -> BkineR { BkineR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - BRK COMP1 enable"]
#[inline (always)] pub fn bkcmp1e (& self) -> Bkcmp1eR { Bkcmp1eR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - BRK COMP2 enable"]
#[inline (always)] pub fn bkcmp2e (& self) -> Bkcmp2eR { Bkcmp2eR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 9 - BRK BKIN input polarity"]
#[inline (always)] pub fn bkinp (& self) -> BkinpR { BkinpR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - BRK COMP1 input polarity"]
#[inline (always)] pub fn bkcmp1p (& self) -> Bkcmp1pR { Bkcmp1pR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - BRK COMP2 input polarit"]
#[inline (always)] pub fn bkcmp2p (& self) -> Bkcmp2pR { Bkcmp2pR :: new (((self . bits >> 11) & 1) != 0) } } impl W {
#[doc = "Bit 0 - BRK BKIN input enable"]
#[inline (always)] pub fn bkine (& mut self) -> BkineW < '_ , Af1Spec > { BkineW :: new (self , 0) }
#[doc = "Bit 1 - BRK COMP1 enable"]
#[inline (always)] pub fn bkcmp1e (& mut self) -> Bkcmp1eW < '_ , Af1Spec > { Bkcmp1eW :: new (self , 1) }
#[doc = "Bit 2 - BRK COMP2 enable"]
#[inline (always)] pub fn bkcmp2e (& mut self) -> Bkcmp2eW < '_ , Af1Spec > { Bkcmp2eW :: new (self , 2) }
#[doc = "Bit 9 - BRK BKIN input polarity"]
#[inline (always)] pub fn bkinp (& mut self) -> BkinpW < '_ , Af1Spec > { BkinpW :: new (self , 9) }
#[doc = "Bit 10 - BRK COMP1 input polarity"]
#[inline (always)] pub fn bkcmp1p (& mut self) -> Bkcmp1pW < '_ , Af1Spec > { Bkcmp1pW :: new (self , 10) }
#[doc = "Bit 11 - BRK COMP2 input polarit"]
#[inline (always)] pub fn bkcmp2p (& mut self) -> Bkcmp2pW < '_ , Af1Spec > { Bkcmp2pW :: new (self , 11) } }
#[doc = "alternate function register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`af1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`af1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Af1Spec ; impl crate :: RegisterSpec for Af1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`af1::R`](R) reader structure"] impl crate :: Readable for Af1Spec { }
#[doc = "`write(|w| ..)` method takes [`af1::W`](W) writer structure"] impl crate :: Writable for Af1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AF1 to value 0x01"] impl crate :: Resettable for Af1Spec { const RESET_VALUE : u32 = 0x01 ; } }
#[doc = "TISEL (rw) register accessor: input selection register\n\nYou can [`read`](crate::Reg::read) this register and get [`tisel::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tisel::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tisel`] module"]
#[doc (alias = "TISEL")] pub type Tisel = crate :: Reg < tisel :: TiselSpec > ;
#[doc = "input selection register"] pub mod tisel {
#[doc = "Register `TISEL` reader"] pub type R = crate :: R < TiselSpec > ;
#[doc = "Register `TISEL` writer"] pub type W = crate :: W < TiselSpec > ;
#[doc = "Field `TI1SEL` reader - selects TI1\\[0\\] to TI1\\[15\\] input"] pub type Ti1selR = crate :: FieldReader ;
#[doc = "Field `TI1SEL` writer - selects TI1\\[0\\] to TI1\\[15\\] input"] pub type Ti1selW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - selects TI1\\[0\\] to TI1\\[15\\] input"]
#[inline (always)] pub fn ti1sel (& self) -> Ti1selR { Ti1selR :: new ((self . bits & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - selects TI1\\[0\\] to TI1\\[15\\] input"]
#[inline (always)] pub fn ti1sel (& mut self) -> Ti1selW < '_ , TiselSpec > { Ti1selW :: new (self , 0) } }
#[doc = "input selection register\n\nYou can [`read`](crate::Reg::read) this register and get [`tisel::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tisel::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TiselSpec ; impl crate :: RegisterSpec for TiselSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`tisel::R`](R) reader structure"] impl crate :: Readable for TiselSpec { }
#[doc = "`write(|w| ..)` method takes [`tisel::W`](W) writer structure"] impl crate :: Writable for TiselSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets TISEL to value 0"] impl crate :: Resettable for TiselSpec { } } }
#[doc = "General purpose timers"] pub type Tim17 = crate :: Periph < tim17 :: RegisterBlock , 0x4001_4800 > ; impl core :: fmt :: Debug for Tim17 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim17") . finish () } }
#[doc = "General purpose timers"] pub mod tim17 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr1 : Cr1 , cr2 : Cr2 , _reserved2 : [u8 ; 0x04] , dier : Dier , sr : Sr , egr : Egr , _reserved_5_ccmr1 : [u8 ; 0x04] , _reserved6 : [u8 ; 0x04] , ccer : Ccer , cnt : Cnt , psc : Psc , arr : Arr , rcr : Rcr , ccr1 : Ccr1 , _reserved12 : [u8 ; 0x0c] , bdtr : Bdtr , dcr : Dcr , dmar : Dmar , or1 : Or1 , _reserved16 : [u8 ; 0x0c] , af1 : Af1 , _reserved17 : [u8 ; 0x04] , tisel : Tisel , } impl RegisterBlock {
#[doc = "0x00 - control register 1"]
#[inline (always)] pub const fn cr1 (& self) -> & Cr1 { & self . cr1 }
#[doc = "0x04 - control register 2"]
#[inline (always)] pub const fn cr2 (& self) -> & Cr2 { & self . cr2 }
#[doc = "0x0c - DMA/Interrupt enable register"]
#[inline (always)] pub const fn dier (& self) -> & Dier { & self . dier }
#[doc = "0x10 - status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x14 - event generation register"]
#[inline (always)] pub const fn egr (& self) -> & Egr { & self . egr }
#[doc = "0x18 - capture/compare mode register 1 (input mode)"]
#[inline (always)] pub const fn ccmr1_input (& self) -> & Ccmr1Input { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x18 - capture/compare mode register (output mode)"]
#[inline (always)] pub const fn ccmr1_output (& self) -> & Ccmr1Output { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x20 - capture/compare enable register"]
#[inline (always)] pub const fn ccer (& self) -> & Ccer { & self . ccer }
#[doc = "0x24 - counter"]
#[inline (always)] pub const fn cnt (& self) -> & Cnt { & self . cnt }
#[doc = "0x28 - prescaler"]
#[inline (always)] pub const fn psc (& self) -> & Psc { & self . psc }
#[doc = "0x2c - auto-reload register"]
#[inline (always)] pub const fn arr (& self) -> & Arr { & self . arr }
#[doc = "0x30 - repetition counter register"]
#[inline (always)] pub const fn rcr (& self) -> & Rcr { & self . rcr }
#[doc = "0x34 - capture/compare register 1"]
#[inline (always)] pub const fn ccr1 (& self) -> & Ccr1 { & self . ccr1 }
#[doc = "0x44 - break and dead-time register"]
#[inline (always)] pub const fn bdtr (& self) -> & Bdtr { & self . bdtr }
#[doc = "0x48 - DMA control register"]
#[inline (always)] pub const fn dcr (& self) -> & Dcr { & self . dcr }
#[doc = "0x4c - DMA address for full transfer"]
#[inline (always)] pub const fn dmar (& self) -> & Dmar { & self . dmar }
#[doc = "0x50 - TIM option register 1"]
#[inline (always)] pub const fn or1 (& self) -> & Or1 { & self . or1 }
#[doc = "0x60 - alternate function register 1"]
#[inline (always)] pub const fn af1 (& self) -> & Af1 { & self . af1 }
#[doc = "0x68 - input selection register"]
#[inline (always)] pub const fn tisel (& self) -> & Tisel { & self . tisel } }
#[doc = "CR1 (rw) register accessor: control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
#[doc (alias = "CR1")] pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ;
#[doc = "control register 1"] pub mod cr1 {
#[doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ;
#[doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ;
#[doc = "Field `CEN` reader - Counter enable"] pub type CenR = crate :: BitReader ;
#[doc = "Field `CEN` writer - Counter enable"] pub type CenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDIS` reader - Update disable"] pub type UdisR = crate :: BitReader ;
#[doc = "Field `UDIS` writer - Update disable"] pub type UdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `URS` reader - Update request source"] pub type UrsR = crate :: BitReader ;
#[doc = "Field `URS` writer - Update request source"] pub type UrsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OPM` reader - One-pulse mode"] pub type OpmR = crate :: BitReader ;
#[doc = "Field `OPM` writer - One-pulse mode"] pub type OpmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ARPE` reader - Auto-reload preload enable"] pub type ArpeR = crate :: BitReader ;
#[doc = "Field `ARPE` writer - Auto-reload preload enable"] pub type ArpeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CKD` reader - Clock division"] pub type CkdR = crate :: FieldReader ;
#[doc = "Field `CKD` writer - Clock division"] pub type CkdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UIFREMAP` reader - UIF status bit remapping"] pub type UifremapR = crate :: BitReader ;
#[doc = "Field `UIFREMAP` writer - UIF status bit remapping"] pub type UifremapW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& self) -> CenR { CenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& self) -> UdisR { UdisR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& self) -> UrsR { UrsR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - One-pulse mode"]
#[inline (always)] pub fn opm (& self) -> OpmR { OpmR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& self) -> ArpeR { ArpeR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Clock division"]
#[inline (always)] pub fn ckd (& self) -> CkdR { CkdR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 11 - UIF status bit remapping"]
#[inline (always)] pub fn uifremap (& self) -> UifremapR { UifremapR :: new (((self . bits >> 11) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& mut self) -> CenW < '_ , Cr1Spec > { CenW :: new (self , 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& mut self) -> UdisW < '_ , Cr1Spec > { UdisW :: new (self , 1) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& mut self) -> UrsW < '_ , Cr1Spec > { UrsW :: new (self , 2) }
#[doc = "Bit 3 - One-pulse mode"]
#[inline (always)] pub fn opm (& mut self) -> OpmW < '_ , Cr1Spec > { OpmW :: new (self , 3) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& mut self) -> ArpeW < '_ , Cr1Spec > { ArpeW :: new (self , 7) }
#[doc = "Bits 8:9 - Clock division"]
#[inline (always)] pub fn ckd (& mut self) -> CkdW < '_ , Cr1Spec > { CkdW :: new (self , 8) }
#[doc = "Bit 11 - UIF status bit remapping"]
#[inline (always)] pub fn uifremap (& mut self) -> UifremapW < '_ , Cr1Spec > { UifremapW :: new (self , 11) } }
#[doc = "control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { } }
#[doc = "CR2 (rw) register accessor: control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`] module"]
#[doc (alias = "CR2")] pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ;
#[doc = "control register 2"] pub mod cr2 {
#[doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ;
#[doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ;
#[doc = "Field `CCPC` reader - Capture/compare preloaded control"] pub type CcpcR = crate :: BitReader ;
#[doc = "Field `CCPC` writer - Capture/compare preloaded control"] pub type CcpcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CCUS` reader - Capture/compare control update selection"] pub type CcusR = crate :: BitReader ;
#[doc = "Field `CCUS` writer - Capture/compare control update selection"] pub type CcusW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CCDS` reader - Capture/compare DMA selection"] pub type CcdsR = crate :: BitReader ;
#[doc = "Field `CCDS` writer - Capture/compare DMA selection"] pub type CcdsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS1` reader - Output Idle state 1"] pub type Ois1R = crate :: BitReader ;
#[doc = "Field `OIS1` writer - Output Idle state 1"] pub type Ois1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS1N` reader - Output Idle state 1"] pub type Ois1nR = crate :: BitReader ;
#[doc = "Field `OIS1N` writer - Output Idle state 1"] pub type Ois1nW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Capture/compare preloaded control"]
#[inline (always)] pub fn ccpc (& self) -> CcpcR { CcpcR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 2 - Capture/compare control update selection"]
#[inline (always)] pub fn ccus (& self) -> CcusR { CcusR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Capture/compare DMA selection"]
#[inline (always)] pub fn ccds (& self) -> CcdsR { CcdsR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 8 - Output Idle state 1"]
#[inline (always)] pub fn ois1 (& self) -> Ois1R { Ois1R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Output Idle state 1"]
#[inline (always)] pub fn ois1n (& self) -> Ois1nR { Ois1nR :: new (((self . bits >> 9) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Capture/compare preloaded control"]
#[inline (always)] pub fn ccpc (& mut self) -> CcpcW < '_ , Cr2Spec > { CcpcW :: new (self , 0) }
#[doc = "Bit 2 - Capture/compare control update selection"]
#[inline (always)] pub fn ccus (& mut self) -> CcusW < '_ , Cr2Spec > { CcusW :: new (self , 2) }
#[doc = "Bit 3 - Capture/compare DMA selection"]
#[inline (always)] pub fn ccds (& mut self) -> CcdsW < '_ , Cr2Spec > { CcdsW :: new (self , 3) }
#[doc = "Bit 8 - Output Idle state 1"]
#[inline (always)] pub fn ois1 (& mut self) -> Ois1W < '_ , Cr2Spec > { Ois1W :: new (self , 8) }
#[doc = "Bit 9 - Output Idle state 1"]
#[inline (always)] pub fn ois1n (& mut self) -> Ois1nW < '_ , Cr2Spec > { Ois1nW :: new (self , 9) } }
#[doc = "control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR2 to value 0"] impl crate :: Resettable for Cr2Spec { } }
#[doc = "DIER (rw) register accessor: DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dier`] module"]
#[doc (alias = "DIER")] pub type Dier = crate :: Reg < dier :: DierSpec > ;
#[doc = "DMA/Interrupt enable register"] pub mod dier {
#[doc = "Register `DIER` reader"] pub type R = crate :: R < DierSpec > ;
#[doc = "Register `DIER` writer"] pub type W = crate :: W < DierSpec > ;
#[doc = "Field `UIE` reader - Update interrupt enable"] pub type UieR = crate :: BitReader ;
#[doc = "Field `UIE` writer - Update interrupt enable"] pub type UieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1IE` reader - Capture/Compare 1 interrupt enable"] pub type Cc1ieR = crate :: BitReader ;
#[doc = "Field `CC1IE` writer - Capture/Compare 1 interrupt enable"] pub type Cc1ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMIE` reader - COM interrupt enable"] pub type ComieR = crate :: BitReader ;
#[doc = "Field `COMIE` writer - COM interrupt enable"] pub type ComieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BIE` reader - Break interrupt enable"] pub type BieR = crate :: BitReader ;
#[doc = "Field `BIE` writer - Break interrupt enable"] pub type BieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDE` reader - Update DMA request enable"] pub type UdeR = crate :: BitReader ;
#[doc = "Field `UDE` writer - Update DMA request enable"] pub type UdeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1DE` reader - Capture/Compare 1 DMA request enable"] pub type Cc1deR = crate :: BitReader ;
#[doc = "Field `CC1DE` writer - Capture/Compare 1 DMA request enable"] pub type Cc1deW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& self) -> UieR { UieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
#[inline (always)] pub fn cc1ie (& self) -> Cc1ieR { Cc1ieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 5 - COM interrupt enable"]
#[inline (always)] pub fn comie (& self) -> ComieR { ComieR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 7 - Break interrupt enable"]
#[inline (always)] pub fn bie (& self) -> BieR { BieR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Update DMA request enable"]
#[inline (always)] pub fn ude (& self) -> UdeR { UdeR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
#[inline (always)] pub fn cc1de (& self) -> Cc1deR { Cc1deR :: new (((self . bits >> 9) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& mut self) -> UieW < '_ , DierSpec > { UieW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
#[inline (always)] pub fn cc1ie (& mut self) -> Cc1ieW < '_ , DierSpec > { Cc1ieW :: new (self , 1) }
#[doc = "Bit 5 - COM interrupt enable"]
#[inline (always)] pub fn comie (& mut self) -> ComieW < '_ , DierSpec > { ComieW :: new (self , 5) }
#[doc = "Bit 7 - Break interrupt enable"]
#[inline (always)] pub fn bie (& mut self) -> BieW < '_ , DierSpec > { BieW :: new (self , 7) }
#[doc = "Bit 8 - Update DMA request enable"]
#[inline (always)] pub fn ude (& mut self) -> UdeW < '_ , DierSpec > { UdeW :: new (self , 8) }
#[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
#[inline (always)] pub fn cc1de (& mut self) -> Cc1deW < '_ , DierSpec > { Cc1deW :: new (self , 9) } }
#[doc = "DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DierSpec ; impl crate :: RegisterSpec for DierSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dier::R`](R) reader structure"] impl crate :: Readable for DierSpec { }
#[doc = "`write(|w| ..)` method takes [`dier::W`](W) writer structure"] impl crate :: Writable for DierSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIER to value 0"] impl crate :: Resettable for DierSpec { } }
#[doc = "SR (rw) register accessor: status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `UIF` reader - Update interrupt flag"] pub type UifR = crate :: BitReader ;
#[doc = "Field `UIF` writer - Update interrupt flag"] pub type UifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1IF` reader - Capture/compare 1 interrupt flag"] pub type Cc1ifR = crate :: BitReader ;
#[doc = "Field `CC1IF` writer - Capture/compare 1 interrupt flag"] pub type Cc1ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMIF` reader - COM interrupt flag"] pub type ComifR = crate :: BitReader ;
#[doc = "Field `COMIF` writer - COM interrupt flag"] pub type ComifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BIF` reader - Break interrupt flag"] pub type BifR = crate :: BitReader ;
#[doc = "Field `BIF` writer - Break interrupt flag"] pub type BifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1OF` reader - Capture/Compare 1 overcapture flag"] pub type Cc1ofR = crate :: BitReader ;
#[doc = "Field `CC1OF` writer - Capture/Compare 1 overcapture flag"] pub type Cc1ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& self) -> UifR { UifR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
#[inline (always)] pub fn cc1if (& self) -> Cc1ifR { Cc1ifR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 5 - COM interrupt flag"]
#[inline (always)] pub fn comif (& self) -> ComifR { ComifR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 7 - Break interrupt flag"]
#[inline (always)] pub fn bif (& self) -> BifR { BifR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
#[inline (always)] pub fn cc1of (& self) -> Cc1ofR { Cc1ofR :: new (((self . bits >> 9) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& mut self) -> UifW < '_ , SrSpec > { UifW :: new (self , 0) }
#[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
#[inline (always)] pub fn cc1if (& mut self) -> Cc1ifW < '_ , SrSpec > { Cc1ifW :: new (self , 1) }
#[doc = "Bit 5 - COM interrupt flag"]
#[inline (always)] pub fn comif (& mut self) -> ComifW < '_ , SrSpec > { ComifW :: new (self , 5) }
#[doc = "Bit 7 - Break interrupt flag"]
#[inline (always)] pub fn bif (& mut self) -> BifW < '_ , SrSpec > { BifW :: new (self , 7) }
#[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
#[inline (always)] pub fn cc1of (& mut self) -> Cc1ofW < '_ , SrSpec > { Cc1ofW :: new (self , 9) } }
#[doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "EGR (w) register accessor: event generation register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@egr`] module"]
#[doc (alias = "EGR")] pub type Egr = crate :: Reg < egr :: EgrSpec > ;
#[doc = "event generation register"] pub mod egr {
#[doc = "Register `EGR` writer"] pub type W = crate :: W < EgrSpec > ;
#[doc = "Field `UG` writer - Update generation"] pub type UgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1G` writer - Capture/compare 1 generation"] pub type Cc1gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMG` writer - Capture/Compare control update generation"] pub type ComgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BG` writer - Break generation"] pub type BgW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Update generation"]
#[inline (always)] pub fn ug (& mut self) -> UgW < '_ , EgrSpec > { UgW :: new (self , 0) }
#[doc = "Bit 1 - Capture/compare 1 generation"]
#[inline (always)] pub fn cc1g (& mut self) -> Cc1gW < '_ , EgrSpec > { Cc1gW :: new (self , 1) }
#[doc = "Bit 5 - Capture/Compare control update generation"]
#[inline (always)] pub fn comg (& mut self) -> ComgW < '_ , EgrSpec > { ComgW :: new (self , 5) }
#[doc = "Bit 7 - Break generation"]
#[inline (always)] pub fn bg (& mut self) -> BgW < '_ , EgrSpec > { BgW :: new (self , 7) } }
#[doc = "event generation register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct EgrSpec ; impl crate :: RegisterSpec for EgrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`egr::W`](W) writer structure"] impl crate :: Writable for EgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EGR to value 0"] impl crate :: Resettable for EgrSpec { } }
#[doc = "CCMR1_Output (rw) register accessor: capture/compare mode register (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_output::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_output::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr1_output`] module"]
#[doc (alias = "CCMR1_Output")] pub type Ccmr1Output = crate :: Reg < ccmr1_output :: Ccmr1OutputSpec > ;
#[doc = "capture/compare mode register (output mode)"] pub mod ccmr1_output {
#[doc = "Register `CCMR1_Output` reader"] pub type R = crate :: R < Ccmr1OutputSpec > ;
#[doc = "Register `CCMR1_Output` writer"] pub type W = crate :: W < Ccmr1OutputSpec > ;
#[doc = "Field `CC1S` reader - Capture/Compare 1 selection"] pub type Cc1sR = crate :: FieldReader ;
#[doc = "Field `CC1S` writer - Capture/Compare 1 selection"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC1FE` reader - Output Compare 1 fast enable"] pub type Oc1feR = crate :: BitReader ;
#[doc = "Field `OC1FE` writer - Output Compare 1 fast enable"] pub type Oc1feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1PE` reader - Output Compare 1 preload enable"] pub type Oc1peR = crate :: BitReader ;
#[doc = "Field `OC1PE` writer - Output Compare 1 preload enable"] pub type Oc1peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1M` reader - Output Compare 1 mode"] pub type Oc1mR = crate :: FieldReader ;
#[doc = "Field `OC1M` writer - Output Compare 1 mode"] pub type Oc1mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC1M_3` reader - Output Compare 1 mode"] pub type Oc1m3R = crate :: BitReader ;
#[doc = "Field `OC1M_3` writer - Output Compare 1 mode"] pub type Oc1m3W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) }
#[doc = "Bit 2 - Output Compare 1 fast enable"]
#[inline (always)] pub fn oc1fe (& self) -> Oc1feR { Oc1feR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Output Compare 1 preload enable"]
#[inline (always)] pub fn oc1pe (& self) -> Oc1peR { Oc1peR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Output Compare 1 mode"]
#[inline (always)] pub fn oc1m (& self) -> Oc1mR { Oc1mR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 16 - Output Compare 1 mode"]
#[inline (always)] pub fn oc1m_3 (& self) -> Oc1m3R { Oc1m3R :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& mut self) -> Cc1sW < '_ , Ccmr1OutputSpec > { Cc1sW :: new (self , 0) }
#[doc = "Bit 2 - Output Compare 1 fast enable"]
#[inline (always)] pub fn oc1fe (& mut self) -> Oc1feW < '_ , Ccmr1OutputSpec > { Oc1feW :: new (self , 2) }
#[doc = "Bit 3 - Output Compare 1 preload enable"]
#[inline (always)] pub fn oc1pe (& mut self) -> Oc1peW < '_ , Ccmr1OutputSpec > { Oc1peW :: new (self , 3) }
#[doc = "Bits 4:6 - Output Compare 1 mode"]
#[inline (always)] pub fn oc1m (& mut self) -> Oc1mW < '_ , Ccmr1OutputSpec > { Oc1mW :: new (self , 4) }
#[doc = "Bit 16 - Output Compare 1 mode"]
#[inline (always)] pub fn oc1m_3 (& mut self) -> Oc1m3W < '_ , Ccmr1OutputSpec > { Oc1m3W :: new (self , 16) } }
#[doc = "capture/compare mode register (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_output::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_output::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1OutputSpec ; impl crate :: RegisterSpec for Ccmr1OutputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr1_output::R`](R) reader structure"] impl crate :: Readable for Ccmr1OutputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr1_output::W`](W) writer structure"] impl crate :: Writable for Ccmr1OutputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR1_Output to value 0"] impl crate :: Resettable for Ccmr1OutputSpec { } }
#[doc = "CCMR1_Input (rw) register accessor: capture/compare mode register 1 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr1_input`] module"]
#[doc (alias = "CCMR1_Input")] pub type Ccmr1Input = crate :: Reg < ccmr1_input :: Ccmr1InputSpec > ;
#[doc = "capture/compare mode register 1 (input mode)"] pub mod ccmr1_input {
#[doc = "Register `CCMR1_Input` reader"] pub type R = crate :: R < Ccmr1InputSpec > ;
#[doc = "Register `CCMR1_Input` writer"] pub type W = crate :: W < Ccmr1InputSpec > ;
#[doc = "Field `CC1S` reader - Capture/Compare 1 selection"] pub type Cc1sR = crate :: FieldReader ;
#[doc = "Field `CC1S` writer - Capture/Compare 1 selection"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC1PSC` reader - Input capture 1 prescaler"] pub type Ic1pscR = crate :: FieldReader ;
#[doc = "Field `IC1PSC` writer - Input capture 1 prescaler"] pub type Ic1pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC1F` reader - Input capture 1 filter"] pub type Ic1fR = crate :: FieldReader ;
#[doc = "Field `IC1F` writer - Input capture 1 filter"] pub type Ic1fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Input capture 1 prescaler"]
#[inline (always)] pub fn ic1psc (& self) -> Ic1pscR { Ic1pscR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:7 - Input capture 1 filter"]
#[inline (always)] pub fn ic1f (& self) -> Ic1fR { Ic1fR :: new (((self . bits >> 4) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& mut self) -> Cc1sW < '_ , Ccmr1InputSpec > { Cc1sW :: new (self , 0) }
#[doc = "Bits 2:3 - Input capture 1 prescaler"]
#[inline (always)] pub fn ic1psc (& mut self) -> Ic1pscW < '_ , Ccmr1InputSpec > { Ic1pscW :: new (self , 2) }
#[doc = "Bits 4:7 - Input capture 1 filter"]
#[inline (always)] pub fn ic1f (& mut self) -> Ic1fW < '_ , Ccmr1InputSpec > { Ic1fW :: new (self , 4) } }
#[doc = "capture/compare mode register 1 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1InputSpec ; impl crate :: RegisterSpec for Ccmr1InputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr1_input::R`](R) reader structure"] impl crate :: Readable for Ccmr1InputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr1_input::W`](W) writer structure"] impl crate :: Writable for Ccmr1InputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR1_Input to value 0"] impl crate :: Resettable for Ccmr1InputSpec { } }
#[doc = "CCER (rw) register accessor: capture/compare enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccer::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccer::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccer`] module"]
#[doc (alias = "CCER")] pub type Ccer = crate :: Reg < ccer :: CcerSpec > ;
#[doc = "capture/compare enable register"] pub mod ccer {
#[doc = "Register `CCER` reader"] pub type R = crate :: R < CcerSpec > ;
#[doc = "Register `CCER` writer"] pub type W = crate :: W < CcerSpec > ;
#[doc = "Field `CC1E` reader - Capture/Compare 1 output enable"] pub type Cc1eR = crate :: BitReader ;
#[doc = "Field `CC1E` writer - Capture/Compare 1 output enable"] pub type Cc1eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1P` reader - Capture/Compare 1 output Polarity"] pub type Cc1pR = crate :: BitReader ;
#[doc = "Field `CC1P` writer - Capture/Compare 1 output Polarity"] pub type Cc1pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1NE` reader - Capture/Compare 1 complementary output enable"] pub type Cc1neR = crate :: BitReader ;
#[doc = "Field `CC1NE` writer - Capture/Compare 1 complementary output enable"] pub type Cc1neW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1NP` reader - Capture/Compare 1 output Polarity"] pub type Cc1npR = crate :: BitReader ;
#[doc = "Field `CC1NP` writer - Capture/Compare 1 output Polarity"] pub type Cc1npW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Capture/Compare 1 output enable"]
#[inline (always)] pub fn cc1e (& self) -> Cc1eR { Cc1eR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1p (& self) -> Cc1pR { Cc1pR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
#[inline (always)] pub fn cc1ne (& self) -> Cc1neR { Cc1neR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1np (& self) -> Cc1npR { Cc1npR :: new (((self . bits >> 3) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Capture/Compare 1 output enable"]
#[inline (always)] pub fn cc1e (& mut self) -> Cc1eW < '_ , CcerSpec > { Cc1eW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1p (& mut self) -> Cc1pW < '_ , CcerSpec > { Cc1pW :: new (self , 1) }
#[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
#[inline (always)] pub fn cc1ne (& mut self) -> Cc1neW < '_ , CcerSpec > { Cc1neW :: new (self , 2) }
#[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1np (& mut self) -> Cc1npW < '_ , CcerSpec > { Cc1npW :: new (self , 3) } }
#[doc = "capture/compare enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccer::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccer::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CcerSpec ; impl crate :: RegisterSpec for CcerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccer::R`](R) reader structure"] impl crate :: Readable for CcerSpec { }
#[doc = "`write(|w| ..)` method takes [`ccer::W`](W) writer structure"] impl crate :: Writable for CcerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCER to value 0"] impl crate :: Resettable for CcerSpec { } }
#[doc = "CNT (rw) register accessor: counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt`] module"]
#[doc (alias = "CNT")] pub type Cnt = crate :: Reg < cnt :: CntSpec > ;
#[doc = "counter"] pub mod cnt {
#[doc = "Register `CNT` reader"] pub type R = crate :: R < CntSpec > ;
#[doc = "Register `CNT` writer"] pub type W = crate :: W < CntSpec > ;
#[doc = "Field `CNT` reader - counter value"] pub type CntR = crate :: FieldReader < u16 > ;
#[doc = "Field `CNT` writer - counter value"] pub type CntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `UIFCPY` reader - UIF Copy"] pub type UifcpyR = crate :: BitReader ; impl R {
#[doc = "Bits 0:15 - counter value"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bit 31 - UIF Copy"]
#[inline (always)] pub fn uifcpy (& self) -> UifcpyR { UifcpyR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:15 - counter value"]
#[inline (always)] pub fn cnt (& mut self) -> CntW < '_ , CntSpec > { CntW :: new (self , 0) } }
#[doc = "counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CntSpec ; impl crate :: RegisterSpec for CntSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cnt::R`](R) reader structure"] impl crate :: Readable for CntSpec { }
#[doc = "`write(|w| ..)` method takes [`cnt::W`](W) writer structure"] impl crate :: Writable for CntSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNT to value 0"] impl crate :: Resettable for CntSpec { } }
#[doc = "PSC (rw) register accessor: prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@psc`] module"]
#[doc (alias = "PSC")] pub type Psc = crate :: Reg < psc :: PscSpec > ;
#[doc = "prescaler"] pub mod psc {
#[doc = "Register `PSC` reader"] pub type R = crate :: R < PscSpec > ;
#[doc = "Register `PSC` writer"] pub type W = crate :: W < PscSpec > ;
#[doc = "Field `PSC` reader - Prescaler value"] pub type PscR = crate :: FieldReader < u16 > ;
#[doc = "Field `PSC` writer - Prescaler value"] pub type PscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& self) -> PscR { PscR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& mut self) -> PscW < '_ , PscSpec > { PscW :: new (self , 0) } }
#[doc = "prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PscSpec ; impl crate :: RegisterSpec for PscSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`psc::R`](R) reader structure"] impl crate :: Readable for PscSpec { }
#[doc = "`write(|w| ..)` method takes [`psc::W`](W) writer structure"] impl crate :: Writable for PscSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PSC to value 0"] impl crate :: Resettable for PscSpec { } }
#[doc = "ARR (rw) register accessor: auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@arr`] module"]
#[doc (alias = "ARR")] pub type Arr = crate :: Reg < arr :: ArrSpec > ;
#[doc = "auto-reload register"] pub mod arr {
#[doc = "Register `ARR` reader"] pub type R = crate :: R < ArrSpec > ;
#[doc = "Register `ARR` writer"] pub type W = crate :: W < ArrSpec > ;
#[doc = "Field `ARR` reader - Auto-reload value"] pub type ArrR = crate :: FieldReader < u16 > ;
#[doc = "Field `ARR` writer - Auto-reload value"] pub type ArrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Auto-reload value"]
#[inline (always)] pub fn arr (& self) -> ArrR { ArrR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Auto-reload value"]
#[inline (always)] pub fn arr (& mut self) -> ArrW < '_ , ArrSpec > { ArrW :: new (self , 0) } }
#[doc = "auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ArrSpec ; impl crate :: RegisterSpec for ArrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`arr::R`](R) reader structure"] impl crate :: Readable for ArrSpec { }
#[doc = "`write(|w| ..)` method takes [`arr::W`](W) writer structure"] impl crate :: Writable for ArrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ARR to value 0xffff"] impl crate :: Resettable for ArrSpec { const RESET_VALUE : u32 = 0xffff ; } }
#[doc = "RCR (rw) register accessor: repetition counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`rcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rcr`] module"]
#[doc (alias = "RCR")] pub type Rcr = crate :: Reg < rcr :: RcrSpec > ;
#[doc = "repetition counter register"] pub mod rcr {
#[doc = "Register `RCR` reader"] pub type R = crate :: R < RcrSpec > ;
#[doc = "Register `RCR` writer"] pub type W = crate :: W < RcrSpec > ;
#[doc = "Field `REP` reader - Repetition counter value"] pub type RepR = crate :: FieldReader ;
#[doc = "Field `REP` writer - Repetition counter value"] pub type RepW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - Repetition counter value"]
#[inline (always)] pub fn rep (& self) -> RepR { RepR :: new ((self . bits & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - Repetition counter value"]
#[inline (always)] pub fn rep (& mut self) -> RepW < '_ , RcrSpec > { RepW :: new (self , 0) } }
#[doc = "repetition counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`rcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RcrSpec ; impl crate :: RegisterSpec for RcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rcr::R`](R) reader structure"] impl crate :: Readable for RcrSpec { }
#[doc = "`write(|w| ..)` method takes [`rcr::W`](W) writer structure"] impl crate :: Writable for RcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RCR to value 0"] impl crate :: Resettable for RcrSpec { } }
#[doc = "CCR1 (rw) register accessor: capture/compare register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr1`] module"]
#[doc (alias = "CCR1")] pub type Ccr1 = crate :: Reg < ccr1 :: Ccr1Spec > ;
#[doc = "capture/compare register 1"] pub mod ccr1 {
#[doc = "Register `CCR1` reader"] pub type R = crate :: R < Ccr1Spec > ;
#[doc = "Register `CCR1` writer"] pub type W = crate :: W < Ccr1Spec > ;
#[doc = "Field `CCR1` reader - Capture/Compare 1 value"] pub type Ccr1R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR1` writer - Capture/Compare 1 value"] pub type Ccr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare 1 value"]
#[inline (always)] pub fn ccr1 (& self) -> Ccr1R { Ccr1R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare 1 value"]
#[inline (always)] pub fn ccr1 (& mut self) -> Ccr1W < '_ , Ccr1Spec > { Ccr1W :: new (self , 0) } }
#[doc = "capture/compare register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr1Spec ; impl crate :: RegisterSpec for Ccr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr1::R`](R) reader structure"] impl crate :: Readable for Ccr1Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr1::W`](W) writer structure"] impl crate :: Writable for Ccr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR1 to value 0"] impl crate :: Resettable for Ccr1Spec { } }
#[doc = "BDTR (rw) register accessor: break and dead-time register\n\nYou can [`read`](crate::Reg::read) this register and get [`bdtr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bdtr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bdtr`] module"]
#[doc (alias = "BDTR")] pub type Bdtr = crate :: Reg < bdtr :: BdtrSpec > ;
#[doc = "break and dead-time register"] pub mod bdtr {
#[doc = "Register `BDTR` reader"] pub type R = crate :: R < BdtrSpec > ;
#[doc = "Register `BDTR` writer"] pub type W = crate :: W < BdtrSpec > ;
#[doc = "Field `DTG` reader - Dead-time generator setup"] pub type DtgR = crate :: FieldReader ;
#[doc = "Field `DTG` writer - Dead-time generator setup"] pub type DtgW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `LOCK` reader - Lock configuration"] pub type LockR = crate :: FieldReader ;
#[doc = "Field `LOCK` writer - Lock configuration"] pub type LockW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSSI` reader - Off-state selection for Idle mode"] pub type OssiR = crate :: BitReader ;
#[doc = "Field `OSSI` writer - Off-state selection for Idle mode"] pub type OssiW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OSSR` reader - Off-state selection for Run mode"] pub type OssrR = crate :: BitReader ;
#[doc = "Field `OSSR` writer - Off-state selection for Run mode"] pub type OssrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKE` reader - Break enable"] pub type BkeR = crate :: BitReader ;
#[doc = "Field `BKE` writer - Break enable"] pub type BkeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKP` reader - Break polarity"] pub type BkpR = crate :: BitReader ;
#[doc = "Field `BKP` writer - Break polarity"] pub type BkpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AOE` reader - Automatic output enable"] pub type AoeR = crate :: BitReader ;
#[doc = "Field `AOE` writer - Automatic output enable"] pub type AoeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MOE` reader - Main output enable"] pub type MoeR = crate :: BitReader ;
#[doc = "Field `MOE` writer - Main output enable"] pub type MoeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKDSRM` reader - Break Disarm"] pub type BkdsrmR = crate :: BitReader ;
#[doc = "Field `BKDSRM` writer - Break Disarm"] pub type BkdsrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKBID` reader - Break Bidirectional"] pub type BkbidR = crate :: BitReader ;
#[doc = "Field `BKBID` writer - Break Bidirectional"] pub type BkbidW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Dead-time generator setup"]
#[inline (always)] pub fn dtg (& self) -> DtgR { DtgR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:9 - Lock configuration"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 10 - Off-state selection for Idle mode"]
#[inline (always)] pub fn ossi (& self) -> OssiR { OssiR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Off-state selection for Run mode"]
#[inline (always)] pub fn ossr (& self) -> OssrR { OssrR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Break enable"]
#[inline (always)] pub fn bke (& self) -> BkeR { BkeR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Break polarity"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Automatic output enable"]
#[inline (always)] pub fn aoe (& self) -> AoeR { AoeR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Main output enable"]
#[inline (always)] pub fn moe (& self) -> MoeR { MoeR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 26 - Break Disarm"]
#[inline (always)] pub fn bkdsrm (& self) -> BkdsrmR { BkdsrmR :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 28 - Break Bidirectional"]
#[inline (always)] pub fn bkbid (& self) -> BkbidR { BkbidR :: new (((self . bits >> 28) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Dead-time generator setup"]
#[inline (always)] pub fn dtg (& mut self) -> DtgW < '_ , BdtrSpec > { DtgW :: new (self , 0) }
#[doc = "Bits 8:9 - Lock configuration"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , BdtrSpec > { LockW :: new (self , 8) }
#[doc = "Bit 10 - Off-state selection for Idle mode"]
#[inline (always)] pub fn ossi (& mut self) -> OssiW < '_ , BdtrSpec > { OssiW :: new (self , 10) }
#[doc = "Bit 11 - Off-state selection for Run mode"]
#[inline (always)] pub fn ossr (& mut self) -> OssrW < '_ , BdtrSpec > { OssrW :: new (self , 11) }
#[doc = "Bit 12 - Break enable"]
#[inline (always)] pub fn bke (& mut self) -> BkeW < '_ , BdtrSpec > { BkeW :: new (self , 12) }
#[doc = "Bit 13 - Break polarity"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , BdtrSpec > { BkpW :: new (self , 13) }
#[doc = "Bit 14 - Automatic output enable"]
#[inline (always)] pub fn aoe (& mut self) -> AoeW < '_ , BdtrSpec > { AoeW :: new (self , 14) }
#[doc = "Bit 15 - Main output enable"]
#[inline (always)] pub fn moe (& mut self) -> MoeW < '_ , BdtrSpec > { MoeW :: new (self , 15) }
#[doc = "Bit 26 - Break Disarm"]
#[inline (always)] pub fn bkdsrm (& mut self) -> BkdsrmW < '_ , BdtrSpec > { BkdsrmW :: new (self , 26) }
#[doc = "Bit 28 - Break Bidirectional"]
#[inline (always)] pub fn bkbid (& mut self) -> BkbidW < '_ , BdtrSpec > { BkbidW :: new (self , 28) } }
#[doc = "break and dead-time register\n\nYou can [`read`](crate::Reg::read) this register and get [`bdtr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bdtr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BdtrSpec ; impl crate :: RegisterSpec for BdtrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bdtr::R`](R) reader structure"] impl crate :: Readable for BdtrSpec { }
#[doc = "`write(|w| ..)` method takes [`bdtr::W`](W) writer structure"] impl crate :: Writable for BdtrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BDTR to value 0"] impl crate :: Resettable for BdtrSpec { } }
#[doc = "DCR (rw) register accessor: DMA control register\n\nYou can [`read`](crate::Reg::read) this register and get [`dcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dcr`] module"]
#[doc (alias = "DCR")] pub type Dcr = crate :: Reg < dcr :: DcrSpec > ;
#[doc = "DMA control register"] pub mod dcr {
#[doc = "Register `DCR` reader"] pub type R = crate :: R < DcrSpec > ;
#[doc = "Register `DCR` writer"] pub type W = crate :: W < DcrSpec > ;
#[doc = "Field `DBA` reader - DMA base address"] pub type DbaR = crate :: FieldReader ;
#[doc = "Field `DBA` writer - DMA base address"] pub type DbaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `DBL` reader - DMA burst length"] pub type DblR = crate :: FieldReader ;
#[doc = "Field `DBL` writer - DMA burst length"] pub type DblW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:4 - DMA base address"]
#[inline (always)] pub fn dba (& self) -> DbaR { DbaR :: new ((self . bits & 0x1f) as u8) }
#[doc = "Bits 8:12 - DMA burst length"]
#[inline (always)] pub fn dbl (& self) -> DblR { DblR :: new (((self . bits >> 8) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:4 - DMA base address"]
#[inline (always)] pub fn dba (& mut self) -> DbaW < '_ , DcrSpec > { DbaW :: new (self , 0) }
#[doc = "Bits 8:12 - DMA burst length"]
#[inline (always)] pub fn dbl (& mut self) -> DblW < '_ , DcrSpec > { DblW :: new (self , 8) } }
#[doc = "DMA control register\n\nYou can [`read`](crate::Reg::read) this register and get [`dcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DcrSpec ; impl crate :: RegisterSpec for DcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dcr::R`](R) reader structure"] impl crate :: Readable for DcrSpec { }
#[doc = "`write(|w| ..)` method takes [`dcr::W`](W) writer structure"] impl crate :: Writable for DcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DCR to value 0"] impl crate :: Resettable for DcrSpec { } }
#[doc = "DMAR (rw) register accessor: DMA address for full transfer\n\nYou can [`read`](crate::Reg::read) this register and get [`dmar::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmar::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dmar`] module"]
#[doc (alias = "DMAR")] pub type Dmar = crate :: Reg < dmar :: DmarSpec > ;
#[doc = "DMA address for full transfer"] pub mod dmar {
#[doc = "Register `DMAR` reader"] pub type R = crate :: R < DmarSpec > ;
#[doc = "Register `DMAR` writer"] pub type W = crate :: W < DmarSpec > ;
#[doc = "Field `DMAB` reader - DMA register for burst accesses"] pub type DmabR = crate :: FieldReader < u16 > ;
#[doc = "Field `DMAB` writer - DMA register for burst accesses"] pub type DmabW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - DMA register for burst accesses"]
#[inline (always)] pub fn dmab (& self) -> DmabR { DmabR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - DMA register for burst accesses"]
#[inline (always)] pub fn dmab (& mut self) -> DmabW < '_ , DmarSpec > { DmabW :: new (self , 0) } }
#[doc = "DMA address for full transfer\n\nYou can [`read`](crate::Reg::read) this register and get [`dmar::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmar::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DmarSpec ; impl crate :: RegisterSpec for DmarSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dmar::R`](R) reader structure"] impl crate :: Readable for DmarSpec { }
#[doc = "`write(|w| ..)` method takes [`dmar::W`](W) writer structure"] impl crate :: Writable for DmarSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMAR to value 0"] impl crate :: Resettable for DmarSpec { } }
#[doc = "OR1 (rw) register accessor: TIM option register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`or1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`or1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@or1`] module"]
#[doc (alias = "OR1")] pub type Or1 = crate :: Reg < or1 :: Or1Spec > ;
#[doc = "TIM option register 1"] pub mod or1 {
#[doc = "Register `OR1` reader"] pub type R = crate :: R < Or1Spec > ;
#[doc = "Register `OR1` writer"] pub type W = crate :: W < Or1Spec > ;
#[doc = "Field `TI1_RMP` reader - Input capture 1 remap"] pub type Ti1RmpR = crate :: FieldReader ;
#[doc = "Field `TI1_RMP` writer - Input capture 1 remap"] pub type Ti1RmpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:1 - Input capture 1 remap"]
#[inline (always)] pub fn ti1_rmp (& self) -> Ti1RmpR { Ti1RmpR :: new ((self . bits & 3) as u8) } } impl W {
#[doc = "Bits 0:1 - Input capture 1 remap"]
#[inline (always)] pub fn ti1_rmp (& mut self) -> Ti1RmpW < '_ , Or1Spec > { Ti1RmpW :: new (self , 0) } }
#[doc = "TIM option register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`or1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`or1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Or1Spec ; impl crate :: RegisterSpec for Or1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`or1::R`](R) reader structure"] impl crate :: Readable for Or1Spec { }
#[doc = "`write(|w| ..)` method takes [`or1::W`](W) writer structure"] impl crate :: Writable for Or1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OR1 to value 0"] impl crate :: Resettable for Or1Spec { } }
#[doc = "AF1 (rw) register accessor: alternate function register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`af1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`af1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@af1`] module"]
#[doc (alias = "AF1")] pub type Af1 = crate :: Reg < af1 :: Af1Spec > ;
#[doc = "alternate function register 1"] pub mod af1 {
#[doc = "Register `AF1` reader"] pub type R = crate :: R < Af1Spec > ;
#[doc = "Register `AF1` writer"] pub type W = crate :: W < Af1Spec > ;
#[doc = "Field `BKINE` reader - BRK BKIN input enable"] pub type BkineR = crate :: BitReader ;
#[doc = "Field `BKINE` writer - BRK BKIN input enable"] pub type BkineW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKCMP1E` reader - BRK COMP1 enable"] pub type Bkcmp1eR = crate :: BitReader ;
#[doc = "Field `BKCMP1E` writer - BRK COMP1 enable"] pub type Bkcmp1eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKCMP2E` reader - BRK COMP2 enable"] pub type Bkcmp2eR = crate :: BitReader ;
#[doc = "Field `BKCMP2E` writer - BRK COMP2 enable"] pub type Bkcmp2eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKINP` reader - BRK BKIN input polarity"] pub type BkinpR = crate :: BitReader ;
#[doc = "Field `BKINP` writer - BRK BKIN input polarity"] pub type BkinpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKCMP1P` reader - BRK COMP1 input polarity"] pub type Bkcmp1pR = crate :: BitReader ;
#[doc = "Field `BKCMP1P` writer - BRK COMP1 input polarity"] pub type Bkcmp1pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKCMP2P` reader - BRK COMP2 input polarit"] pub type Bkcmp2pR = crate :: BitReader ;
#[doc = "Field `BKCMP2P` writer - BRK COMP2 input polarit"] pub type Bkcmp2pW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - BRK BKIN input enable"]
#[inline (always)] pub fn bkine (& self) -> BkineR { BkineR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - BRK COMP1 enable"]
#[inline (always)] pub fn bkcmp1e (& self) -> Bkcmp1eR { Bkcmp1eR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - BRK COMP2 enable"]
#[inline (always)] pub fn bkcmp2e (& self) -> Bkcmp2eR { Bkcmp2eR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 9 - BRK BKIN input polarity"]
#[inline (always)] pub fn bkinp (& self) -> BkinpR { BkinpR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - BRK COMP1 input polarity"]
#[inline (always)] pub fn bkcmp1p (& self) -> Bkcmp1pR { Bkcmp1pR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - BRK COMP2 input polarit"]
#[inline (always)] pub fn bkcmp2p (& self) -> Bkcmp2pR { Bkcmp2pR :: new (((self . bits >> 11) & 1) != 0) } } impl W {
#[doc = "Bit 0 - BRK BKIN input enable"]
#[inline (always)] pub fn bkine (& mut self) -> BkineW < '_ , Af1Spec > { BkineW :: new (self , 0) }
#[doc = "Bit 1 - BRK COMP1 enable"]
#[inline (always)] pub fn bkcmp1e (& mut self) -> Bkcmp1eW < '_ , Af1Spec > { Bkcmp1eW :: new (self , 1) }
#[doc = "Bit 2 - BRK COMP2 enable"]
#[inline (always)] pub fn bkcmp2e (& mut self) -> Bkcmp2eW < '_ , Af1Spec > { Bkcmp2eW :: new (self , 2) }
#[doc = "Bit 9 - BRK BKIN input polarity"]
#[inline (always)] pub fn bkinp (& mut self) -> BkinpW < '_ , Af1Spec > { BkinpW :: new (self , 9) }
#[doc = "Bit 10 - BRK COMP1 input polarity"]
#[inline (always)] pub fn bkcmp1p (& mut self) -> Bkcmp1pW < '_ , Af1Spec > { Bkcmp1pW :: new (self , 10) }
#[doc = "Bit 11 - BRK COMP2 input polarit"]
#[inline (always)] pub fn bkcmp2p (& mut self) -> Bkcmp2pW < '_ , Af1Spec > { Bkcmp2pW :: new (self , 11) } }
#[doc = "alternate function register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`af1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`af1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Af1Spec ; impl crate :: RegisterSpec for Af1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`af1::R`](R) reader structure"] impl crate :: Readable for Af1Spec { }
#[doc = "`write(|w| ..)` method takes [`af1::W`](W) writer structure"] impl crate :: Writable for Af1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AF1 to value 0x01"] impl crate :: Resettable for Af1Spec { const RESET_VALUE : u32 = 0x01 ; } }
#[doc = "TISEL (rw) register accessor: input selection register\n\nYou can [`read`](crate::Reg::read) this register and get [`tisel::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tisel::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tisel`] module"]
#[doc (alias = "TISEL")] pub type Tisel = crate :: Reg < tisel :: TiselSpec > ;
#[doc = "input selection register"] pub mod tisel {
#[doc = "Register `TISEL` reader"] pub type R = crate :: R < TiselSpec > ;
#[doc = "Register `TISEL` writer"] pub type W = crate :: W < TiselSpec > ;
#[doc = "Field `TI1SEL` reader - selects TI1\\[0\\] to TI1\\[15\\] input"] pub type Ti1selR = crate :: FieldReader ;
#[doc = "Field `TI1SEL` writer - selects TI1\\[0\\] to TI1\\[15\\] input"] pub type Ti1selW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - selects TI1\\[0\\] to TI1\\[15\\] input"]
#[inline (always)] pub fn ti1sel (& self) -> Ti1selR { Ti1selR :: new ((self . bits & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - selects TI1\\[0\\] to TI1\\[15\\] input"]
#[inline (always)] pub fn ti1sel (& mut self) -> Ti1selW < '_ , TiselSpec > { Ti1selW :: new (self , 0) } }
#[doc = "input selection register\n\nYou can [`read`](crate::Reg::read) this register and get [`tisel::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tisel::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TiselSpec ; impl crate :: RegisterSpec for TiselSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`tisel::R`](R) reader structure"] impl crate :: Readable for TiselSpec { }
#[doc = "`write(|w| ..)` method takes [`tisel::W`](W) writer structure"] impl crate :: Writable for TiselSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets TISEL to value 0"] impl crate :: Resettable for TiselSpec { } } }
#[doc = "Advanced-timers"] pub type Tim1 = crate :: Periph < tim1 :: RegisterBlock , 0x4001_2c00 > ; impl core :: fmt :: Debug for Tim1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim1") . finish () } }
#[doc = "Advanced-timers"] pub mod tim1 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr1 : Cr1 , cr2 : Cr2 , smcr : Smcr , dier : Dier , sr : Sr , egr : Egr , _reserved_6_ccmr1 : [u8 ; 0x04] , _reserved_7_ccmr2 : [u8 ; 0x04] , ccer : Ccer , cnt : Cnt , psc : Psc , arr : Arr , rcr : Rcr , ccr1 : Ccr1 , ccr2 : Ccr2 , ccr3 : Ccr3 , ccr4 : Ccr4 , bdtr : Bdtr , dcr : Dcr , dmar : Dmar , or : Or , ccmr3_output : Ccmr3Output , ccr5 : Ccr5 , ccr6 : Ccr6 , af1 : Af1 , af2 : Af2 , } impl RegisterBlock {
#[doc = "0x00 - control register 1"]
#[inline (always)] pub const fn cr1 (& self) -> & Cr1 { & self . cr1 }
#[doc = "0x04 - control register 2"]
#[inline (always)] pub const fn cr2 (& self) -> & Cr2 { & self . cr2 }
#[doc = "0x08 - slave mode control register"]
#[inline (always)] pub const fn smcr (& self) -> & Smcr { & self . smcr }
#[doc = "0x0c - DMA/Interrupt enable register"]
#[inline (always)] pub const fn dier (& self) -> & Dier { & self . dier }
#[doc = "0x10 - status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x14 - event generation register"]
#[inline (always)] pub const fn egr (& self) -> & Egr { & self . egr }
#[doc = "0x18 - capture/compare mode register 1 (output mode)"]
#[inline (always)] pub const fn ccmr1_output (& self) -> & Ccmr1Output { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x18 - capture/compare mode register 1 (output mode)"]
#[inline (always)] pub const fn ccmr1_input (& self) -> & Ccmr1Input { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x1c - capture/compare mode register 2 (output mode)"]
#[inline (always)] pub const fn ccmr2_input (& self) -> & Ccmr2Input { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (28) . cast () } }
#[doc = "0x1c - capture/compare mode register 2 (output mode)"]
#[inline (always)] pub const fn ccmr2_output (& self) -> & Ccmr2Output { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (28) . cast () } }
#[doc = "0x20 - capture/compare enable register"]
#[inline (always)] pub const fn ccer (& self) -> & Ccer { & self . ccer }
#[doc = "0x24 - counter"]
#[inline (always)] pub const fn cnt (& self) -> & Cnt { & self . cnt }
#[doc = "0x28 - prescaler"]
#[inline (always)] pub const fn psc (& self) -> & Psc { & self . psc }
#[doc = "0x2c - auto-reload register"]
#[inline (always)] pub const fn arr (& self) -> & Arr { & self . arr }
#[doc = "0x30 - repetition counter register"]
#[inline (always)] pub const fn rcr (& self) -> & Rcr { & self . rcr }
#[doc = "0x34 - capture/compare register 1"]
#[inline (always)] pub const fn ccr1 (& self) -> & Ccr1 { & self . ccr1 }
#[doc = "0x38 - capture/compare register 2"]
#[inline (always)] pub const fn ccr2 (& self) -> & Ccr2 { & self . ccr2 }
#[doc = "0x3c - capture/compare register 3"]
#[inline (always)] pub const fn ccr3 (& self) -> & Ccr3 { & self . ccr3 }
#[doc = "0x40 - capture/compare register 4"]
#[inline (always)] pub const fn ccr4 (& self) -> & Ccr4 { & self . ccr4 }
#[doc = "0x44 - break and dead-time register"]
#[inline (always)] pub const fn bdtr (& self) -> & Bdtr { & self . bdtr }
#[doc = "0x48 - DMA control register"]
#[inline (always)] pub const fn dcr (& self) -> & Dcr { & self . dcr }
#[doc = "0x4c - DMA address for full transfer"]
#[inline (always)] pub const fn dmar (& self) -> & Dmar { & self . dmar }
#[doc = "0x50 - DMA address for full transfer"]
#[inline (always)] pub const fn or (& self) -> & Or { & self . or }
#[doc = "0x54 - capture/compare mode register 2 (output mode)"]
#[inline (always)] pub const fn ccmr3_output (& self) -> & Ccmr3Output { & self . ccmr3_output }
#[doc = "0x58 - capture/compare register 4"]
#[inline (always)] pub const fn ccr5 (& self) -> & Ccr5 { & self . ccr5 }
#[doc = "0x5c - capture/compare register 4"]
#[inline (always)] pub const fn ccr6 (& self) -> & Ccr6 { & self . ccr6 }
#[doc = "0x60 - DMA address for full transfer"]
#[inline (always)] pub const fn af1 (& self) -> & Af1 { & self . af1 }
#[doc = "0x64 - DMA address for full transfer"]
#[inline (always)] pub const fn af2 (& self) -> & Af2 { & self . af2 } }
#[doc = "CR1 (rw) register accessor: control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
#[doc (alias = "CR1")] pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ;
#[doc = "control register 1"] pub mod cr1 {
#[doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ;
#[doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ;
#[doc = "Field `CEN` reader - Counter enable"] pub type CenR = crate :: BitReader ;
#[doc = "Field `CEN` writer - Counter enable"] pub type CenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDIS` reader - Update disable"] pub type UdisR = crate :: BitReader ;
#[doc = "Field `UDIS` writer - Update disable"] pub type UdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `URS` reader - Update request source"] pub type UrsR = crate :: BitReader ;
#[doc = "Field `URS` writer - Update request source"] pub type UrsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OPM` reader - One-pulse mode"] pub type OpmR = crate :: BitReader ;
#[doc = "Field `OPM` writer - One-pulse mode"] pub type OpmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CMS` reader - Center-aligned mode selection"] pub type CmsR = crate :: FieldReader ;
#[doc = "Field `CMS` writer - Center-aligned mode selection"] pub type CmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ARPE` reader - Auto-reload preload enable"] pub type ArpeR = crate :: BitReader ;
#[doc = "Field `ARPE` writer - Auto-reload preload enable"] pub type ArpeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CKD` reader - Clock division"] pub type CkdR = crate :: FieldReader ;
#[doc = "Field `CKD` writer - Clock division"] pub type CkdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UIFREMAP` reader - UIF status bit remapping"] pub type UifremapR = crate :: BitReader ;
#[doc = "Field `UIFREMAP` writer - UIF status bit remapping"] pub type UifremapW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& self) -> CenR { CenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& self) -> UdisR { UdisR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& self) -> UrsR { UrsR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - One-pulse mode"]
#[inline (always)] pub fn opm (& self) -> OpmR { OpmR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bits 5:6 - Center-aligned mode selection"]
#[inline (always)] pub fn cms (& self) -> CmsR { CmsR :: new (((self . bits >> 5) & 3) as u8) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& self) -> ArpeR { ArpeR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Clock division"]
#[inline (always)] pub fn ckd (& self) -> CkdR { CkdR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 11 - UIF status bit remapping"]
#[inline (always)] pub fn uifremap (& self) -> UifremapR { UifremapR :: new (((self . bits >> 11) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& mut self) -> CenW < '_ , Cr1Spec > { CenW :: new (self , 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& mut self) -> UdisW < '_ , Cr1Spec > { UdisW :: new (self , 1) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& mut self) -> UrsW < '_ , Cr1Spec > { UrsW :: new (self , 2) }
#[doc = "Bit 3 - One-pulse mode"]
#[inline (always)] pub fn opm (& mut self) -> OpmW < '_ , Cr1Spec > { OpmW :: new (self , 3) }
#[doc = "Bit 4 - Direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Cr1Spec > { DirW :: new (self , 4) }
#[doc = "Bits 5:6 - Center-aligned mode selection"]
#[inline (always)] pub fn cms (& mut self) -> CmsW < '_ , Cr1Spec > { CmsW :: new (self , 5) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& mut self) -> ArpeW < '_ , Cr1Spec > { ArpeW :: new (self , 7) }
#[doc = "Bits 8:9 - Clock division"]
#[inline (always)] pub fn ckd (& mut self) -> CkdW < '_ , Cr1Spec > { CkdW :: new (self , 8) }
#[doc = "Bit 11 - UIF status bit remapping"]
#[inline (always)] pub fn uifremap (& mut self) -> UifremapW < '_ , Cr1Spec > { UifremapW :: new (self , 11) } }
#[doc = "control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { } }
#[doc = "CR2 (rw) register accessor: control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`] module"]
#[doc (alias = "CR2")] pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ;
#[doc = "control register 2"] pub mod cr2 {
#[doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ;
#[doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ;
#[doc = "Field `CCPC` reader - Capture/compare preloaded control"] pub type CcpcR = crate :: BitReader ;
#[doc = "Field `CCPC` writer - Capture/compare preloaded control"] pub type CcpcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CCUS` reader - Capture/compare control update selection"] pub type CcusR = crate :: BitReader ;
#[doc = "Field `CCUS` writer - Capture/compare control update selection"] pub type CcusW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CCDS` reader - Capture/compare DMA selection"] pub type CcdsR = crate :: BitReader ;
#[doc = "Field `CCDS` writer - Capture/compare DMA selection"] pub type CcdsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MMS` reader - Master mode selection"] pub type MmsR = crate :: FieldReader ;
#[doc = "Field `MMS` writer - Master mode selection"] pub type MmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `TI1S` reader - TI1 selection"] pub type Ti1sR = crate :: BitReader ;
#[doc = "Field `TI1S` writer - TI1 selection"] pub type Ti1sW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS1` reader - Output Idle state 1"] pub type Ois1R = crate :: BitReader ;
#[doc = "Field `OIS1` writer - Output Idle state 1"] pub type Ois1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS1N` reader - Output Idle state 1"] pub type Ois1nR = crate :: BitReader ;
#[doc = "Field `OIS1N` writer - Output Idle state 1"] pub type Ois1nW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS2` reader - Output Idle state 2"] pub type Ois2R = crate :: BitReader ;
#[doc = "Field `OIS2` writer - Output Idle state 2"] pub type Ois2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS2N` reader - Output Idle state 2"] pub type Ois2nR = crate :: BitReader ;
#[doc = "Field `OIS2N` writer - Output Idle state 2"] pub type Ois2nW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS3` reader - Output Idle state 3"] pub type Ois3R = crate :: BitReader ;
#[doc = "Field `OIS3` writer - Output Idle state 3"] pub type Ois3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS3N` reader - Output Idle state 3"] pub type Ois3nR = crate :: BitReader ;
#[doc = "Field `OIS3N` writer - Output Idle state 3"] pub type Ois3nW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS4` reader - Output Idle state 4"] pub type Ois4R = crate :: BitReader ;
#[doc = "Field `OIS4` writer - Output Idle state 4"] pub type Ois4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS5` reader - Output Idle state 5 (OC5 output)"] pub type Ois5R = crate :: BitReader ;
#[doc = "Field `OIS5` writer - Output Idle state 5 (OC5 output)"] pub type Ois5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS6` reader - Output Idle state 6 (OC6 output)"] pub type Ois6R = crate :: BitReader ;
#[doc = "Field `OIS6` writer - Output Idle state 6 (OC6 output)"] pub type Ois6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MMS2` reader - Master mode selection 2"] pub type Mms2R = crate :: FieldReader ;
#[doc = "Field `MMS2` writer - Master mode selection 2"] pub type Mms2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bit 0 - Capture/compare preloaded control"]
#[inline (always)] pub fn ccpc (& self) -> CcpcR { CcpcR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 2 - Capture/compare control update selection"]
#[inline (always)] pub fn ccus (& self) -> CcusR { CcusR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Capture/compare DMA selection"]
#[inline (always)] pub fn ccds (& self) -> CcdsR { CcdsR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Master mode selection"]
#[inline (always)] pub fn mms (& self) -> MmsR { MmsR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - TI1 selection"]
#[inline (always)] pub fn ti1s (& self) -> Ti1sR { Ti1sR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Output Idle state 1"]
#[inline (always)] pub fn ois1 (& self) -> Ois1R { Ois1R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Output Idle state 1"]
#[inline (always)] pub fn ois1n (& self) -> Ois1nR { Ois1nR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Output Idle state 2"]
#[inline (always)] pub fn ois2 (& self) -> Ois2R { Ois2R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Output Idle state 2"]
#[inline (always)] pub fn ois2n (& self) -> Ois2nR { Ois2nR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Output Idle state 3"]
#[inline (always)] pub fn ois3 (& self) -> Ois3R { Ois3R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Output Idle state 3"]
#[inline (always)] pub fn ois3n (& self) -> Ois3nR { Ois3nR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Output Idle state 4"]
#[inline (always)] pub fn ois4 (& self) -> Ois4R { Ois4R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 16 - Output Idle state 5 (OC5 output)"]
#[inline (always)] pub fn ois5 (& self) -> Ois5R { Ois5R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 18 - Output Idle state 6 (OC6 output)"]
#[inline (always)] pub fn ois6 (& self) -> Ois6R { Ois6R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bits 20:23 - Master mode selection 2"]
#[inline (always)] pub fn mms2 (& self) -> Mms2R { Mms2R :: new (((self . bits >> 20) & 0x0f) as u8) } } impl W {
#[doc = "Bit 0 - Capture/compare preloaded control"]
#[inline (always)] pub fn ccpc (& mut self) -> CcpcW < '_ , Cr2Spec > { CcpcW :: new (self , 0) }
#[doc = "Bit 2 - Capture/compare control update selection"]
#[inline (always)] pub fn ccus (& mut self) -> CcusW < '_ , Cr2Spec > { CcusW :: new (self , 2) }
#[doc = "Bit 3 - Capture/compare DMA selection"]
#[inline (always)] pub fn ccds (& mut self) -> CcdsW < '_ , Cr2Spec > { CcdsW :: new (self , 3) }
#[doc = "Bits 4:6 - Master mode selection"]
#[inline (always)] pub fn mms (& mut self) -> MmsW < '_ , Cr2Spec > { MmsW :: new (self , 4) }
#[doc = "Bit 7 - TI1 selection"]
#[inline (always)] pub fn ti1s (& mut self) -> Ti1sW < '_ , Cr2Spec > { Ti1sW :: new (self , 7) }
#[doc = "Bit 8 - Output Idle state 1"]
#[inline (always)] pub fn ois1 (& mut self) -> Ois1W < '_ , Cr2Spec > { Ois1W :: new (self , 8) }
#[doc = "Bit 9 - Output Idle state 1"]
#[inline (always)] pub fn ois1n (& mut self) -> Ois1nW < '_ , Cr2Spec > { Ois1nW :: new (self , 9) }
#[doc = "Bit 10 - Output Idle state 2"]
#[inline (always)] pub fn ois2 (& mut self) -> Ois2W < '_ , Cr2Spec > { Ois2W :: new (self , 10) }
#[doc = "Bit 11 - Output Idle state 2"]
#[inline (always)] pub fn ois2n (& mut self) -> Ois2nW < '_ , Cr2Spec > { Ois2nW :: new (self , 11) }
#[doc = "Bit 12 - Output Idle state 3"]
#[inline (always)] pub fn ois3 (& mut self) -> Ois3W < '_ , Cr2Spec > { Ois3W :: new (self , 12) }
#[doc = "Bit 13 - Output Idle state 3"]
#[inline (always)] pub fn ois3n (& mut self) -> Ois3nW < '_ , Cr2Spec > { Ois3nW :: new (self , 13) }
#[doc = "Bit 14 - Output Idle state 4"]
#[inline (always)] pub fn ois4 (& mut self) -> Ois4W < '_ , Cr2Spec > { Ois4W :: new (self , 14) }
#[doc = "Bit 16 - Output Idle state 5 (OC5 output)"]
#[inline (always)] pub fn ois5 (& mut self) -> Ois5W < '_ , Cr2Spec > { Ois5W :: new (self , 16) }
#[doc = "Bit 18 - Output Idle state 6 (OC6 output)"]
#[inline (always)] pub fn ois6 (& mut self) -> Ois6W < '_ , Cr2Spec > { Ois6W :: new (self , 18) }
#[doc = "Bits 20:23 - Master mode selection 2"]
#[inline (always)] pub fn mms2 (& mut self) -> Mms2W < '_ , Cr2Spec > { Mms2W :: new (self , 20) } }
#[doc = "control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR2 to value 0"] impl crate :: Resettable for Cr2Spec { } }
#[doc = "SMCR (rw) register accessor: slave mode control register\n\nYou can [`read`](crate::Reg::read) this register and get [`smcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@smcr`] module"]
#[doc (alias = "SMCR")] pub type Smcr = crate :: Reg < smcr :: SmcrSpec > ;
#[doc = "slave mode control register"] pub mod smcr {
#[doc = "Register `SMCR` reader"] pub type R = crate :: R < SmcrSpec > ;
#[doc = "Register `SMCR` writer"] pub type W = crate :: W < SmcrSpec > ;
#[doc = "Field `SMS` reader - Slave mode selection"] pub type SmsR = crate :: FieldReader ;
#[doc = "Field `SMS` writer - Slave mode selection"] pub type SmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OCCS` reader - OCREF clear selection"] pub type OccsR = crate :: BitReader ;
#[doc = "Field `OCCS` writer - OCREF clear selection"] pub type OccsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TS` reader - Trigger selection"] pub type TsR = crate :: FieldReader ;
#[doc = "Field `TS` writer - Trigger selection"] pub type TsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `MSM` reader - Master/Slave mode"] pub type MsmR = crate :: BitReader ;
#[doc = "Field `MSM` writer - Master/Slave mode"] pub type MsmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ETF` reader - External trigger filter"] pub type EtfR = crate :: FieldReader ;
#[doc = "Field `ETF` writer - External trigger filter"] pub type EtfW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ETPS` reader - External trigger prescaler"] pub type EtpsR = crate :: FieldReader ;
#[doc = "Field `ETPS` writer - External trigger prescaler"] pub type EtpsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ECE` reader - External clock enable"] pub type EceR = crate :: BitReader ;
#[doc = "Field `ECE` writer - External clock enable"] pub type EceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ETP` reader - External trigger polarity"] pub type EtpR = crate :: BitReader ;
#[doc = "Field `ETP` writer - External trigger polarity"] pub type EtpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SMS_3` reader - Slave mode selection - bit 3"] pub type Sms3R = crate :: BitReader ;
#[doc = "Field `SMS_3` writer - Slave mode selection - bit 3"] pub type Sms3W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:2 - Slave mode selection"]
#[inline (always)] pub fn sms (& self) -> SmsR { SmsR :: new ((self . bits & 7) as u8) }
#[doc = "Bit 3 - OCREF clear selection"]
#[inline (always)] pub fn occs (& self) -> OccsR { OccsR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Trigger selection"]
#[inline (always)] pub fn ts (& self) -> TsR { TsR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Master/Slave mode"]
#[inline (always)] pub fn msm (& self) -> MsmR { MsmR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:11 - External trigger filter"]
#[inline (always)] pub fn etf (& self) -> EtfR { EtfR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:13 - External trigger prescaler"]
#[inline (always)] pub fn etps (& self) -> EtpsR { EtpsR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - External clock enable"]
#[inline (always)] pub fn ece (& self) -> EceR { EceR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - External trigger polarity"]
#[inline (always)] pub fn etp (& self) -> EtpR { EtpR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Slave mode selection - bit 3"]
#[inline (always)] pub fn sms_3 (& self) -> Sms3R { Sms3R :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bits 0:2 - Slave mode selection"]
#[inline (always)] pub fn sms (& mut self) -> SmsW < '_ , SmcrSpec > { SmsW :: new (self , 0) }
#[doc = "Bit 3 - OCREF clear selection"]
#[inline (always)] pub fn occs (& mut self) -> OccsW < '_ , SmcrSpec > { OccsW :: new (self , 3) }
#[doc = "Bits 4:6 - Trigger selection"]
#[inline (always)] pub fn ts (& mut self) -> TsW < '_ , SmcrSpec > { TsW :: new (self , 4) }
#[doc = "Bit 7 - Master/Slave mode"]
#[inline (always)] pub fn msm (& mut self) -> MsmW < '_ , SmcrSpec > { MsmW :: new (self , 7) }
#[doc = "Bits 8:11 - External trigger filter"]
#[inline (always)] pub fn etf (& mut self) -> EtfW < '_ , SmcrSpec > { EtfW :: new (self , 8) }
#[doc = "Bits 12:13 - External trigger prescaler"]
#[inline (always)] pub fn etps (& mut self) -> EtpsW < '_ , SmcrSpec > { EtpsW :: new (self , 12) }
#[doc = "Bit 14 - External clock enable"]
#[inline (always)] pub fn ece (& mut self) -> EceW < '_ , SmcrSpec > { EceW :: new (self , 14) }
#[doc = "Bit 15 - External trigger polarity"]
#[inline (always)] pub fn etp (& mut self) -> EtpW < '_ , SmcrSpec > { EtpW :: new (self , 15) }
#[doc = "Bit 16 - Slave mode selection - bit 3"]
#[inline (always)] pub fn sms_3 (& mut self) -> Sms3W < '_ , SmcrSpec > { Sms3W :: new (self , 16) } }
#[doc = "slave mode control register\n\nYou can [`read`](crate::Reg::read) this register and get [`smcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SmcrSpec ; impl crate :: RegisterSpec for SmcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`smcr::R`](R) reader structure"] impl crate :: Readable for SmcrSpec { }
#[doc = "`write(|w| ..)` method takes [`smcr::W`](W) writer structure"] impl crate :: Writable for SmcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SMCR to value 0"] impl crate :: Resettable for SmcrSpec { } }
#[doc = "DIER (rw) register accessor: DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dier`] module"]
#[doc (alias = "DIER")] pub type Dier = crate :: Reg < dier :: DierSpec > ;
#[doc = "DMA/Interrupt enable register"] pub mod dier {
#[doc = "Register `DIER` reader"] pub type R = crate :: R < DierSpec > ;
#[doc = "Register `DIER` writer"] pub type W = crate :: W < DierSpec > ;
#[doc = "Field `UIE` reader - Update interrupt enable"] pub type UieR = crate :: BitReader ;
#[doc = "Field `UIE` writer - Update interrupt enable"] pub type UieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1IE` reader - Capture/Compare 1 interrupt enable"] pub type Cc1ieR = crate :: BitReader ;
#[doc = "Field `CC1IE` writer - Capture/Compare 1 interrupt enable"] pub type Cc1ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2IE` reader - Capture/Compare 2 interrupt enable"] pub type Cc2ieR = crate :: BitReader ;
#[doc = "Field `CC2IE` writer - Capture/Compare 2 interrupt enable"] pub type Cc2ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3IE` reader - Capture/Compare 3 interrupt enable"] pub type Cc3ieR = crate :: BitReader ;
#[doc = "Field `CC3IE` writer - Capture/Compare 3 interrupt enable"] pub type Cc3ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4IE` reader - Capture/Compare 4 interrupt enable"] pub type Cc4ieR = crate :: BitReader ;
#[doc = "Field `CC4IE` writer - Capture/Compare 4 interrupt enable"] pub type Cc4ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMIE` reader - COM interrupt enable"] pub type ComieR = crate :: BitReader ;
#[doc = "Field `COMIE` writer - COM interrupt enable"] pub type ComieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIE` reader - Trigger interrupt enable"] pub type TieR = crate :: BitReader ;
#[doc = "Field `TIE` writer - Trigger interrupt enable"] pub type TieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BIE` reader - Break interrupt enable"] pub type BieR = crate :: BitReader ;
#[doc = "Field `BIE` writer - Break interrupt enable"] pub type BieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDE` reader - Update DMA request enable"] pub type UdeR = crate :: BitReader ;
#[doc = "Field `UDE` writer - Update DMA request enable"] pub type UdeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1DE` reader - Capture/Compare 1 DMA request enable"] pub type Cc1deR = crate :: BitReader ;
#[doc = "Field `CC1DE` writer - Capture/Compare 1 DMA request enable"] pub type Cc1deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2DE` reader - Capture/Compare 2 DMA request enable"] pub type Cc2deR = crate :: BitReader ;
#[doc = "Field `CC2DE` writer - Capture/Compare 2 DMA request enable"] pub type Cc2deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3DE` reader - Capture/Compare 3 DMA request enable"] pub type Cc3deR = crate :: BitReader ;
#[doc = "Field `CC3DE` writer - Capture/Compare 3 DMA request enable"] pub type Cc3deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4DE` reader - Capture/Compare 4 DMA request enable"] pub type Cc4deR = crate :: BitReader ;
#[doc = "Field `CC4DE` writer - Capture/Compare 4 DMA request enable"] pub type Cc4deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMDE` reader - COM DMA request enable"] pub type ComdeR = crate :: BitReader ;
#[doc = "Field `COMDE` writer - COM DMA request enable"] pub type ComdeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TDE` reader - Trigger DMA request enable"] pub type TdeR = crate :: BitReader ;
#[doc = "Field `TDE` writer - Trigger DMA request enable"] pub type TdeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& self) -> UieR { UieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
#[inline (always)] pub fn cc1ie (& self) -> Cc1ieR { Cc1ieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
#[inline (always)] pub fn cc2ie (& self) -> Cc2ieR { Cc2ieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
#[inline (always)] pub fn cc3ie (& self) -> Cc3ieR { Cc3ieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
#[inline (always)] pub fn cc4ie (& self) -> Cc4ieR { Cc4ieR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - COM interrupt enable"]
#[inline (always)] pub fn comie (& self) -> ComieR { ComieR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Trigger interrupt enable"]
#[inline (always)] pub fn tie (& self) -> TieR { TieR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Break interrupt enable"]
#[inline (always)] pub fn bie (& self) -> BieR { BieR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Update DMA request enable"]
#[inline (always)] pub fn ude (& self) -> UdeR { UdeR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
#[inline (always)] pub fn cc1de (& self) -> Cc1deR { Cc1deR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
#[inline (always)] pub fn cc2de (& self) -> Cc2deR { Cc2deR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
#[inline (always)] pub fn cc3de (& self) -> Cc3deR { Cc3deR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
#[inline (always)] pub fn cc4de (& self) -> Cc4deR { Cc4deR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - COM DMA request enable"]
#[inline (always)] pub fn comde (& self) -> ComdeR { ComdeR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Trigger DMA request enable"]
#[inline (always)] pub fn tde (& self) -> TdeR { TdeR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& mut self) -> UieW < '_ , DierSpec > { UieW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
#[inline (always)] pub fn cc1ie (& mut self) -> Cc1ieW < '_ , DierSpec > { Cc1ieW :: new (self , 1) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
#[inline (always)] pub fn cc2ie (& mut self) -> Cc2ieW < '_ , DierSpec > { Cc2ieW :: new (self , 2) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
#[inline (always)] pub fn cc3ie (& mut self) -> Cc3ieW < '_ , DierSpec > { Cc3ieW :: new (self , 3) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
#[inline (always)] pub fn cc4ie (& mut self) -> Cc4ieW < '_ , DierSpec > { Cc4ieW :: new (self , 4) }
#[doc = "Bit 5 - COM interrupt enable"]
#[inline (always)] pub fn comie (& mut self) -> ComieW < '_ , DierSpec > { ComieW :: new (self , 5) }
#[doc = "Bit 6 - Trigger interrupt enable"]
#[inline (always)] pub fn tie (& mut self) -> TieW < '_ , DierSpec > { TieW :: new (self , 6) }
#[doc = "Bit 7 - Break interrupt enable"]
#[inline (always)] pub fn bie (& mut self) -> BieW < '_ , DierSpec > { BieW :: new (self , 7) }
#[doc = "Bit 8 - Update DMA request enable"]
#[inline (always)] pub fn ude (& mut self) -> UdeW < '_ , DierSpec > { UdeW :: new (self , 8) }
#[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
#[inline (always)] pub fn cc1de (& mut self) -> Cc1deW < '_ , DierSpec > { Cc1deW :: new (self , 9) }
#[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
#[inline (always)] pub fn cc2de (& mut self) -> Cc2deW < '_ , DierSpec > { Cc2deW :: new (self , 10) }
#[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
#[inline (always)] pub fn cc3de (& mut self) -> Cc3deW < '_ , DierSpec > { Cc3deW :: new (self , 11) }
#[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
#[inline (always)] pub fn cc4de (& mut self) -> Cc4deW < '_ , DierSpec > { Cc4deW :: new (self , 12) }
#[doc = "Bit 13 - COM DMA request enable"]
#[inline (always)] pub fn comde (& mut self) -> ComdeW < '_ , DierSpec > { ComdeW :: new (self , 13) }
#[doc = "Bit 14 - Trigger DMA request enable"]
#[inline (always)] pub fn tde (& mut self) -> TdeW < '_ , DierSpec > { TdeW :: new (self , 14) } }
#[doc = "DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DierSpec ; impl crate :: RegisterSpec for DierSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dier::R`](R) reader structure"] impl crate :: Readable for DierSpec { }
#[doc = "`write(|w| ..)` method takes [`dier::W`](W) writer structure"] impl crate :: Writable for DierSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIER to value 0"] impl crate :: Resettable for DierSpec { } }
#[doc = "SR (rw) register accessor: status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `UIF` reader - Update interrupt flag"] pub type UifR = crate :: BitReader ;
#[doc = "Field `UIF` writer - Update interrupt flag"] pub type UifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1IF` reader - Capture/compare 1 interrupt flag"] pub type Cc1ifR = crate :: BitReader ;
#[doc = "Field `CC1IF` writer - Capture/compare 1 interrupt flag"] pub type Cc1ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2IF` reader - Capture/Compare 2 interrupt flag"] pub type Cc2ifR = crate :: BitReader ;
#[doc = "Field `CC2IF` writer - Capture/Compare 2 interrupt flag"] pub type Cc2ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3IF` reader - Capture/Compare 3 interrupt flag"] pub type Cc3ifR = crate :: BitReader ;
#[doc = "Field `CC3IF` writer - Capture/Compare 3 interrupt flag"] pub type Cc3ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4IF` reader - Capture/Compare 4 interrupt flag"] pub type Cc4ifR = crate :: BitReader ;
#[doc = "Field `CC4IF` writer - Capture/Compare 4 interrupt flag"] pub type Cc4ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMIF` reader - COM interrupt flag"] pub type ComifR = crate :: BitReader ;
#[doc = "Field `COMIF` writer - COM interrupt flag"] pub type ComifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIF` reader - Trigger interrupt flag"] pub type TifR = crate :: BitReader ;
#[doc = "Field `TIF` writer - Trigger interrupt flag"] pub type TifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BIF` reader - Break interrupt flag"] pub type BifR = crate :: BitReader ;
#[doc = "Field `BIF` writer - Break interrupt flag"] pub type BifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `B2IF` reader - Break 2 interrupt flag"] pub type B2ifR = crate :: BitReader ;
#[doc = "Field `B2IF` writer - Break 2 interrupt flag"] pub type B2ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1OF` reader - Capture/Compare 1 overcapture flag"] pub type Cc1ofR = crate :: BitReader ;
#[doc = "Field `CC1OF` writer - Capture/Compare 1 overcapture flag"] pub type Cc1ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2OF` reader - Capture/compare 2 overcapture flag"] pub type Cc2ofR = crate :: BitReader ;
#[doc = "Field `CC2OF` writer - Capture/compare 2 overcapture flag"] pub type Cc2ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3OF` reader - Capture/Compare 3 overcapture flag"] pub type Cc3ofR = crate :: BitReader ;
#[doc = "Field `CC3OF` writer - Capture/Compare 3 overcapture flag"] pub type Cc3ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4OF` reader - Capture/Compare 4 overcapture flag"] pub type Cc4ofR = crate :: BitReader ;
#[doc = "Field `CC4OF` writer - Capture/Compare 4 overcapture flag"] pub type Cc4ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SBIF` reader - System Break interrupt flag"] pub type SbifR = crate :: BitReader ;
#[doc = "Field `SBIF` writer - System Break interrupt flag"] pub type SbifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC5IF` reader - Compare 5 interrupt flag"] pub type Cc5ifR = crate :: BitReader ;
#[doc = "Field `CC5IF` writer - Compare 5 interrupt flag"] pub type Cc5ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC6IF` reader - Compare 6 interrupt flag"] pub type Cc6ifR = crate :: BitReader ;
#[doc = "Field `CC6IF` writer - Compare 6 interrupt flag"] pub type Cc6ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& self) -> UifR { UifR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
#[inline (always)] pub fn cc1if (& self) -> Cc1ifR { Cc1ifR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
#[inline (always)] pub fn cc2if (& self) -> Cc2ifR { Cc2ifR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
#[inline (always)] pub fn cc3if (& self) -> Cc3ifR { Cc3ifR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
#[inline (always)] pub fn cc4if (& self) -> Cc4ifR { Cc4ifR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - COM interrupt flag"]
#[inline (always)] pub fn comif (& self) -> ComifR { ComifR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Trigger interrupt flag"]
#[inline (always)] pub fn tif (& self) -> TifR { TifR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Break interrupt flag"]
#[inline (always)] pub fn bif (& self) -> BifR { BifR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Break 2 interrupt flag"]
#[inline (always)] pub fn b2if (& self) -> B2ifR { B2ifR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
#[inline (always)] pub fn cc1of (& self) -> Cc1ofR { Cc1ofR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
#[inline (always)] pub fn cc2of (& self) -> Cc2ofR { Cc2ofR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
#[inline (always)] pub fn cc3of (& self) -> Cc3ofR { Cc3ofR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
#[inline (always)] pub fn cc4of (& self) -> Cc4ofR { Cc4ofR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - System Break interrupt flag"]
#[inline (always)] pub fn sbif (& self) -> SbifR { SbifR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 16 - Compare 5 interrupt flag"]
#[inline (always)] pub fn cc5if (& self) -> Cc5ifR { Cc5ifR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Compare 6 interrupt flag"]
#[inline (always)] pub fn cc6if (& self) -> Cc6ifR { Cc6ifR :: new (((self . bits >> 17) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& mut self) -> UifW < '_ , SrSpec > { UifW :: new (self , 0) }
#[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
#[inline (always)] pub fn cc1if (& mut self) -> Cc1ifW < '_ , SrSpec > { Cc1ifW :: new (self , 1) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
#[inline (always)] pub fn cc2if (& mut self) -> Cc2ifW < '_ , SrSpec > { Cc2ifW :: new (self , 2) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
#[inline (always)] pub fn cc3if (& mut self) -> Cc3ifW < '_ , SrSpec > { Cc3ifW :: new (self , 3) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
#[inline (always)] pub fn cc4if (& mut self) -> Cc4ifW < '_ , SrSpec > { Cc4ifW :: new (self , 4) }
#[doc = "Bit 5 - COM interrupt flag"]
#[inline (always)] pub fn comif (& mut self) -> ComifW < '_ , SrSpec > { ComifW :: new (self , 5) }
#[doc = "Bit 6 - Trigger interrupt flag"]
#[inline (always)] pub fn tif (& mut self) -> TifW < '_ , SrSpec > { TifW :: new (self , 6) }
#[doc = "Bit 7 - Break interrupt flag"]
#[inline (always)] pub fn bif (& mut self) -> BifW < '_ , SrSpec > { BifW :: new (self , 7) }
#[doc = "Bit 8 - Break 2 interrupt flag"]
#[inline (always)] pub fn b2if (& mut self) -> B2ifW < '_ , SrSpec > { B2ifW :: new (self , 8) }
#[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
#[inline (always)] pub fn cc1of (& mut self) -> Cc1ofW < '_ , SrSpec > { Cc1ofW :: new (self , 9) }
#[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
#[inline (always)] pub fn cc2of (& mut self) -> Cc2ofW < '_ , SrSpec > { Cc2ofW :: new (self , 10) }
#[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
#[inline (always)] pub fn cc3of (& mut self) -> Cc3ofW < '_ , SrSpec > { Cc3ofW :: new (self , 11) }
#[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
#[inline (always)] pub fn cc4of (& mut self) -> Cc4ofW < '_ , SrSpec > { Cc4ofW :: new (self , 12) }
#[doc = "Bit 13 - System Break interrupt flag"]
#[inline (always)] pub fn sbif (& mut self) -> SbifW < '_ , SrSpec > { SbifW :: new (self , 13) }
#[doc = "Bit 16 - Compare 5 interrupt flag"]
#[inline (always)] pub fn cc5if (& mut self) -> Cc5ifW < '_ , SrSpec > { Cc5ifW :: new (self , 16) }
#[doc = "Bit 17 - Compare 6 interrupt flag"]
#[inline (always)] pub fn cc6if (& mut self) -> Cc6ifW < '_ , SrSpec > { Cc6ifW :: new (self , 17) } }
#[doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "EGR (w) register accessor: event generation register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@egr`] module"]
#[doc (alias = "EGR")] pub type Egr = crate :: Reg < egr :: EgrSpec > ;
#[doc = "event generation register"] pub mod egr {
#[doc = "Register `EGR` writer"] pub type W = crate :: W < EgrSpec > ;
#[doc = "Field `UG` writer - Update generation"] pub type UgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1G` writer - Capture/compare 1 generation"] pub type Cc1gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2G` writer - Capture/compare 2 generation"] pub type Cc2gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3G` writer - Capture/compare 3 generation"] pub type Cc3gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4G` writer - Capture/compare 4 generation"] pub type Cc4gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMG` writer - Capture/Compare control update generation"] pub type ComgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TG` writer - Trigger generation"] pub type TgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BG` writer - Break generation"] pub type BgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `B2G` writer - Break 2 generation"] pub type B2gW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Update generation"]
#[inline (always)] pub fn ug (& mut self) -> UgW < '_ , EgrSpec > { UgW :: new (self , 0) }
#[doc = "Bit 1 - Capture/compare 1 generation"]
#[inline (always)] pub fn cc1g (& mut self) -> Cc1gW < '_ , EgrSpec > { Cc1gW :: new (self , 1) }
#[doc = "Bit 2 - Capture/compare 2 generation"]
#[inline (always)] pub fn cc2g (& mut self) -> Cc2gW < '_ , EgrSpec > { Cc2gW :: new (self , 2) }
#[doc = "Bit 3 - Capture/compare 3 generation"]
#[inline (always)] pub fn cc3g (& mut self) -> Cc3gW < '_ , EgrSpec > { Cc3gW :: new (self , 3) }
#[doc = "Bit 4 - Capture/compare 4 generation"]
#[inline (always)] pub fn cc4g (& mut self) -> Cc4gW < '_ , EgrSpec > { Cc4gW :: new (self , 4) }
#[doc = "Bit 5 - Capture/Compare control update generation"]
#[inline (always)] pub fn comg (& mut self) -> ComgW < '_ , EgrSpec > { ComgW :: new (self , 5) }
#[doc = "Bit 6 - Trigger generation"]
#[inline (always)] pub fn tg (& mut self) -> TgW < '_ , EgrSpec > { TgW :: new (self , 6) }
#[doc = "Bit 7 - Break generation"]
#[inline (always)] pub fn bg (& mut self) -> BgW < '_ , EgrSpec > { BgW :: new (self , 7) }
#[doc = "Bit 8 - Break 2 generation"]
#[inline (always)] pub fn b2g (& mut self) -> B2gW < '_ , EgrSpec > { B2gW :: new (self , 8) } }
#[doc = "event generation register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct EgrSpec ; impl crate :: RegisterSpec for EgrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`egr::W`](W) writer structure"] impl crate :: Writable for EgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EGR to value 0"] impl crate :: Resettable for EgrSpec { } }
#[doc = "CCMR1_Input (rw) register accessor: capture/compare mode register 1 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr1_input`] module"]
#[doc (alias = "CCMR1_Input")] pub type Ccmr1Input = crate :: Reg < ccmr1_input :: Ccmr1InputSpec > ;
#[doc = "capture/compare mode register 1 (output mode)"] pub mod ccmr1_input {
#[doc = "Register `CCMR1_Input` reader"] pub type R = crate :: R < Ccmr1InputSpec > ;
#[doc = "Register `CCMR1_Input` writer"] pub type W = crate :: W < Ccmr1InputSpec > ;
#[doc = "Field `CC1S` reader - Capture/Compare 1 selection"] pub type Cc1sR = crate :: FieldReader ;
#[doc = "Field `CC1S` writer - Capture/Compare 1 selection"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC1PSC` reader - Input capture 1 prescaler"] pub type Ic1pscR = crate :: FieldReader ;
#[doc = "Field `IC1PSC` writer - Input capture 1 prescaler"] pub type Ic1pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `C1F` reader - Input capture 1 filter"] pub type C1fR = crate :: FieldReader ;
#[doc = "Field `C1F` writer - Input capture 1 filter"] pub type C1fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `CC2S` reader - capture/Compare 2 selection"] pub type Cc2sR = crate :: FieldReader ;
#[doc = "Field `CC2S` writer - capture/Compare 2 selection"] pub type Cc2sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC2PSC` reader - Input capture 2 prescaler"] pub type Ic2pscR = crate :: FieldReader ;
#[doc = "Field `IC2PSC` writer - Input capture 2 prescaler"] pub type Ic2pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC2F` reader - Input capture 2 filter"] pub type Ic2fR = crate :: FieldReader ;
#[doc = "Field `IC2F` writer - Input capture 2 filter"] pub type Ic2fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Input capture 1 prescaler"]
#[inline (always)] pub fn ic1psc (& self) -> Ic1pscR { Ic1pscR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:7 - Input capture 1 filter"]
#[inline (always)] pub fn c1f (& self) -> C1fR { C1fR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:9 - capture/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& self) -> Cc2sR { Cc2sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Input capture 2 prescaler"]
#[inline (always)] pub fn ic2psc (& self) -> Ic2pscR { Ic2pscR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:15 - Input capture 2 filter"]
#[inline (always)] pub fn ic2f (& self) -> Ic2fR { Ic2fR :: new (((self . bits >> 12) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& mut self) -> Cc1sW < '_ , Ccmr1InputSpec > { Cc1sW :: new (self , 0) }
#[doc = "Bits 2:3 - Input capture 1 prescaler"]
#[inline (always)] pub fn ic1psc (& mut self) -> Ic1pscW < '_ , Ccmr1InputSpec > { Ic1pscW :: new (self , 2) }
#[doc = "Bits 4:7 - Input capture 1 filter"]
#[inline (always)] pub fn c1f (& mut self) -> C1fW < '_ , Ccmr1InputSpec > { C1fW :: new (self , 4) }
#[doc = "Bits 8:9 - capture/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& mut self) -> Cc2sW < '_ , Ccmr1InputSpec > { Cc2sW :: new (self , 8) }
#[doc = "Bits 10:11 - Input capture 2 prescaler"]
#[inline (always)] pub fn ic2psc (& mut self) -> Ic2pscW < '_ , Ccmr1InputSpec > { Ic2pscW :: new (self , 10) }
#[doc = "Bits 12:15 - Input capture 2 filter"]
#[inline (always)] pub fn ic2f (& mut self) -> Ic2fW < '_ , Ccmr1InputSpec > { Ic2fW :: new (self , 12) } }
#[doc = "capture/compare mode register 1 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1InputSpec ; impl crate :: RegisterSpec for Ccmr1InputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr1_input::R`](R) reader structure"] impl crate :: Readable for Ccmr1InputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr1_input::W`](W) writer structure"] impl crate :: Writable for Ccmr1InputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR1_Input to value 0"] impl crate :: Resettable for Ccmr1InputSpec { } }
#[doc = "CCMR1_Output (rw) register accessor: capture/compare mode register 1 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_output::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_output::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr1_output`] module"]
#[doc (alias = "CCMR1_Output")] pub type Ccmr1Output = crate :: Reg < ccmr1_output :: Ccmr1OutputSpec > ;
#[doc = "capture/compare mode register 1 (output mode)"] pub mod ccmr1_output {
#[doc = "Register `CCMR1_Output` reader"] pub type R = crate :: R < Ccmr1OutputSpec > ;
#[doc = "Register `CCMR1_Output` writer"] pub type W = crate :: W < Ccmr1OutputSpec > ;
#[doc = "Field `CC1S` reader - Capture/Compare 1 selection"] pub type Cc1sR = crate :: FieldReader ;
#[doc = "Field `CC1S` writer - Capture/Compare 1 selection"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC1FE` reader - Output Compare 1 fast enable"] pub type Oc1feR = crate :: BitReader ;
#[doc = "Field `OC1FE` writer - Output Compare 1 fast enable"] pub type Oc1feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1PE` reader - Output Compare 1 preload enable"] pub type Oc1peR = crate :: BitReader ;
#[doc = "Field `OC1PE` writer - Output Compare 1 preload enable"] pub type Oc1peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1M` reader - Output Compare 1 mode"] pub type Oc1mR = crate :: FieldReader ;
#[doc = "Field `OC1M` writer - Output Compare 1 mode"] pub type Oc1mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC1CE` reader - Output Compare 1 clear enable"] pub type Oc1ceR = crate :: BitReader ;
#[doc = "Field `OC1CE` writer - Output Compare 1 clear enable"] pub type Oc1ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2S` reader - Capture/Compare 2 selection"] pub type Cc2sR = crate :: FieldReader ;
#[doc = "Field `CC2S` writer - Capture/Compare 2 selection"] pub type Cc2sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC2FE` reader - Output Compare 2 fast enable"] pub type Oc2feR = crate :: BitReader ;
#[doc = "Field `OC2FE` writer - Output Compare 2 fast enable"] pub type Oc2feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC2PE` reader - Output Compare 2 preload enable"] pub type Oc2peR = crate :: BitReader ;
#[doc = "Field `OC2PE` writer - Output Compare 2 preload enable"] pub type Oc2peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC2M` reader - Output Compare 2 mode"] pub type Oc2mR = crate :: FieldReader ;
#[doc = "Field `OC2M` writer - Output Compare 2 mode"] pub type Oc2mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC2CE` reader - Output Compare 2 clear enable"] pub type Oc2ceR = crate :: BitReader ;
#[doc = "Field `OC2CE` writer - Output Compare 2 clear enable"] pub type Oc2ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1M_3` reader - Output Compare 1 mode - bit 3"] pub type Oc1m3R = crate :: BitReader ;
#[doc = "Field `OC1M_3` writer - Output Compare 1 mode - bit 3"] pub type Oc1m3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC2M_3` reader - Output Compare 2 mode - bit 3"] pub type Oc2m3R = crate :: BitReader ;
#[doc = "Field `OC2M_3` writer - Output Compare 2 mode - bit 3"] pub type Oc2m3W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) }
#[doc = "Bit 2 - Output Compare 1 fast enable"]
#[inline (always)] pub fn oc1fe (& self) -> Oc1feR { Oc1feR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Output Compare 1 preload enable"]
#[inline (always)] pub fn oc1pe (& self) -> Oc1peR { Oc1peR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Output Compare 1 mode"]
#[inline (always)] pub fn oc1m (& self) -> Oc1mR { Oc1mR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Output Compare 1 clear enable"]
#[inline (always)] pub fn oc1ce (& self) -> Oc1ceR { Oc1ceR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Capture/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& self) -> Cc2sR { Cc2sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 10 - Output Compare 2 fast enable"]
#[inline (always)] pub fn oc2fe (& self) -> Oc2feR { Oc2feR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Output Compare 2 preload enable"]
#[inline (always)] pub fn oc2pe (& self) -> Oc2peR { Oc2peR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:14 - Output Compare 2 mode"]
#[inline (always)] pub fn oc2m (& self) -> Oc2mR { Oc2mR :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bit 15 - Output Compare 2 clear enable"]
#[inline (always)] pub fn oc2ce (& self) -> Oc2ceR { Oc2ceR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Output Compare 1 mode - bit 3"]
#[inline (always)] pub fn oc1m_3 (& self) -> Oc1m3R { Oc1m3R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 24 - Output Compare 2 mode - bit 3"]
#[inline (always)] pub fn oc2m_3 (& self) -> Oc2m3R { Oc2m3R :: new (((self . bits >> 24) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& mut self) -> Cc1sW < '_ , Ccmr1OutputSpec > { Cc1sW :: new (self , 0) }
#[doc = "Bit 2 - Output Compare 1 fast enable"]
#[inline (always)] pub fn oc1fe (& mut self) -> Oc1feW < '_ , Ccmr1OutputSpec > { Oc1feW :: new (self , 2) }
#[doc = "Bit 3 - Output Compare 1 preload enable"]
#[inline (always)] pub fn oc1pe (& mut self) -> Oc1peW < '_ , Ccmr1OutputSpec > { Oc1peW :: new (self , 3) }
#[doc = "Bits 4:6 - Output Compare 1 mode"]
#[inline (always)] pub fn oc1m (& mut self) -> Oc1mW < '_ , Ccmr1OutputSpec > { Oc1mW :: new (self , 4) }
#[doc = "Bit 7 - Output Compare 1 clear enable"]
#[inline (always)] pub fn oc1ce (& mut self) -> Oc1ceW < '_ , Ccmr1OutputSpec > { Oc1ceW :: new (self , 7) }
#[doc = "Bits 8:9 - Capture/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& mut self) -> Cc2sW < '_ , Ccmr1OutputSpec > { Cc2sW :: new (self , 8) }
#[doc = "Bit 10 - Output Compare 2 fast enable"]
#[inline (always)] pub fn oc2fe (& mut self) -> Oc2feW < '_ , Ccmr1OutputSpec > { Oc2feW :: new (self , 10) }
#[doc = "Bit 11 - Output Compare 2 preload enable"]
#[inline (always)] pub fn oc2pe (& mut self) -> Oc2peW < '_ , Ccmr1OutputSpec > { Oc2peW :: new (self , 11) }
#[doc = "Bits 12:14 - Output Compare 2 mode"]
#[inline (always)] pub fn oc2m (& mut self) -> Oc2mW < '_ , Ccmr1OutputSpec > { Oc2mW :: new (self , 12) }
#[doc = "Bit 15 - Output Compare 2 clear enable"]
#[inline (always)] pub fn oc2ce (& mut self) -> Oc2ceW < '_ , Ccmr1OutputSpec > { Oc2ceW :: new (self , 15) }
#[doc = "Bit 16 - Output Compare 1 mode - bit 3"]
#[inline (always)] pub fn oc1m_3 (& mut self) -> Oc1m3W < '_ , Ccmr1OutputSpec > { Oc1m3W :: new (self , 16) }
#[doc = "Bit 24 - Output Compare 2 mode - bit 3"]
#[inline (always)] pub fn oc2m_3 (& mut self) -> Oc2m3W < '_ , Ccmr1OutputSpec > { Oc2m3W :: new (self , 24) } }
#[doc = "capture/compare mode register 1 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_output::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_output::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1OutputSpec ; impl crate :: RegisterSpec for Ccmr1OutputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr1_output::R`](R) reader structure"] impl crate :: Readable for Ccmr1OutputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr1_output::W`](W) writer structure"] impl crate :: Writable for Ccmr1OutputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR1_Output to value 0"] impl crate :: Resettable for Ccmr1OutputSpec { } }
#[doc = "CCMR2_Output (rw) register accessor: capture/compare mode register 2 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_output::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_output::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr2_output`] module"]
#[doc (alias = "CCMR2_Output")] pub type Ccmr2Output = crate :: Reg < ccmr2_output :: Ccmr2OutputSpec > ;
#[doc = "capture/compare mode register 2 (output mode)"] pub mod ccmr2_output {
#[doc = "Register `CCMR2_Output` reader"] pub type R = crate :: R < Ccmr2OutputSpec > ;
#[doc = "Register `CCMR2_Output` writer"] pub type W = crate :: W < Ccmr2OutputSpec > ;
#[doc = "Field `CC3S` reader - Capture/Compare 3 selection"] pub type Cc3sR = crate :: FieldReader ;
#[doc = "Field `CC3S` writer - Capture/Compare 3 selection"] pub type Cc3sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC3FE` reader - Output compare 3 fast enable"] pub type Oc3feR = crate :: BitReader ;
#[doc = "Field `OC3FE` writer - Output compare 3 fast enable"] pub type Oc3feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC3PE` reader - Output compare 3 preload enable"] pub type Oc3peR = crate :: BitReader ;
#[doc = "Field `OC3PE` writer - Output compare 3 preload enable"] pub type Oc3peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC3M` reader - Output compare 3 mode"] pub type Oc3mR = crate :: FieldReader ;
#[doc = "Field `OC3M` writer - Output compare 3 mode"] pub type Oc3mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC3CE` reader - Output compare 3 clear enable"] pub type Oc3ceR = crate :: BitReader ;
#[doc = "Field `OC3CE` writer - Output compare 3 clear enable"] pub type Oc3ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4S` reader - Capture/Compare 4 selection"] pub type Cc4sR = crate :: FieldReader ;
#[doc = "Field `CC4S` writer - Capture/Compare 4 selection"] pub type Cc4sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC4FE` reader - Output compare 4 fast enable"] pub type Oc4feR = crate :: BitReader ;
#[doc = "Field `OC4FE` writer - Output compare 4 fast enable"] pub type Oc4feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC4PE` reader - Output compare 4 preload enable"] pub type Oc4peR = crate :: BitReader ;
#[doc = "Field `OC4PE` writer - Output compare 4 preload enable"] pub type Oc4peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC4M` reader - Output compare 4 mode"] pub type Oc4mR = crate :: FieldReader ;
#[doc = "Field `OC4M` writer - Output compare 4 mode"] pub type Oc4mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC4CE` reader - Output compare 4 clear enable"] pub type Oc4ceR = crate :: BitReader ;
#[doc = "Field `OC4CE` writer - Output compare 4 clear enable"] pub type Oc4ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC3M_3` reader - Output Compare 3 mode - bit 3"] pub type Oc3m3R = crate :: BitReader ;
#[doc = "Field `OC3M_3` writer - Output Compare 3 mode - bit 3"] pub type Oc3m3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC4M_3` reader - Output Compare 4 mode - bit 3"] pub type Oc4m3R = crate :: BitReader ;
#[doc = "Field `OC4M_3` writer - Output Compare 4 mode - bit 3"] pub type Oc4m3W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 3 selection"]
#[inline (always)] pub fn cc3s (& self) -> Cc3sR { Cc3sR :: new ((self . bits & 3) as u8) }
#[doc = "Bit 2 - Output compare 3 fast enable"]
#[inline (always)] pub fn oc3fe (& self) -> Oc3feR { Oc3feR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Output compare 3 preload enable"]
#[inline (always)] pub fn oc3pe (& self) -> Oc3peR { Oc3peR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Output compare 3 mode"]
#[inline (always)] pub fn oc3m (& self) -> Oc3mR { Oc3mR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Output compare 3 clear enable"]
#[inline (always)] pub fn oc3ce (& self) -> Oc3ceR { Oc3ceR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& self) -> Cc4sR { Cc4sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 10 - Output compare 4 fast enable"]
#[inline (always)] pub fn oc4fe (& self) -> Oc4feR { Oc4feR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Output compare 4 preload enable"]
#[inline (always)] pub fn oc4pe (& self) -> Oc4peR { Oc4peR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:14 - Output compare 4 mode"]
#[inline (always)] pub fn oc4m (& self) -> Oc4mR { Oc4mR :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bit 15 - Output compare 4 clear enable"]
#[inline (always)] pub fn oc4ce (& self) -> Oc4ceR { Oc4ceR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Output Compare 3 mode - bit 3"]
#[inline (always)] pub fn oc3m_3 (& self) -> Oc3m3R { Oc3m3R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 24 - Output Compare 4 mode - bit 3"]
#[inline (always)] pub fn oc4m_3 (& self) -> Oc4m3R { Oc4m3R :: new (((self . bits >> 24) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 3 selection"]
#[inline (always)] pub fn cc3s (& mut self) -> Cc3sW < '_ , Ccmr2OutputSpec > { Cc3sW :: new (self , 0) }
#[doc = "Bit 2 - Output compare 3 fast enable"]
#[inline (always)] pub fn oc3fe (& mut self) -> Oc3feW < '_ , Ccmr2OutputSpec > { Oc3feW :: new (self , 2) }
#[doc = "Bit 3 - Output compare 3 preload enable"]
#[inline (always)] pub fn oc3pe (& mut self) -> Oc3peW < '_ , Ccmr2OutputSpec > { Oc3peW :: new (self , 3) }
#[doc = "Bits 4:6 - Output compare 3 mode"]
#[inline (always)] pub fn oc3m (& mut self) -> Oc3mW < '_ , Ccmr2OutputSpec > { Oc3mW :: new (self , 4) }
#[doc = "Bit 7 - Output compare 3 clear enable"]
#[inline (always)] pub fn oc3ce (& mut self) -> Oc3ceW < '_ , Ccmr2OutputSpec > { Oc3ceW :: new (self , 7) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& mut self) -> Cc4sW < '_ , Ccmr2OutputSpec > { Cc4sW :: new (self , 8) }
#[doc = "Bit 10 - Output compare 4 fast enable"]
#[inline (always)] pub fn oc4fe (& mut self) -> Oc4feW < '_ , Ccmr2OutputSpec > { Oc4feW :: new (self , 10) }
#[doc = "Bit 11 - Output compare 4 preload enable"]
#[inline (always)] pub fn oc4pe (& mut self) -> Oc4peW < '_ , Ccmr2OutputSpec > { Oc4peW :: new (self , 11) }
#[doc = "Bits 12:14 - Output compare 4 mode"]
#[inline (always)] pub fn oc4m (& mut self) -> Oc4mW < '_ , Ccmr2OutputSpec > { Oc4mW :: new (self , 12) }
#[doc = "Bit 15 - Output compare 4 clear enable"]
#[inline (always)] pub fn oc4ce (& mut self) -> Oc4ceW < '_ , Ccmr2OutputSpec > { Oc4ceW :: new (self , 15) }
#[doc = "Bit 16 - Output Compare 3 mode - bit 3"]
#[inline (always)] pub fn oc3m_3 (& mut self) -> Oc3m3W < '_ , Ccmr2OutputSpec > { Oc3m3W :: new (self , 16) }
#[doc = "Bit 24 - Output Compare 4 mode - bit 3"]
#[inline (always)] pub fn oc4m_3 (& mut self) -> Oc4m3W < '_ , Ccmr2OutputSpec > { Oc4m3W :: new (self , 24) } }
#[doc = "capture/compare mode register 2 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_output::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_output::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr2OutputSpec ; impl crate :: RegisterSpec for Ccmr2OutputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr2_output::R`](R) reader structure"] impl crate :: Readable for Ccmr2OutputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr2_output::W`](W) writer structure"] impl crate :: Writable for Ccmr2OutputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR2_Output to value 0"] impl crate :: Resettable for Ccmr2OutputSpec { } }
#[doc = "CCMR2_Input (rw) register accessor: capture/compare mode register 2 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_input::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_input::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr2_input`] module"]
#[doc (alias = "CCMR2_Input")] pub type Ccmr2Input = crate :: Reg < ccmr2_input :: Ccmr2InputSpec > ;
#[doc = "capture/compare mode register 2 (output mode)"] pub mod ccmr2_input {
#[doc = "Register `CCMR2_Input` reader"] pub type R = crate :: R < Ccmr2InputSpec > ;
#[doc = "Register `CCMR2_Input` writer"] pub type W = crate :: W < Ccmr2InputSpec > ;
#[doc = "Field `CC3S` reader - Capture/Compare 3 selection"] pub type Cc3sR = crate :: FieldReader ;
#[doc = "Field `CC3S` writer - Capture/Compare 3 selection"] pub type Cc3sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `C3PSC` reader - Input capture 3 prescaler"] pub type C3pscR = crate :: FieldReader ;
#[doc = "Field `C3PSC` writer - Input capture 3 prescaler"] pub type C3pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC3F` reader - Input capture 3 filter"] pub type Ic3fR = crate :: FieldReader ;
#[doc = "Field `IC3F` writer - Input capture 3 filter"] pub type Ic3fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `CC4S` reader - Capture/Compare 4 selection"] pub type Cc4sR = crate :: FieldReader ;
#[doc = "Field `CC4S` writer - Capture/Compare 4 selection"] pub type Cc4sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC4PSC` reader - Input capture 4 prescaler"] pub type Ic4pscR = crate :: FieldReader ;
#[doc = "Field `IC4PSC` writer - Input capture 4 prescaler"] pub type Ic4pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC4F` reader - Input capture 4 filter"] pub type Ic4fR = crate :: FieldReader ;
#[doc = "Field `IC4F` writer - Input capture 4 filter"] pub type Ic4fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 3 selection"]
#[inline (always)] pub fn cc3s (& self) -> Cc3sR { Cc3sR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Input capture 3 prescaler"]
#[inline (always)] pub fn c3psc (& self) -> C3pscR { C3pscR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:7 - Input capture 3 filter"]
#[inline (always)] pub fn ic3f (& self) -> Ic3fR { Ic3fR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& self) -> Cc4sR { Cc4sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Input capture 4 prescaler"]
#[inline (always)] pub fn ic4psc (& self) -> Ic4pscR { Ic4pscR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:15 - Input capture 4 filter"]
#[inline (always)] pub fn ic4f (& self) -> Ic4fR { Ic4fR :: new (((self . bits >> 12) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 3 selection"]
#[inline (always)] pub fn cc3s (& mut self) -> Cc3sW < '_ , Ccmr2InputSpec > { Cc3sW :: new (self , 0) }
#[doc = "Bits 2:3 - Input capture 3 prescaler"]
#[inline (always)] pub fn c3psc (& mut self) -> C3pscW < '_ , Ccmr2InputSpec > { C3pscW :: new (self , 2) }
#[doc = "Bits 4:7 - Input capture 3 filter"]
#[inline (always)] pub fn ic3f (& mut self) -> Ic3fW < '_ , Ccmr2InputSpec > { Ic3fW :: new (self , 4) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& mut self) -> Cc4sW < '_ , Ccmr2InputSpec > { Cc4sW :: new (self , 8) }
#[doc = "Bits 10:11 - Input capture 4 prescaler"]
#[inline (always)] pub fn ic4psc (& mut self) -> Ic4pscW < '_ , Ccmr2InputSpec > { Ic4pscW :: new (self , 10) }
#[doc = "Bits 12:15 - Input capture 4 filter"]
#[inline (always)] pub fn ic4f (& mut self) -> Ic4fW < '_ , Ccmr2InputSpec > { Ic4fW :: new (self , 12) } }
#[doc = "capture/compare mode register 2 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_input::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_input::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr2InputSpec ; impl crate :: RegisterSpec for Ccmr2InputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr2_input::R`](R) reader structure"] impl crate :: Readable for Ccmr2InputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr2_input::W`](W) writer structure"] impl crate :: Writable for Ccmr2InputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR2_Input to value 0"] impl crate :: Resettable for Ccmr2InputSpec { } }
#[doc = "CCER (rw) register accessor: capture/compare enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccer::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccer::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccer`] module"]
#[doc (alias = "CCER")] pub type Ccer = crate :: Reg < ccer :: CcerSpec > ;
#[doc = "capture/compare enable register"] pub mod ccer {
#[doc = "Register `CCER` reader"] pub type R = crate :: R < CcerSpec > ;
#[doc = "Register `CCER` writer"] pub type W = crate :: W < CcerSpec > ;
#[doc = "Field `CC1E` reader - Capture/Compare 1 output enable"] pub type Cc1eR = crate :: BitReader ;
#[doc = "Field `CC1E` writer - Capture/Compare 1 output enable"] pub type Cc1eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1P` reader - Capture/Compare 1 output Polarity"] pub type Cc1pR = crate :: BitReader ;
#[doc = "Field `CC1P` writer - Capture/Compare 1 output Polarity"] pub type Cc1pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1NE` reader - Capture/Compare 1 complementary output enable"] pub type Cc1neR = crate :: BitReader ;
#[doc = "Field `CC1NE` writer - Capture/Compare 1 complementary output enable"] pub type Cc1neW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1NP` reader - Capture/Compare 1 output Polarity"] pub type Cc1npR = crate :: BitReader ;
#[doc = "Field `CC1NP` writer - Capture/Compare 1 output Polarity"] pub type Cc1npW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2E` reader - Capture/Compare 2 output enable"] pub type Cc2eR = crate :: BitReader ;
#[doc = "Field `CC2E` writer - Capture/Compare 2 output enable"] pub type Cc2eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2P` reader - Capture/Compare 2 output Polarity"] pub type Cc2pR = crate :: BitReader ;
#[doc = "Field `CC2P` writer - Capture/Compare 2 output Polarity"] pub type Cc2pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2NE` reader - Capture/Compare 2 complementary output enable"] pub type Cc2neR = crate :: BitReader ;
#[doc = "Field `CC2NE` writer - Capture/Compare 2 complementary output enable"] pub type Cc2neW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2NP` reader - Capture/Compare 2 output Polarity"] pub type Cc2npR = crate :: BitReader ;
#[doc = "Field `CC2NP` writer - Capture/Compare 2 output Polarity"] pub type Cc2npW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3E` reader - Capture/Compare 3 output enable"] pub type Cc3eR = crate :: BitReader ;
#[doc = "Field `CC3E` writer - Capture/Compare 3 output enable"] pub type Cc3eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3P` reader - Capture/Compare 3 output Polarity"] pub type Cc3pR = crate :: BitReader ;
#[doc = "Field `CC3P` writer - Capture/Compare 3 output Polarity"] pub type Cc3pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3NE` reader - Capture/Compare 3 complementary output enable"] pub type Cc3neR = crate :: BitReader ;
#[doc = "Field `CC3NE` writer - Capture/Compare 3 complementary output enable"] pub type Cc3neW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3NP` reader - Capture/Compare 3 output Polarity"] pub type Cc3npR = crate :: BitReader ;
#[doc = "Field `CC3NP` writer - Capture/Compare 3 output Polarity"] pub type Cc3npW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4E` reader - Capture/Compare 4 output enable"] pub type Cc4eR = crate :: BitReader ;
#[doc = "Field `CC4E` writer - Capture/Compare 4 output enable"] pub type Cc4eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4P` reader - Capture/Compare 3 output Polarity"] pub type Cc4pR = crate :: BitReader ;
#[doc = "Field `CC4P` writer - Capture/Compare 3 output Polarity"] pub type Cc4pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4NP` reader - Capture/Compare 4 complementary output polarity"] pub type Cc4npR = crate :: BitReader ;
#[doc = "Field `CC4NP` writer - Capture/Compare 4 complementary output polarity"] pub type Cc4npW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC5E` reader - Capture/Compare 5 output enable"] pub type Cc5eR = crate :: BitReader ;
#[doc = "Field `CC5E` writer - Capture/Compare 5 output enable"] pub type Cc5eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC5P` reader - Capture/Compare 5 output polarity"] pub type Cc5pR = crate :: BitReader ;
#[doc = "Field `CC5P` writer - Capture/Compare 5 output polarity"] pub type Cc5pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC6E` reader - Capture/Compare 6 output enable"] pub type Cc6eR = crate :: BitReader ;
#[doc = "Field `CC6E` writer - Capture/Compare 6 output enable"] pub type Cc6eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC6P` reader - Capture/Compare 6 output polarity"] pub type Cc6pR = crate :: BitReader ;
#[doc = "Field `CC6P` writer - Capture/Compare 6 output polarity"] pub type Cc6pW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Capture/Compare 1 output enable"]
#[inline (always)] pub fn cc1e (& self) -> Cc1eR { Cc1eR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1p (& self) -> Cc1pR { Cc1pR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
#[inline (always)] pub fn cc1ne (& self) -> Cc1neR { Cc1neR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1np (& self) -> Cc1npR { Cc1npR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Capture/Compare 2 output enable"]
#[inline (always)] pub fn cc2e (& self) -> Cc2eR { Cc2eR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
#[inline (always)] pub fn cc2p (& self) -> Cc2pR { Cc2pR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Capture/Compare 2 complementary output enable"]
#[inline (always)] pub fn cc2ne (& self) -> Cc2neR { Cc2neR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
#[inline (always)] pub fn cc2np (& self) -> Cc2npR { Cc2npR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Capture/Compare 3 output enable"]
#[inline (always)] pub fn cc3e (& self) -> Cc3eR { Cc3eR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 3 output Polarity"]
#[inline (always)] pub fn cc3p (& self) -> Cc3pR { Cc3pR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Capture/Compare 3 complementary output enable"]
#[inline (always)] pub fn cc3ne (& self) -> Cc3neR { Cc3neR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Capture/Compare 3 output Polarity"]
#[inline (always)] pub fn cc3np (& self) -> Cc3npR { Cc3npR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Capture/Compare 4 output enable"]
#[inline (always)] pub fn cc4e (& self) -> Cc4eR { Cc4eR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Capture/Compare 3 output Polarity"]
#[inline (always)] pub fn cc4p (& self) -> Cc4pR { Cc4pR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 15 - Capture/Compare 4 complementary output polarity"]
#[inline (always)] pub fn cc4np (& self) -> Cc4npR { Cc4npR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Capture/Compare 5 output enable"]
#[inline (always)] pub fn cc5e (& self) -> Cc5eR { Cc5eR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Capture/Compare 5 output polarity"]
#[inline (always)] pub fn cc5p (& self) -> Cc5pR { Cc5pR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 20 - Capture/Compare 6 output enable"]
#[inline (always)] pub fn cc6e (& self) -> Cc6eR { Cc6eR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Capture/Compare 6 output polarity"]
#[inline (always)] pub fn cc6p (& self) -> Cc6pR { Cc6pR :: new (((self . bits >> 21) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Capture/Compare 1 output enable"]
#[inline (always)] pub fn cc1e (& mut self) -> Cc1eW < '_ , CcerSpec > { Cc1eW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1p (& mut self) -> Cc1pW < '_ , CcerSpec > { Cc1pW :: new (self , 1) }
#[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
#[inline (always)] pub fn cc1ne (& mut self) -> Cc1neW < '_ , CcerSpec > { Cc1neW :: new (self , 2) }
#[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1np (& mut self) -> Cc1npW < '_ , CcerSpec > { Cc1npW :: new (self , 3) }
#[doc = "Bit 4 - Capture/Compare 2 output enable"]
#[inline (always)] pub fn cc2e (& mut self) -> Cc2eW < '_ , CcerSpec > { Cc2eW :: new (self , 4) }
#[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
#[inline (always)] pub fn cc2p (& mut self) -> Cc2pW < '_ , CcerSpec > { Cc2pW :: new (self , 5) }
#[doc = "Bit 6 - Capture/Compare 2 complementary output enable"]
#[inline (always)] pub fn cc2ne (& mut self) -> Cc2neW < '_ , CcerSpec > { Cc2neW :: new (self , 6) }
#[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
#[inline (always)] pub fn cc2np (& mut self) -> Cc2npW < '_ , CcerSpec > { Cc2npW :: new (self , 7) }
#[doc = "Bit 8 - Capture/Compare 3 output enable"]
#[inline (always)] pub fn cc3e (& mut self) -> Cc3eW < '_ , CcerSpec > { Cc3eW :: new (self , 8) }
#[doc = "Bit 9 - Capture/Compare 3 output Polarity"]
#[inline (always)] pub fn cc3p (& mut self) -> Cc3pW < '_ , CcerSpec > { Cc3pW :: new (self , 9) }
#[doc = "Bit 10 - Capture/Compare 3 complementary output enable"]
#[inline (always)] pub fn cc3ne (& mut self) -> Cc3neW < '_ , CcerSpec > { Cc3neW :: new (self , 10) }
#[doc = "Bit 11 - Capture/Compare 3 output Polarity"]
#[inline (always)] pub fn cc3np (& mut self) -> Cc3npW < '_ , CcerSpec > { Cc3npW :: new (self , 11) }
#[doc = "Bit 12 - Capture/Compare 4 output enable"]
#[inline (always)] pub fn cc4e (& mut self) -> Cc4eW < '_ , CcerSpec > { Cc4eW :: new (self , 12) }
#[doc = "Bit 13 - Capture/Compare 3 output Polarity"]
#[inline (always)] pub fn cc4p (& mut self) -> Cc4pW < '_ , CcerSpec > { Cc4pW :: new (self , 13) }
#[doc = "Bit 15 - Capture/Compare 4 complementary output polarity"]
#[inline (always)] pub fn cc4np (& mut self) -> Cc4npW < '_ , CcerSpec > { Cc4npW :: new (self , 15) }
#[doc = "Bit 16 - Capture/Compare 5 output enable"]
#[inline (always)] pub fn cc5e (& mut self) -> Cc5eW < '_ , CcerSpec > { Cc5eW :: new (self , 16) }
#[doc = "Bit 17 - Capture/Compare 5 output polarity"]
#[inline (always)] pub fn cc5p (& mut self) -> Cc5pW < '_ , CcerSpec > { Cc5pW :: new (self , 17) }
#[doc = "Bit 20 - Capture/Compare 6 output enable"]
#[inline (always)] pub fn cc6e (& mut self) -> Cc6eW < '_ , CcerSpec > { Cc6eW :: new (self , 20) }
#[doc = "Bit 21 - Capture/Compare 6 output polarity"]
#[inline (always)] pub fn cc6p (& mut self) -> Cc6pW < '_ , CcerSpec > { Cc6pW :: new (self , 21) } }
#[doc = "capture/compare enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccer::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccer::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CcerSpec ; impl crate :: RegisterSpec for CcerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccer::R`](R) reader structure"] impl crate :: Readable for CcerSpec { }
#[doc = "`write(|w| ..)` method takes [`ccer::W`](W) writer structure"] impl crate :: Writable for CcerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCER to value 0"] impl crate :: Resettable for CcerSpec { } }
#[doc = "CNT (rw) register accessor: counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt`] module"]
#[doc (alias = "CNT")] pub type Cnt = crate :: Reg < cnt :: CntSpec > ;
#[doc = "counter"] pub mod cnt {
#[doc = "Register `CNT` reader"] pub type R = crate :: R < CntSpec > ;
#[doc = "Register `CNT` writer"] pub type W = crate :: W < CntSpec > ;
#[doc = "Field `CNT` reader - counter value"] pub type CntR = crate :: FieldReader < u16 > ;
#[doc = "Field `CNT` writer - counter value"] pub type CntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `UIFCPY` reader - UIF copy"] pub type UifcpyR = crate :: BitReader ; impl R {
#[doc = "Bits 0:15 - counter value"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bit 31 - UIF copy"]
#[inline (always)] pub fn uifcpy (& self) -> UifcpyR { UifcpyR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:15 - counter value"]
#[inline (always)] pub fn cnt (& mut self) -> CntW < '_ , CntSpec > { CntW :: new (self , 0) } }
#[doc = "counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CntSpec ; impl crate :: RegisterSpec for CntSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cnt::R`](R) reader structure"] impl crate :: Readable for CntSpec { }
#[doc = "`write(|w| ..)` method takes [`cnt::W`](W) writer structure"] impl crate :: Writable for CntSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNT to value 0"] impl crate :: Resettable for CntSpec { } }
#[doc = "PSC (rw) register accessor: prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@psc`] module"]
#[doc (alias = "PSC")] pub type Psc = crate :: Reg < psc :: PscSpec > ;
#[doc = "prescaler"] pub mod psc {
#[doc = "Register `PSC` reader"] pub type R = crate :: R < PscSpec > ;
#[doc = "Register `PSC` writer"] pub type W = crate :: W < PscSpec > ;
#[doc = "Field `PSC` reader - Prescaler value"] pub type PscR = crate :: FieldReader < u16 > ;
#[doc = "Field `PSC` writer - Prescaler value"] pub type PscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& self) -> PscR { PscR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& mut self) -> PscW < '_ , PscSpec > { PscW :: new (self , 0) } }
#[doc = "prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PscSpec ; impl crate :: RegisterSpec for PscSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`psc::R`](R) reader structure"] impl crate :: Readable for PscSpec { }
#[doc = "`write(|w| ..)` method takes [`psc::W`](W) writer structure"] impl crate :: Writable for PscSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PSC to value 0"] impl crate :: Resettable for PscSpec { } }
#[doc = "ARR (rw) register accessor: auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@arr`] module"]
#[doc (alias = "ARR")] pub type Arr = crate :: Reg < arr :: ArrSpec > ;
#[doc = "auto-reload register"] pub mod arr {
#[doc = "Register `ARR` reader"] pub type R = crate :: R < ArrSpec > ;
#[doc = "Register `ARR` writer"] pub type W = crate :: W < ArrSpec > ;
#[doc = "Field `ARR` reader - Auto-reload value"] pub type ArrR = crate :: FieldReader < u16 > ;
#[doc = "Field `ARR` writer - Auto-reload value"] pub type ArrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Auto-reload value"]
#[inline (always)] pub fn arr (& self) -> ArrR { ArrR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Auto-reload value"]
#[inline (always)] pub fn arr (& mut self) -> ArrW < '_ , ArrSpec > { ArrW :: new (self , 0) } }
#[doc = "auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ArrSpec ; impl crate :: RegisterSpec for ArrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`arr::R`](R) reader structure"] impl crate :: Readable for ArrSpec { }
#[doc = "`write(|w| ..)` method takes [`arr::W`](W) writer structure"] impl crate :: Writable for ArrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ARR to value 0xffff"] impl crate :: Resettable for ArrSpec { const RESET_VALUE : u32 = 0xffff ; } }
#[doc = "RCR (rw) register accessor: repetition counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`rcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rcr`] module"]
#[doc (alias = "RCR")] pub type Rcr = crate :: Reg < rcr :: RcrSpec > ;
#[doc = "repetition counter register"] pub mod rcr {
#[doc = "Register `RCR` reader"] pub type R = crate :: R < RcrSpec > ;
#[doc = "Register `RCR` writer"] pub type W = crate :: W < RcrSpec > ;
#[doc = "Field `REP` reader - Repetition counter value"] pub type RepR = crate :: FieldReader < u16 > ;
#[doc = "Field `REP` writer - Repetition counter value"] pub type RepW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Repetition counter value"]
#[inline (always)] pub fn rep (& self) -> RepR { RepR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Repetition counter value"]
#[inline (always)] pub fn rep (& mut self) -> RepW < '_ , RcrSpec > { RepW :: new (self , 0) } }
#[doc = "repetition counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`rcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RcrSpec ; impl crate :: RegisterSpec for RcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rcr::R`](R) reader structure"] impl crate :: Readable for RcrSpec { }
#[doc = "`write(|w| ..)` method takes [`rcr::W`](W) writer structure"] impl crate :: Writable for RcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RCR to value 0"] impl crate :: Resettable for RcrSpec { } }
#[doc = "CCR1 (rw) register accessor: capture/compare register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr1`] module"]
#[doc (alias = "CCR1")] pub type Ccr1 = crate :: Reg < ccr1 :: Ccr1Spec > ;
#[doc = "capture/compare register 1"] pub mod ccr1 {
#[doc = "Register `CCR1` reader"] pub type R = crate :: R < Ccr1Spec > ;
#[doc = "Register `CCR1` writer"] pub type W = crate :: W < Ccr1Spec > ;
#[doc = "Field `CCR1` reader - Capture/Compare 1 value"] pub type Ccr1R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR1` writer - Capture/Compare 1 value"] pub type Ccr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare 1 value"]
#[inline (always)] pub fn ccr1 (& self) -> Ccr1R { Ccr1R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare 1 value"]
#[inline (always)] pub fn ccr1 (& mut self) -> Ccr1W < '_ , Ccr1Spec > { Ccr1W :: new (self , 0) } }
#[doc = "capture/compare register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr1Spec ; impl crate :: RegisterSpec for Ccr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr1::R`](R) reader structure"] impl crate :: Readable for Ccr1Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr1::W`](W) writer structure"] impl crate :: Writable for Ccr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR1 to value 0"] impl crate :: Resettable for Ccr1Spec { } }
#[doc = "CCR2 (rw) register accessor: capture/compare register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr2`] module"]
#[doc (alias = "CCR2")] pub type Ccr2 = crate :: Reg < ccr2 :: Ccr2Spec > ;
#[doc = "capture/compare register 2"] pub mod ccr2 {
#[doc = "Register `CCR2` reader"] pub type R = crate :: R < Ccr2Spec > ;
#[doc = "Register `CCR2` writer"] pub type W = crate :: W < Ccr2Spec > ;
#[doc = "Field `CCR2` reader - Capture/Compare 2 value"] pub type Ccr2R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR2` writer - Capture/Compare 2 value"] pub type Ccr2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare 2 value"]
#[inline (always)] pub fn ccr2 (& self) -> Ccr2R { Ccr2R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare 2 value"]
#[inline (always)] pub fn ccr2 (& mut self) -> Ccr2W < '_ , Ccr2Spec > { Ccr2W :: new (self , 0) } }
#[doc = "capture/compare register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr2Spec ; impl crate :: RegisterSpec for Ccr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr2::R`](R) reader structure"] impl crate :: Readable for Ccr2Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr2::W`](W) writer structure"] impl crate :: Writable for Ccr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR2 to value 0"] impl crate :: Resettable for Ccr2Spec { } }
#[doc = "CCR3 (rw) register accessor: capture/compare register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr3`] module"]
#[doc (alias = "CCR3")] pub type Ccr3 = crate :: Reg < ccr3 :: Ccr3Spec > ;
#[doc = "capture/compare register 3"] pub mod ccr3 {
#[doc = "Register `CCR3` reader"] pub type R = crate :: R < Ccr3Spec > ;
#[doc = "Register `CCR3` writer"] pub type W = crate :: W < Ccr3Spec > ;
#[doc = "Field `CCR3` reader - Capture/Compare value"] pub type Ccr3R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR3` writer - Capture/Compare value"] pub type Ccr3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare value"]
#[inline (always)] pub fn ccr3 (& self) -> Ccr3R { Ccr3R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare value"]
#[inline (always)] pub fn ccr3 (& mut self) -> Ccr3W < '_ , Ccr3Spec > { Ccr3W :: new (self , 0) } }
#[doc = "capture/compare register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr3Spec ; impl crate :: RegisterSpec for Ccr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr3::R`](R) reader structure"] impl crate :: Readable for Ccr3Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr3::W`](W) writer structure"] impl crate :: Writable for Ccr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR3 to value 0"] impl crate :: Resettable for Ccr3Spec { } }
#[doc = "CCR4 (rw) register accessor: capture/compare register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr4`] module"]
#[doc (alias = "CCR4")] pub type Ccr4 = crate :: Reg < ccr4 :: Ccr4Spec > ;
#[doc = "capture/compare register 4"] pub mod ccr4 {
#[doc = "Register `CCR4` reader"] pub type R = crate :: R < Ccr4Spec > ;
#[doc = "Register `CCR4` writer"] pub type W = crate :: W < Ccr4Spec > ;
#[doc = "Field `CCR4` reader - Capture/Compare value"] pub type Ccr4R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR4` writer - Capture/Compare value"] pub type Ccr4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare value"]
#[inline (always)] pub fn ccr4 (& self) -> Ccr4R { Ccr4R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare value"]
#[inline (always)] pub fn ccr4 (& mut self) -> Ccr4W < '_ , Ccr4Spec > { Ccr4W :: new (self , 0) } }
#[doc = "capture/compare register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr4Spec ; impl crate :: RegisterSpec for Ccr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr4::R`](R) reader structure"] impl crate :: Readable for Ccr4Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr4::W`](W) writer structure"] impl crate :: Writable for Ccr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR4 to value 0"] impl crate :: Resettable for Ccr4Spec { } }
#[doc = "BDTR (rw) register accessor: break and dead-time register\n\nYou can [`read`](crate::Reg::read) this register and get [`bdtr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bdtr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bdtr`] module"]
#[doc (alias = "BDTR")] pub type Bdtr = crate :: Reg < bdtr :: BdtrSpec > ;
#[doc = "break and dead-time register"] pub mod bdtr {
#[doc = "Register `BDTR` reader"] pub type R = crate :: R < BdtrSpec > ;
#[doc = "Register `BDTR` writer"] pub type W = crate :: W < BdtrSpec > ;
#[doc = "Field `DTG` reader - Dead-time generator setup"] pub type DtgR = crate :: FieldReader ;
#[doc = "Field `DTG` writer - Dead-time generator setup"] pub type DtgW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `LOCK` reader - Lock configuration"] pub type LockR = crate :: FieldReader ;
#[doc = "Field `LOCK` writer - Lock configuration"] pub type LockW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSSI` reader - Off-state selection for Idle mode"] pub type OssiR = crate :: BitReader ;
#[doc = "Field `OSSI` writer - Off-state selection for Idle mode"] pub type OssiW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OSSR` reader - Off-state selection for Run mode"] pub type OssrR = crate :: BitReader ;
#[doc = "Field `OSSR` writer - Off-state selection for Run mode"] pub type OssrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKE` reader - Break enable"] pub type BkeR = crate :: BitReader ;
#[doc = "Field `BKE` writer - Break enable"] pub type BkeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKP` reader - Break polarity"] pub type BkpR = crate :: BitReader ;
#[doc = "Field `BKP` writer - Break polarity"] pub type BkpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AOE` reader - Automatic output enable"] pub type AoeR = crate :: BitReader ;
#[doc = "Field `AOE` writer - Automatic output enable"] pub type AoeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MOE` reader - Main output enable"] pub type MoeR = crate :: BitReader ;
#[doc = "Field `MOE` writer - Main output enable"] pub type MoeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKF` reader - Break filter"] pub type BkfR = crate :: FieldReader ;
#[doc = "Field `BKF` writer - Break filter"] pub type BkfW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `BK2F` reader - Break 2 filter"] pub type Bk2fR = crate :: FieldReader ;
#[doc = "Field `BK2F` writer - Break 2 filter"] pub type Bk2fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `BK2E` reader - Break 2 enable"] pub type Bk2eR = crate :: BitReader ;
#[doc = "Field `BK2E` writer - Break 2 enable"] pub type Bk2eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BK2P` reader - Break 2 polarity"] pub type Bk2pR = crate :: BitReader ;
#[doc = "Field `BK2P` writer - Break 2 polarity"] pub type Bk2pW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Dead-time generator setup"]
#[inline (always)] pub fn dtg (& self) -> DtgR { DtgR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:9 - Lock configuration"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 10 - Off-state selection for Idle mode"]
#[inline (always)] pub fn ossi (& self) -> OssiR { OssiR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Off-state selection for Run mode"]
#[inline (always)] pub fn ossr (& self) -> OssrR { OssrR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Break enable"]
#[inline (always)] pub fn bke (& self) -> BkeR { BkeR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Break polarity"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Automatic output enable"]
#[inline (always)] pub fn aoe (& self) -> AoeR { AoeR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Main output enable"]
#[inline (always)] pub fn moe (& self) -> MoeR { MoeR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bits 16:19 - Break filter"]
#[inline (always)] pub fn bkf (& self) -> BkfR { BkfR :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bits 20:23 - Break 2 filter"]
#[inline (always)] pub fn bk2f (& self) -> Bk2fR { Bk2fR :: new (((self . bits >> 20) & 0x0f) as u8) }
#[doc = "Bit 24 - Break 2 enable"]
#[inline (always)] pub fn bk2e (& self) -> Bk2eR { Bk2eR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Break 2 polarity"]
#[inline (always)] pub fn bk2p (& self) -> Bk2pR { Bk2pR :: new (((self . bits >> 25) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Dead-time generator setup"]
#[inline (always)] pub fn dtg (& mut self) -> DtgW < '_ , BdtrSpec > { DtgW :: new (self , 0) }
#[doc = "Bits 8:9 - Lock configuration"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , BdtrSpec > { LockW :: new (self , 8) }
#[doc = "Bit 10 - Off-state selection for Idle mode"]
#[inline (always)] pub fn ossi (& mut self) -> OssiW < '_ , BdtrSpec > { OssiW :: new (self , 10) }
#[doc = "Bit 11 - Off-state selection for Run mode"]
#[inline (always)] pub fn ossr (& mut self) -> OssrW < '_ , BdtrSpec > { OssrW :: new (self , 11) }
#[doc = "Bit 12 - Break enable"]
#[inline (always)] pub fn bke (& mut self) -> BkeW < '_ , BdtrSpec > { BkeW :: new (self , 12) }
#[doc = "Bit 13 - Break polarity"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , BdtrSpec > { BkpW :: new (self , 13) }
#[doc = "Bit 14 - Automatic output enable"]
#[inline (always)] pub fn aoe (& mut self) -> AoeW < '_ , BdtrSpec > { AoeW :: new (self , 14) }
#[doc = "Bit 15 - Main output enable"]
#[inline (always)] pub fn moe (& mut self) -> MoeW < '_ , BdtrSpec > { MoeW :: new (self , 15) }
#[doc = "Bits 16:19 - Break filter"]
#[inline (always)] pub fn bkf (& mut self) -> BkfW < '_ , BdtrSpec > { BkfW :: new (self , 16) }
#[doc = "Bits 20:23 - Break 2 filter"]
#[inline (always)] pub fn bk2f (& mut self) -> Bk2fW < '_ , BdtrSpec > { Bk2fW :: new (self , 20) }
#[doc = "Bit 24 - Break 2 enable"]
#[inline (always)] pub fn bk2e (& mut self) -> Bk2eW < '_ , BdtrSpec > { Bk2eW :: new (self , 24) }
#[doc = "Bit 25 - Break 2 polarity"]
#[inline (always)] pub fn bk2p (& mut self) -> Bk2pW < '_ , BdtrSpec > { Bk2pW :: new (self , 25) } }
#[doc = "break and dead-time register\n\nYou can [`read`](crate::Reg::read) this register and get [`bdtr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bdtr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BdtrSpec ; impl crate :: RegisterSpec for BdtrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bdtr::R`](R) reader structure"] impl crate :: Readable for BdtrSpec { }
#[doc = "`write(|w| ..)` method takes [`bdtr::W`](W) writer structure"] impl crate :: Writable for BdtrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BDTR to value 0"] impl crate :: Resettable for BdtrSpec { } }
#[doc = "DCR (rw) register accessor: DMA control register\n\nYou can [`read`](crate::Reg::read) this register and get [`dcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dcr`] module"]
#[doc (alias = "DCR")] pub type Dcr = crate :: Reg < dcr :: DcrSpec > ;
#[doc = "DMA control register"] pub mod dcr {
#[doc = "Register `DCR` reader"] pub type R = crate :: R < DcrSpec > ;
#[doc = "Register `DCR` writer"] pub type W = crate :: W < DcrSpec > ;
#[doc = "Field `DBA` reader - DMA base address"] pub type DbaR = crate :: FieldReader ;
#[doc = "Field `DBA` writer - DMA base address"] pub type DbaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `DBL` reader - DMA burst length"] pub type DblR = crate :: FieldReader ;
#[doc = "Field `DBL` writer - DMA burst length"] pub type DblW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:4 - DMA base address"]
#[inline (always)] pub fn dba (& self) -> DbaR { DbaR :: new ((self . bits & 0x1f) as u8) }
#[doc = "Bits 8:12 - DMA burst length"]
#[inline (always)] pub fn dbl (& self) -> DblR { DblR :: new (((self . bits >> 8) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:4 - DMA base address"]
#[inline (always)] pub fn dba (& mut self) -> DbaW < '_ , DcrSpec > { DbaW :: new (self , 0) }
#[doc = "Bits 8:12 - DMA burst length"]
#[inline (always)] pub fn dbl (& mut self) -> DblW < '_ , DcrSpec > { DblW :: new (self , 8) } }
#[doc = "DMA control register\n\nYou can [`read`](crate::Reg::read) this register and get [`dcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DcrSpec ; impl crate :: RegisterSpec for DcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dcr::R`](R) reader structure"] impl crate :: Readable for DcrSpec { }
#[doc = "`write(|w| ..)` method takes [`dcr::W`](W) writer structure"] impl crate :: Writable for DcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DCR to value 0"] impl crate :: Resettable for DcrSpec { } }
#[doc = "DMAR (rw) register accessor: DMA address for full transfer\n\nYou can [`read`](crate::Reg::read) this register and get [`dmar::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmar::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dmar`] module"]
#[doc (alias = "DMAR")] pub type Dmar = crate :: Reg < dmar :: DmarSpec > ;
#[doc = "DMA address for full transfer"] pub mod dmar {
#[doc = "Register `DMAR` reader"] pub type R = crate :: R < DmarSpec > ;
#[doc = "Register `DMAR` writer"] pub type W = crate :: W < DmarSpec > ;
#[doc = "Field `DMAB` reader - DMA register for burst accesses"] pub type DmabR = crate :: FieldReader < u16 > ;
#[doc = "Field `DMAB` writer - DMA register for burst accesses"] pub type DmabW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - DMA register for burst accesses"]
#[inline (always)] pub fn dmab (& self) -> DmabR { DmabR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - DMA register for burst accesses"]
#[inline (always)] pub fn dmab (& mut self) -> DmabW < '_ , DmarSpec > { DmabW :: new (self , 0) } }
#[doc = "DMA address for full transfer\n\nYou can [`read`](crate::Reg::read) this register and get [`dmar::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmar::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DmarSpec ; impl crate :: RegisterSpec for DmarSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dmar::R`](R) reader structure"] impl crate :: Readable for DmarSpec { }
#[doc = "`write(|w| ..)` method takes [`dmar::W`](W) writer structure"] impl crate :: Writable for DmarSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMAR to value 0"] impl crate :: Resettable for DmarSpec { } }
#[doc = "OR (rw) register accessor: DMA address for full transfer\n\nYou can [`read`](crate::Reg::read) this register and get [`or::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`or::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@or`] module"]
#[doc (alias = "OR")] pub type Or = crate :: Reg < or :: OrSpec > ;
#[doc = "DMA address for full transfer"] pub mod or {
#[doc = "Register `OR` reader"] pub type R = crate :: R < OrSpec > ;
#[doc = "Register `OR` writer"] pub type W = crate :: W < OrSpec > ;
#[doc = "Field `TIM1_ETR_ADC1_RMP` reader - TIM1_ETR_ADC1 remapping capability"] pub type Tim1EtrAdc1RmpR = crate :: FieldReader ;
#[doc = "Field `TIM1_ETR_ADC1_RMP` writer - TIM1_ETR_ADC1 remapping capability"] pub type Tim1EtrAdc1RmpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `TI1_RMP` reader - Input Capture 1 remap"] pub type Ti1RmpR = crate :: BitReader ;
#[doc = "Field `TI1_RMP` writer - Input Capture 1 remap"] pub type Ti1RmpW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - TIM1_ETR_ADC1 remapping capability"]
#[inline (always)] pub fn tim1_etr_adc1_rmp (& self) -> Tim1EtrAdc1RmpR { Tim1EtrAdc1RmpR :: new ((self . bits & 3) as u8) }
#[doc = "Bit 4 - Input Capture 1 remap"]
#[inline (always)] pub fn ti1_rmp (& self) -> Ti1RmpR { Ti1RmpR :: new (((self . bits >> 4) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - TIM1_ETR_ADC1 remapping capability"]
#[inline (always)] pub fn tim1_etr_adc1_rmp (& mut self) -> Tim1EtrAdc1RmpW < '_ , OrSpec > { Tim1EtrAdc1RmpW :: new (self , 0) }
#[doc = "Bit 4 - Input Capture 1 remap"]
#[inline (always)] pub fn ti1_rmp (& mut self) -> Ti1RmpW < '_ , OrSpec > { Ti1RmpW :: new (self , 4) } }
#[doc = "DMA address for full transfer\n\nYou can [`read`](crate::Reg::read) this register and get [`or::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`or::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OrSpec ; impl crate :: RegisterSpec for OrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`or::R`](R) reader structure"] impl crate :: Readable for OrSpec { }
#[doc = "`write(|w| ..)` method takes [`or::W`](W) writer structure"] impl crate :: Writable for OrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OR to value 0"] impl crate :: Resettable for OrSpec { } }
#[doc = "CCMR3_Output (rw) register accessor: capture/compare mode register 2 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr3_output::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr3_output::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr3_output`] module"]
#[doc (alias = "CCMR3_Output")] pub type Ccmr3Output = crate :: Reg < ccmr3_output :: Ccmr3OutputSpec > ;
#[doc = "capture/compare mode register 2 (output mode)"] pub mod ccmr3_output {
#[doc = "Register `CCMR3_Output` reader"] pub type R = crate :: R < Ccmr3OutputSpec > ;
#[doc = "Register `CCMR3_Output` writer"] pub type W = crate :: W < Ccmr3OutputSpec > ;
#[doc = "Field `OC5FE` reader - Output compare 5 fast enable"] pub type Oc5feR = crate :: BitReader ;
#[doc = "Field `OC5FE` writer - Output compare 5 fast enable"] pub type Oc5feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC5PE` reader - Output compare 5 preload enable"] pub type Oc5peR = crate :: BitReader ;
#[doc = "Field `OC5PE` writer - Output compare 5 preload enable"] pub type Oc5peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC5M` reader - Output compare 5 mode"] pub type Oc5mR = crate :: FieldReader ;
#[doc = "Field `OC5M` writer - Output compare 5 mode"] pub type Oc5mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC5CE` reader - Output compare 5 clear enable"] pub type Oc5ceR = crate :: BitReader ;
#[doc = "Field `OC5CE` writer - Output compare 5 clear enable"] pub type Oc5ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC6FE` reader - Output compare 6 fast enable"] pub type Oc6feR = crate :: BitReader ;
#[doc = "Field `OC6FE` writer - Output compare 6 fast enable"] pub type Oc6feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC6PE` reader - Output compare 6 preload enable"] pub type Oc6peR = crate :: BitReader ;
#[doc = "Field `OC6PE` writer - Output compare 6 preload enable"] pub type Oc6peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC6M` reader - Output compare 6 mode"] pub type Oc6mR = crate :: FieldReader ;
#[doc = "Field `OC6M` writer - Output compare 6 mode"] pub type Oc6mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC6CE` reader - Output compare 6 clear enable"] pub type Oc6ceR = crate :: BitReader ;
#[doc = "Field `OC6CE` writer - Output compare 6 clear enable"] pub type Oc6ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC5M_bit3` reader - Output Compare 5 mode bit 3"] pub type Oc5mBit3R = crate :: BitReader ;
#[doc = "Field `OC5M_bit3` writer - Output Compare 5 mode bit 3"] pub type Oc5mBit3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC6M_bit3` reader - Output Compare 6 mode bit 3"] pub type Oc6mBit3R = crate :: BitReader ;
#[doc = "Field `OC6M_bit3` writer - Output Compare 6 mode bit 3"] pub type Oc6mBit3W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 2 - Output compare 5 fast enable"]
#[inline (always)] pub fn oc5fe (& self) -> Oc5feR { Oc5feR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Output compare 5 preload enable"]
#[inline (always)] pub fn oc5pe (& self) -> Oc5peR { Oc5peR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Output compare 5 mode"]
#[inline (always)] pub fn oc5m (& self) -> Oc5mR { Oc5mR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Output compare 5 clear enable"]
#[inline (always)] pub fn oc5ce (& self) -> Oc5ceR { Oc5ceR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 10 - Output compare 6 fast enable"]
#[inline (always)] pub fn oc6fe (& self) -> Oc6feR { Oc6feR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Output compare 6 preload enable"]
#[inline (always)] pub fn oc6pe (& self) -> Oc6peR { Oc6peR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:14 - Output compare 6 mode"]
#[inline (always)] pub fn oc6m (& self) -> Oc6mR { Oc6mR :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bit 15 - Output compare 6 clear enable"]
#[inline (always)] pub fn oc6ce (& self) -> Oc6ceR { Oc6ceR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Output Compare 5 mode bit 3"]
#[inline (always)] pub fn oc5m_bit3 (& self) -> Oc5mBit3R { Oc5mBit3R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 24 - Output Compare 6 mode bit 3"]
#[inline (always)] pub fn oc6m_bit3 (& self) -> Oc6mBit3R { Oc6mBit3R :: new (((self . bits >> 24) & 1) != 0) } } impl W {
#[doc = "Bit 2 - Output compare 5 fast enable"]
#[inline (always)] pub fn oc5fe (& mut self) -> Oc5feW < '_ , Ccmr3OutputSpec > { Oc5feW :: new (self , 2) }
#[doc = "Bit 3 - Output compare 5 preload enable"]
#[inline (always)] pub fn oc5pe (& mut self) -> Oc5peW < '_ , Ccmr3OutputSpec > { Oc5peW :: new (self , 3) }
#[doc = "Bits 4:6 - Output compare 5 mode"]
#[inline (always)] pub fn oc5m (& mut self) -> Oc5mW < '_ , Ccmr3OutputSpec > { Oc5mW :: new (self , 4) }
#[doc = "Bit 7 - Output compare 5 clear enable"]
#[inline (always)] pub fn oc5ce (& mut self) -> Oc5ceW < '_ , Ccmr3OutputSpec > { Oc5ceW :: new (self , 7) }
#[doc = "Bit 10 - Output compare 6 fast enable"]
#[inline (always)] pub fn oc6fe (& mut self) -> Oc6feW < '_ , Ccmr3OutputSpec > { Oc6feW :: new (self , 10) }
#[doc = "Bit 11 - Output compare 6 preload enable"]
#[inline (always)] pub fn oc6pe (& mut self) -> Oc6peW < '_ , Ccmr3OutputSpec > { Oc6peW :: new (self , 11) }
#[doc = "Bits 12:14 - Output compare 6 mode"]
#[inline (always)] pub fn oc6m (& mut self) -> Oc6mW < '_ , Ccmr3OutputSpec > { Oc6mW :: new (self , 12) }
#[doc = "Bit 15 - Output compare 6 clear enable"]
#[inline (always)] pub fn oc6ce (& mut self) -> Oc6ceW < '_ , Ccmr3OutputSpec > { Oc6ceW :: new (self , 15) }
#[doc = "Bit 16 - Output Compare 5 mode bit 3"]
#[inline (always)] pub fn oc5m_bit3 (& mut self) -> Oc5mBit3W < '_ , Ccmr3OutputSpec > { Oc5mBit3W :: new (self , 16) }
#[doc = "Bit 24 - Output Compare 6 mode bit 3"]
#[inline (always)] pub fn oc6m_bit3 (& mut self) -> Oc6mBit3W < '_ , Ccmr3OutputSpec > { Oc6mBit3W :: new (self , 24) } }
#[doc = "capture/compare mode register 2 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr3_output::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr3_output::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr3OutputSpec ; impl crate :: RegisterSpec for Ccmr3OutputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr3_output::R`](R) reader structure"] impl crate :: Readable for Ccmr3OutputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr3_output::W`](W) writer structure"] impl crate :: Writable for Ccmr3OutputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR3_Output to value 0"] impl crate :: Resettable for Ccmr3OutputSpec { } }
#[doc = "CCR5 (rw) register accessor: capture/compare register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr5`] module"]
#[doc (alias = "CCR5")] pub type Ccr5 = crate :: Reg < ccr5 :: Ccr5Spec > ;
#[doc = "capture/compare register 4"] pub mod ccr5 {
#[doc = "Register `CCR5` reader"] pub type R = crate :: R < Ccr5Spec > ;
#[doc = "Register `CCR5` writer"] pub type W = crate :: W < Ccr5Spec > ;
#[doc = "Field `CCR5` reader - Capture/Compare value"] pub type Ccr5R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR5` writer - Capture/Compare value"] pub type Ccr5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `GC5C1` reader - Group Channel 5 and Channel 1"] pub type Gc5c1R = crate :: BitReader ;
#[doc = "Field `GC5C1` writer - Group Channel 5 and Channel 1"] pub type Gc5c1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GC5C2` reader - Group Channel 5 and Channel 2"] pub type Gc5c2R = crate :: BitReader ;
#[doc = "Field `GC5C2` writer - Group Channel 5 and Channel 2"] pub type Gc5c2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GC5C3` reader - Group Channel 5 and Channel 3"] pub type Gc5c3R = crate :: BitReader ;
#[doc = "Field `GC5C3` writer - Group Channel 5 and Channel 3"] pub type Gc5c3W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare value"]
#[inline (always)] pub fn ccr5 (& self) -> Ccr5R { Ccr5R :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bit 29 - Group Channel 5 and Channel 1"]
#[inline (always)] pub fn gc5c1 (& self) -> Gc5c1R { Gc5c1R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Group Channel 5 and Channel 2"]
#[inline (always)] pub fn gc5c2 (& self) -> Gc5c2R { Gc5c2R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Group Channel 5 and Channel 3"]
#[inline (always)] pub fn gc5c3 (& self) -> Gc5c3R { Gc5c3R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare value"]
#[inline (always)] pub fn ccr5 (& mut self) -> Ccr5W < '_ , Ccr5Spec > { Ccr5W :: new (self , 0) }
#[doc = "Bit 29 - Group Channel 5 and Channel 1"]
#[inline (always)] pub fn gc5c1 (& mut self) -> Gc5c1W < '_ , Ccr5Spec > { Gc5c1W :: new (self , 29) }
#[doc = "Bit 30 - Group Channel 5 and Channel 2"]
#[inline (always)] pub fn gc5c2 (& mut self) -> Gc5c2W < '_ , Ccr5Spec > { Gc5c2W :: new (self , 30) }
#[doc = "Bit 31 - Group Channel 5 and Channel 3"]
#[inline (always)] pub fn gc5c3 (& mut self) -> Gc5c3W < '_ , Ccr5Spec > { Gc5c3W :: new (self , 31) } }
#[doc = "capture/compare register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr5Spec ; impl crate :: RegisterSpec for Ccr5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr5::R`](R) reader structure"] impl crate :: Readable for Ccr5Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr5::W`](W) writer structure"] impl crate :: Writable for Ccr5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR5 to value 0"] impl crate :: Resettable for Ccr5Spec { } }
#[doc = "CCR6 (rw) register accessor: capture/compare register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr6`] module"]
#[doc (alias = "CCR6")] pub type Ccr6 = crate :: Reg < ccr6 :: Ccr6Spec > ;
#[doc = "capture/compare register 4"] pub mod ccr6 {
#[doc = "Register `CCR6` reader"] pub type R = crate :: R < Ccr6Spec > ;
#[doc = "Register `CCR6` writer"] pub type W = crate :: W < Ccr6Spec > ;
#[doc = "Field `CCR6` reader - Capture/Compare value"] pub type Ccr6R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR6` writer - Capture/Compare value"] pub type Ccr6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare value"]
#[inline (always)] pub fn ccr6 (& self) -> Ccr6R { Ccr6R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare value"]
#[inline (always)] pub fn ccr6 (& mut self) -> Ccr6W < '_ , Ccr6Spec > { Ccr6W :: new (self , 0) } }
#[doc = "capture/compare register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr6Spec ; impl crate :: RegisterSpec for Ccr6Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr6::R`](R) reader structure"] impl crate :: Readable for Ccr6Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr6::W`](W) writer structure"] impl crate :: Writable for Ccr6Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR6 to value 0"] impl crate :: Resettable for Ccr6Spec { } }
#[doc = "AF1 (rw) register accessor: DMA address for full transfer\n\nYou can [`read`](crate::Reg::read) this register and get [`af1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`af1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@af1`] module"]
#[doc (alias = "AF1")] pub type Af1 = crate :: Reg < af1 :: Af1Spec > ;
#[doc = "DMA address for full transfer"] pub mod af1 {
#[doc = "Register `AF1` reader"] pub type R = crate :: R < Af1Spec > ;
#[doc = "Register `AF1` writer"] pub type W = crate :: W < Af1Spec > ;
#[doc = "Field `BKINE` reader - BRK BKIN input enable"] pub type BkineR = crate :: BitReader ;
#[doc = "Field `BKINE` writer - BRK BKIN input enable"] pub type BkineW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKCMP1E` reader - BRK COMP1 enable"] pub type Bkcmp1eR = crate :: BitReader ;
#[doc = "Field `BKCMP1E` writer - BRK COMP1 enable"] pub type Bkcmp1eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKCMP2E` reader - BRK COMP2 enable"] pub type Bkcmp2eR = crate :: BitReader ;
#[doc = "Field `BKCMP2E` writer - BRK COMP2 enable"] pub type Bkcmp2eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKINP` reader - BRK BKIN input polarity"] pub type BkinpR = crate :: BitReader ;
#[doc = "Field `BKINP` writer - BRK BKIN input polarity"] pub type BkinpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKCMP1P` reader - BRK COMP1 input polarity"] pub type Bkcmp1pR = crate :: BitReader ;
#[doc = "Field `BKCMP1P` writer - BRK COMP1 input polarity"] pub type Bkcmp1pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKCMP2P` reader - BRK COMP2 input polarity"] pub type Bkcmp2pR = crate :: BitReader ;
#[doc = "Field `BKCMP2P` writer - BRK COMP2 input polarity"] pub type Bkcmp2pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ETRSEL` reader - ETR source selection"] pub type EtrselR = crate :: FieldReader ;
#[doc = "Field `ETRSEL` writer - ETR source selection"] pub type EtrselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bit 0 - BRK BKIN input enable"]
#[inline (always)] pub fn bkine (& self) -> BkineR { BkineR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - BRK COMP1 enable"]
#[inline (always)] pub fn bkcmp1e (& self) -> Bkcmp1eR { Bkcmp1eR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - BRK COMP2 enable"]
#[inline (always)] pub fn bkcmp2e (& self) -> Bkcmp2eR { Bkcmp2eR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 9 - BRK BKIN input polarity"]
#[inline (always)] pub fn bkinp (& self) -> BkinpR { BkinpR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - BRK COMP1 input polarity"]
#[inline (always)] pub fn bkcmp1p (& self) -> Bkcmp1pR { Bkcmp1pR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - BRK COMP2 input polarity"]
#[inline (always)] pub fn bkcmp2p (& self) -> Bkcmp2pR { Bkcmp2pR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 14:16 - ETR source selection"]
#[inline (always)] pub fn etrsel (& self) -> EtrselR { EtrselR :: new (((self . bits >> 14) & 7) as u8) } } impl W {
#[doc = "Bit 0 - BRK BKIN input enable"]
#[inline (always)] pub fn bkine (& mut self) -> BkineW < '_ , Af1Spec > { BkineW :: new (self , 0) }
#[doc = "Bit 1 - BRK COMP1 enable"]
#[inline (always)] pub fn bkcmp1e (& mut self) -> Bkcmp1eW < '_ , Af1Spec > { Bkcmp1eW :: new (self , 1) }
#[doc = "Bit 2 - BRK COMP2 enable"]
#[inline (always)] pub fn bkcmp2e (& mut self) -> Bkcmp2eW < '_ , Af1Spec > { Bkcmp2eW :: new (self , 2) }
#[doc = "Bit 9 - BRK BKIN input polarity"]
#[inline (always)] pub fn bkinp (& mut self) -> BkinpW < '_ , Af1Spec > { BkinpW :: new (self , 9) }
#[doc = "Bit 10 - BRK COMP1 input polarity"]
#[inline (always)] pub fn bkcmp1p (& mut self) -> Bkcmp1pW < '_ , Af1Spec > { Bkcmp1pW :: new (self , 10) }
#[doc = "Bit 11 - BRK COMP2 input polarity"]
#[inline (always)] pub fn bkcmp2p (& mut self) -> Bkcmp2pW < '_ , Af1Spec > { Bkcmp2pW :: new (self , 11) }
#[doc = "Bits 14:16 - ETR source selection"]
#[inline (always)] pub fn etrsel (& mut self) -> EtrselW < '_ , Af1Spec > { EtrselW :: new (self , 14) } }
#[doc = "DMA address for full transfer\n\nYou can [`read`](crate::Reg::read) this register and get [`af1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`af1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Af1Spec ; impl crate :: RegisterSpec for Af1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`af1::R`](R) reader structure"] impl crate :: Readable for Af1Spec { }
#[doc = "`write(|w| ..)` method takes [`af1::W`](W) writer structure"] impl crate :: Writable for Af1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AF1 to value 0x01"] impl crate :: Resettable for Af1Spec { const RESET_VALUE : u32 = 0x01 ; } }
#[doc = "AF2 (rw) register accessor: DMA address for full transfer\n\nYou can [`read`](crate::Reg::read) this register and get [`af2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`af2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@af2`] module"]
#[doc (alias = "AF2")] pub type Af2 = crate :: Reg < af2 :: Af2Spec > ;
#[doc = "DMA address for full transfer"] pub mod af2 {
#[doc = "Register `AF2` reader"] pub type R = crate :: R < Af2Spec > ;
#[doc = "Register `AF2` writer"] pub type W = crate :: W < Af2Spec > ;
#[doc = "Field `BK2INE` reader - BRK2 BKIN input enable"] pub type Bk2ineR = crate :: BitReader ;
#[doc = "Field `BK2INE` writer - BRK2 BKIN input enable"] pub type Bk2ineW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BK2CMP1E` reader - BRK2 COMP1 enable"] pub type Bk2cmp1eR = crate :: BitReader ;
#[doc = "Field `BK2CMP1E` writer - BRK2 COMP1 enable"] pub type Bk2cmp1eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BK2CMP2E` reader - BRK2 COMP2 enable"] pub type Bk2cmp2eR = crate :: BitReader ;
#[doc = "Field `BK2CMP2E` writer - BRK2 COMP2 enable"] pub type Bk2cmp2eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BK2DFBK0E` reader - BRK2 DFSDM_BREAK0 enable"] pub type Bk2dfbk0eR = crate :: BitReader ;
#[doc = "Field `BK2DFBK0E` writer - BRK2 DFSDM_BREAK0 enable"] pub type Bk2dfbk0eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BK2INP` reader - BRK2 BKIN input polarity"] pub type Bk2inpR = crate :: BitReader ;
#[doc = "Field `BK2INP` writer - BRK2 BKIN input polarity"] pub type Bk2inpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BK2CMP1P` reader - BRK2 COMP1 input polarity"] pub type Bk2cmp1pR = crate :: BitReader ;
#[doc = "Field `BK2CMP1P` writer - BRK2 COMP1 input polarity"] pub type Bk2cmp1pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BK2CMP2P` reader - BRK2 COMP2 input polarity"] pub type Bk2cmp2pR = crate :: BitReader ;
#[doc = "Field `BK2CMP2P` writer - BRK2 COMP2 input polarity"] pub type Bk2cmp2pW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - BRK2 BKIN input enable"]
#[inline (always)] pub fn bk2ine (& self) -> Bk2ineR { Bk2ineR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - BRK2 COMP1 enable"]
#[inline (always)] pub fn bk2cmp1e (& self) -> Bk2cmp1eR { Bk2cmp1eR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - BRK2 COMP2 enable"]
#[inline (always)] pub fn bk2cmp2e (& self) -> Bk2cmp2eR { Bk2cmp2eR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 8 - BRK2 DFSDM_BREAK0 enable"]
#[inline (always)] pub fn bk2dfbk0e (& self) -> Bk2dfbk0eR { Bk2dfbk0eR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - BRK2 BKIN input polarity"]
#[inline (always)] pub fn bk2inp (& self) -> Bk2inpR { Bk2inpR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - BRK2 COMP1 input polarity"]
#[inline (always)] pub fn bk2cmp1p (& self) -> Bk2cmp1pR { Bk2cmp1pR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - BRK2 COMP2 input polarity"]
#[inline (always)] pub fn bk2cmp2p (& self) -> Bk2cmp2pR { Bk2cmp2pR :: new (((self . bits >> 11) & 1) != 0) } } impl W {
#[doc = "Bit 0 - BRK2 BKIN input enable"]
#[inline (always)] pub fn bk2ine (& mut self) -> Bk2ineW < '_ , Af2Spec > { Bk2ineW :: new (self , 0) }
#[doc = "Bit 1 - BRK2 COMP1 enable"]
#[inline (always)] pub fn bk2cmp1e (& mut self) -> Bk2cmp1eW < '_ , Af2Spec > { Bk2cmp1eW :: new (self , 1) }
#[doc = "Bit 2 - BRK2 COMP2 enable"]
#[inline (always)] pub fn bk2cmp2e (& mut self) -> Bk2cmp2eW < '_ , Af2Spec > { Bk2cmp2eW :: new (self , 2) }
#[doc = "Bit 8 - BRK2 DFSDM_BREAK0 enable"]
#[inline (always)] pub fn bk2dfbk0e (& mut self) -> Bk2dfbk0eW < '_ , Af2Spec > { Bk2dfbk0eW :: new (self , 8) }
#[doc = "Bit 9 - BRK2 BKIN input polarity"]
#[inline (always)] pub fn bk2inp (& mut self) -> Bk2inpW < '_ , Af2Spec > { Bk2inpW :: new (self , 9) }
#[doc = "Bit 10 - BRK2 COMP1 input polarity"]
#[inline (always)] pub fn bk2cmp1p (& mut self) -> Bk2cmp1pW < '_ , Af2Spec > { Bk2cmp1pW :: new (self , 10) }
#[doc = "Bit 11 - BRK2 COMP2 input polarity"]
#[inline (always)] pub fn bk2cmp2p (& mut self) -> Bk2cmp2pW < '_ , Af2Spec > { Bk2cmp2pW :: new (self , 11) } }
#[doc = "DMA address for full transfer\n\nYou can [`read`](crate::Reg::read) this register and get [`af2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`af2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Af2Spec ; impl crate :: RegisterSpec for Af2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`af2::R`](R) reader structure"] impl crate :: Readable for Af2Spec { }
#[doc = "`write(|w| ..)` method takes [`af2::W`](W) writer structure"] impl crate :: Writable for Af2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AF2 to value 0x01"] impl crate :: Resettable for Af2Spec { const RESET_VALUE : u32 = 0x01 ; } } }
#[doc = "Low power timer"] pub type Lptim1 = crate :: Periph < lptim1 :: RegisterBlock , 0x4000_7c00 > ; impl core :: fmt :: Debug for Lptim1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Lptim1") . finish () } }
#[doc = "Low power timer"] pub mod lptim1 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { isr : Isr , icr : Icr , ier : Ier , cfgr : Cfgr , cr : Cr , cmp : Cmp , arr : Arr , cnt : Cnt , or : Or , } impl RegisterBlock {
#[doc = "0x00 - Interrupt and Status Register"]
#[inline (always)] pub const fn isr (& self) -> & Isr { & self . isr }
#[doc = "0x04 - Interrupt Clear Register"]
#[inline (always)] pub const fn icr (& self) -> & Icr { & self . icr }
#[doc = "0x08 - Interrupt Enable Register"]
#[inline (always)] pub const fn ier (& self) -> & Ier { & self . ier }
#[doc = "0x0c - Configuration Register"]
#[inline (always)] pub const fn cfgr (& self) -> & Cfgr { & self . cfgr }
#[doc = "0x10 - Control Register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x14 - Compare Register"]
#[inline (always)] pub const fn cmp (& self) -> & Cmp { & self . cmp }
#[doc = "0x18 - Autoreload Register"]
#[inline (always)] pub const fn arr (& self) -> & Arr { & self . arr }
#[doc = "0x1c - Counter Register"]
#[inline (always)] pub const fn cnt (& self) -> & Cnt { & self . cnt }
#[doc = "0x20 - Option Register"]
#[inline (always)] pub const fn or (& self) -> & Or { & self . or } }
#[doc = "ISR (r) register accessor: Interrupt and Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@isr`] module"]
#[doc (alias = "ISR")] pub type Isr = crate :: Reg < isr :: IsrSpec > ;
#[doc = "Interrupt and Status Register"] pub mod isr {
#[doc = "Register `ISR` reader"] pub type R = crate :: R < IsrSpec > ;
#[doc = "Field `CMPM` reader - Compare match"] pub type CmpmR = crate :: BitReader ;
#[doc = "Field `ARRM` reader - Autoreload match"] pub type ArrmR = crate :: BitReader ;
#[doc = "Field `EXTTRIG` reader - External trigger edge event"] pub type ExttrigR = crate :: BitReader ;
#[doc = "Field `CMPOK` reader - Compare register update OK"] pub type CmpokR = crate :: BitReader ;
#[doc = "Field `ARROK` reader - Autoreload register update OK"] pub type ArrokR = crate :: BitReader ;
#[doc = "Field `UP` reader - Counter direction change down to up"] pub type UpR = crate :: BitReader ;
#[doc = "Field `DOWN` reader - Counter direction change up to down"] pub type DownR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Compare match"]
#[inline (always)] pub fn cmpm (& self) -> CmpmR { CmpmR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Autoreload match"]
#[inline (always)] pub fn arrm (& self) -> ArrmR { ArrmR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - External trigger edge event"]
#[inline (always)] pub fn exttrig (& self) -> ExttrigR { ExttrigR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Compare register update OK"]
#[inline (always)] pub fn cmpok (& self) -> CmpokR { CmpokR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Autoreload register update OK"]
#[inline (always)] pub fn arrok (& self) -> ArrokR { ArrokR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Counter direction change down to up"]
#[inline (always)] pub fn up (& self) -> UpR { UpR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Counter direction change up to down"]
#[inline (always)] pub fn down (& self) -> DownR { DownR :: new (((self . bits >> 6) & 1) != 0) } }
#[doc = "Interrupt and Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IsrSpec ; impl crate :: RegisterSpec for IsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`isr::R`](R) reader structure"] impl crate :: Readable for IsrSpec { }
#[doc = "`reset()` method sets ISR to value 0"] impl crate :: Resettable for IsrSpec { } }
#[doc = "ICR (w) register accessor: Interrupt Clear Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@icr`] module"]
#[doc (alias = "ICR")] pub type Icr = crate :: Reg < icr :: IcrSpec > ;
#[doc = "Interrupt Clear Register"] pub mod icr {
#[doc = "Register `ICR` writer"] pub type W = crate :: W < IcrSpec > ;
#[doc = "Field `CMPMCF` writer - compare match Clear Flag"] pub type CmpmcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ARRMCF` writer - Autoreload match Clear Flag"] pub type ArrmcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EXTTRIGCF` writer - External trigger valid edge Clear Flag"] pub type ExttrigcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CMPOKCF` writer - Compare register update OK Clear Flag"] pub type CmpokcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ARROKCF` writer - Autoreload register update OK Clear Flag"] pub type ArrokcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UPCF` writer - Direction change to UP Clear Flag"] pub type UpcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DOWNCF` writer - Direction change to down Clear Flag"] pub type DowncfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - compare match Clear Flag"]
#[inline (always)] pub fn cmpmcf (& mut self) -> CmpmcfW < '_ , IcrSpec > { CmpmcfW :: new (self , 0) }
#[doc = "Bit 1 - Autoreload match Clear Flag"]
#[inline (always)] pub fn arrmcf (& mut self) -> ArrmcfW < '_ , IcrSpec > { ArrmcfW :: new (self , 1) }
#[doc = "Bit 2 - External trigger valid edge Clear Flag"]
#[inline (always)] pub fn exttrigcf (& mut self) -> ExttrigcfW < '_ , IcrSpec > { ExttrigcfW :: new (self , 2) }
#[doc = "Bit 3 - Compare register update OK Clear Flag"]
#[inline (always)] pub fn cmpokcf (& mut self) -> CmpokcfW < '_ , IcrSpec > { CmpokcfW :: new (self , 3) }
#[doc = "Bit 4 - Autoreload register update OK Clear Flag"]
#[inline (always)] pub fn arrokcf (& mut self) -> ArrokcfW < '_ , IcrSpec > { ArrokcfW :: new (self , 4) }
#[doc = "Bit 5 - Direction change to UP Clear Flag"]
#[inline (always)] pub fn upcf (& mut self) -> UpcfW < '_ , IcrSpec > { UpcfW :: new (self , 5) }
#[doc = "Bit 6 - Direction change to down Clear Flag"]
#[inline (always)] pub fn downcf (& mut self) -> DowncfW < '_ , IcrSpec > { DowncfW :: new (self , 6) } }
#[doc = "Interrupt Clear Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IcrSpec ; impl crate :: RegisterSpec for IcrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`icr::W`](W) writer structure"] impl crate :: Writable for IcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ICR to value 0"] impl crate :: Resettable for IcrSpec { } }
#[doc = "IER (rw) register accessor: Interrupt Enable Register\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ier`] module"]
#[doc (alias = "IER")] pub type Ier = crate :: Reg < ier :: IerSpec > ;
#[doc = "Interrupt Enable Register"] pub mod ier {
#[doc = "Register `IER` reader"] pub type R = crate :: R < IerSpec > ;
#[doc = "Register `IER` writer"] pub type W = crate :: W < IerSpec > ;
#[doc = "Field `CMPMIE` reader - Compare match Interrupt Enable"] pub type CmpmieR = crate :: BitReader ;
#[doc = "Field `CMPMIE` writer - Compare match Interrupt Enable"] pub type CmpmieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ARRMIE` reader - Autoreload match Interrupt Enable"] pub type ArrmieR = crate :: BitReader ;
#[doc = "Field `ARRMIE` writer - Autoreload match Interrupt Enable"] pub type ArrmieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EXTTRIGIE` reader - External trigger valid edge Interrupt Enable"] pub type ExttrigieR = crate :: BitReader ;
#[doc = "Field `EXTTRIGIE` writer - External trigger valid edge Interrupt Enable"] pub type ExttrigieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CMPOKIE` reader - Compare register update OK Interrupt Enable"] pub type CmpokieR = crate :: BitReader ;
#[doc = "Field `CMPOKIE` writer - Compare register update OK Interrupt Enable"] pub type CmpokieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ARROKIE` reader - Autoreload register update OK Interrupt Enable"] pub type ArrokieR = crate :: BitReader ;
#[doc = "Field `ARROKIE` writer - Autoreload register update OK Interrupt Enable"] pub type ArrokieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UPIE` reader - Direction change to UP Interrupt Enable"] pub type UpieR = crate :: BitReader ;
#[doc = "Field `UPIE` writer - Direction change to UP Interrupt Enable"] pub type UpieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DOWNIE` reader - Direction change to down Interrupt Enable"] pub type DownieR = crate :: BitReader ;
#[doc = "Field `DOWNIE` writer - Direction change to down Interrupt Enable"] pub type DownieW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Compare match Interrupt Enable"]
#[inline (always)] pub fn cmpmie (& self) -> CmpmieR { CmpmieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Autoreload match Interrupt Enable"]
#[inline (always)] pub fn arrmie (& self) -> ArrmieR { ArrmieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - External trigger valid edge Interrupt Enable"]
#[inline (always)] pub fn exttrigie (& self) -> ExttrigieR { ExttrigieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Compare register update OK Interrupt Enable"]
#[inline (always)] pub fn cmpokie (& self) -> CmpokieR { CmpokieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Autoreload register update OK Interrupt Enable"]
#[inline (always)] pub fn arrokie (& self) -> ArrokieR { ArrokieR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Direction change to UP Interrupt Enable"]
#[inline (always)] pub fn upie (& self) -> UpieR { UpieR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Direction change to down Interrupt Enable"]
#[inline (always)] pub fn downie (& self) -> DownieR { DownieR :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Compare match Interrupt Enable"]
#[inline (always)] pub fn cmpmie (& mut self) -> CmpmieW < '_ , IerSpec > { CmpmieW :: new (self , 0) }
#[doc = "Bit 1 - Autoreload match Interrupt Enable"]
#[inline (always)] pub fn arrmie (& mut self) -> ArrmieW < '_ , IerSpec > { ArrmieW :: new (self , 1) }
#[doc = "Bit 2 - External trigger valid edge Interrupt Enable"]
#[inline (always)] pub fn exttrigie (& mut self) -> ExttrigieW < '_ , IerSpec > { ExttrigieW :: new (self , 2) }
#[doc = "Bit 3 - Compare register update OK Interrupt Enable"]
#[inline (always)] pub fn cmpokie (& mut self) -> CmpokieW < '_ , IerSpec > { CmpokieW :: new (self , 3) }
#[doc = "Bit 4 - Autoreload register update OK Interrupt Enable"]
#[inline (always)] pub fn arrokie (& mut self) -> ArrokieW < '_ , IerSpec > { ArrokieW :: new (self , 4) }
#[doc = "Bit 5 - Direction change to UP Interrupt Enable"]
#[inline (always)] pub fn upie (& mut self) -> UpieW < '_ , IerSpec > { UpieW :: new (self , 5) }
#[doc = "Bit 6 - Direction change to down Interrupt Enable"]
#[inline (always)] pub fn downie (& mut self) -> DownieW < '_ , IerSpec > { DownieW :: new (self , 6) } }
#[doc = "Interrupt Enable Register\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IerSpec ; impl crate :: RegisterSpec for IerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ier::R`](R) reader structure"] impl crate :: Readable for IerSpec { }
#[doc = "`write(|w| ..)` method takes [`ier::W`](W) writer structure"] impl crate :: Writable for IerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IER to value 0"] impl crate :: Resettable for IerSpec { } }
#[doc = "CFGR (rw) register accessor: Configuration Register\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfgr`] module"]
#[doc (alias = "CFGR")] pub type Cfgr = crate :: Reg < cfgr :: CfgrSpec > ;
#[doc = "Configuration Register"] pub mod cfgr {
#[doc = "Register `CFGR` reader"] pub type R = crate :: R < CfgrSpec > ;
#[doc = "Register `CFGR` writer"] pub type W = crate :: W < CfgrSpec > ;
#[doc = "Field `CKSEL` reader - Clock selector"] pub type CkselR = crate :: BitReader ;
#[doc = "Field `CKSEL` writer - Clock selector"] pub type CkselW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CKPOL` reader - Clock Polarity"] pub type CkpolR = crate :: FieldReader ;
#[doc = "Field `CKPOL` writer - Clock Polarity"] pub type CkpolW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CKFLT` reader - Configurable digital filter for external clock"] pub type CkfltR = crate :: FieldReader ;
#[doc = "Field `CKFLT` writer - Configurable digital filter for external clock"] pub type CkfltW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `TRGFLT` reader - Configurable digital filter for trigger"] pub type TrgfltR = crate :: FieldReader ;
#[doc = "Field `TRGFLT` writer - Configurable digital filter for trigger"] pub type TrgfltW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PRESC` reader - Clock prescaler"] pub type PrescR = crate :: FieldReader ;
#[doc = "Field `PRESC` writer - Clock prescaler"] pub type PrescW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `TRIGSEL` reader - Trigger selector"] pub type TrigselR = crate :: FieldReader ;
#[doc = "Field `TRIGSEL` writer - Trigger selector"] pub type TrigselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `TRIGEN` reader - Trigger enable and polarity"] pub type TrigenR = crate :: FieldReader ;
#[doc = "Field `TRIGEN` writer - Trigger enable and polarity"] pub type TrigenW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `TIMOUT` reader - Timeout enable"] pub type TimoutR = crate :: BitReader ;
#[doc = "Field `TIMOUT` writer - Timeout enable"] pub type TimoutW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WAVE` reader - Waveform shape"] pub type WaveR = crate :: BitReader ;
#[doc = "Field `WAVE` writer - Waveform shape"] pub type WaveW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WAVPOL` reader - Waveform shape polarity"] pub type WavpolR = crate :: BitReader ;
#[doc = "Field `WAVPOL` writer - Waveform shape polarity"] pub type WavpolW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PRELOAD` reader - Registers update mode"] pub type PreloadR = crate :: BitReader ;
#[doc = "Field `PRELOAD` writer - Registers update mode"] pub type PreloadW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COUNTMODE` reader - counter mode enabled"] pub type CountmodeR = crate :: BitReader ;
#[doc = "Field `COUNTMODE` writer - counter mode enabled"] pub type CountmodeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ENC` reader - Encoder mode enable"] pub type EncR = crate :: BitReader ;
#[doc = "Field `ENC` writer - Encoder mode enable"] pub type EncW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Clock selector"]
#[inline (always)] pub fn cksel (& self) -> CkselR { CkselR :: new ((self . bits & 1) != 0) }
#[doc = "Bits 1:2 - Clock Polarity"]
#[inline (always)] pub fn ckpol (& self) -> CkpolR { CkpolR :: new (((self . bits >> 1) & 3) as u8) }
#[doc = "Bits 3:4 - Configurable digital filter for external clock"]
#[inline (always)] pub fn ckflt (& self) -> CkfltR { CkfltR :: new (((self . bits >> 3) & 3) as u8) }
#[doc = "Bits 6:7 - Configurable digital filter for trigger"]
#[inline (always)] pub fn trgflt (& self) -> TrgfltR { TrgfltR :: new (((self . bits >> 6) & 3) as u8) }
#[doc = "Bits 9:11 - Clock prescaler"]
#[inline (always)] pub fn presc (& self) -> PrescR { PrescR :: new (((self . bits >> 9) & 7) as u8) }
#[doc = "Bits 13:15 - Trigger selector"]
#[inline (always)] pub fn trigsel (& self) -> TrigselR { TrigselR :: new (((self . bits >> 13) & 7) as u8) }
#[doc = "Bits 17:18 - Trigger enable and polarity"]
#[inline (always)] pub fn trigen (& self) -> TrigenR { TrigenR :: new (((self . bits >> 17) & 3) as u8) }
#[doc = "Bit 19 - Timeout enable"]
#[inline (always)] pub fn timout (& self) -> TimoutR { TimoutR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Waveform shape"]
#[inline (always)] pub fn wave (& self) -> WaveR { WaveR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Waveform shape polarity"]
#[inline (always)] pub fn wavpol (& self) -> WavpolR { WavpolR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Registers update mode"]
#[inline (always)] pub fn preload (& self) -> PreloadR { PreloadR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - counter mode enabled"]
#[inline (always)] pub fn countmode (& self) -> CountmodeR { CountmodeR :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Encoder mode enable"]
#[inline (always)] pub fn enc (& self) -> EncR { EncR :: new (((self . bits >> 24) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Clock selector"]
#[inline (always)] pub fn cksel (& mut self) -> CkselW < '_ , CfgrSpec > { CkselW :: new (self , 0) }
#[doc = "Bits 1:2 - Clock Polarity"]
#[inline (always)] pub fn ckpol (& mut self) -> CkpolW < '_ , CfgrSpec > { CkpolW :: new (self , 1) }
#[doc = "Bits 3:4 - Configurable digital filter for external clock"]
#[inline (always)] pub fn ckflt (& mut self) -> CkfltW < '_ , CfgrSpec > { CkfltW :: new (self , 3) }
#[doc = "Bits 6:7 - Configurable digital filter for trigger"]
#[inline (always)] pub fn trgflt (& mut self) -> TrgfltW < '_ , CfgrSpec > { TrgfltW :: new (self , 6) }
#[doc = "Bits 9:11 - Clock prescaler"]
#[inline (always)] pub fn presc (& mut self) -> PrescW < '_ , CfgrSpec > { PrescW :: new (self , 9) }
#[doc = "Bits 13:15 - Trigger selector"]
#[inline (always)] pub fn trigsel (& mut self) -> TrigselW < '_ , CfgrSpec > { TrigselW :: new (self , 13) }
#[doc = "Bits 17:18 - Trigger enable and polarity"]
#[inline (always)] pub fn trigen (& mut self) -> TrigenW < '_ , CfgrSpec > { TrigenW :: new (self , 17) }
#[doc = "Bit 19 - Timeout enable"]
#[inline (always)] pub fn timout (& mut self) -> TimoutW < '_ , CfgrSpec > { TimoutW :: new (self , 19) }
#[doc = "Bit 20 - Waveform shape"]
#[inline (always)] pub fn wave (& mut self) -> WaveW < '_ , CfgrSpec > { WaveW :: new (self , 20) }
#[doc = "Bit 21 - Waveform shape polarity"]
#[inline (always)] pub fn wavpol (& mut self) -> WavpolW < '_ , CfgrSpec > { WavpolW :: new (self , 21) }
#[doc = "Bit 22 - Registers update mode"]
#[inline (always)] pub fn preload (& mut self) -> PreloadW < '_ , CfgrSpec > { PreloadW :: new (self , 22) }
#[doc = "Bit 23 - counter mode enabled"]
#[inline (always)] pub fn countmode (& mut self) -> CountmodeW < '_ , CfgrSpec > { CountmodeW :: new (self , 23) }
#[doc = "Bit 24 - Encoder mode enable"]
#[inline (always)] pub fn enc (& mut self) -> EncW < '_ , CfgrSpec > { EncW :: new (self , 24) } }
#[doc = "Configuration Register\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CfgrSpec ; impl crate :: RegisterSpec for CfgrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cfgr::R`](R) reader structure"] impl crate :: Readable for CfgrSpec { }
#[doc = "`write(|w| ..)` method takes [`cfgr::W`](W) writer structure"] impl crate :: Writable for CfgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CFGR to value 0"] impl crate :: Resettable for CfgrSpec { } }
#[doc = "CR (rw) register accessor: Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "Control Register"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `ENABLE` reader - LPTIM Enable"] pub type EnableR = crate :: BitReader ;
#[doc = "Field `ENABLE` writer - LPTIM Enable"] pub type EnableW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SNGSTRT` reader - LPTIM start in single mode"] pub type SngstrtR = crate :: BitReader ;
#[doc = "Field `SNGSTRT` writer - LPTIM start in single mode"] pub type SngstrtW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CNTSTRT` reader - Timer start in continuous mode"] pub type CntstrtR = crate :: BitReader ;
#[doc = "Field `CNTSTRT` writer - Timer start in continuous mode"] pub type CntstrtW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COUNTRST` reader - Counter reset"] pub type CountrstR = crate :: BitReader ;
#[doc = "Field `COUNTRST` writer - Counter reset"] pub type CountrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RSTARE` reader - Reset after read enable"] pub type RstareR = crate :: BitReader ;
#[doc = "Field `RSTARE` writer - Reset after read enable"] pub type RstareW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - LPTIM Enable"]
#[inline (always)] pub fn enable (& self) -> EnableR { EnableR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - LPTIM start in single mode"]
#[inline (always)] pub fn sngstrt (& self) -> SngstrtR { SngstrtR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Timer start in continuous mode"]
#[inline (always)] pub fn cntstrt (& self) -> CntstrtR { CntstrtR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Counter reset"]
#[inline (always)] pub fn countrst (& self) -> CountrstR { CountrstR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Reset after read enable"]
#[inline (always)] pub fn rstare (& self) -> RstareR { RstareR :: new (((self . bits >> 4) & 1) != 0) } } impl W {
#[doc = "Bit 0 - LPTIM Enable"]
#[inline (always)] pub fn enable (& mut self) -> EnableW < '_ , CrSpec > { EnableW :: new (self , 0) }
#[doc = "Bit 1 - LPTIM start in single mode"]
#[inline (always)] pub fn sngstrt (& mut self) -> SngstrtW < '_ , CrSpec > { SngstrtW :: new (self , 1) }
#[doc = "Bit 2 - Timer start in continuous mode"]
#[inline (always)] pub fn cntstrt (& mut self) -> CntstrtW < '_ , CrSpec > { CntstrtW :: new (self , 2) }
#[doc = "Bit 3 - Counter reset"]
#[inline (always)] pub fn countrst (& mut self) -> CountrstW < '_ , CrSpec > { CountrstW :: new (self , 3) }
#[doc = "Bit 4 - Reset after read enable"]
#[inline (always)] pub fn rstare (& mut self) -> RstareW < '_ , CrSpec > { RstareW :: new (self , 4) } }
#[doc = "Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { } }
#[doc = "CMP (rw) register accessor: Compare Register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmp::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmp::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmp`] module"]
#[doc (alias = "CMP")] pub type Cmp = crate :: Reg < cmp :: CmpSpec > ;
#[doc = "Compare Register"] pub mod cmp {
#[doc = "Register `CMP` reader"] pub type R = crate :: R < CmpSpec > ;
#[doc = "Register `CMP` writer"] pub type W = crate :: W < CmpSpec > ;
#[doc = "Field `CMP` reader - Compare value"] pub type CmpR = crate :: FieldReader < u16 > ;
#[doc = "Field `CMP` writer - Compare value"] pub type CmpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Compare value"]
#[inline (always)] pub fn cmp (& self) -> CmpR { CmpR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Compare value"]
#[inline (always)] pub fn cmp (& mut self) -> CmpW < '_ , CmpSpec > { CmpW :: new (self , 0) } }
#[doc = "Compare Register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmp::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmp::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CmpSpec ; impl crate :: RegisterSpec for CmpSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmp::R`](R) reader structure"] impl crate :: Readable for CmpSpec { }
#[doc = "`write(|w| ..)` method takes [`cmp::W`](W) writer structure"] impl crate :: Writable for CmpSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMP to value 0"] impl crate :: Resettable for CmpSpec { } }
#[doc = "ARR (rw) register accessor: Autoreload Register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@arr`] module"]
#[doc (alias = "ARR")] pub type Arr = crate :: Reg < arr :: ArrSpec > ;
#[doc = "Autoreload Register"] pub mod arr {
#[doc = "Register `ARR` reader"] pub type R = crate :: R < ArrSpec > ;
#[doc = "Register `ARR` writer"] pub type W = crate :: W < ArrSpec > ;
#[doc = "Field `ARR` reader - Auto reload value"] pub type ArrR = crate :: FieldReader < u16 > ;
#[doc = "Field `ARR` writer - Auto reload value"] pub type ArrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Auto reload value"]
#[inline (always)] pub fn arr (& self) -> ArrR { ArrR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Auto reload value"]
#[inline (always)] pub fn arr (& mut self) -> ArrW < '_ , ArrSpec > { ArrW :: new (self , 0) } }
#[doc = "Autoreload Register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ArrSpec ; impl crate :: RegisterSpec for ArrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`arr::R`](R) reader structure"] impl crate :: Readable for ArrSpec { }
#[doc = "`write(|w| ..)` method takes [`arr::W`](W) writer structure"] impl crate :: Writable for ArrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ARR to value 0x01"] impl crate :: Resettable for ArrSpec { const RESET_VALUE : u32 = 0x01 ; } }
#[doc = "CNT (r) register accessor: Counter Register\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt`] module"]
#[doc (alias = "CNT")] pub type Cnt = crate :: Reg < cnt :: CntSpec > ;
#[doc = "Counter Register"] pub mod cnt {
#[doc = "Register `CNT` reader"] pub type R = crate :: R < CntSpec > ;
#[doc = "Field `CNT` reader - Counter value"] pub type CntR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - Counter value"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0xffff) as u16) } }
#[doc = "Counter Register\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CntSpec ; impl crate :: RegisterSpec for CntSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cnt::R`](R) reader structure"] impl crate :: Readable for CntSpec { }
#[doc = "`reset()` method sets CNT to value 0"] impl crate :: Resettable for CntSpec { } }
#[doc = "OR (rw) register accessor: Option Register\n\nYou can [`read`](crate::Reg::read) this register and get [`or::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`or::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@or`] module"]
#[doc (alias = "OR")] pub type Or = crate :: Reg < or :: OrSpec > ;
#[doc = "Option Register"] pub mod or {
#[doc = "Register `OR` reader"] pub type R = crate :: R < OrSpec > ;
#[doc = "Register `OR` writer"] pub type W = crate :: W < OrSpec > ;
#[doc = "Field `OR1` reader - Option register bit 1"] pub type Or1R = crate :: BitReader ;
#[doc = "Field `OR1` writer - Option register bit 1"] pub type Or1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OR2` reader - Option register bit 2"] pub type Or2R = crate :: BitReader ;
#[doc = "Field `OR2` writer - Option register bit 2"] pub type Or2W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Option register bit 1"]
#[inline (always)] pub fn or1 (& self) -> Or1R { Or1R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Option register bit 2"]
#[inline (always)] pub fn or2 (& self) -> Or2R { Or2R :: new (((self . bits >> 1) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Option register bit 1"]
#[inline (always)] pub fn or1 (& mut self) -> Or1W < '_ , OrSpec > { Or1W :: new (self , 0) }
#[doc = "Bit 1 - Option register bit 2"]
#[inline (always)] pub fn or2 (& mut self) -> Or2W < '_ , OrSpec > { Or2W :: new (self , 1) } }
#[doc = "Option Register\n\nYou can [`read`](crate::Reg::read) this register and get [`or::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`or::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OrSpec ; impl crate :: RegisterSpec for OrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`or::R`](R) reader structure"] impl crate :: Readable for OrSpec { }
#[doc = "`write(|w| ..)` method takes [`or::W`](W) writer structure"] impl crate :: Writable for OrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OR to value 0"] impl crate :: Resettable for OrSpec { } } }
#[doc = "Low power timer"] pub type Lptim2 = crate :: Periph < lptim1 :: RegisterBlock , 0x4000_9400 > ; impl core :: fmt :: Debug for Lptim2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Lptim2") . finish () } }
#[doc = "Low power timer"] pub use self :: lptim1 as lptim2 ;
#[doc = "Universal synchronous asynchronous receiver transmitter"] pub type Usart1 = crate :: Periph < usart1 :: RegisterBlock , 0x4001_3800 > ; impl core :: fmt :: Debug for Usart1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Usart1") . finish () } }
#[doc = "Universal synchronous asynchronous receiver transmitter"] pub mod usart1 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr1 : Cr1 , cr2 : Cr2 , cr3 : Cr3 , brr : Brr , gtpr : Gtpr , rtor : Rtor , rqr : Rqr , isr : Isr , icr : Icr , rdr : Rdr , tdr : Tdr , presc : Presc , } impl RegisterBlock {
#[doc = "0x00 - Control register 1"]
#[inline (always)] pub const fn cr1 (& self) -> & Cr1 { & self . cr1 }
#[doc = "0x04 - Control register 2"]
#[inline (always)] pub const fn cr2 (& self) -> & Cr2 { & self . cr2 }
#[doc = "0x08 - Control register 3"]
#[inline (always)] pub const fn cr3 (& self) -> & Cr3 { & self . cr3 }
#[doc = "0x0c - Baud rate register"]
#[inline (always)] pub const fn brr (& self) -> & Brr { & self . brr }
#[doc = "0x10 - Guard time and prescaler register"]
#[inline (always)] pub const fn gtpr (& self) -> & Gtpr { & self . gtpr }
#[doc = "0x14 - Receiver timeout register"]
#[inline (always)] pub const fn rtor (& self) -> & Rtor { & self . rtor }
#[doc = "0x18 - Request register"]
#[inline (always)] pub const fn rqr (& self) -> & Rqr { & self . rqr }
#[doc = "0x1c - Interrupt & status register"]
#[inline (always)] pub const fn isr (& self) -> & Isr { & self . isr }
#[doc = "0x20 - Interrupt flag clear register"]
#[inline (always)] pub const fn icr (& self) -> & Icr { & self . icr }
#[doc = "0x24 - Receive data register"]
#[inline (always)] pub const fn rdr (& self) -> & Rdr { & self . rdr }
#[doc = "0x28 - Transmit data register"]
#[inline (always)] pub const fn tdr (& self) -> & Tdr { & self . tdr }
#[doc = "0x2c - Prescaler register"]
#[inline (always)] pub const fn presc (& self) -> & Presc { & self . presc } }
#[doc = "CR1 (rw) register accessor: Control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
#[doc (alias = "CR1")] pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ;
#[doc = "Control register 1"] pub mod cr1 {
#[doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ;
#[doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ;
#[doc = "Field `UE` reader - USART enable"] pub type UeR = crate :: BitReader ;
#[doc = "Field `UE` writer - USART enable"] pub type UeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UESM` reader - USART enable in Stop mode"] pub type UesmR = crate :: BitReader ;
#[doc = "Field `UESM` writer - USART enable in Stop mode"] pub type UesmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RE` reader - Receiver enable"] pub type ReR = crate :: BitReader ;
#[doc = "Field `RE` writer - Receiver enable"] pub type ReW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TE` reader - Transmitter enable"] pub type TeR = crate :: BitReader ;
#[doc = "Field `TE` writer - Transmitter enable"] pub type TeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IDLEIE` reader - IDLE interrupt enable"] pub type IdleieR = crate :: BitReader ;
#[doc = "Field `IDLEIE` writer - IDLE interrupt enable"] pub type IdleieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXNEIE` reader - RXNE interrupt enable"] pub type RxneieR = crate :: BitReader ;
#[doc = "Field `RXNEIE` writer - RXNE interrupt enable"] pub type RxneieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transmission complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transmission complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXEIE` reader - interrupt enable"] pub type TxeieR = crate :: BitReader ;
#[doc = "Field `TXEIE` writer - interrupt enable"] pub type TxeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PEIE` reader - PE interrupt enable"] pub type PeieR = crate :: BitReader ;
#[doc = "Field `PEIE` writer - PE interrupt enable"] pub type PeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PS` reader - Parity selection"] pub type PsR = crate :: BitReader ;
#[doc = "Field `PS` writer - Parity selection"] pub type PsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PCE` reader - Parity control enable"] pub type PceR = crate :: BitReader ;
#[doc = "Field `PCE` writer - Parity control enable"] pub type PceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WAKE` reader - Receiver wakeup method"] pub type WakeR = crate :: BitReader ;
#[doc = "Field `WAKE` writer - Receiver wakeup method"] pub type WakeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `M0` reader - Word length"] pub type M0R = crate :: BitReader ;
#[doc = "Field `M0` writer - Word length"] pub type M0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MME` reader - Mute mode enable"] pub type MmeR = crate :: BitReader ;
#[doc = "Field `MME` writer - Mute mode enable"] pub type MmeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CMIE` reader - Character match interrupt enable"] pub type CmieR = crate :: BitReader ;
#[doc = "Field `CMIE` writer - Character match interrupt enable"] pub type CmieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OVER8` reader - Oversampling mode"] pub type Over8R = crate :: BitReader ;
#[doc = "Field `OVER8` writer - Oversampling mode"] pub type Over8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DEDT0` reader - DEDT0"] pub type Dedt0R = crate :: BitReader ;
#[doc = "Field `DEDT0` writer - DEDT0"] pub type Dedt0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DEDT1` reader - DEDT1"] pub type Dedt1R = crate :: BitReader ;
#[doc = "Field `DEDT1` writer - DEDT1"] pub type Dedt1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DEDT2` reader - DEDT2"] pub type Dedt2R = crate :: BitReader ;
#[doc = "Field `DEDT2` writer - DEDT2"] pub type Dedt2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DEDT3` reader - DEDT3"] pub type Dedt3R = crate :: BitReader ;
#[doc = "Field `DEDT3` writer - DEDT3"] pub type Dedt3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DEDT4` reader - Driver Enable de-assertion time"] pub type Dedt4R = crate :: BitReader ;
#[doc = "Field `DEDT4` writer - Driver Enable de-assertion time"] pub type Dedt4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DEAT0` reader - DEAT0"] pub type Deat0R = crate :: BitReader ;
#[doc = "Field `DEAT0` writer - DEAT0"] pub type Deat0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DEAT1` reader - DEAT1"] pub type Deat1R = crate :: BitReader ;
#[doc = "Field `DEAT1` writer - DEAT1"] pub type Deat1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DEAT2` reader - DEAT2"] pub type Deat2R = crate :: BitReader ;
#[doc = "Field `DEAT2` writer - DEAT2"] pub type Deat2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DEAT3` reader - DEAT3"] pub type Deat3R = crate :: BitReader ;
#[doc = "Field `DEAT3` writer - DEAT3"] pub type Deat3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DEAT4` reader - Driver Enable assertion time"] pub type Deat4R = crate :: BitReader ;
#[doc = "Field `DEAT4` writer - Driver Enable assertion time"] pub type Deat4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RTOIE` reader - Receiver timeout interrupt enable"] pub type RtoieR = crate :: BitReader ;
#[doc = "Field `RTOIE` writer - Receiver timeout interrupt enable"] pub type RtoieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EOBIE` reader - End of Block interrupt enable"] pub type EobieR = crate :: BitReader ;
#[doc = "Field `EOBIE` writer - End of Block interrupt enable"] pub type EobieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `M1` reader - Word length"] pub type M1R = crate :: BitReader ;
#[doc = "Field `M1` writer - Word length"] pub type M1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FIFOEN` reader - FIFO mode enable"] pub type FifoenR = crate :: BitReader ;
#[doc = "Field `FIFOEN` writer - FIFO mode enable"] pub type FifoenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXFEIE` reader - TXFIFO empty interrupt enable"] pub type TxfeieR = crate :: BitReader ;
#[doc = "Field `TXFEIE` writer - TXFIFO empty interrupt enable"] pub type TxfeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXFFIE` reader - RXFIFO Full interrupt enable"] pub type RxffieR = crate :: BitReader ;
#[doc = "Field `RXFFIE` writer - RXFIFO Full interrupt enable"] pub type RxffieW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - USART enable"]
#[inline (always)] pub fn ue (& self) -> UeR { UeR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - USART enable in Stop mode"]
#[inline (always)] pub fn uesm (& self) -> UesmR { UesmR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Receiver enable"]
#[inline (always)] pub fn re (& self) -> ReR { ReR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transmitter enable"]
#[inline (always)] pub fn te (& self) -> TeR { TeR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - IDLE interrupt enable"]
#[inline (always)] pub fn idleie (& self) -> IdleieR { IdleieR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RXNE interrupt enable"]
#[inline (always)] pub fn rxneie (& self) -> RxneieR { RxneieR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Transmission complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - interrupt enable"]
#[inline (always)] pub fn txeie (& self) -> TxeieR { TxeieR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - PE interrupt enable"]
#[inline (always)] pub fn peie (& self) -> PeieR { PeieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Parity selection"]
#[inline (always)] pub fn ps (& self) -> PsR { PsR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Parity control enable"]
#[inline (always)] pub fn pce (& self) -> PceR { PceR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Receiver wakeup method"]
#[inline (always)] pub fn wake (& self) -> WakeR { WakeR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Word length"]
#[inline (always)] pub fn m0 (& self) -> M0R { M0R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Mute mode enable"]
#[inline (always)] pub fn mme (& self) -> MmeR { MmeR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Character match interrupt enable"]
#[inline (always)] pub fn cmie (& self) -> CmieR { CmieR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Oversampling mode"]
#[inline (always)] pub fn over8 (& self) -> Over8R { Over8R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - DEDT0"]
#[inline (always)] pub fn dedt0 (& self) -> Dedt0R { Dedt0R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - DEDT1"]
#[inline (always)] pub fn dedt1 (& self) -> Dedt1R { Dedt1R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - DEDT2"]
#[inline (always)] pub fn dedt2 (& self) -> Dedt2R { Dedt2R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - DEDT3"]
#[inline (always)] pub fn dedt3 (& self) -> Dedt3R { Dedt3R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Driver Enable de-assertion time"]
#[inline (always)] pub fn dedt4 (& self) -> Dedt4R { Dedt4R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - DEAT0"]
#[inline (always)] pub fn deat0 (& self) -> Deat0R { Deat0R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - DEAT1"]
#[inline (always)] pub fn deat1 (& self) -> Deat1R { Deat1R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - DEAT2"]
#[inline (always)] pub fn deat2 (& self) -> Deat2R { Deat2R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - DEAT3"]
#[inline (always)] pub fn deat3 (& self) -> Deat3R { Deat3R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Driver Enable assertion time"]
#[inline (always)] pub fn deat4 (& self) -> Deat4R { Deat4R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Receiver timeout interrupt enable"]
#[inline (always)] pub fn rtoie (& self) -> RtoieR { RtoieR :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - End of Block interrupt enable"]
#[inline (always)] pub fn eobie (& self) -> EobieR { EobieR :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Word length"]
#[inline (always)] pub fn m1 (& self) -> M1R { M1R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - FIFO mode enable"]
#[inline (always)] pub fn fifoen (& self) -> FifoenR { FifoenR :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - TXFIFO empty interrupt enable"]
#[inline (always)] pub fn txfeie (& self) -> TxfeieR { TxfeieR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - RXFIFO Full interrupt enable"]
#[inline (always)] pub fn rxffie (& self) -> RxffieR { RxffieR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - USART enable"]
#[inline (always)] pub fn ue (& mut self) -> UeW < '_ , Cr1Spec > { UeW :: new (self , 0) }
#[doc = "Bit 1 - USART enable in Stop mode"]
#[inline (always)] pub fn uesm (& mut self) -> UesmW < '_ , Cr1Spec > { UesmW :: new (self , 1) }
#[doc = "Bit 2 - Receiver enable"]
#[inline (always)] pub fn re (& mut self) -> ReW < '_ , Cr1Spec > { ReW :: new (self , 2) }
#[doc = "Bit 3 - Transmitter enable"]
#[inline (always)] pub fn te (& mut self) -> TeW < '_ , Cr1Spec > { TeW :: new (self , 3) }
#[doc = "Bit 4 - IDLE interrupt enable"]
#[inline (always)] pub fn idleie (& mut self) -> IdleieW < '_ , Cr1Spec > { IdleieW :: new (self , 4) }
#[doc = "Bit 5 - RXNE interrupt enable"]
#[inline (always)] pub fn rxneie (& mut self) -> RxneieW < '_ , Cr1Spec > { RxneieW :: new (self , 5) }
#[doc = "Bit 6 - Transmission complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Cr1Spec > { TcieW :: new (self , 6) }
#[doc = "Bit 7 - interrupt enable"]
#[inline (always)] pub fn txeie (& mut self) -> TxeieW < '_ , Cr1Spec > { TxeieW :: new (self , 7) }
#[doc = "Bit 8 - PE interrupt enable"]
#[inline (always)] pub fn peie (& mut self) -> PeieW < '_ , Cr1Spec > { PeieW :: new (self , 8) }
#[doc = "Bit 9 - Parity selection"]
#[inline (always)] pub fn ps (& mut self) -> PsW < '_ , Cr1Spec > { PsW :: new (self , 9) }
#[doc = "Bit 10 - Parity control enable"]
#[inline (always)] pub fn pce (& mut self) -> PceW < '_ , Cr1Spec > { PceW :: new (self , 10) }
#[doc = "Bit 11 - Receiver wakeup method"]
#[inline (always)] pub fn wake (& mut self) -> WakeW < '_ , Cr1Spec > { WakeW :: new (self , 11) }
#[doc = "Bit 12 - Word length"]
#[inline (always)] pub fn m0 (& mut self) -> M0W < '_ , Cr1Spec > { M0W :: new (self , 12) }
#[doc = "Bit 13 - Mute mode enable"]
#[inline (always)] pub fn mme (& mut self) -> MmeW < '_ , Cr1Spec > { MmeW :: new (self , 13) }
#[doc = "Bit 14 - Character match interrupt enable"]
#[inline (always)] pub fn cmie (& mut self) -> CmieW < '_ , Cr1Spec > { CmieW :: new (self , 14) }
#[doc = "Bit 15 - Oversampling mode"]
#[inline (always)] pub fn over8 (& mut self) -> Over8W < '_ , Cr1Spec > { Over8W :: new (self , 15) }
#[doc = "Bit 16 - DEDT0"]
#[inline (always)] pub fn dedt0 (& mut self) -> Dedt0W < '_ , Cr1Spec > { Dedt0W :: new (self , 16) }
#[doc = "Bit 17 - DEDT1"]
#[inline (always)] pub fn dedt1 (& mut self) -> Dedt1W < '_ , Cr1Spec > { Dedt1W :: new (self , 17) }
#[doc = "Bit 18 - DEDT2"]
#[inline (always)] pub fn dedt2 (& mut self) -> Dedt2W < '_ , Cr1Spec > { Dedt2W :: new (self , 18) }
#[doc = "Bit 19 - DEDT3"]
#[inline (always)] pub fn dedt3 (& mut self) -> Dedt3W < '_ , Cr1Spec > { Dedt3W :: new (self , 19) }
#[doc = "Bit 20 - Driver Enable de-assertion time"]
#[inline (always)] pub fn dedt4 (& mut self) -> Dedt4W < '_ , Cr1Spec > { Dedt4W :: new (self , 20) }
#[doc = "Bit 21 - DEAT0"]
#[inline (always)] pub fn deat0 (& mut self) -> Deat0W < '_ , Cr1Spec > { Deat0W :: new (self , 21) }
#[doc = "Bit 22 - DEAT1"]
#[inline (always)] pub fn deat1 (& mut self) -> Deat1W < '_ , Cr1Spec > { Deat1W :: new (self , 22) }
#[doc = "Bit 23 - DEAT2"]
#[inline (always)] pub fn deat2 (& mut self) -> Deat2W < '_ , Cr1Spec > { Deat2W :: new (self , 23) }
#[doc = "Bit 24 - DEAT3"]
#[inline (always)] pub fn deat3 (& mut self) -> Deat3W < '_ , Cr1Spec > { Deat3W :: new (self , 24) }
#[doc = "Bit 25 - Driver Enable assertion time"]
#[inline (always)] pub fn deat4 (& mut self) -> Deat4W < '_ , Cr1Spec > { Deat4W :: new (self , 25) }
#[doc = "Bit 26 - Receiver timeout interrupt enable"]
#[inline (always)] pub fn rtoie (& mut self) -> RtoieW < '_ , Cr1Spec > { RtoieW :: new (self , 26) }
#[doc = "Bit 27 - End of Block interrupt enable"]
#[inline (always)] pub fn eobie (& mut self) -> EobieW < '_ , Cr1Spec > { EobieW :: new (self , 27) }
#[doc = "Bit 28 - Word length"]
#[inline (always)] pub fn m1 (& mut self) -> M1W < '_ , Cr1Spec > { M1W :: new (self , 28) }
#[doc = "Bit 29 - FIFO mode enable"]
#[inline (always)] pub fn fifoen (& mut self) -> FifoenW < '_ , Cr1Spec > { FifoenW :: new (self , 29) }
#[doc = "Bit 30 - TXFIFO empty interrupt enable"]
#[inline (always)] pub fn txfeie (& mut self) -> TxfeieW < '_ , Cr1Spec > { TxfeieW :: new (self , 30) }
#[doc = "Bit 31 - RXFIFO Full interrupt enable"]
#[inline (always)] pub fn rxffie (& mut self) -> RxffieW < '_ , Cr1Spec > { RxffieW :: new (self , 31) } }
#[doc = "Control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { } }
#[doc = "CR2 (rw) register accessor: Control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`] module"]
#[doc (alias = "CR2")] pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ;
#[doc = "Control register 2"] pub mod cr2 {
#[doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ;
#[doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ;
#[doc = "Field `SLVEN` reader - Synchronous Slave mode enable"] pub type SlvenR = crate :: BitReader ;
#[doc = "Field `SLVEN` writer - Synchronous Slave mode enable"] pub type SlvenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIS_NSS` reader - When the DSI_NSS bit is set, the NSS pin input will be ignored"] pub type DisNssR = crate :: BitReader ;
#[doc = "Field `DIS_NSS` writer - When the DSI_NSS bit is set, the NSS pin input will be ignored"] pub type DisNssW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADDM7` reader - 7-bit Address Detection/4-bit Address Detection"] pub type Addm7R = crate :: BitReader ;
#[doc = "Field `ADDM7` writer - 7-bit Address Detection/4-bit Address Detection"] pub type Addm7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LBDL` reader - LIN break detection length"] pub type LbdlR = crate :: BitReader ;
#[doc = "Field `LBDL` writer - LIN break detection length"] pub type LbdlW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LBDIE` reader - LIN break detection interrupt enable"] pub type LbdieR = crate :: BitReader ;
#[doc = "Field `LBDIE` writer - LIN break detection interrupt enable"] pub type LbdieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LBCL` reader - Last bit clock pulse"] pub type LbclR = crate :: BitReader ;
#[doc = "Field `LBCL` writer - Last bit clock pulse"] pub type LbclW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CPHA` reader - Clock phase"] pub type CphaR = crate :: BitReader ;
#[doc = "Field `CPHA` writer - Clock phase"] pub type CphaW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CPOL` reader - Clock polarity"] pub type CpolR = crate :: BitReader ;
#[doc = "Field `CPOL` writer - Clock polarity"] pub type CpolW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CLKEN` reader - Clock enable"] pub type ClkenR = crate :: BitReader ;
#[doc = "Field `CLKEN` writer - Clock enable"] pub type ClkenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STOP` reader - STOP bits"] pub type StopR = crate :: FieldReader ;
#[doc = "Field `STOP` writer - STOP bits"] pub type StopW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `LINEN` reader - LIN mode enable"] pub type LinenR = crate :: BitReader ;
#[doc = "Field `LINEN` writer - LIN mode enable"] pub type LinenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWAP` reader - Swap TX/RX pins"] pub type SwapR = crate :: BitReader ;
#[doc = "Field `SWAP` writer - Swap TX/RX pins"] pub type SwapW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXINV` reader - RX pin active level inversion"] pub type RxinvR = crate :: BitReader ;
#[doc = "Field `RXINV` writer - RX pin active level inversion"] pub type RxinvW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXINV` reader - TX pin active level inversion"] pub type TxinvR = crate :: BitReader ;
#[doc = "Field `TXINV` writer - TX pin active level inversion"] pub type TxinvW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TAINV` reader - Binary data inversion"] pub type TainvR = crate :: BitReader ;
#[doc = "Field `TAINV` writer - Binary data inversion"] pub type TainvW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MSBFIRST` reader - Most significant bit first"] pub type MsbfirstR = crate :: BitReader ;
#[doc = "Field `MSBFIRST` writer - Most significant bit first"] pub type MsbfirstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ABREN` reader - Auto baud rate enable"] pub type AbrenR = crate :: BitReader ;
#[doc = "Field `ABREN` writer - Auto baud rate enable"] pub type AbrenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ABRMOD0` reader - ABRMOD0"] pub type Abrmod0R = crate :: BitReader ;
#[doc = "Field `ABRMOD0` writer - ABRMOD0"] pub type Abrmod0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ABRMOD1` reader - Auto baud rate mode"] pub type Abrmod1R = crate :: BitReader ;
#[doc = "Field `ABRMOD1` writer - Auto baud rate mode"] pub type Abrmod1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RTOEN` reader - Receiver timeout enable"] pub type RtoenR = crate :: BitReader ;
#[doc = "Field `RTOEN` writer - Receiver timeout enable"] pub type RtoenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADD0_3` reader - Address of the USART node"] pub type Add0_3R = crate :: FieldReader ;
#[doc = "Field `ADD0_3` writer - Address of the USART node"] pub type Add0_3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ADD4_7` reader - Address of the USART node"] pub type Add4_7R = crate :: FieldReader ;
#[doc = "Field `ADD4_7` writer - Address of the USART node"] pub type Add4_7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bit 0 - Synchronous Slave mode enable"]
#[inline (always)] pub fn slven (& self) -> SlvenR { SlvenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 3 - When the DSI_NSS bit is set, the NSS pin input will be ignored"]
#[inline (always)] pub fn dis_nss (& self) -> DisNssR { DisNssR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - 7-bit Address Detection/4-bit Address Detection"]
#[inline (always)] pub fn addm7 (& self) -> Addm7R { Addm7R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - LIN break detection length"]
#[inline (always)] pub fn lbdl (& self) -> LbdlR { LbdlR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - LIN break detection interrupt enable"]
#[inline (always)] pub fn lbdie (& self) -> LbdieR { LbdieR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 8 - Last bit clock pulse"]
#[inline (always)] pub fn lbcl (& self) -> LbclR { LbclR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Clock phase"]
#[inline (always)] pub fn cpha (& self) -> CphaR { CphaR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Clock polarity"]
#[inline (always)] pub fn cpol (& self) -> CpolR { CpolR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Clock enable"]
#[inline (always)] pub fn clken (& self) -> ClkenR { ClkenR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:13 - STOP bits"]
#[inline (always)] pub fn stop (& self) -> StopR { StopR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - LIN mode enable"]
#[inline (always)] pub fn linen (& self) -> LinenR { LinenR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Swap TX/RX pins"]
#[inline (always)] pub fn swap (& self) -> SwapR { SwapR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - RX pin active level inversion"]
#[inline (always)] pub fn rxinv (& self) -> RxinvR { RxinvR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - TX pin active level inversion"]
#[inline (always)] pub fn txinv (& self) -> TxinvR { TxinvR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Binary data inversion"]
#[inline (always)] pub fn tainv (& self) -> TainvR { TainvR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Most significant bit first"]
#[inline (always)] pub fn msbfirst (& self) -> MsbfirstR { MsbfirstR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Auto baud rate enable"]
#[inline (always)] pub fn abren (& self) -> AbrenR { AbrenR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - ABRMOD0"]
#[inline (always)] pub fn abrmod0 (& self) -> Abrmod0R { Abrmod0R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Auto baud rate mode"]
#[inline (always)] pub fn abrmod1 (& self) -> Abrmod1R { Abrmod1R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Receiver timeout enable"]
#[inline (always)] pub fn rtoen (& self) -> RtoenR { RtoenR :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bits 24:27 - Address of the USART node"]
#[inline (always)] pub fn add0_3 (& self) -> Add0_3R { Add0_3R :: new (((self . bits >> 24) & 0x0f) as u8) }
#[doc = "Bits 28:31 - Address of the USART node"]
#[inline (always)] pub fn add4_7 (& self) -> Add4_7R { Add4_7R :: new (((self . bits >> 28) & 0x0f) as u8) } } impl W {
#[doc = "Bit 0 - Synchronous Slave mode enable"]
#[inline (always)] pub fn slven (& mut self) -> SlvenW < '_ , Cr2Spec > { SlvenW :: new (self , 0) }
#[doc = "Bit 3 - When the DSI_NSS bit is set, the NSS pin input will be ignored"]
#[inline (always)] pub fn dis_nss (& mut self) -> DisNssW < '_ , Cr2Spec > { DisNssW :: new (self , 3) }
#[doc = "Bit 4 - 7-bit Address Detection/4-bit Address Detection"]
#[inline (always)] pub fn addm7 (& mut self) -> Addm7W < '_ , Cr2Spec > { Addm7W :: new (self , 4) }
#[doc = "Bit 5 - LIN break detection length"]
#[inline (always)] pub fn lbdl (& mut self) -> LbdlW < '_ , Cr2Spec > { LbdlW :: new (self , 5) }
#[doc = "Bit 6 - LIN break detection interrupt enable"]
#[inline (always)] pub fn lbdie (& mut self) -> LbdieW < '_ , Cr2Spec > { LbdieW :: new (self , 6) }
#[doc = "Bit 8 - Last bit clock pulse"]
#[inline (always)] pub fn lbcl (& mut self) -> LbclW < '_ , Cr2Spec > { LbclW :: new (self , 8) }
#[doc = "Bit 9 - Clock phase"]
#[inline (always)] pub fn cpha (& mut self) -> CphaW < '_ , Cr2Spec > { CphaW :: new (self , 9) }
#[doc = "Bit 10 - Clock polarity"]
#[inline (always)] pub fn cpol (& mut self) -> CpolW < '_ , Cr2Spec > { CpolW :: new (self , 10) }
#[doc = "Bit 11 - Clock enable"]
#[inline (always)] pub fn clken (& mut self) -> ClkenW < '_ , Cr2Spec > { ClkenW :: new (self , 11) }
#[doc = "Bits 12:13 - STOP bits"]
#[inline (always)] pub fn stop (& mut self) -> StopW < '_ , Cr2Spec > { StopW :: new (self , 12) }
#[doc = "Bit 14 - LIN mode enable"]
#[inline (always)] pub fn linen (& mut self) -> LinenW < '_ , Cr2Spec > { LinenW :: new (self , 14) }
#[doc = "Bit 15 - Swap TX/RX pins"]
#[inline (always)] pub fn swap (& mut self) -> SwapW < '_ , Cr2Spec > { SwapW :: new (self , 15) }
#[doc = "Bit 16 - RX pin active level inversion"]
#[inline (always)] pub fn rxinv (& mut self) -> RxinvW < '_ , Cr2Spec > { RxinvW :: new (self , 16) }
#[doc = "Bit 17 - TX pin active level inversion"]
#[inline (always)] pub fn txinv (& mut self) -> TxinvW < '_ , Cr2Spec > { TxinvW :: new (self , 17) }
#[doc = "Bit 18 - Binary data inversion"]
#[inline (always)] pub fn tainv (& mut self) -> TainvW < '_ , Cr2Spec > { TainvW :: new (self , 18) }
#[doc = "Bit 19 - Most significant bit first"]
#[inline (always)] pub fn msbfirst (& mut self) -> MsbfirstW < '_ , Cr2Spec > { MsbfirstW :: new (self , 19) }
#[doc = "Bit 20 - Auto baud rate enable"]
#[inline (always)] pub fn abren (& mut self) -> AbrenW < '_ , Cr2Spec > { AbrenW :: new (self , 20) }
#[doc = "Bit 21 - ABRMOD0"]
#[inline (always)] pub fn abrmod0 (& mut self) -> Abrmod0W < '_ , Cr2Spec > { Abrmod0W :: new (self , 21) }
#[doc = "Bit 22 - Auto baud rate mode"]
#[inline (always)] pub fn abrmod1 (& mut self) -> Abrmod1W < '_ , Cr2Spec > { Abrmod1W :: new (self , 22) }
#[doc = "Bit 23 - Receiver timeout enable"]
#[inline (always)] pub fn rtoen (& mut self) -> RtoenW < '_ , Cr2Spec > { RtoenW :: new (self , 23) }
#[doc = "Bits 24:27 - Address of the USART node"]
#[inline (always)] pub fn add0_3 (& mut self) -> Add0_3W < '_ , Cr2Spec > { Add0_3W :: new (self , 24) }
#[doc = "Bits 28:31 - Address of the USART node"]
#[inline (always)] pub fn add4_7 (& mut self) -> Add4_7W < '_ , Cr2Spec > { Add4_7W :: new (self , 28) } }
#[doc = "Control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR2 to value 0"] impl crate :: Resettable for Cr2Spec { } }
#[doc = "CR3 (rw) register accessor: Control register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`cr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr3`] module"]
#[doc (alias = "CR3")] pub type Cr3 = crate :: Reg < cr3 :: Cr3Spec > ;
#[doc = "Control register 3"] pub mod cr3 {
#[doc = "Register `CR3` reader"] pub type R = crate :: R < Cr3Spec > ;
#[doc = "Register `CR3` writer"] pub type W = crate :: W < Cr3Spec > ;
#[doc = "Field `EIE` reader - Error interrupt enable"] pub type EieR = crate :: BitReader ;
#[doc = "Field `EIE` writer - Error interrupt enable"] pub type EieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IREN` reader - Ir mode enable"] pub type IrenR = crate :: BitReader ;
#[doc = "Field `IREN` writer - Ir mode enable"] pub type IrenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IRLP` reader - Ir low-power"] pub type IrlpR = crate :: BitReader ;
#[doc = "Field `IRLP` writer - Ir low-power"] pub type IrlpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HDSEL` reader - Half-duplex selection"] pub type HdselR = crate :: BitReader ;
#[doc = "Field `HDSEL` writer - Half-duplex selection"] pub type HdselW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NACK` reader - Smartcard NACK enable"] pub type NackR = crate :: BitReader ;
#[doc = "Field `NACK` writer - Smartcard NACK enable"] pub type NackW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SCEN` reader - Smartcard mode enable"] pub type ScenR = crate :: BitReader ;
#[doc = "Field `SCEN` writer - Smartcard mode enable"] pub type ScenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMAR` reader - DMA enable receiver"] pub type DmarR = crate :: BitReader ;
#[doc = "Field `DMAR` writer - DMA enable receiver"] pub type DmarW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMAT` reader - DMA enable transmitter"] pub type DmatR = crate :: BitReader ;
#[doc = "Field `DMAT` writer - DMA enable transmitter"] pub type DmatW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RTSE` reader - RTS enable"] pub type RtseR = crate :: BitReader ;
#[doc = "Field `RTSE` writer - RTS enable"] pub type RtseW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTSE` reader - CTS enable"] pub type CtseR = crate :: BitReader ;
#[doc = "Field `CTSE` writer - CTS enable"] pub type CtseW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTSIE` reader - CTS interrupt enable"] pub type CtsieR = crate :: BitReader ;
#[doc = "Field `CTSIE` writer - CTS interrupt enable"] pub type CtsieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ONEBIT` reader - One sample bit method enable"] pub type OnebitR = crate :: BitReader ;
#[doc = "Field `ONEBIT` writer - One sample bit method enable"] pub type OnebitW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OVRDIS` reader - Overrun Disable"] pub type OvrdisR = crate :: BitReader ;
#[doc = "Field `OVRDIS` writer - Overrun Disable"] pub type OvrdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DDRE` reader - DMA Disable on Reception Error"] pub type DdreR = crate :: BitReader ;
#[doc = "Field `DDRE` writer - DMA Disable on Reception Error"] pub type DdreW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DEM` reader - Driver enable mode"] pub type DemR = crate :: BitReader ;
#[doc = "Field `DEM` writer - Driver enable mode"] pub type DemW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DEP` reader - Driver enable polarity selection"] pub type DepR = crate :: BitReader ;
#[doc = "Field `DEP` writer - Driver enable polarity selection"] pub type DepW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SCARCNT` reader - Smartcard auto-retry count"] pub type ScarcntR = crate :: FieldReader ;
#[doc = "Field `SCARCNT` writer - Smartcard auto-retry count"] pub type ScarcntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `WUS` reader - Wakeup from Stop mode interrupt flag selection"] pub type WusR = crate :: FieldReader ;
#[doc = "Field `WUS` writer - Wakeup from Stop mode interrupt flag selection"] pub type WusW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `WUFIE` reader - Wakeup from Stop mode interrupt enable"] pub type WufieR = crate :: BitReader ;
#[doc = "Field `WUFIE` writer - Wakeup from Stop mode interrupt enable"] pub type WufieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXFTIE` reader - threshold interrupt enable"] pub type TxftieR = crate :: BitReader ;
#[doc = "Field `TXFTIE` writer - threshold interrupt enable"] pub type TxftieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCBGTIE` reader - Tr Complete before guard time, interrupt enable"] pub type TcbgtieR = crate :: BitReader ;
#[doc = "Field `TCBGTIE` writer - Tr Complete before guard time, interrupt enable"] pub type TcbgtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXFTCFG` reader - Receive FIFO threshold configuration"] pub type RxftcfgR = crate :: FieldReader ;
#[doc = "Field `RXFTCFG` writer - Receive FIFO threshold configuration"] pub type RxftcfgW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `RXFTIE` reader - RXFIFO threshold interrupt enable"] pub type RxftieR = crate :: BitReader ;
#[doc = "Field `RXFTIE` writer - RXFIFO threshold interrupt enable"] pub type RxftieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXFTCFG` reader - TXFIFO threshold configuration"] pub type TxftcfgR = crate :: FieldReader ;
#[doc = "Field `TXFTCFG` writer - TXFIFO threshold configuration"] pub type TxftcfgW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bit 0 - Error interrupt enable"]
#[inline (always)] pub fn eie (& self) -> EieR { EieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Ir mode enable"]
#[inline (always)] pub fn iren (& self) -> IrenR { IrenR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Ir low-power"]
#[inline (always)] pub fn irlp (& self) -> IrlpR { IrlpR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Half-duplex selection"]
#[inline (always)] pub fn hdsel (& self) -> HdselR { HdselR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Smartcard NACK enable"]
#[inline (always)] pub fn nack (& self) -> NackR { NackR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Smartcard mode enable"]
#[inline (always)] pub fn scen (& self) -> ScenR { ScenR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - DMA enable receiver"]
#[inline (always)] pub fn dmar (& self) -> DmarR { DmarR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - DMA enable transmitter"]
#[inline (always)] pub fn dmat (& self) -> DmatR { DmatR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - RTS enable"]
#[inline (always)] pub fn rtse (& self) -> RtseR { RtseR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - CTS enable"]
#[inline (always)] pub fn ctse (& self) -> CtseR { CtseR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - CTS interrupt enable"]
#[inline (always)] pub fn ctsie (& self) -> CtsieR { CtsieR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - One sample bit method enable"]
#[inline (always)] pub fn onebit (& self) -> OnebitR { OnebitR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Overrun Disable"]
#[inline (always)] pub fn ovrdis (& self) -> OvrdisR { OvrdisR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - DMA Disable on Reception Error"]
#[inline (always)] pub fn ddre (& self) -> DdreR { DdreR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Driver enable mode"]
#[inline (always)] pub fn dem (& self) -> DemR { DemR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Driver enable polarity selection"]
#[inline (always)] pub fn dep (& self) -> DepR { DepR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bits 17:19 - Smartcard auto-retry count"]
#[inline (always)] pub fn scarcnt (& self) -> ScarcntR { ScarcntR :: new (((self . bits >> 17) & 7) as u8) }
#[doc = "Bits 20:21 - Wakeup from Stop mode interrupt flag selection"]
#[inline (always)] pub fn wus (& self) -> WusR { WusR :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bit 22 - Wakeup from Stop mode interrupt enable"]
#[inline (always)] pub fn wufie (& self) -> WufieR { WufieR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - threshold interrupt enable"]
#[inline (always)] pub fn txftie (& self) -> TxftieR { TxftieR :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Tr Complete before guard time, interrupt enable"]
#[inline (always)] pub fn tcbgtie (& self) -> TcbgtieR { TcbgtieR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bits 25:27 - Receive FIFO threshold configuration"]
#[inline (always)] pub fn rxftcfg (& self) -> RxftcfgR { RxftcfgR :: new (((self . bits >> 25) & 7) as u8) }
#[doc = "Bit 28 - RXFIFO threshold interrupt enable"]
#[inline (always)] pub fn rxftie (& self) -> RxftieR { RxftieR :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bits 29:31 - TXFIFO threshold configuration"]
#[inline (always)] pub fn txftcfg (& self) -> TxftcfgR { TxftcfgR :: new (((self . bits >> 29) & 7) as u8) } } impl W {
#[doc = "Bit 0 - Error interrupt enable"]
#[inline (always)] pub fn eie (& mut self) -> EieW < '_ , Cr3Spec > { EieW :: new (self , 0) }
#[doc = "Bit 1 - Ir mode enable"]
#[inline (always)] pub fn iren (& mut self) -> IrenW < '_ , Cr3Spec > { IrenW :: new (self , 1) }
#[doc = "Bit 2 - Ir low-power"]
#[inline (always)] pub fn irlp (& mut self) -> IrlpW < '_ , Cr3Spec > { IrlpW :: new (self , 2) }
#[doc = "Bit 3 - Half-duplex selection"]
#[inline (always)] pub fn hdsel (& mut self) -> HdselW < '_ , Cr3Spec > { HdselW :: new (self , 3) }
#[doc = "Bit 4 - Smartcard NACK enable"]
#[inline (always)] pub fn nack (& mut self) -> NackW < '_ , Cr3Spec > { NackW :: new (self , 4) }
#[doc = "Bit 5 - Smartcard mode enable"]
#[inline (always)] pub fn scen (& mut self) -> ScenW < '_ , Cr3Spec > { ScenW :: new (self , 5) }
#[doc = "Bit 6 - DMA enable receiver"]
#[inline (always)] pub fn dmar (& mut self) -> DmarW < '_ , Cr3Spec > { DmarW :: new (self , 6) }
#[doc = "Bit 7 - DMA enable transmitter"]
#[inline (always)] pub fn dmat (& mut self) -> DmatW < '_ , Cr3Spec > { DmatW :: new (self , 7) }
#[doc = "Bit 8 - RTS enable"]
#[inline (always)] pub fn rtse (& mut self) -> RtseW < '_ , Cr3Spec > { RtseW :: new (self , 8) }
#[doc = "Bit 9 - CTS enable"]
#[inline (always)] pub fn ctse (& mut self) -> CtseW < '_ , Cr3Spec > { CtseW :: new (self , 9) }
#[doc = "Bit 10 - CTS interrupt enable"]
#[inline (always)] pub fn ctsie (& mut self) -> CtsieW < '_ , Cr3Spec > { CtsieW :: new (self , 10) }
#[doc = "Bit 11 - One sample bit method enable"]
#[inline (always)] pub fn onebit (& mut self) -> OnebitW < '_ , Cr3Spec > { OnebitW :: new (self , 11) }
#[doc = "Bit 12 - Overrun Disable"]
#[inline (always)] pub fn ovrdis (& mut self) -> OvrdisW < '_ , Cr3Spec > { OvrdisW :: new (self , 12) }
#[doc = "Bit 13 - DMA Disable on Reception Error"]
#[inline (always)] pub fn ddre (& mut self) -> DdreW < '_ , Cr3Spec > { DdreW :: new (self , 13) }
#[doc = "Bit 14 - Driver enable mode"]
#[inline (always)] pub fn dem (& mut self) -> DemW < '_ , Cr3Spec > { DemW :: new (self , 14) }
#[doc = "Bit 15 - Driver enable polarity selection"]
#[inline (always)] pub fn dep (& mut self) -> DepW < '_ , Cr3Spec > { DepW :: new (self , 15) }
#[doc = "Bits 17:19 - Smartcard auto-retry count"]
#[inline (always)] pub fn scarcnt (& mut self) -> ScarcntW < '_ , Cr3Spec > { ScarcntW :: new (self , 17) }
#[doc = "Bits 20:21 - Wakeup from Stop mode interrupt flag selection"]
#[inline (always)] pub fn wus (& mut self) -> WusW < '_ , Cr3Spec > { WusW :: new (self , 20) }
#[doc = "Bit 22 - Wakeup from Stop mode interrupt enable"]
#[inline (always)] pub fn wufie (& mut self) -> WufieW < '_ , Cr3Spec > { WufieW :: new (self , 22) }
#[doc = "Bit 23 - threshold interrupt enable"]
#[inline (always)] pub fn txftie (& mut self) -> TxftieW < '_ , Cr3Spec > { TxftieW :: new (self , 23) }
#[doc = "Bit 24 - Tr Complete before guard time, interrupt enable"]
#[inline (always)] pub fn tcbgtie (& mut self) -> TcbgtieW < '_ , Cr3Spec > { TcbgtieW :: new (self , 24) }
#[doc = "Bits 25:27 - Receive FIFO threshold configuration"]
#[inline (always)] pub fn rxftcfg (& mut self) -> RxftcfgW < '_ , Cr3Spec > { RxftcfgW :: new (self , 25) }
#[doc = "Bit 28 - RXFIFO threshold interrupt enable"]
#[inline (always)] pub fn rxftie (& mut self) -> RxftieW < '_ , Cr3Spec > { RxftieW :: new (self , 28) }
#[doc = "Bits 29:31 - TXFIFO threshold configuration"]
#[inline (always)] pub fn txftcfg (& mut self) -> TxftcfgW < '_ , Cr3Spec > { TxftcfgW :: new (self , 29) } }
#[doc = "Control register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`cr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr3Spec ; impl crate :: RegisterSpec for Cr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr3::R`](R) reader structure"] impl crate :: Readable for Cr3Spec { }
#[doc = "`write(|w| ..)` method takes [`cr3::W`](W) writer structure"] impl crate :: Writable for Cr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR3 to value 0"] impl crate :: Resettable for Cr3Spec { } }
#[doc = "BRR (rw) register accessor: Baud rate register\n\nYou can [`read`](crate::Reg::read) this register and get [`brr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@brr`] module"]
#[doc (alias = "BRR")] pub type Brr = crate :: Reg < brr :: BrrSpec > ;
#[doc = "Baud rate register"] pub mod brr {
#[doc = "Register `BRR` reader"] pub type R = crate :: R < BrrSpec > ;
#[doc = "Register `BRR` writer"] pub type W = crate :: W < BrrSpec > ;
#[doc = "Field `BRR` reader - BRR_4_15"] pub type BrrR = crate :: FieldReader < u16 > ;
#[doc = "Field `BRR` writer - BRR_4_15"] pub type BrrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - BRR_4_15"]
#[inline (always)] pub fn brr (& self) -> BrrR { BrrR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - BRR_4_15"]
#[inline (always)] pub fn brr (& mut self) -> BrrW < '_ , BrrSpec > { BrrW :: new (self , 0) } }
#[doc = "Baud rate register\n\nYou can [`read`](crate::Reg::read) this register and get [`brr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BrrSpec ; impl crate :: RegisterSpec for BrrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`brr::R`](R) reader structure"] impl crate :: Readable for BrrSpec { }
#[doc = "`write(|w| ..)` method takes [`brr::W`](W) writer structure"] impl crate :: Writable for BrrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BRR to value 0"] impl crate :: Resettable for BrrSpec { } }
#[doc = "GTPR (rw) register accessor: Guard time and prescaler register\n\nYou can [`read`](crate::Reg::read) this register and get [`gtpr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gtpr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gtpr`] module"]
#[doc (alias = "GTPR")] pub type Gtpr = crate :: Reg < gtpr :: GtprSpec > ;
#[doc = "Guard time and prescaler register"] pub mod gtpr {
#[doc = "Register `GTPR` reader"] pub type R = crate :: R < GtprSpec > ;
#[doc = "Register `GTPR` writer"] pub type W = crate :: W < GtprSpec > ;
#[doc = "Field `PSC` reader - Prescaler value"] pub type PscR = crate :: FieldReader ;
#[doc = "Field `PSC` writer - Prescaler value"] pub type PscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `GT` reader - Guard time value"] pub type GtR = crate :: FieldReader ;
#[doc = "Field `GT` writer - Guard time value"] pub type GtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - Prescaler value"]
#[inline (always)] pub fn psc (& self) -> PscR { PscR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - Guard time value"]
#[inline (always)] pub fn gt (& self) -> GtR { GtR :: new (((self . bits >> 8) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - Prescaler value"]
#[inline (always)] pub fn psc (& mut self) -> PscW < '_ , GtprSpec > { PscW :: new (self , 0) }
#[doc = "Bits 8:15 - Guard time value"]
#[inline (always)] pub fn gt (& mut self) -> GtW < '_ , GtprSpec > { GtW :: new (self , 8) } }
#[doc = "Guard time and prescaler register\n\nYou can [`read`](crate::Reg::read) this register and get [`gtpr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gtpr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct GtprSpec ; impl crate :: RegisterSpec for GtprSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`gtpr::R`](R) reader structure"] impl crate :: Readable for GtprSpec { }
#[doc = "`write(|w| ..)` method takes [`gtpr::W`](W) writer structure"] impl crate :: Writable for GtprSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets GTPR to value 0"] impl crate :: Resettable for GtprSpec { } }
#[doc = "RTOR (rw) register accessor: Receiver timeout register\n\nYou can [`read`](crate::Reg::read) this register and get [`rtor::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtor::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rtor`] module"]
#[doc (alias = "RTOR")] pub type Rtor = crate :: Reg < rtor :: RtorSpec > ;
#[doc = "Receiver timeout register"] pub mod rtor {
#[doc = "Register `RTOR` reader"] pub type R = crate :: R < RtorSpec > ;
#[doc = "Register `RTOR` writer"] pub type W = crate :: W < RtorSpec > ;
#[doc = "Field `RTO` reader - Receiver timeout value"] pub type RtoR = crate :: FieldReader < u32 > ;
#[doc = "Field `RTO` writer - Receiver timeout value"] pub type RtoW < 'a , REG > = crate :: FieldWriter < 'a , REG , 24 , u32 > ;
#[doc = "Field `BLEN` reader - Block Length"] pub type BlenR = crate :: FieldReader ;
#[doc = "Field `BLEN` writer - Block Length"] pub type BlenW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:23 - Receiver timeout value"]
#[inline (always)] pub fn rto (& self) -> RtoR { RtoR :: new (self . bits & 0x00ff_ffff) }
#[doc = "Bits 24:31 - Block Length"]
#[inline (always)] pub fn blen (& self) -> BlenR { BlenR :: new (((self . bits >> 24) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:23 - Receiver timeout value"]
#[inline (always)] pub fn rto (& mut self) -> RtoW < '_ , RtorSpec > { RtoW :: new (self , 0) }
#[doc = "Bits 24:31 - Block Length"]
#[inline (always)] pub fn blen (& mut self) -> BlenW < '_ , RtorSpec > { BlenW :: new (self , 24) } }
#[doc = "Receiver timeout register\n\nYou can [`read`](crate::Reg::read) this register and get [`rtor::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtor::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RtorSpec ; impl crate :: RegisterSpec for RtorSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rtor::R`](R) reader structure"] impl crate :: Readable for RtorSpec { }
#[doc = "`write(|w| ..)` method takes [`rtor::W`](W) writer structure"] impl crate :: Writable for RtorSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RTOR to value 0"] impl crate :: Resettable for RtorSpec { } }
#[doc = "RQR (w) register accessor: Request register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rqr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rqr`] module"]
#[doc (alias = "RQR")] pub type Rqr = crate :: Reg < rqr :: RqrSpec > ;
#[doc = "Request register"] pub mod rqr {
#[doc = "Register `RQR` writer"] pub type W = crate :: W < RqrSpec > ;
#[doc = "Field `ABRRQ` writer - Auto baud rate request"] pub type AbrrqW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SBKRQ` writer - Send break request"] pub type SbkrqW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MMRQ` writer - Mute mode request"] pub type MmrqW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXFRQ` writer - Receive data flush request"] pub type RxfrqW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXFRQ` writer - Transmit data flush request"] pub type TxfrqW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Auto baud rate request"]
#[inline (always)] pub fn abrrq (& mut self) -> AbrrqW < '_ , RqrSpec > { AbrrqW :: new (self , 0) }
#[doc = "Bit 1 - Send break request"]
#[inline (always)] pub fn sbkrq (& mut self) -> SbkrqW < '_ , RqrSpec > { SbkrqW :: new (self , 1) }
#[doc = "Bit 2 - Mute mode request"]
#[inline (always)] pub fn mmrq (& mut self) -> MmrqW < '_ , RqrSpec > { MmrqW :: new (self , 2) }
#[doc = "Bit 3 - Receive data flush request"]
#[inline (always)] pub fn rxfrq (& mut self) -> RxfrqW < '_ , RqrSpec > { RxfrqW :: new (self , 3) }
#[doc = "Bit 4 - Transmit data flush request"]
#[inline (always)] pub fn txfrq (& mut self) -> TxfrqW < '_ , RqrSpec > { TxfrqW :: new (self , 4) } }
#[doc = "Request register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rqr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RqrSpec ; impl crate :: RegisterSpec for RqrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`rqr::W`](W) writer structure"] impl crate :: Writable for RqrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RQR to value 0"] impl crate :: Resettable for RqrSpec { } }
#[doc = "ISR (r) register accessor: Interrupt & status register\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@isr`] module"]
#[doc (alias = "ISR")] pub type Isr = crate :: Reg < isr :: IsrSpec > ;
#[doc = "Interrupt & status register"] pub mod isr {
#[doc = "Register `ISR` reader"] pub type R = crate :: R < IsrSpec > ;
#[doc = "Field `PE` reader - PE"] pub type PeR = crate :: BitReader ;
#[doc = "Field `FE` reader - FE"] pub type FeR = crate :: BitReader ;
#[doc = "Field `NF` reader - NF"] pub type NfR = crate :: BitReader ;
#[doc = "Field `ORE` reader - ORE"] pub type OreR = crate :: BitReader ;
#[doc = "Field `IDLE` reader - IDLE"] pub type IdleR = crate :: BitReader ;
#[doc = "Field `RXNE` reader - RXNE"] pub type RxneR = crate :: BitReader ;
#[doc = "Field `TC` reader - TC"] pub type TcR = crate :: BitReader ;
#[doc = "Field `TXE` reader - TXE"] pub type TxeR = crate :: BitReader ;
#[doc = "Field `LBDF` reader - LBDF"] pub type LbdfR = crate :: BitReader ;
#[doc = "Field `CTSIF` reader - CTSIF"] pub type CtsifR = crate :: BitReader ;
#[doc = "Field `CTS` reader - CTS"] pub type CtsR = crate :: BitReader ;
#[doc = "Field `RTOF` reader - RTOF"] pub type RtofR = crate :: BitReader ;
#[doc = "Field `EOBF` reader - EOBF"] pub type EobfR = crate :: BitReader ;
#[doc = "Field `UDR` reader - SPI slave underrun error flag"] pub type UdrR = crate :: BitReader ;
#[doc = "Field `ABRE` reader - ABRE"] pub type AbreR = crate :: BitReader ;
#[doc = "Field `ABRF` reader - ABRF"] pub type AbrfR = crate :: BitReader ;
#[doc = "Field `BUSY` reader - BUSY"] pub type BusyR = crate :: BitReader ;
#[doc = "Field `CMF` reader - CMF"] pub type CmfR = crate :: BitReader ;
#[doc = "Field `SBKF` reader - SBKF"] pub type SbkfR = crate :: BitReader ;
#[doc = "Field `RWU` reader - RWU"] pub type RwuR = crate :: BitReader ;
#[doc = "Field `WUF` reader - WUF"] pub type WufR = crate :: BitReader ;
#[doc = "Field `TEACK` reader - TEACK"] pub type TeackR = crate :: BitReader ;
#[doc = "Field `REACK` reader - REACK"] pub type ReackR = crate :: BitReader ;
#[doc = "Field `TXFE` reader - TXFIFO Empty"] pub type TxfeR = crate :: BitReader ;
#[doc = "Field `RXFF` reader - RXFIFO Full"] pub type RxffR = crate :: BitReader ;
#[doc = "Field `TCBGT` reader - Transmission complete before guard time flag"] pub type TcbgtR = crate :: BitReader ;
#[doc = "Field `RXFT` reader - RXFIFO threshold flag"] pub type RxftR = crate :: BitReader ;
#[doc = "Field `TXFT` reader - TXFIFO threshold flag"] pub type TxftR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - PE"]
#[inline (always)] pub fn pe (& self) -> PeR { PeR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - FE"]
#[inline (always)] pub fn fe (& self) -> FeR { FeR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - NF"]
#[inline (always)] pub fn nf (& self) -> NfR { NfR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - ORE"]
#[inline (always)] pub fn ore (& self) -> OreR { OreR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - IDLE"]
#[inline (always)] pub fn idle (& self) -> IdleR { IdleR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RXNE"]
#[inline (always)] pub fn rxne (& self) -> RxneR { RxneR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - TC"]
#[inline (always)] pub fn tc (& self) -> TcR { TcR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - TXE"]
#[inline (always)] pub fn txe (& self) -> TxeR { TxeR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - LBDF"]
#[inline (always)] pub fn lbdf (& self) -> LbdfR { LbdfR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - CTSIF"]
#[inline (always)] pub fn ctsif (& self) -> CtsifR { CtsifR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - CTS"]
#[inline (always)] pub fn cts (& self) -> CtsR { CtsR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - RTOF"]
#[inline (always)] pub fn rtof (& self) -> RtofR { RtofR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - EOBF"]
#[inline (always)] pub fn eobf (& self) -> EobfR { EobfR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - SPI slave underrun error flag"]
#[inline (always)] pub fn udr (& self) -> UdrR { UdrR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - ABRE"]
#[inline (always)] pub fn abre (& self) -> AbreR { AbreR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - ABRF"]
#[inline (always)] pub fn abrf (& self) -> AbrfR { AbrfR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - BUSY"]
#[inline (always)] pub fn busy (& self) -> BusyR { BusyR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - CMF"]
#[inline (always)] pub fn cmf (& self) -> CmfR { CmfR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - SBKF"]
#[inline (always)] pub fn sbkf (& self) -> SbkfR { SbkfR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - RWU"]
#[inline (always)] pub fn rwu (& self) -> RwuR { RwuR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - WUF"]
#[inline (always)] pub fn wuf (& self) -> WufR { WufR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - TEACK"]
#[inline (always)] pub fn teack (& self) -> TeackR { TeackR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - REACK"]
#[inline (always)] pub fn reack (& self) -> ReackR { ReackR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - TXFIFO Empty"]
#[inline (always)] pub fn txfe (& self) -> TxfeR { TxfeR :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - RXFIFO Full"]
#[inline (always)] pub fn rxff (& self) -> RxffR { RxffR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Transmission complete before guard time flag"]
#[inline (always)] pub fn tcbgt (& self) -> TcbgtR { TcbgtR :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - RXFIFO threshold flag"]
#[inline (always)] pub fn rxft (& self) -> RxftR { RxftR :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - TXFIFO threshold flag"]
#[inline (always)] pub fn txft (& self) -> TxftR { TxftR :: new (((self . bits >> 27) & 1) != 0) } }
#[doc = "Interrupt & status register\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IsrSpec ; impl crate :: RegisterSpec for IsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`isr::R`](R) reader structure"] impl crate :: Readable for IsrSpec { }
#[doc = "`reset()` method sets ISR to value 0xc0"] impl crate :: Resettable for IsrSpec { const RESET_VALUE : u32 = 0xc0 ; } }
#[doc = "ICR (w) register accessor: Interrupt flag clear register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@icr`] module"]
#[doc (alias = "ICR")] pub type Icr = crate :: Reg < icr :: IcrSpec > ;
#[doc = "Interrupt flag clear register"] pub mod icr {
#[doc = "Register `ICR` writer"] pub type W = crate :: W < IcrSpec > ;
#[doc = "Field `PECF` writer - Parity error clear flag"] pub type PecfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FECF` writer - Framing error clear flag"] pub type FecfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NCF` writer - Noise detected clear flag"] pub type NcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ORECF` writer - Overrun error clear flag"] pub type OrecfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IDLECF` writer - Idle line detected clear flag"] pub type IdlecfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXFECF` writer - TXFIFO empty clear flag"] pub type TxfecfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCCF` writer - Transmission complete clear flag"] pub type TccfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCBGTCF` writer - Transmission complete before Guard time clear flag"] pub type TcbgtcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LBDCF` writer - LIN break detection clear flag"] pub type LbdcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTSCF` writer - CTS clear flag"] pub type CtscfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RTOCF` writer - Receiver timeout clear flag"] pub type RtocfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EOBCF` writer - End of block clear flag"] pub type EobcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDRCF` writer - SPI slave underrun clear flag"] pub type UdrcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CMCF` writer - Character match clear flag"] pub type CmcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WUCF` writer - Wakeup from Stop mode clear flag"] pub type WucfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Parity error clear flag"]
#[inline (always)] pub fn pecf (& mut self) -> PecfW < '_ , IcrSpec > { PecfW :: new (self , 0) }
#[doc = "Bit 1 - Framing error clear flag"]
#[inline (always)] pub fn fecf (& mut self) -> FecfW < '_ , IcrSpec > { FecfW :: new (self , 1) }
#[doc = "Bit 2 - Noise detected clear flag"]
#[inline (always)] pub fn ncf (& mut self) -> NcfW < '_ , IcrSpec > { NcfW :: new (self , 2) }
#[doc = "Bit 3 - Overrun error clear flag"]
#[inline (always)] pub fn orecf (& mut self) -> OrecfW < '_ , IcrSpec > { OrecfW :: new (self , 3) }
#[doc = "Bit 4 - Idle line detected clear flag"]
#[inline (always)] pub fn idlecf (& mut self) -> IdlecfW < '_ , IcrSpec > { IdlecfW :: new (self , 4) }
#[doc = "Bit 5 - TXFIFO empty clear flag"]
#[inline (always)] pub fn txfecf (& mut self) -> TxfecfW < '_ , IcrSpec > { TxfecfW :: new (self , 5) }
#[doc = "Bit 6 - Transmission complete clear flag"]
#[inline (always)] pub fn tccf (& mut self) -> TccfW < '_ , IcrSpec > { TccfW :: new (self , 6) }
#[doc = "Bit 7 - Transmission complete before Guard time clear flag"]
#[inline (always)] pub fn tcbgtcf (& mut self) -> TcbgtcfW < '_ , IcrSpec > { TcbgtcfW :: new (self , 7) }
#[doc = "Bit 8 - LIN break detection clear flag"]
#[inline (always)] pub fn lbdcf (& mut self) -> LbdcfW < '_ , IcrSpec > { LbdcfW :: new (self , 8) }
#[doc = "Bit 9 - CTS clear flag"]
#[inline (always)] pub fn ctscf (& mut self) -> CtscfW < '_ , IcrSpec > { CtscfW :: new (self , 9) }
#[doc = "Bit 11 - Receiver timeout clear flag"]
#[inline (always)] pub fn rtocf (& mut self) -> RtocfW < '_ , IcrSpec > { RtocfW :: new (self , 11) }
#[doc = "Bit 12 - End of block clear flag"]
#[inline (always)] pub fn eobcf (& mut self) -> EobcfW < '_ , IcrSpec > { EobcfW :: new (self , 12) }
#[doc = "Bit 13 - SPI slave underrun clear flag"]
#[inline (always)] pub fn udrcf (& mut self) -> UdrcfW < '_ , IcrSpec > { UdrcfW :: new (self , 13) }
#[doc = "Bit 17 - Character match clear flag"]
#[inline (always)] pub fn cmcf (& mut self) -> CmcfW < '_ , IcrSpec > { CmcfW :: new (self , 17) }
#[doc = "Bit 20 - Wakeup from Stop mode clear flag"]
#[inline (always)] pub fn wucf (& mut self) -> WucfW < '_ , IcrSpec > { WucfW :: new (self , 20) } }
#[doc = "Interrupt flag clear register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IcrSpec ; impl crate :: RegisterSpec for IcrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`icr::W`](W) writer structure"] impl crate :: Writable for IcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ICR to value 0"] impl crate :: Resettable for IcrSpec { } }
#[doc = "RDR (r) register accessor: Receive data register\n\nYou can [`read`](crate::Reg::read) this register and get [`rdr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rdr`] module"]
#[doc (alias = "RDR")] pub type Rdr = crate :: Reg < rdr :: RdrSpec > ;
#[doc = "Receive data register"] pub mod rdr {
#[doc = "Register `RDR` reader"] pub type R = crate :: R < RdrSpec > ;
#[doc = "Field `RDR` reader - Receive data value"] pub type RdrR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:8 - Receive data value"]
#[inline (always)] pub fn rdr (& self) -> RdrR { RdrR :: new ((self . bits & 0x01ff) as u16) } }
#[doc = "Receive data register\n\nYou can [`read`](crate::Reg::read) this register and get [`rdr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RdrSpec ; impl crate :: RegisterSpec for RdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rdr::R`](R) reader structure"] impl crate :: Readable for RdrSpec { }
#[doc = "`reset()` method sets RDR to value 0"] impl crate :: Resettable for RdrSpec { } }
#[doc = "TDR (rw) register accessor: Transmit data register\n\nYou can [`read`](crate::Reg::read) this register and get [`tdr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tdr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tdr`] module"]
#[doc (alias = "TDR")] pub type Tdr = crate :: Reg < tdr :: TdrSpec > ;
#[doc = "Transmit data register"] pub mod tdr {
#[doc = "Register `TDR` reader"] pub type R = crate :: R < TdrSpec > ;
#[doc = "Register `TDR` writer"] pub type W = crate :: W < TdrSpec > ;
#[doc = "Field `TDR` reader - Transmit data value"] pub type TdrR = crate :: FieldReader < u16 > ;
#[doc = "Field `TDR` writer - Transmit data value"] pub type TdrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 9 , u16 > ; impl R {
#[doc = "Bits 0:8 - Transmit data value"]
#[inline (always)] pub fn tdr (& self) -> TdrR { TdrR :: new ((self . bits & 0x01ff) as u16) } } impl W {
#[doc = "Bits 0:8 - Transmit data value"]
#[inline (always)] pub fn tdr (& mut self) -> TdrW < '_ , TdrSpec > { TdrW :: new (self , 0) } }
#[doc = "Transmit data register\n\nYou can [`read`](crate::Reg::read) this register and get [`tdr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tdr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TdrSpec ; impl crate :: RegisterSpec for TdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`tdr::R`](R) reader structure"] impl crate :: Readable for TdrSpec { }
#[doc = "`write(|w| ..)` method takes [`tdr::W`](W) writer structure"] impl crate :: Writable for TdrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets TDR to value 0"] impl crate :: Resettable for TdrSpec { } }
#[doc = "PRESC (rw) register accessor: Prescaler register\n\nYou can [`read`](crate::Reg::read) this register and get [`presc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`presc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@presc`] module"]
#[doc (alias = "PRESC")] pub type Presc = crate :: Reg < presc :: PrescSpec > ;
#[doc = "Prescaler register"] pub mod presc {
#[doc = "Register `PRESC` reader"] pub type R = crate :: R < PrescSpec > ;
#[doc = "Register `PRESC` writer"] pub type W = crate :: W < PrescSpec > ;
#[doc = "Field `PRESCALER` reader - Clock prescaler"] pub type PrescalerR = crate :: FieldReader ;
#[doc = "Field `PRESCALER` writer - Clock prescaler"] pub type PrescalerW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - Clock prescaler"]
#[inline (always)] pub fn prescaler (& self) -> PrescalerR { PrescalerR :: new ((self . bits & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - Clock prescaler"]
#[inline (always)] pub fn prescaler (& mut self) -> PrescalerW < '_ , PrescSpec > { PrescalerW :: new (self , 0) } }
#[doc = "Prescaler register\n\nYou can [`read`](crate::Reg::read) this register and get [`presc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`presc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PrescSpec ; impl crate :: RegisterSpec for PrescSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`presc::R`](R) reader structure"] impl crate :: Readable for PrescSpec { }
#[doc = "`write(|w| ..)` method takes [`presc::W`](W) writer structure"] impl crate :: Writable for PrescSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PRESC to value 0"] impl crate :: Resettable for PrescSpec { } } }
#[doc = "Universal synchronous asynchronous receiver transmitter"] pub type Lpuart1 = crate :: Periph < usart1 :: RegisterBlock , 0x4000_8000 > ; impl core :: fmt :: Debug for Lpuart1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Lpuart1") . finish () } }
#[doc = "Universal synchronous asynchronous receiver transmitter"] pub use self :: usart1 as lpuart1 ;
#[doc = "Serial peripheral interface/Inter-IC sound"] pub type Spi1 = crate :: Periph < spi1 :: RegisterBlock , 0x4001_3000 > ; impl core :: fmt :: Debug for Spi1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Spi1") . finish () } }
#[doc = "Serial peripheral interface/Inter-IC sound"] pub mod spi1 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr1 : Cr1 , cr2 : Cr2 , sr : Sr , dr : Dr , crcpr : Crcpr , rxcrcr : Rxcrcr , txcrcr : Txcrcr , } impl RegisterBlock {
#[doc = "0x00 - control register 1"]
#[inline (always)] pub const fn cr1 (& self) -> & Cr1 { & self . cr1 }
#[doc = "0x04 - control register 2"]
#[inline (always)] pub const fn cr2 (& self) -> & Cr2 { & self . cr2 }
#[doc = "0x08 - status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x0c - data register"]
#[inline (always)] pub const fn dr (& self) -> & Dr { & self . dr }
#[doc = "0x10 - CRC polynomial register"]
#[inline (always)] pub const fn crcpr (& self) -> & Crcpr { & self . crcpr }
#[doc = "0x14 - RX CRC register"]
#[inline (always)] pub const fn rxcrcr (& self) -> & Rxcrcr { & self . rxcrcr }
#[doc = "0x18 - TX CRC register"]
#[inline (always)] pub const fn txcrcr (& self) -> & Txcrcr { & self . txcrcr } }
#[doc = "CR1 (rw) register accessor: control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
#[doc (alias = "CR1")] pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ;
#[doc = "control register 1"] pub mod cr1 {
#[doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ;
#[doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ;
#[doc = "Field `CPHA` reader - Clock phase"] pub type CphaR = crate :: BitReader ;
#[doc = "Field `CPHA` writer - Clock phase"] pub type CphaW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CPOL` reader - Clock polarity"] pub type CpolR = crate :: BitReader ;
#[doc = "Field `CPOL` writer - Clock polarity"] pub type CpolW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MSTR` reader - Master selection"] pub type MstrR = crate :: BitReader ;
#[doc = "Field `MSTR` writer - Master selection"] pub type MstrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR` reader - Baud rate control"] pub type BrR = crate :: FieldReader ;
#[doc = "Field `BR` writer - Baud rate control"] pub type BrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SPE` reader - SPI enable"] pub type SpeR = crate :: BitReader ;
#[doc = "Field `SPE` writer - SPI enable"] pub type SpeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSBFIRST` reader - Frame format"] pub type LsbfirstR = crate :: BitReader ;
#[doc = "Field `LSBFIRST` writer - Frame format"] pub type LsbfirstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SSI` reader - Internal slave select"] pub type SsiR = crate :: BitReader ;
#[doc = "Field `SSI` writer - Internal slave select"] pub type SsiW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SSM` reader - Software slave management"] pub type SsmR = crate :: BitReader ;
#[doc = "Field `SSM` writer - Software slave management"] pub type SsmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXONLY` reader - Receive only"] pub type RxonlyR = crate :: BitReader ;
#[doc = "Field `RXONLY` writer - Receive only"] pub type RxonlyW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CRCL` reader - CRC length"] pub type CrclR = crate :: BitReader ;
#[doc = "Field `CRCL` writer - CRC length"] pub type CrclW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CRCNEXT` reader - CRC transfer next"] pub type CrcnextR = crate :: BitReader ;
#[doc = "Field `CRCNEXT` writer - CRC transfer next"] pub type CrcnextW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CRCEN` reader - Hardware CRC calculation enable"] pub type CrcenR = crate :: BitReader ;
#[doc = "Field `CRCEN` writer - Hardware CRC calculation enable"] pub type CrcenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BIDIOE` reader - Output enable in bidirectional mode"] pub type BidioeR = crate :: BitReader ;
#[doc = "Field `BIDIOE` writer - Output enable in bidirectional mode"] pub type BidioeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BIDIMODE` reader - Bidirectional data mode enable"] pub type BidimodeR = crate :: BitReader ;
#[doc = "Field `BIDIMODE` writer - Bidirectional data mode enable"] pub type BidimodeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Clock phase"]
#[inline (always)] pub fn cpha (& self) -> CphaR { CphaR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Clock polarity"]
#[inline (always)] pub fn cpol (& self) -> CpolR { CpolR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Master selection"]
#[inline (always)] pub fn mstr (& self) -> MstrR { MstrR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 3:5 - Baud rate control"]
#[inline (always)] pub fn br (& self) -> BrR { BrR :: new (((self . bits >> 3) & 7) as u8) }
#[doc = "Bit 6 - SPI enable"]
#[inline (always)] pub fn spe (& self) -> SpeR { SpeR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Frame format"]
#[inline (always)] pub fn lsbfirst (& self) -> LsbfirstR { LsbfirstR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Internal slave select"]
#[inline (always)] pub fn ssi (& self) -> SsiR { SsiR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Software slave management"]
#[inline (always)] pub fn ssm (& self) -> SsmR { SsmR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Receive only"]
#[inline (always)] pub fn rxonly (& self) -> RxonlyR { RxonlyR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - CRC length"]
#[inline (always)] pub fn crcl (& self) -> CrclR { CrclR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - CRC transfer next"]
#[inline (always)] pub fn crcnext (& self) -> CrcnextR { CrcnextR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Hardware CRC calculation enable"]
#[inline (always)] pub fn crcen (& self) -> CrcenR { CrcenR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Output enable in bidirectional mode"]
#[inline (always)] pub fn bidioe (& self) -> BidioeR { BidioeR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Bidirectional data mode enable"]
#[inline (always)] pub fn bidimode (& self) -> BidimodeR { BidimodeR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Clock phase"]
#[inline (always)] pub fn cpha (& mut self) -> CphaW < '_ , Cr1Spec > { CphaW :: new (self , 0) }
#[doc = "Bit 1 - Clock polarity"]
#[inline (always)] pub fn cpol (& mut self) -> CpolW < '_ , Cr1Spec > { CpolW :: new (self , 1) }
#[doc = "Bit 2 - Master selection"]
#[inline (always)] pub fn mstr (& mut self) -> MstrW < '_ , Cr1Spec > { MstrW :: new (self , 2) }
#[doc = "Bits 3:5 - Baud rate control"]
#[inline (always)] pub fn br (& mut self) -> BrW < '_ , Cr1Spec > { BrW :: new (self , 3) }
#[doc = "Bit 6 - SPI enable"]
#[inline (always)] pub fn spe (& mut self) -> SpeW < '_ , Cr1Spec > { SpeW :: new (self , 6) }
#[doc = "Bit 7 - Frame format"]
#[inline (always)] pub fn lsbfirst (& mut self) -> LsbfirstW < '_ , Cr1Spec > { LsbfirstW :: new (self , 7) }
#[doc = "Bit 8 - Internal slave select"]
#[inline (always)] pub fn ssi (& mut self) -> SsiW < '_ , Cr1Spec > { SsiW :: new (self , 8) }
#[doc = "Bit 9 - Software slave management"]
#[inline (always)] pub fn ssm (& mut self) -> SsmW < '_ , Cr1Spec > { SsmW :: new (self , 9) }
#[doc = "Bit 10 - Receive only"]
#[inline (always)] pub fn rxonly (& mut self) -> RxonlyW < '_ , Cr1Spec > { RxonlyW :: new (self , 10) }
#[doc = "Bit 11 - CRC length"]
#[inline (always)] pub fn crcl (& mut self) -> CrclW < '_ , Cr1Spec > { CrclW :: new (self , 11) }
#[doc = "Bit 12 - CRC transfer next"]
#[inline (always)] pub fn crcnext (& mut self) -> CrcnextW < '_ , Cr1Spec > { CrcnextW :: new (self , 12) }
#[doc = "Bit 13 - Hardware CRC calculation enable"]
#[inline (always)] pub fn crcen (& mut self) -> CrcenW < '_ , Cr1Spec > { CrcenW :: new (self , 13) }
#[doc = "Bit 14 - Output enable in bidirectional mode"]
#[inline (always)] pub fn bidioe (& mut self) -> BidioeW < '_ , Cr1Spec > { BidioeW :: new (self , 14) }
#[doc = "Bit 15 - Bidirectional data mode enable"]
#[inline (always)] pub fn bidimode (& mut self) -> BidimodeW < '_ , Cr1Spec > { BidimodeW :: new (self , 15) } }
#[doc = "control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { } }
#[doc = "CR2 (rw) register accessor: control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`] module"]
#[doc (alias = "CR2")] pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ;
#[doc = "control register 2"] pub mod cr2 {
#[doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ;
#[doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ;
#[doc = "Field `RXDMAEN` reader - Rx buffer DMA enable"] pub type RxdmaenR = crate :: BitReader ;
#[doc = "Field `RXDMAEN` writer - Rx buffer DMA enable"] pub type RxdmaenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXDMAEN` reader - Tx buffer DMA enable"] pub type TxdmaenR = crate :: BitReader ;
#[doc = "Field `TXDMAEN` writer - Tx buffer DMA enable"] pub type TxdmaenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SSOE` reader - SS output enable"] pub type SsoeR = crate :: BitReader ;
#[doc = "Field `SSOE` writer - SS output enable"] pub type SsoeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NSSP` reader - NSS pulse management"] pub type NsspR = crate :: BitReader ;
#[doc = "Field `NSSP` writer - NSS pulse management"] pub type NsspW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FRF` reader - Frame format"] pub type FrfR = crate :: BitReader ;
#[doc = "Field `FRF` writer - Frame format"] pub type FrfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ERRIE` reader - Error interrupt enable"] pub type ErrieR = crate :: BitReader ;
#[doc = "Field `ERRIE` writer - Error interrupt enable"] pub type ErrieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXNEIE` reader - RX buffer not empty interrupt enable"] pub type RxneieR = crate :: BitReader ;
#[doc = "Field `RXNEIE` writer - RX buffer not empty interrupt enable"] pub type RxneieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXEIE` reader - Tx buffer empty interrupt enable"] pub type TxeieR = crate :: BitReader ;
#[doc = "Field `TXEIE` writer - Tx buffer empty interrupt enable"] pub type TxeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DS` reader - Data size"] pub type DsR = crate :: FieldReader ;
#[doc = "Field `DS` writer - Data size"] pub type DsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `FRXTH` reader - FIFO reception threshold"] pub type FrxthR = crate :: BitReader ;
#[doc = "Field `FRXTH` writer - FIFO reception threshold"] pub type FrxthW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LDMA_RX` reader - Last DMA transfer for reception"] pub type LdmaRxR = crate :: BitReader ;
#[doc = "Field `LDMA_RX` writer - Last DMA transfer for reception"] pub type LdmaRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LDMA_TX` reader - Last DMA transfer for transmission"] pub type LdmaTxR = crate :: BitReader ;
#[doc = "Field `LDMA_TX` writer - Last DMA transfer for transmission"] pub type LdmaTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Rx buffer DMA enable"]
#[inline (always)] pub fn rxdmaen (& self) -> RxdmaenR { RxdmaenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Tx buffer DMA enable"]
#[inline (always)] pub fn txdmaen (& self) -> TxdmaenR { TxdmaenR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - SS output enable"]
#[inline (always)] pub fn ssoe (& self) -> SsoeR { SsoeR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - NSS pulse management"]
#[inline (always)] pub fn nssp (& self) -> NsspR { NsspR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Frame format"]
#[inline (always)] pub fn frf (& self) -> FrfR { FrfR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Error interrupt enable"]
#[inline (always)] pub fn errie (& self) -> ErrieR { ErrieR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RX buffer not empty interrupt enable"]
#[inline (always)] pub fn rxneie (& self) -> RxneieR { RxneieR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Tx buffer empty interrupt enable"]
#[inline (always)] pub fn txeie (& self) -> TxeieR { TxeieR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:11 - Data size"]
#[inline (always)] pub fn ds (& self) -> DsR { DsR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 12 - FIFO reception threshold"]
#[inline (always)] pub fn frxth (& self) -> FrxthR { FrxthR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Last DMA transfer for reception"]
#[inline (always)] pub fn ldma_rx (& self) -> LdmaRxR { LdmaRxR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Last DMA transfer for transmission"]
#[inline (always)] pub fn ldma_tx (& self) -> LdmaTxR { LdmaTxR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Rx buffer DMA enable"]
#[inline (always)] pub fn rxdmaen (& mut self) -> RxdmaenW < '_ , Cr2Spec > { RxdmaenW :: new (self , 0) }
#[doc = "Bit 1 - Tx buffer DMA enable"]
#[inline (always)] pub fn txdmaen (& mut self) -> TxdmaenW < '_ , Cr2Spec > { TxdmaenW :: new (self , 1) }
#[doc = "Bit 2 - SS output enable"]
#[inline (always)] pub fn ssoe (& mut self) -> SsoeW < '_ , Cr2Spec > { SsoeW :: new (self , 2) }
#[doc = "Bit 3 - NSS pulse management"]
#[inline (always)] pub fn nssp (& mut self) -> NsspW < '_ , Cr2Spec > { NsspW :: new (self , 3) }
#[doc = "Bit 4 - Frame format"]
#[inline (always)] pub fn frf (& mut self) -> FrfW < '_ , Cr2Spec > { FrfW :: new (self , 4) }
#[doc = "Bit 5 - Error interrupt enable"]
#[inline (always)] pub fn errie (& mut self) -> ErrieW < '_ , Cr2Spec > { ErrieW :: new (self , 5) }
#[doc = "Bit 6 - RX buffer not empty interrupt enable"]
#[inline (always)] pub fn rxneie (& mut self) -> RxneieW < '_ , Cr2Spec > { RxneieW :: new (self , 6) }
#[doc = "Bit 7 - Tx buffer empty interrupt enable"]
#[inline (always)] pub fn txeie (& mut self) -> TxeieW < '_ , Cr2Spec > { TxeieW :: new (self , 7) }
#[doc = "Bits 8:11 - Data size"]
#[inline (always)] pub fn ds (& mut self) -> DsW < '_ , Cr2Spec > { DsW :: new (self , 8) }
#[doc = "Bit 12 - FIFO reception threshold"]
#[inline (always)] pub fn frxth (& mut self) -> FrxthW < '_ , Cr2Spec > { FrxthW :: new (self , 12) }
#[doc = "Bit 13 - Last DMA transfer for reception"]
#[inline (always)] pub fn ldma_rx (& mut self) -> LdmaRxW < '_ , Cr2Spec > { LdmaRxW :: new (self , 13) }
#[doc = "Bit 14 - Last DMA transfer for transmission"]
#[inline (always)] pub fn ldma_tx (& mut self) -> LdmaTxW < '_ , Cr2Spec > { LdmaTxW :: new (self , 14) } }
#[doc = "control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR2 to value 0x0700"] impl crate :: Resettable for Cr2Spec { const RESET_VALUE : u32 = 0x0700 ; } }
#[doc = "SR (rw) register accessor: status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `RXNE` reader - Receive buffer not empty"] pub type RxneR = crate :: BitReader ;
#[doc = "Field `TXE` reader - Transmit buffer empty"] pub type TxeR = crate :: BitReader ;
#[doc = "Field `CRCERR` reader - CRC error flag"] pub type CrcerrR = crate :: BitReader ;
#[doc = "Field `CRCERR` writer - CRC error flag"] pub type CrcerrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MODF` reader - Mode fault"] pub type ModfR = crate :: BitReader ;
#[doc = "Field `OVR` reader - Overrun flag"] pub type OvrR = crate :: BitReader ;
#[doc = "Field `BSY` reader - Busy flag"] pub type BsyR = crate :: BitReader ;
#[doc = "Field `TIFRFE` reader - TI frame format error"] pub type TifrfeR = crate :: BitReader ;
#[doc = "Field `FRLVL` reader - FIFO reception level"] pub type FrlvlR = crate :: FieldReader ;
#[doc = "Field `FTLVL` reader - FIFO transmission level"] pub type FtlvlR = crate :: FieldReader ; impl R {
#[doc = "Bit 0 - Receive buffer not empty"]
#[inline (always)] pub fn rxne (& self) -> RxneR { RxneR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transmit buffer empty"]
#[inline (always)] pub fn txe (& self) -> TxeR { TxeR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 4 - CRC error flag"]
#[inline (always)] pub fn crcerr (& self) -> CrcerrR { CrcerrR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Mode fault"]
#[inline (always)] pub fn modf (& self) -> ModfR { ModfR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Overrun flag"]
#[inline (always)] pub fn ovr (& self) -> OvrR { OvrR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Busy flag"]
#[inline (always)] pub fn bsy (& self) -> BsyR { BsyR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - TI frame format error"]
#[inline (always)] pub fn tifrfe (& self) -> TifrfeR { TifrfeR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bits 9:10 - FIFO reception level"]
#[inline (always)] pub fn frlvl (& self) -> FrlvlR { FrlvlR :: new (((self . bits >> 9) & 3) as u8) }
#[doc = "Bits 11:12 - FIFO transmission level"]
#[inline (always)] pub fn ftlvl (& self) -> FtlvlR { FtlvlR :: new (((self . bits >> 11) & 3) as u8) } } impl W {
#[doc = "Bit 4 - CRC error flag"]
#[inline (always)] pub fn crcerr (& mut self) -> CrcerrW < '_ , SrSpec > { CrcerrW :: new (self , 4) } }
#[doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0x02"] impl crate :: Resettable for SrSpec { const RESET_VALUE : u32 = 0x02 ; } }
#[doc = "DR (rw) register accessor: data register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr`] module"]
#[doc (alias = "DR")] pub type Dr = crate :: Reg < dr :: DrSpec > ;
#[doc = "data register"] pub mod dr {
#[doc = "Register `DR` reader"] pub type R = crate :: R < DrSpec > ;
#[doc = "Register `DR` writer"] pub type W = crate :: W < DrSpec > ;
#[doc = "Field `DR` reader - Data register"] pub type DrR = crate :: FieldReader < u16 > ;
#[doc = "Field `DR` writer - Data register"] pub type DrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Data register"]
#[inline (always)] pub fn dr (& self) -> DrR { DrR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Data register"]
#[inline (always)] pub fn dr (& mut self) -> DrW < '_ , DrSpec > { DrW :: new (self , 0) } }
#[doc = "data register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DrSpec ; impl crate :: RegisterSpec for DrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr::R`](R) reader structure"] impl crate :: Readable for DrSpec { }
#[doc = "`write(|w| ..)` method takes [`dr::W`](W) writer structure"] impl crate :: Writable for DrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR to value 0"] impl crate :: Resettable for DrSpec { } }
#[doc = "CRCPR (rw) register accessor: CRC polynomial register\n\nYou can [`read`](crate::Reg::read) this register and get [`crcpr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`crcpr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@crcpr`] module"]
#[doc (alias = "CRCPR")] pub type Crcpr = crate :: Reg < crcpr :: CrcprSpec > ;
#[doc = "CRC polynomial register"] pub mod crcpr {
#[doc = "Register `CRCPR` reader"] pub type R = crate :: R < CrcprSpec > ;
#[doc = "Register `CRCPR` writer"] pub type W = crate :: W < CrcprSpec > ;
#[doc = "Field `CRCPOLY` reader - CRC polynomial register"] pub type CrcpolyR = crate :: FieldReader < u16 > ;
#[doc = "Field `CRCPOLY` writer - CRC polynomial register"] pub type CrcpolyW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - CRC polynomial register"]
#[inline (always)] pub fn crcpoly (& self) -> CrcpolyR { CrcpolyR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - CRC polynomial register"]
#[inline (always)] pub fn crcpoly (& mut self) -> CrcpolyW < '_ , CrcprSpec > { CrcpolyW :: new (self , 0) } }
#[doc = "CRC polynomial register\n\nYou can [`read`](crate::Reg::read) this register and get [`crcpr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`crcpr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrcprSpec ; impl crate :: RegisterSpec for CrcprSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`crcpr::R`](R) reader structure"] impl crate :: Readable for CrcprSpec { }
#[doc = "`write(|w| ..)` method takes [`crcpr::W`](W) writer structure"] impl crate :: Writable for CrcprSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CRCPR to value 0x07"] impl crate :: Resettable for CrcprSpec { const RESET_VALUE : u32 = 0x07 ; } }
#[doc = "RXCRCR (r) register accessor: RX CRC register\n\nYou can [`read`](crate::Reg::read) this register and get [`rxcrcr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rxcrcr`] module"]
#[doc (alias = "RXCRCR")] pub type Rxcrcr = crate :: Reg < rxcrcr :: RxcrcrSpec > ;
#[doc = "RX CRC register"] pub mod rxcrcr {
#[doc = "Register `RXCRCR` reader"] pub type R = crate :: R < RxcrcrSpec > ;
#[doc = "Field `RxCRC` reader - Rx CRC register"] pub type RxCrcR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - Rx CRC register"]
#[inline (always)] pub fn rx_crc (& self) -> RxCrcR { RxCrcR :: new ((self . bits & 0xffff) as u16) } }
#[doc = "RX CRC register\n\nYou can [`read`](crate::Reg::read) this register and get [`rxcrcr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RxcrcrSpec ; impl crate :: RegisterSpec for RxcrcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rxcrcr::R`](R) reader structure"] impl crate :: Readable for RxcrcrSpec { }
#[doc = "`reset()` method sets RXCRCR to value 0"] impl crate :: Resettable for RxcrcrSpec { } }
#[doc = "TXCRCR (r) register accessor: TX CRC register\n\nYou can [`read`](crate::Reg::read) this register and get [`txcrcr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@txcrcr`] module"]
#[doc (alias = "TXCRCR")] pub type Txcrcr = crate :: Reg < txcrcr :: TxcrcrSpec > ;
#[doc = "TX CRC register"] pub mod txcrcr {
#[doc = "Register `TXCRCR` reader"] pub type R = crate :: R < TxcrcrSpec > ;
#[doc = "Field `TxCRC` reader - Tx CRC register"] pub type TxCrcR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - Tx CRC register"]
#[inline (always)] pub fn tx_crc (& self) -> TxCrcR { TxCrcR :: new ((self . bits & 0xffff) as u16) } }
#[doc = "TX CRC register\n\nYou can [`read`](crate::Reg::read) this register and get [`txcrcr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TxcrcrSpec ; impl crate :: RegisterSpec for TxcrcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`txcrcr::R`](R) reader structure"] impl crate :: Readable for TxcrcrSpec { }
#[doc = "`reset()` method sets TXCRCR to value 0"] impl crate :: Resettable for TxcrcrSpec { } } }
#[doc = "Serial peripheral interface/Inter-IC sound"] pub type Spi2 = crate :: Periph < spi1 :: RegisterBlock , 0x4000_3800 > ; impl core :: fmt :: Debug for Spi2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Spi2") . finish () } }
#[doc = "Serial peripheral interface/Inter-IC sound"] pub use self :: spi1 as spi2 ;
#[doc = "Real-time clock"] pub type Rtc = crate :: Periph < rtc :: RegisterBlock , 0x4000_2800 > ; impl core :: fmt :: Debug for Rtc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rtc") . finish () } }
#[doc = "Real-time clock"] pub mod rtc {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { tr : Tr , dr : Dr , cr : Cr , isr : Isr , prer : Prer , wutr : Wutr , _reserved6 : [u8 ; 0x04] , alrmar : Alrmar , alrmbr : Alrmbr , wpr : Wpr , ssr : Ssr , shiftr : Shiftr , tstr : Tstr , tsdr : Tsdr , tsssr : Tsssr , calr : Calr , tampcr : Tampcr , alrmassr : Alrmassr , alrmbssr : Alrmbssr , or : Or , bkp0r : Bkp0r , bkp1r : Bkp1r , bkp2r : Bkp2r , bkp3r : Bkp3r , bkp4r : Bkp4r , bkp5r : Bkp5r , bkp6r : Bkp6r , bkp7r : Bkp7r , bkp8r : Bkp8r , bkp9r : Bkp9r , bkp10r : Bkp10r , bkp11r : Bkp11r , bkp12r : Bkp12r , bkp13r : Bkp13r , bkp14r : Bkp14r , bkp15r : Bkp15r , bkp16r : Bkp16r , bkp17r : Bkp17r , bkp18r : Bkp18r , bkp19r : Bkp19r , } impl RegisterBlock {
#[doc = "0x00 - time register"]
#[inline (always)] pub const fn tr (& self) -> & Tr { & self . tr }
#[doc = "0x04 - date register"]
#[inline (always)] pub const fn dr (& self) -> & Dr { & self . dr }
#[doc = "0x08 - control register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x0c - initialization and status register"]
#[inline (always)] pub const fn isr (& self) -> & Isr { & self . isr }
#[doc = "0x10 - prescaler register"]
#[inline (always)] pub const fn prer (& self) -> & Prer { & self . prer }
#[doc = "0x14 - wakeup timer register"]
#[inline (always)] pub const fn wutr (& self) -> & Wutr { & self . wutr }
#[doc = "0x1c - alarm A register"]
#[inline (always)] pub const fn alrmar (& self) -> & Alrmar { & self . alrmar }
#[doc = "0x20 - alarm B register"]
#[inline (always)] pub const fn alrmbr (& self) -> & Alrmbr { & self . alrmbr }
#[doc = "0x24 - write protection register"]
#[inline (always)] pub const fn wpr (& self) -> & Wpr { & self . wpr }
#[doc = "0x28 - sub second register"]
#[inline (always)] pub const fn ssr (& self) -> & Ssr { & self . ssr }
#[doc = "0x2c - shift control register"]
#[inline (always)] pub const fn shiftr (& self) -> & Shiftr { & self . shiftr }
#[doc = "0x30 - time stamp time register"]
#[inline (always)] pub const fn tstr (& self) -> & Tstr { & self . tstr }
#[doc = "0x34 - time stamp date register"]
#[inline (always)] pub const fn tsdr (& self) -> & Tsdr { & self . tsdr }
#[doc = "0x38 - timestamp sub second register"]
#[inline (always)] pub const fn tsssr (& self) -> & Tsssr { & self . tsssr }
#[doc = "0x3c - calibration register"]
#[inline (always)] pub const fn calr (& self) -> & Calr { & self . calr }
#[doc = "0x40 - tamper configuration register"]
#[inline (always)] pub const fn tampcr (& self) -> & Tampcr { & self . tampcr }
#[doc = "0x44 - alarm A sub second register"]
#[inline (always)] pub const fn alrmassr (& self) -> & Alrmassr { & self . alrmassr }
#[doc = "0x48 - alarm B sub second register"]
#[inline (always)] pub const fn alrmbssr (& self) -> & Alrmbssr { & self . alrmbssr }
#[doc = "0x4c - option register"]
#[inline (always)] pub const fn or (& self) -> & Or { & self . or }
#[doc = "0x50 - backup register"]
#[inline (always)] pub const fn bkp0r (& self) -> & Bkp0r { & self . bkp0r }
#[doc = "0x54 - backup register"]
#[inline (always)] pub const fn bkp1r (& self) -> & Bkp1r { & self . bkp1r }
#[doc = "0x58 - backup register"]
#[inline (always)] pub const fn bkp2r (& self) -> & Bkp2r { & self . bkp2r }
#[doc = "0x5c - backup register"]
#[inline (always)] pub const fn bkp3r (& self) -> & Bkp3r { & self . bkp3r }
#[doc = "0x60 - backup register"]
#[inline (always)] pub const fn bkp4r (& self) -> & Bkp4r { & self . bkp4r }
#[doc = "0x64 - backup register"]
#[inline (always)] pub const fn bkp5r (& self) -> & Bkp5r { & self . bkp5r }
#[doc = "0x68 - backup register"]
#[inline (always)] pub const fn bkp6r (& self) -> & Bkp6r { & self . bkp6r }
#[doc = "0x6c - backup register"]
#[inline (always)] pub const fn bkp7r (& self) -> & Bkp7r { & self . bkp7r }
#[doc = "0x70 - backup register"]
#[inline (always)] pub const fn bkp8r (& self) -> & Bkp8r { & self . bkp8r }
#[doc = "0x74 - backup register"]
#[inline (always)] pub const fn bkp9r (& self) -> & Bkp9r { & self . bkp9r }
#[doc = "0x78 - backup register"]
#[inline (always)] pub const fn bkp10r (& self) -> & Bkp10r { & self . bkp10r }
#[doc = "0x7c - backup register"]
#[inline (always)] pub const fn bkp11r (& self) -> & Bkp11r { & self . bkp11r }
#[doc = "0x80 - backup register"]
#[inline (always)] pub const fn bkp12r (& self) -> & Bkp12r { & self . bkp12r }
#[doc = "0x84 - backup register"]
#[inline (always)] pub const fn bkp13r (& self) -> & Bkp13r { & self . bkp13r }
#[doc = "0x88 - backup register"]
#[inline (always)] pub const fn bkp14r (& self) -> & Bkp14r { & self . bkp14r }
#[doc = "0x8c - backup register"]
#[inline (always)] pub const fn bkp15r (& self) -> & Bkp15r { & self . bkp15r }
#[doc = "0x90 - backup register"]
#[inline (always)] pub const fn bkp16r (& self) -> & Bkp16r { & self . bkp16r }
#[doc = "0x94 - backup register"]
#[inline (always)] pub const fn bkp17r (& self) -> & Bkp17r { & self . bkp17r }
#[doc = "0x98 - backup register"]
#[inline (always)] pub const fn bkp18r (& self) -> & Bkp18r { & self . bkp18r }
#[doc = "0x9c - backup register"]
#[inline (always)] pub const fn bkp19r (& self) -> & Bkp19r { & self . bkp19r } }
#[doc = "TR (rw) register accessor: time register\n\nYou can [`read`](crate::Reg::read) this register and get [`tr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tr`] module"]
#[doc (alias = "TR")] pub type Tr = crate :: Reg < tr :: TrSpec > ;
#[doc = "time register"] pub mod tr {
#[doc = "Register `TR` reader"] pub type R = crate :: R < TrSpec > ;
#[doc = "Register `TR` writer"] pub type W = crate :: W < TrSpec > ;
#[doc = "Field `SU` reader - Second units in BCD format"] pub type SuR = crate :: FieldReader ;
#[doc = "Field `SU` writer - Second units in BCD format"] pub type SuW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ST` reader - Second tens in BCD format"] pub type StR = crate :: FieldReader ;
#[doc = "Field `ST` writer - Second tens in BCD format"] pub type StW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `MNU` reader - Minute units in BCD format"] pub type MnuR = crate :: FieldReader ;
#[doc = "Field `MNU` writer - Minute units in BCD format"] pub type MnuW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `MNT` reader - Minute tens in BCD format"] pub type MntR = crate :: FieldReader ;
#[doc = "Field `MNT` writer - Minute tens in BCD format"] pub type MntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `HU` reader - Hour units in BCD format"] pub type HuR = crate :: FieldReader ;
#[doc = "Field `HU` writer - Hour units in BCD format"] pub type HuW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `HT` reader - Hour tens in BCD format"] pub type HtR = crate :: FieldReader ;
#[doc = "Field `HT` writer - Hour tens in BCD format"] pub type HtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PM` reader - AM/PM notation"] pub type PmR = crate :: BitReader ;
#[doc = "Field `PM` writer - AM/PM notation"] pub type PmW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:3 - Second units in BCD format"]
#[inline (always)] pub fn su (& self) -> SuR { SuR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:6 - Second tens in BCD format"]
#[inline (always)] pub fn st (& self) -> StR { StR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bits 8:11 - Minute units in BCD format"]
#[inline (always)] pub fn mnu (& self) -> MnuR { MnuR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:14 - Minute tens in BCD format"]
#[inline (always)] pub fn mnt (& self) -> MntR { MntR :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bits 16:19 - Hour units in BCD format"]
#[inline (always)] pub fn hu (& self) -> HuR { HuR :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bits 20:21 - Hour tens in BCD format"]
#[inline (always)] pub fn ht (& self) -> HtR { HtR :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bit 22 - AM/PM notation"]
#[inline (always)] pub fn pm (& self) -> PmR { PmR :: new (((self . bits >> 22) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - Second units in BCD format"]
#[inline (always)] pub fn su (& mut self) -> SuW < '_ , TrSpec > { SuW :: new (self , 0) }
#[doc = "Bits 4:6 - Second tens in BCD format"]
#[inline (always)] pub fn st (& mut self) -> StW < '_ , TrSpec > { StW :: new (self , 4) }
#[doc = "Bits 8:11 - Minute units in BCD format"]
#[inline (always)] pub fn mnu (& mut self) -> MnuW < '_ , TrSpec > { MnuW :: new (self , 8) }
#[doc = "Bits 12:14 - Minute tens in BCD format"]
#[inline (always)] pub fn mnt (& mut self) -> MntW < '_ , TrSpec > { MntW :: new (self , 12) }
#[doc = "Bits 16:19 - Hour units in BCD format"]
#[inline (always)] pub fn hu (& mut self) -> HuW < '_ , TrSpec > { HuW :: new (self , 16) }
#[doc = "Bits 20:21 - Hour tens in BCD format"]
#[inline (always)] pub fn ht (& mut self) -> HtW < '_ , TrSpec > { HtW :: new (self , 20) }
#[doc = "Bit 22 - AM/PM notation"]
#[inline (always)] pub fn pm (& mut self) -> PmW < '_ , TrSpec > { PmW :: new (self , 22) } }
#[doc = "time register\n\nYou can [`read`](crate::Reg::read) this register and get [`tr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TrSpec ; impl crate :: RegisterSpec for TrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`tr::R`](R) reader structure"] impl crate :: Readable for TrSpec { }
#[doc = "`write(|w| ..)` method takes [`tr::W`](W) writer structure"] impl crate :: Writable for TrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets TR to value 0"] impl crate :: Resettable for TrSpec { } }
#[doc = "DR (rw) register accessor: date register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr`] module"]
#[doc (alias = "DR")] pub type Dr = crate :: Reg < dr :: DrSpec > ;
#[doc = "date register"] pub mod dr {
#[doc = "Register `DR` reader"] pub type R = crate :: R < DrSpec > ;
#[doc = "Register `DR` writer"] pub type W = crate :: W < DrSpec > ;
#[doc = "Field `DU` reader - Date units in BCD format"] pub type DuR = crate :: FieldReader ;
#[doc = "Field `DU` writer - Date units in BCD format"] pub type DuW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `DT` reader - Date tens in BCD format"] pub type DtR = crate :: FieldReader ;
#[doc = "Field `DT` writer - Date tens in BCD format"] pub type DtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MU` reader - Month units in BCD format"] pub type MuR = crate :: FieldReader ;
#[doc = "Field `MU` writer - Month units in BCD format"] pub type MuW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `MT` reader - Month tens in BCD format"] pub type MtR = crate :: BitReader ;
#[doc = "Field `MT` writer - Month tens in BCD format"] pub type MtW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WDU` reader - Week day units"] pub type WduR = crate :: FieldReader ;
#[doc = "Field `WDU` writer - Week day units"] pub type WduW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `YU` reader - Year units in BCD format"] pub type YuR = crate :: FieldReader ;
#[doc = "Field `YU` writer - Year units in BCD format"] pub type YuW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `YT` reader - Year tens in BCD format"] pub type YtR = crate :: FieldReader ;
#[doc = "Field `YT` writer - Year tens in BCD format"] pub type YtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - Date units in BCD format"]
#[inline (always)] pub fn du (& self) -> DuR { DuR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:5 - Date tens in BCD format"]
#[inline (always)] pub fn dt (& self) -> DtR { DtR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bits 8:11 - Month units in BCD format"]
#[inline (always)] pub fn mu (& self) -> MuR { MuR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 12 - Month tens in BCD format"]
#[inline (always)] pub fn mt (& self) -> MtR { MtR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bits 13:15 - Week day units"]
#[inline (always)] pub fn wdu (& self) -> WduR { WduR :: new (((self . bits >> 13) & 7) as u8) }
#[doc = "Bits 16:19 - Year units in BCD format"]
#[inline (always)] pub fn yu (& self) -> YuR { YuR :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bits 20:23 - Year tens in BCD format"]
#[inline (always)] pub fn yt (& self) -> YtR { YtR :: new (((self . bits >> 20) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - Date units in BCD format"]
#[inline (always)] pub fn du (& mut self) -> DuW < '_ , DrSpec > { DuW :: new (self , 0) }
#[doc = "Bits 4:5 - Date tens in BCD format"]
#[inline (always)] pub fn dt (& mut self) -> DtW < '_ , DrSpec > { DtW :: new (self , 4) }
#[doc = "Bits 8:11 - Month units in BCD format"]
#[inline (always)] pub fn mu (& mut self) -> MuW < '_ , DrSpec > { MuW :: new (self , 8) }
#[doc = "Bit 12 - Month tens in BCD format"]
#[inline (always)] pub fn mt (& mut self) -> MtW < '_ , DrSpec > { MtW :: new (self , 12) }
#[doc = "Bits 13:15 - Week day units"]
#[inline (always)] pub fn wdu (& mut self) -> WduW < '_ , DrSpec > { WduW :: new (self , 13) }
#[doc = "Bits 16:19 - Year units in BCD format"]
#[inline (always)] pub fn yu (& mut self) -> YuW < '_ , DrSpec > { YuW :: new (self , 16) }
#[doc = "Bits 20:23 - Year tens in BCD format"]
#[inline (always)] pub fn yt (& mut self) -> YtW < '_ , DrSpec > { YtW :: new (self , 20) } }
#[doc = "date register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DrSpec ; impl crate :: RegisterSpec for DrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr::R`](R) reader structure"] impl crate :: Readable for DrSpec { }
#[doc = "`write(|w| ..)` method takes [`dr::W`](W) writer structure"] impl crate :: Writable for DrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR to value 0x2101"] impl crate :: Resettable for DrSpec { const RESET_VALUE : u32 = 0x2101 ; } }
#[doc = "CR (rw) register accessor: control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "control register"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `WCKSEL` reader - Wakeup clock selection"] pub type WckselR = crate :: FieldReader ;
#[doc = "Field `WCKSEL` writer - Wakeup clock selection"] pub type WckselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `TSEDGE` reader - Time-stamp event active edge"] pub type TsedgeR = crate :: BitReader ;
#[doc = "Field `TSEDGE` writer - Time-stamp event active edge"] pub type TsedgeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `REFCKON` reader - Reference clock detection enable (50 or 60 Hz)"] pub type RefckonR = crate :: BitReader ;
#[doc = "Field `REFCKON` writer - Reference clock detection enable (50 or 60 Hz)"] pub type RefckonW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BYPSHAD` reader - Bypass the shadow registers"] pub type BypshadR = crate :: BitReader ;
#[doc = "Field `BYPSHAD` writer - Bypass the shadow registers"] pub type BypshadW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FMT` reader - Hour format"] pub type FmtR = crate :: BitReader ;
#[doc = "Field `FMT` writer - Hour format"] pub type FmtW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ALRAE` reader - Alarm A enable"] pub type AlraeR = crate :: BitReader ;
#[doc = "Field `ALRAE` writer - Alarm A enable"] pub type AlraeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ALRBE` reader - Alarm B enable"] pub type AlrbeR = crate :: BitReader ;
#[doc = "Field `ALRBE` writer - Alarm B enable"] pub type AlrbeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WUTE` reader - Wakeup timer enable"] pub type WuteR = crate :: BitReader ;
#[doc = "Field `WUTE` writer - Wakeup timer enable"] pub type WuteW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TSE` reader - Time stamp enable"] pub type TseR = crate :: BitReader ;
#[doc = "Field `TSE` writer - Time stamp enable"] pub type TseW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ALRAIE` reader - Alarm A interrupt enable"] pub type AlraieR = crate :: BitReader ;
#[doc = "Field `ALRAIE` writer - Alarm A interrupt enable"] pub type AlraieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ALRBIE` reader - Alarm B interrupt enable"] pub type AlrbieR = crate :: BitReader ;
#[doc = "Field `ALRBIE` writer - Alarm B interrupt enable"] pub type AlrbieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WUTIE` reader - Wakeup timer interrupt enable"] pub type WutieR = crate :: BitReader ;
#[doc = "Field `WUTIE` writer - Wakeup timer interrupt enable"] pub type WutieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TSIE` reader - Time-stamp interrupt enable"] pub type TsieR = crate :: BitReader ;
#[doc = "Field `TSIE` writer - Time-stamp interrupt enable"] pub type TsieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADD1H` reader - Add 1 hour (summer time change)"] pub type Add1hR = crate :: BitReader ;
#[doc = "Field `ADD1H` writer - Add 1 hour (summer time change)"] pub type Add1hW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SUB1H` reader - Subtract 1 hour (winter time change)"] pub type Sub1hR = crate :: BitReader ;
#[doc = "Field `SUB1H` writer - Subtract 1 hour (winter time change)"] pub type Sub1hW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKP` reader - Backup"] pub type BkpR = crate :: BitReader ;
#[doc = "Field `BKP` writer - Backup"] pub type BkpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COSEL` reader - Calibration output selection"] pub type CoselR = crate :: BitReader ;
#[doc = "Field `COSEL` writer - Calibration output selection"] pub type CoselW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `POL` reader - Output polarity"] pub type PolR = crate :: BitReader ;
#[doc = "Field `POL` writer - Output polarity"] pub type PolW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OSEL` reader - Output selection"] pub type OselR = crate :: FieldReader ;
#[doc = "Field `OSEL` writer - Output selection"] pub type OselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `COE` reader - Calibration output enable"] pub type CoeR = crate :: BitReader ;
#[doc = "Field `COE` writer - Calibration output enable"] pub type CoeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ITSE` reader - timestamp on internal event enable"] pub type ItseR = crate :: BitReader ;
#[doc = "Field `ITSE` writer - timestamp on internal event enable"] pub type ItseW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:2 - Wakeup clock selection"]
#[inline (always)] pub fn wcksel (& self) -> WckselR { WckselR :: new ((self . bits & 7) as u8) }
#[doc = "Bit 3 - Time-stamp event active edge"]
#[inline (always)] pub fn tsedge (& self) -> TsedgeR { TsedgeR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Reference clock detection enable (50 or 60 Hz)"]
#[inline (always)] pub fn refckon (& self) -> RefckonR { RefckonR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Bypass the shadow registers"]
#[inline (always)] pub fn bypshad (& self) -> BypshadR { BypshadR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Hour format"]
#[inline (always)] pub fn fmt (& self) -> FmtR { FmtR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 8 - Alarm A enable"]
#[inline (always)] pub fn alrae (& self) -> AlraeR { AlraeR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Alarm B enable"]
#[inline (always)] pub fn alrbe (& self) -> AlrbeR { AlrbeR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Wakeup timer enable"]
#[inline (always)] pub fn wute (& self) -> WuteR { WuteR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Time stamp enable"]
#[inline (always)] pub fn tse (& self) -> TseR { TseR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Alarm A interrupt enable"]
#[inline (always)] pub fn alraie (& self) -> AlraieR { AlraieR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Alarm B interrupt enable"]
#[inline (always)] pub fn alrbie (& self) -> AlrbieR { AlrbieR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Wakeup timer interrupt enable"]
#[inline (always)] pub fn wutie (& self) -> WutieR { WutieR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Time-stamp interrupt enable"]
#[inline (always)] pub fn tsie (& self) -> TsieR { TsieR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Add 1 hour (summer time change)"]
#[inline (always)] pub fn add1h (& self) -> Add1hR { Add1hR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Subtract 1 hour (winter time change)"]
#[inline (always)] pub fn sub1h (& self) -> Sub1hR { Sub1hR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Backup"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Calibration output selection"]
#[inline (always)] pub fn cosel (& self) -> CoselR { CoselR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Output polarity"]
#[inline (always)] pub fn pol (& self) -> PolR { PolR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bits 21:22 - Output selection"]
#[inline (always)] pub fn osel (& self) -> OselR { OselR :: new (((self . bits >> 21) & 3) as u8) }
#[doc = "Bit 23 - Calibration output enable"]
#[inline (always)] pub fn coe (& self) -> CoeR { CoeR :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - timestamp on internal event enable"]
#[inline (always)] pub fn itse (& self) -> ItseR { ItseR :: new (((self . bits >> 24) & 1) != 0) } } impl W {
#[doc = "Bits 0:2 - Wakeup clock selection"]
#[inline (always)] pub fn wcksel (& mut self) -> WckselW < '_ , CrSpec > { WckselW :: new (self , 0) }
#[doc = "Bit 3 - Time-stamp event active edge"]
#[inline (always)] pub fn tsedge (& mut self) -> TsedgeW < '_ , CrSpec > { TsedgeW :: new (self , 3) }
#[doc = "Bit 4 - Reference clock detection enable (50 or 60 Hz)"]
#[inline (always)] pub fn refckon (& mut self) -> RefckonW < '_ , CrSpec > { RefckonW :: new (self , 4) }
#[doc = "Bit 5 - Bypass the shadow registers"]
#[inline (always)] pub fn bypshad (& mut self) -> BypshadW < '_ , CrSpec > { BypshadW :: new (self , 5) }
#[doc = "Bit 6 - Hour format"]
#[inline (always)] pub fn fmt (& mut self) -> FmtW < '_ , CrSpec > { FmtW :: new (self , 6) }
#[doc = "Bit 8 - Alarm A enable"]
#[inline (always)] pub fn alrae (& mut self) -> AlraeW < '_ , CrSpec > { AlraeW :: new (self , 8) }
#[doc = "Bit 9 - Alarm B enable"]
#[inline (always)] pub fn alrbe (& mut self) -> AlrbeW < '_ , CrSpec > { AlrbeW :: new (self , 9) }
#[doc = "Bit 10 - Wakeup timer enable"]
#[inline (always)] pub fn wute (& mut self) -> WuteW < '_ , CrSpec > { WuteW :: new (self , 10) }
#[doc = "Bit 11 - Time stamp enable"]
#[inline (always)] pub fn tse (& mut self) -> TseW < '_ , CrSpec > { TseW :: new (self , 11) }
#[doc = "Bit 12 - Alarm A interrupt enable"]
#[inline (always)] pub fn alraie (& mut self) -> AlraieW < '_ , CrSpec > { AlraieW :: new (self , 12) }
#[doc = "Bit 13 - Alarm B interrupt enable"]
#[inline (always)] pub fn alrbie (& mut self) -> AlrbieW < '_ , CrSpec > { AlrbieW :: new (self , 13) }
#[doc = "Bit 14 - Wakeup timer interrupt enable"]
#[inline (always)] pub fn wutie (& mut self) -> WutieW < '_ , CrSpec > { WutieW :: new (self , 14) }
#[doc = "Bit 15 - Time-stamp interrupt enable"]
#[inline (always)] pub fn tsie (& mut self) -> TsieW < '_ , CrSpec > { TsieW :: new (self , 15) }
#[doc = "Bit 16 - Add 1 hour (summer time change)"]
#[inline (always)] pub fn add1h (& mut self) -> Add1hW < '_ , CrSpec > { Add1hW :: new (self , 16) }
#[doc = "Bit 17 - Subtract 1 hour (winter time change)"]
#[inline (always)] pub fn sub1h (& mut self) -> Sub1hW < '_ , CrSpec > { Sub1hW :: new (self , 17) }
#[doc = "Bit 18 - Backup"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , CrSpec > { BkpW :: new (self , 18) }
#[doc = "Bit 19 - Calibration output selection"]
#[inline (always)] pub fn cosel (& mut self) -> CoselW < '_ , CrSpec > { CoselW :: new (self , 19) }
#[doc = "Bit 20 - Output polarity"]
#[inline (always)] pub fn pol (& mut self) -> PolW < '_ , CrSpec > { PolW :: new (self , 20) }
#[doc = "Bits 21:22 - Output selection"]
#[inline (always)] pub fn osel (& mut self) -> OselW < '_ , CrSpec > { OselW :: new (self , 21) }
#[doc = "Bit 23 - Calibration output enable"]
#[inline (always)] pub fn coe (& mut self) -> CoeW < '_ , CrSpec > { CoeW :: new (self , 23) }
#[doc = "Bit 24 - timestamp on internal event enable"]
#[inline (always)] pub fn itse (& mut self) -> ItseW < '_ , CrSpec > { ItseW :: new (self , 24) } }
#[doc = "control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { } }
#[doc = "ISR (rw) register accessor: initialization and status register\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`isr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@isr`] module"]
#[doc (alias = "ISR")] pub type Isr = crate :: Reg < isr :: IsrSpec > ;
#[doc = "initialization and status register"] pub mod isr {
#[doc = "Register `ISR` reader"] pub type R = crate :: R < IsrSpec > ;
#[doc = "Register `ISR` writer"] pub type W = crate :: W < IsrSpec > ;
#[doc = "Field `ALRAWF` reader - Alarm A write flag"] pub type AlrawfR = crate :: BitReader ;
#[doc = "Field `ALRBWF` reader - Alarm B write flag"] pub type AlrbwfR = crate :: BitReader ;
#[doc = "Field `WUTWF` reader - Wakeup timer write flag"] pub type WutwfR = crate :: BitReader ;
#[doc = "Field `SHPF` reader - Shift operation pending"] pub type ShpfR = crate :: BitReader ;
#[doc = "Field `SHPF` writer - Shift operation pending"] pub type ShpfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `INITS` reader - Initialization status flag"] pub type InitsR = crate :: BitReader ;
#[doc = "Field `RSF` reader - Registers synchronization flag"] pub type RsfR = crate :: BitReader ;
#[doc = "Field `RSF` writer - Registers synchronization flag"] pub type RsfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `INITF` reader - Initialization flag"] pub type InitfR = crate :: BitReader ;
#[doc = "Field `INIT` reader - Initialization mode"] pub type InitR = crate :: BitReader ;
#[doc = "Field `INIT` writer - Initialization mode"] pub type InitW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ALRAF` reader - Alarm A flag"] pub type AlrafR = crate :: BitReader ;
#[doc = "Field `ALRAF` writer - Alarm A flag"] pub type AlrafW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ALRBF` reader - Alarm B flag"] pub type AlrbfR = crate :: BitReader ;
#[doc = "Field `ALRBF` writer - Alarm B flag"] pub type AlrbfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WUTF` reader - Wakeup timer flag"] pub type WutfR = crate :: BitReader ;
#[doc = "Field `WUTF` writer - Wakeup timer flag"] pub type WutfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TSF` reader - Time-stamp flag"] pub type TsfR = crate :: BitReader ;
#[doc = "Field `TSF` writer - Time-stamp flag"] pub type TsfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TSOVF` reader - Time-stamp overflow flag"] pub type TsovfR = crate :: BitReader ;
#[doc = "Field `TSOVF` writer - Time-stamp overflow flag"] pub type TsovfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TAMP1F` reader - Tamper detection flag"] pub type Tamp1fR = crate :: BitReader ;
#[doc = "Field `TAMP1F` writer - Tamper detection flag"] pub type Tamp1fW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TAMP2F` reader - RTC_TAMP2 detection flag"] pub type Tamp2fR = crate :: BitReader ;
#[doc = "Field `TAMP2F` writer - RTC_TAMP2 detection flag"] pub type Tamp2fW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TAMP3F` reader - RTC_TAMP3 detection flag"] pub type Tamp3fR = crate :: BitReader ;
#[doc = "Field `TAMP3F` writer - RTC_TAMP3 detection flag"] pub type Tamp3fW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RECALPF` reader - Recalibration pending Flag"] pub type RecalpfR = crate :: BitReader ;
#[doc = "Field `ITSF` reader - INTERNAL TIME-STAMP FLAG"] pub type ItsfR = crate :: BitReader ;
#[doc = "Field `ITSF` writer - INTERNAL TIME-STAMP FLAG"] pub type ItsfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Alarm A write flag"]
#[inline (always)] pub fn alrawf (& self) -> AlrawfR { AlrawfR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Alarm B write flag"]
#[inline (always)] pub fn alrbwf (& self) -> AlrbwfR { AlrbwfR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Wakeup timer write flag"]
#[inline (always)] pub fn wutwf (& self) -> WutwfR { WutwfR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Shift operation pending"]
#[inline (always)] pub fn shpf (& self) -> ShpfR { ShpfR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Initialization status flag"]
#[inline (always)] pub fn inits (& self) -> InitsR { InitsR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Registers synchronization flag"]
#[inline (always)] pub fn rsf (& self) -> RsfR { RsfR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Initialization flag"]
#[inline (always)] pub fn initf (& self) -> InitfR { InitfR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Initialization mode"]
#[inline (always)] pub fn init (& self) -> InitR { InitR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Alarm A flag"]
#[inline (always)] pub fn alraf (& self) -> AlrafR { AlrafR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Alarm B flag"]
#[inline (always)] pub fn alrbf (& self) -> AlrbfR { AlrbfR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Wakeup timer flag"]
#[inline (always)] pub fn wutf (& self) -> WutfR { WutfR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Time-stamp flag"]
#[inline (always)] pub fn tsf (& self) -> TsfR { TsfR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Time-stamp overflow flag"]
#[inline (always)] pub fn tsovf (& self) -> TsovfR { TsovfR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Tamper detection flag"]
#[inline (always)] pub fn tamp1f (& self) -> Tamp1fR { Tamp1fR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - RTC_TAMP2 detection flag"]
#[inline (always)] pub fn tamp2f (& self) -> Tamp2fR { Tamp2fR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - RTC_TAMP3 detection flag"]
#[inline (always)] pub fn tamp3f (& self) -> Tamp3fR { Tamp3fR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Recalibration pending Flag"]
#[inline (always)] pub fn recalpf (& self) -> RecalpfR { RecalpfR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - INTERNAL TIME-STAMP FLAG"]
#[inline (always)] pub fn itsf (& self) -> ItsfR { ItsfR :: new (((self . bits >> 17) & 1) != 0) } } impl W {
#[doc = "Bit 3 - Shift operation pending"]
#[inline (always)] pub fn shpf (& mut self) -> ShpfW < '_ , IsrSpec > { ShpfW :: new (self , 3) }
#[doc = "Bit 5 - Registers synchronization flag"]
#[inline (always)] pub fn rsf (& mut self) -> RsfW < '_ , IsrSpec > { RsfW :: new (self , 5) }
#[doc = "Bit 7 - Initialization mode"]
#[inline (always)] pub fn init (& mut self) -> InitW < '_ , IsrSpec > { InitW :: new (self , 7) }
#[doc = "Bit 8 - Alarm A flag"]
#[inline (always)] pub fn alraf (& mut self) -> AlrafW < '_ , IsrSpec > { AlrafW :: new (self , 8) }
#[doc = "Bit 9 - Alarm B flag"]
#[inline (always)] pub fn alrbf (& mut self) -> AlrbfW < '_ , IsrSpec > { AlrbfW :: new (self , 9) }
#[doc = "Bit 10 - Wakeup timer flag"]
#[inline (always)] pub fn wutf (& mut self) -> WutfW < '_ , IsrSpec > { WutfW :: new (self , 10) }
#[doc = "Bit 11 - Time-stamp flag"]
#[inline (always)] pub fn tsf (& mut self) -> TsfW < '_ , IsrSpec > { TsfW :: new (self , 11) }
#[doc = "Bit 12 - Time-stamp overflow flag"]
#[inline (always)] pub fn tsovf (& mut self) -> TsovfW < '_ , IsrSpec > { TsovfW :: new (self , 12) }
#[doc = "Bit 13 - Tamper detection flag"]
#[inline (always)] pub fn tamp1f (& mut self) -> Tamp1fW < '_ , IsrSpec > { Tamp1fW :: new (self , 13) }
#[doc = "Bit 14 - RTC_TAMP2 detection flag"]
#[inline (always)] pub fn tamp2f (& mut self) -> Tamp2fW < '_ , IsrSpec > { Tamp2fW :: new (self , 14) }
#[doc = "Bit 15 - RTC_TAMP3 detection flag"]
#[inline (always)] pub fn tamp3f (& mut self) -> Tamp3fW < '_ , IsrSpec > { Tamp3fW :: new (self , 15) }
#[doc = "Bit 17 - INTERNAL TIME-STAMP FLAG"]
#[inline (always)] pub fn itsf (& mut self) -> ItsfW < '_ , IsrSpec > { ItsfW :: new (self , 17) } }
#[doc = "initialization and status register\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`isr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IsrSpec ; impl crate :: RegisterSpec for IsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`isr::R`](R) reader structure"] impl crate :: Readable for IsrSpec { }
#[doc = "`write(|w| ..)` method takes [`isr::W`](W) writer structure"] impl crate :: Writable for IsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ISR to value 0x07"] impl crate :: Resettable for IsrSpec { const RESET_VALUE : u32 = 0x07 ; } }
#[doc = "PRER (rw) register accessor: prescaler register\n\nYou can [`read`](crate::Reg::read) this register and get [`prer::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`prer::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@prer`] module"]
#[doc (alias = "PRER")] pub type Prer = crate :: Reg < prer :: PrerSpec > ;
#[doc = "prescaler register"] pub mod prer {
#[doc = "Register `PRER` reader"] pub type R = crate :: R < PrerSpec > ;
#[doc = "Register `PRER` writer"] pub type W = crate :: W < PrerSpec > ;
#[doc = "Field `PREDIV_S` reader - Synchronous prescaler factor"] pub type PredivSR = crate :: FieldReader < u16 > ;
#[doc = "Field `PREDIV_S` writer - Synchronous prescaler factor"] pub type PredivSW < 'a , REG > = crate :: FieldWriter < 'a , REG , 15 , u16 > ;
#[doc = "Field `PREDIV_A` reader - Asynchronous prescaler factor"] pub type PredivAR = crate :: FieldReader ;
#[doc = "Field `PREDIV_A` writer - Asynchronous prescaler factor"] pub type PredivAW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ; impl R {
#[doc = "Bits 0:14 - Synchronous prescaler factor"]
#[inline (always)] pub fn prediv_s (& self) -> PredivSR { PredivSR :: new ((self . bits & 0x7fff) as u16) }
#[doc = "Bits 16:22 - Asynchronous prescaler factor"]
#[inline (always)] pub fn prediv_a (& self) -> PredivAR { PredivAR :: new (((self . bits >> 16) & 0x7f) as u8) } } impl W {
#[doc = "Bits 0:14 - Synchronous prescaler factor"]
#[inline (always)] pub fn prediv_s (& mut self) -> PredivSW < '_ , PrerSpec > { PredivSW :: new (self , 0) }
#[doc = "Bits 16:22 - Asynchronous prescaler factor"]
#[inline (always)] pub fn prediv_a (& mut self) -> PredivAW < '_ , PrerSpec > { PredivAW :: new (self , 16) } }
#[doc = "prescaler register\n\nYou can [`read`](crate::Reg::read) this register and get [`prer::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`prer::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PrerSpec ; impl crate :: RegisterSpec for PrerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`prer::R`](R) reader structure"] impl crate :: Readable for PrerSpec { }
#[doc = "`write(|w| ..)` method takes [`prer::W`](W) writer structure"] impl crate :: Writable for PrerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PRER to value 0x007f_00ff"] impl crate :: Resettable for PrerSpec { const RESET_VALUE : u32 = 0x007f_00ff ; } }
#[doc = "WUTR (rw) register accessor: wakeup timer register\n\nYou can [`read`](crate::Reg::read) this register and get [`wutr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`wutr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@wutr`] module"]
#[doc (alias = "WUTR")] pub type Wutr = crate :: Reg < wutr :: WutrSpec > ;
#[doc = "wakeup timer register"] pub mod wutr {
#[doc = "Register `WUTR` reader"] pub type R = crate :: R < WutrSpec > ;
#[doc = "Register `WUTR` writer"] pub type W = crate :: W < WutrSpec > ;
#[doc = "Field `WUT` reader - Wakeup auto-reload value bits"] pub type WutR = crate :: FieldReader < u16 > ;
#[doc = "Field `WUT` writer - Wakeup auto-reload value bits"] pub type WutW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Wakeup auto-reload value bits"]
#[inline (always)] pub fn wut (& self) -> WutR { WutR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Wakeup auto-reload value bits"]
#[inline (always)] pub fn wut (& mut self) -> WutW < '_ , WutrSpec > { WutW :: new (self , 0) } }
#[doc = "wakeup timer register\n\nYou can [`read`](crate::Reg::read) this register and get [`wutr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`wutr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct WutrSpec ; impl crate :: RegisterSpec for WutrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`wutr::R`](R) reader structure"] impl crate :: Readable for WutrSpec { }
#[doc = "`write(|w| ..)` method takes [`wutr::W`](W) writer structure"] impl crate :: Writable for WutrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets WUTR to value 0xffff"] impl crate :: Resettable for WutrSpec { const RESET_VALUE : u32 = 0xffff ; } }
#[doc = "ALRMAR (rw) register accessor: alarm A register\n\nYou can [`read`](crate::Reg::read) this register and get [`alrmar::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`alrmar::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@alrmar`] module"]
#[doc (alias = "ALRMAR")] pub type Alrmar = crate :: Reg < alrmar :: AlrmarSpec > ;
#[doc = "alarm A register"] pub mod alrmar {
#[doc = "Register `ALRMAR` reader"] pub type R = crate :: R < AlrmarSpec > ;
#[doc = "Register `ALRMAR` writer"] pub type W = crate :: W < AlrmarSpec > ;
#[doc = "Field `SU` reader - Second units in BCD format"] pub type SuR = crate :: FieldReader ;
#[doc = "Field `SU` writer - Second units in BCD format"] pub type SuW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ST` reader - Second tens in BCD format"] pub type StR = crate :: FieldReader ;
#[doc = "Field `ST` writer - Second tens in BCD format"] pub type StW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `MSK1` reader - Alarm A seconds mask"] pub type Msk1R = crate :: BitReader ;
#[doc = "Field `MSK1` writer - Alarm A seconds mask"] pub type Msk1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MNU` reader - Minute units in BCD format"] pub type MnuR = crate :: FieldReader ;
#[doc = "Field `MNU` writer - Minute units in BCD format"] pub type MnuW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `MNT` reader - Minute tens in BCD format"] pub type MntR = crate :: FieldReader ;
#[doc = "Field `MNT` writer - Minute tens in BCD format"] pub type MntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `MSK2` reader - Alarm A minutes mask"] pub type Msk2R = crate :: BitReader ;
#[doc = "Field `MSK2` writer - Alarm A minutes mask"] pub type Msk2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HU` reader - Hour units in BCD format"] pub type HuR = crate :: FieldReader ;
#[doc = "Field `HU` writer - Hour units in BCD format"] pub type HuW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `HT` reader - Hour tens in BCD format"] pub type HtR = crate :: FieldReader ;
#[doc = "Field `HT` writer - Hour tens in BCD format"] pub type HtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PM` reader - AM/PM notation"] pub type PmR = crate :: BitReader ;
#[doc = "Field `PM` writer - AM/PM notation"] pub type PmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MSK3` reader - Alarm A hours mask"] pub type Msk3R = crate :: BitReader ;
#[doc = "Field `MSK3` writer - Alarm A hours mask"] pub type Msk3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DU` reader - Date units or day in BCD format"] pub type DuR = crate :: FieldReader ;
#[doc = "Field `DU` writer - Date units or day in BCD format"] pub type DuW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `DT` reader - Date tens in BCD format"] pub type DtR = crate :: FieldReader ;
#[doc = "Field `DT` writer - Date tens in BCD format"] pub type DtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `WDSEL` reader - Week day selection"] pub type WdselR = crate :: BitReader ;
#[doc = "Field `WDSEL` writer - Week day selection"] pub type WdselW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MSK4` reader - Alarm A date mask"] pub type Msk4R = crate :: BitReader ;
#[doc = "Field `MSK4` writer - Alarm A date mask"] pub type Msk4W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:3 - Second units in BCD format"]
#[inline (always)] pub fn su (& self) -> SuR { SuR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:6 - Second tens in BCD format"]
#[inline (always)] pub fn st (& self) -> StR { StR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Alarm A seconds mask"]
#[inline (always)] pub fn msk1 (& self) -> Msk1R { Msk1R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:11 - Minute units in BCD format"]
#[inline (always)] pub fn mnu (& self) -> MnuR { MnuR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:14 - Minute tens in BCD format"]
#[inline (always)] pub fn mnt (& self) -> MntR { MntR :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bit 15 - Alarm A minutes mask"]
#[inline (always)] pub fn msk2 (& self) -> Msk2R { Msk2R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bits 16:19 - Hour units in BCD format"]
#[inline (always)] pub fn hu (& self) -> HuR { HuR :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bits 20:21 - Hour tens in BCD format"]
#[inline (always)] pub fn ht (& self) -> HtR { HtR :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bit 22 - AM/PM notation"]
#[inline (always)] pub fn pm (& self) -> PmR { PmR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Alarm A hours mask"]
#[inline (always)] pub fn msk3 (& self) -> Msk3R { Msk3R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bits 24:27 - Date units or day in BCD format"]
#[inline (always)] pub fn du (& self) -> DuR { DuR :: new (((self . bits >> 24) & 0x0f) as u8) }
#[doc = "Bits 28:29 - Date tens in BCD format"]
#[inline (always)] pub fn dt (& self) -> DtR { DtR :: new (((self . bits >> 28) & 3) as u8) }
#[doc = "Bit 30 - Week day selection"]
#[inline (always)] pub fn wdsel (& self) -> WdselR { WdselR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Alarm A date mask"]
#[inline (always)] pub fn msk4 (& self) -> Msk4R { Msk4R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - Second units in BCD format"]
#[inline (always)] pub fn su (& mut self) -> SuW < '_ , AlrmarSpec > { SuW :: new (self , 0) }
#[doc = "Bits 4:6 - Second tens in BCD format"]
#[inline (always)] pub fn st (& mut self) -> StW < '_ , AlrmarSpec > { StW :: new (self , 4) }
#[doc = "Bit 7 - Alarm A seconds mask"]
#[inline (always)] pub fn msk1 (& mut self) -> Msk1W < '_ , AlrmarSpec > { Msk1W :: new (self , 7) }
#[doc = "Bits 8:11 - Minute units in BCD format"]
#[inline (always)] pub fn mnu (& mut self) -> MnuW < '_ , AlrmarSpec > { MnuW :: new (self , 8) }
#[doc = "Bits 12:14 - Minute tens in BCD format"]
#[inline (always)] pub fn mnt (& mut self) -> MntW < '_ , AlrmarSpec > { MntW :: new (self , 12) }
#[doc = "Bit 15 - Alarm A minutes mask"]
#[inline (always)] pub fn msk2 (& mut self) -> Msk2W < '_ , AlrmarSpec > { Msk2W :: new (self , 15) }
#[doc = "Bits 16:19 - Hour units in BCD format"]
#[inline (always)] pub fn hu (& mut self) -> HuW < '_ , AlrmarSpec > { HuW :: new (self , 16) }
#[doc = "Bits 20:21 - Hour tens in BCD format"]
#[inline (always)] pub fn ht (& mut self) -> HtW < '_ , AlrmarSpec > { HtW :: new (self , 20) }
#[doc = "Bit 22 - AM/PM notation"]
#[inline (always)] pub fn pm (& mut self) -> PmW < '_ , AlrmarSpec > { PmW :: new (self , 22) }
#[doc = "Bit 23 - Alarm A hours mask"]
#[inline (always)] pub fn msk3 (& mut self) -> Msk3W < '_ , AlrmarSpec > { Msk3W :: new (self , 23) }
#[doc = "Bits 24:27 - Date units or day in BCD format"]
#[inline (always)] pub fn du (& mut self) -> DuW < '_ , AlrmarSpec > { DuW :: new (self , 24) }
#[doc = "Bits 28:29 - Date tens in BCD format"]
#[inline (always)] pub fn dt (& mut self) -> DtW < '_ , AlrmarSpec > { DtW :: new (self , 28) }
#[doc = "Bit 30 - Week day selection"]
#[inline (always)] pub fn wdsel (& mut self) -> WdselW < '_ , AlrmarSpec > { WdselW :: new (self , 30) }
#[doc = "Bit 31 - Alarm A date mask"]
#[inline (always)] pub fn msk4 (& mut self) -> Msk4W < '_ , AlrmarSpec > { Msk4W :: new (self , 31) } }
#[doc = "alarm A register\n\nYou can [`read`](crate::Reg::read) this register and get [`alrmar::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`alrmar::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AlrmarSpec ; impl crate :: RegisterSpec for AlrmarSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`alrmar::R`](R) reader structure"] impl crate :: Readable for AlrmarSpec { }
#[doc = "`write(|w| ..)` method takes [`alrmar::W`](W) writer structure"] impl crate :: Writable for AlrmarSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ALRMAR to value 0"] impl crate :: Resettable for AlrmarSpec { } }
#[doc = "ALRMBR (rw) register accessor: alarm B register\n\nYou can [`read`](crate::Reg::read) this register and get [`alrmbr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`alrmbr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@alrmbr`] module"]
#[doc (alias = "ALRMBR")] pub type Alrmbr = crate :: Reg < alrmbr :: AlrmbrSpec > ;
#[doc = "alarm B register"] pub mod alrmbr {
#[doc = "Register `ALRMBR` reader"] pub type R = crate :: R < AlrmbrSpec > ;
#[doc = "Register `ALRMBR` writer"] pub type W = crate :: W < AlrmbrSpec > ;
#[doc = "Field `SU` reader - Second units in BCD format"] pub type SuR = crate :: FieldReader ;
#[doc = "Field `SU` writer - Second units in BCD format"] pub type SuW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ST` reader - Second tens in BCD format"] pub type StR = crate :: FieldReader ;
#[doc = "Field `ST` writer - Second tens in BCD format"] pub type StW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `MSK1` reader - Alarm B seconds mask"] pub type Msk1R = crate :: BitReader ;
#[doc = "Field `MSK1` writer - Alarm B seconds mask"] pub type Msk1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MNU` reader - Minute units in BCD format"] pub type MnuR = crate :: FieldReader ;
#[doc = "Field `MNU` writer - Minute units in BCD format"] pub type MnuW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `MNT` reader - Minute tens in BCD format"] pub type MntR = crate :: FieldReader ;
#[doc = "Field `MNT` writer - Minute tens in BCD format"] pub type MntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `MSK2` reader - Alarm B minutes mask"] pub type Msk2R = crate :: BitReader ;
#[doc = "Field `MSK2` writer - Alarm B minutes mask"] pub type Msk2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HU` reader - Hour units in BCD format"] pub type HuR = crate :: FieldReader ;
#[doc = "Field `HU` writer - Hour units in BCD format"] pub type HuW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `HT` reader - Hour tens in BCD format"] pub type HtR = crate :: FieldReader ;
#[doc = "Field `HT` writer - Hour tens in BCD format"] pub type HtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PM` reader - AM/PM notation"] pub type PmR = crate :: BitReader ;
#[doc = "Field `PM` writer - AM/PM notation"] pub type PmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MSK3` reader - Alarm B hours mask"] pub type Msk3R = crate :: BitReader ;
#[doc = "Field `MSK3` writer - Alarm B hours mask"] pub type Msk3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DU` reader - Date units or day in BCD format"] pub type DuR = crate :: FieldReader ;
#[doc = "Field `DU` writer - Date units or day in BCD format"] pub type DuW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `DT` reader - Date tens in BCD format"] pub type DtR = crate :: FieldReader ;
#[doc = "Field `DT` writer - Date tens in BCD format"] pub type DtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `WDSEL` reader - Week day selection"] pub type WdselR = crate :: BitReader ;
#[doc = "Field `WDSEL` writer - Week day selection"] pub type WdselW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MSK4` reader - Alarm B date mask"] pub type Msk4R = crate :: BitReader ;
#[doc = "Field `MSK4` writer - Alarm B date mask"] pub type Msk4W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:3 - Second units in BCD format"]
#[inline (always)] pub fn su (& self) -> SuR { SuR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:6 - Second tens in BCD format"]
#[inline (always)] pub fn st (& self) -> StR { StR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Alarm B seconds mask"]
#[inline (always)] pub fn msk1 (& self) -> Msk1R { Msk1R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:11 - Minute units in BCD format"]
#[inline (always)] pub fn mnu (& self) -> MnuR { MnuR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:14 - Minute tens in BCD format"]
#[inline (always)] pub fn mnt (& self) -> MntR { MntR :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bit 15 - Alarm B minutes mask"]
#[inline (always)] pub fn msk2 (& self) -> Msk2R { Msk2R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bits 16:19 - Hour units in BCD format"]
#[inline (always)] pub fn hu (& self) -> HuR { HuR :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bits 20:21 - Hour tens in BCD format"]
#[inline (always)] pub fn ht (& self) -> HtR { HtR :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bit 22 - AM/PM notation"]
#[inline (always)] pub fn pm (& self) -> PmR { PmR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Alarm B hours mask"]
#[inline (always)] pub fn msk3 (& self) -> Msk3R { Msk3R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bits 24:27 - Date units or day in BCD format"]
#[inline (always)] pub fn du (& self) -> DuR { DuR :: new (((self . bits >> 24) & 0x0f) as u8) }
#[doc = "Bits 28:29 - Date tens in BCD format"]
#[inline (always)] pub fn dt (& self) -> DtR { DtR :: new (((self . bits >> 28) & 3) as u8) }
#[doc = "Bit 30 - Week day selection"]
#[inline (always)] pub fn wdsel (& self) -> WdselR { WdselR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Alarm B date mask"]
#[inline (always)] pub fn msk4 (& self) -> Msk4R { Msk4R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - Second units in BCD format"]
#[inline (always)] pub fn su (& mut self) -> SuW < '_ , AlrmbrSpec > { SuW :: new (self , 0) }
#[doc = "Bits 4:6 - Second tens in BCD format"]
#[inline (always)] pub fn st (& mut self) -> StW < '_ , AlrmbrSpec > { StW :: new (self , 4) }
#[doc = "Bit 7 - Alarm B seconds mask"]
#[inline (always)] pub fn msk1 (& mut self) -> Msk1W < '_ , AlrmbrSpec > { Msk1W :: new (self , 7) }
#[doc = "Bits 8:11 - Minute units in BCD format"]
#[inline (always)] pub fn mnu (& mut self) -> MnuW < '_ , AlrmbrSpec > { MnuW :: new (self , 8) }
#[doc = "Bits 12:14 - Minute tens in BCD format"]
#[inline (always)] pub fn mnt (& mut self) -> MntW < '_ , AlrmbrSpec > { MntW :: new (self , 12) }
#[doc = "Bit 15 - Alarm B minutes mask"]
#[inline (always)] pub fn msk2 (& mut self) -> Msk2W < '_ , AlrmbrSpec > { Msk2W :: new (self , 15) }
#[doc = "Bits 16:19 - Hour units in BCD format"]
#[inline (always)] pub fn hu (& mut self) -> HuW < '_ , AlrmbrSpec > { HuW :: new (self , 16) }
#[doc = "Bits 20:21 - Hour tens in BCD format"]
#[inline (always)] pub fn ht (& mut self) -> HtW < '_ , AlrmbrSpec > { HtW :: new (self , 20) }
#[doc = "Bit 22 - AM/PM notation"]
#[inline (always)] pub fn pm (& mut self) -> PmW < '_ , AlrmbrSpec > { PmW :: new (self , 22) }
#[doc = "Bit 23 - Alarm B hours mask"]
#[inline (always)] pub fn msk3 (& mut self) -> Msk3W < '_ , AlrmbrSpec > { Msk3W :: new (self , 23) }
#[doc = "Bits 24:27 - Date units or day in BCD format"]
#[inline (always)] pub fn du (& mut self) -> DuW < '_ , AlrmbrSpec > { DuW :: new (self , 24) }
#[doc = "Bits 28:29 - Date tens in BCD format"]
#[inline (always)] pub fn dt (& mut self) -> DtW < '_ , AlrmbrSpec > { DtW :: new (self , 28) }
#[doc = "Bit 30 - Week day selection"]
#[inline (always)] pub fn wdsel (& mut self) -> WdselW < '_ , AlrmbrSpec > { WdselW :: new (self , 30) }
#[doc = "Bit 31 - Alarm B date mask"]
#[inline (always)] pub fn msk4 (& mut self) -> Msk4W < '_ , AlrmbrSpec > { Msk4W :: new (self , 31) } }
#[doc = "alarm B register\n\nYou can [`read`](crate::Reg::read) this register and get [`alrmbr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`alrmbr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AlrmbrSpec ; impl crate :: RegisterSpec for AlrmbrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`alrmbr::R`](R) reader structure"] impl crate :: Readable for AlrmbrSpec { }
#[doc = "`write(|w| ..)` method takes [`alrmbr::W`](W) writer structure"] impl crate :: Writable for AlrmbrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ALRMBR to value 0"] impl crate :: Resettable for AlrmbrSpec { } }
#[doc = "WPR (w) register accessor: write protection register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`wpr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@wpr`] module"]
#[doc (alias = "WPR")] pub type Wpr = crate :: Reg < wpr :: WprSpec > ;
#[doc = "write protection register"] pub mod wpr {
#[doc = "Register `WPR` writer"] pub type W = crate :: W < WprSpec > ;
#[doc = "Field `KEY` writer - Write protection key"] pub type KeyW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl W {
#[doc = "Bits 0:7 - Write protection key"]
#[inline (always)] pub fn key (& mut self) -> KeyW < '_ , WprSpec > { KeyW :: new (self , 0) } }
#[doc = "write protection register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`wpr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct WprSpec ; impl crate :: RegisterSpec for WprSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`wpr::W`](W) writer structure"] impl crate :: Writable for WprSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets WPR to value 0"] impl crate :: Resettable for WprSpec { } }
#[doc = "SSR (r) register accessor: sub second register\n\nYou can [`read`](crate::Reg::read) this register and get [`ssr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ssr`] module"]
#[doc (alias = "SSR")] pub type Ssr = crate :: Reg < ssr :: SsrSpec > ;
#[doc = "sub second register"] pub mod ssr {
#[doc = "Register `SSR` reader"] pub type R = crate :: R < SsrSpec > ;
#[doc = "Field `SS` reader - Sub second value"] pub type SsR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - Sub second value"]
#[inline (always)] pub fn ss (& self) -> SsR { SsR :: new ((self . bits & 0xffff) as u16) } }
#[doc = "sub second register\n\nYou can [`read`](crate::Reg::read) this register and get [`ssr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SsrSpec ; impl crate :: RegisterSpec for SsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ssr::R`](R) reader structure"] impl crate :: Readable for SsrSpec { }
#[doc = "`reset()` method sets SSR to value 0"] impl crate :: Resettable for SsrSpec { } }
#[doc = "SHIFTR (w) register accessor: shift control register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`shiftr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@shiftr`] module"]
#[doc (alias = "SHIFTR")] pub type Shiftr = crate :: Reg < shiftr :: ShiftrSpec > ;
#[doc = "shift control register"] pub mod shiftr {
#[doc = "Register `SHIFTR` writer"] pub type W = crate :: W < ShiftrSpec > ;
#[doc = "Field `SUBFS` writer - Subtract a fraction of a second"] pub type SubfsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 15 , u16 > ;
#[doc = "Field `ADD1S` writer - Add one second"] pub type Add1sW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bits 0:14 - Subtract a fraction of a second"]
#[inline (always)] pub fn subfs (& mut self) -> SubfsW < '_ , ShiftrSpec > { SubfsW :: new (self , 0) }
#[doc = "Bit 31 - Add one second"]
#[inline (always)] pub fn add1s (& mut self) -> Add1sW < '_ , ShiftrSpec > { Add1sW :: new (self , 31) } }
#[doc = "shift control register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`shiftr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ShiftrSpec ; impl crate :: RegisterSpec for ShiftrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`shiftr::W`](W) writer structure"] impl crate :: Writable for ShiftrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SHIFTR to value 0"] impl crate :: Resettable for ShiftrSpec { } }
#[doc = "TSTR (r) register accessor: time stamp time register\n\nYou can [`read`](crate::Reg::read) this register and get [`tstr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tstr`] module"]
#[doc (alias = "TSTR")] pub type Tstr = crate :: Reg < tstr :: TstrSpec > ;
#[doc = "time stamp time register"] pub mod tstr {
#[doc = "Register `TSTR` reader"] pub type R = crate :: R < TstrSpec > ;
#[doc = "Field `SU` reader - Second units in BCD format"] pub type SuR = crate :: FieldReader ;
#[doc = "Field `ST` reader - Second tens in BCD format"] pub type StR = crate :: FieldReader ;
#[doc = "Field `MNU` reader - Minute units in BCD format"] pub type MnuR = crate :: FieldReader ;
#[doc = "Field `MNT` reader - Minute tens in BCD format"] pub type MntR = crate :: FieldReader ;
#[doc = "Field `HU` reader - Hour units in BCD format"] pub type HuR = crate :: FieldReader ;
#[doc = "Field `HT` reader - Hour tens in BCD format"] pub type HtR = crate :: FieldReader ;
#[doc = "Field `PM` reader - AM/PM notation"] pub type PmR = crate :: BitReader ; impl R {
#[doc = "Bits 0:3 - Second units in BCD format"]
#[inline (always)] pub fn su (& self) -> SuR { SuR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:6 - Second tens in BCD format"]
#[inline (always)] pub fn st (& self) -> StR { StR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bits 8:11 - Minute units in BCD format"]
#[inline (always)] pub fn mnu (& self) -> MnuR { MnuR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:14 - Minute tens in BCD format"]
#[inline (always)] pub fn mnt (& self) -> MntR { MntR :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bits 16:19 - Hour units in BCD format"]
#[inline (always)] pub fn hu (& self) -> HuR { HuR :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bits 20:21 - Hour tens in BCD format"]
#[inline (always)] pub fn ht (& self) -> HtR { HtR :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bit 22 - AM/PM notation"]
#[inline (always)] pub fn pm (& self) -> PmR { PmR :: new (((self . bits >> 22) & 1) != 0) } }
#[doc = "time stamp time register\n\nYou can [`read`](crate::Reg::read) this register and get [`tstr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TstrSpec ; impl crate :: RegisterSpec for TstrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`tstr::R`](R) reader structure"] impl crate :: Readable for TstrSpec { }
#[doc = "`reset()` method sets TSTR to value 0"] impl crate :: Resettable for TstrSpec { } }
#[doc = "TSDR (r) register accessor: time stamp date register\n\nYou can [`read`](crate::Reg::read) this register and get [`tsdr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tsdr`] module"]
#[doc (alias = "TSDR")] pub type Tsdr = crate :: Reg < tsdr :: TsdrSpec > ;
#[doc = "time stamp date register"] pub mod tsdr {
#[doc = "Register `TSDR` reader"] pub type R = crate :: R < TsdrSpec > ;
#[doc = "Field `DU` reader - Date units in BCD format"] pub type DuR = crate :: FieldReader ;
#[doc = "Field `DT` reader - Date tens in BCD format"] pub type DtR = crate :: FieldReader ;
#[doc = "Field `MU` reader - Month units in BCD format"] pub type MuR = crate :: FieldReader ;
#[doc = "Field `MT` reader - Month tens in BCD format"] pub type MtR = crate :: BitReader ;
#[doc = "Field `WDU` reader - Week day units"] pub type WduR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:3 - Date units in BCD format"]
#[inline (always)] pub fn du (& self) -> DuR { DuR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:5 - Date tens in BCD format"]
#[inline (always)] pub fn dt (& self) -> DtR { DtR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bits 8:11 - Month units in BCD format"]
#[inline (always)] pub fn mu (& self) -> MuR { MuR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 12 - Month tens in BCD format"]
#[inline (always)] pub fn mt (& self) -> MtR { MtR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bits 13:15 - Week day units"]
#[inline (always)] pub fn wdu (& self) -> WduR { WduR :: new (((self . bits >> 13) & 7) as u8) } }
#[doc = "time stamp date register\n\nYou can [`read`](crate::Reg::read) this register and get [`tsdr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TsdrSpec ; impl crate :: RegisterSpec for TsdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`tsdr::R`](R) reader structure"] impl crate :: Readable for TsdrSpec { }
#[doc = "`reset()` method sets TSDR to value 0"] impl crate :: Resettable for TsdrSpec { } }
#[doc = "TSSSR (r) register accessor: timestamp sub second register\n\nYou can [`read`](crate::Reg::read) this register and get [`tsssr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tsssr`] module"]
#[doc (alias = "TSSSR")] pub type Tsssr = crate :: Reg < tsssr :: TsssrSpec > ;
#[doc = "timestamp sub second register"] pub mod tsssr {
#[doc = "Register `TSSSR` reader"] pub type R = crate :: R < TsssrSpec > ;
#[doc = "Field `SS` reader - Sub second value"] pub type SsR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - Sub second value"]
#[inline (always)] pub fn ss (& self) -> SsR { SsR :: new ((self . bits & 0xffff) as u16) } }
#[doc = "timestamp sub second register\n\nYou can [`read`](crate::Reg::read) this register and get [`tsssr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TsssrSpec ; impl crate :: RegisterSpec for TsssrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`tsssr::R`](R) reader structure"] impl crate :: Readable for TsssrSpec { }
#[doc = "`reset()` method sets TSSSR to value 0"] impl crate :: Resettable for TsssrSpec { } }
#[doc = "CALR (rw) register accessor: calibration register\n\nYou can [`read`](crate::Reg::read) this register and get [`calr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`calr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@calr`] module"]
#[doc (alias = "CALR")] pub type Calr = crate :: Reg < calr :: CalrSpec > ;
#[doc = "calibration register"] pub mod calr {
#[doc = "Register `CALR` reader"] pub type R = crate :: R < CalrSpec > ;
#[doc = "Register `CALR` writer"] pub type W = crate :: W < CalrSpec > ;
#[doc = "Field `CALM` reader - Calibration minus"] pub type CalmR = crate :: FieldReader < u16 > ;
#[doc = "Field `CALM` writer - Calibration minus"] pub type CalmW < 'a , REG > = crate :: FieldWriter < 'a , REG , 9 , u16 > ;
#[doc = "Field `CALW16` reader - Use a 16-second calibration cycle period"] pub type Calw16R = crate :: BitReader ;
#[doc = "Field `CALW16` writer - Use a 16-second calibration cycle period"] pub type Calw16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CALW8` reader - Use an 8-second calibration cycle period"] pub type Calw8R = crate :: BitReader ;
#[doc = "Field `CALW8` writer - Use an 8-second calibration cycle period"] pub type Calw8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CALP` reader - Increase frequency of RTC by 488.5 ppm"] pub type CalpR = crate :: BitReader ;
#[doc = "Field `CALP` writer - Increase frequency of RTC by 488.5 ppm"] pub type CalpW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:8 - Calibration minus"]
#[inline (always)] pub fn calm (& self) -> CalmR { CalmR :: new ((self . bits & 0x01ff) as u16) }
#[doc = "Bit 13 - Use a 16-second calibration cycle period"]
#[inline (always)] pub fn calw16 (& self) -> Calw16R { Calw16R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Use an 8-second calibration cycle period"]
#[inline (always)] pub fn calw8 (& self) -> Calw8R { Calw8R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Increase frequency of RTC by 488.5 ppm"]
#[inline (always)] pub fn calp (& self) -> CalpR { CalpR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:8 - Calibration minus"]
#[inline (always)] pub fn calm (& mut self) -> CalmW < '_ , CalrSpec > { CalmW :: new (self , 0) }
#[doc = "Bit 13 - Use a 16-second calibration cycle period"]
#[inline (always)] pub fn calw16 (& mut self) -> Calw16W < '_ , CalrSpec > { Calw16W :: new (self , 13) }
#[doc = "Bit 14 - Use an 8-second calibration cycle period"]
#[inline (always)] pub fn calw8 (& mut self) -> Calw8W < '_ , CalrSpec > { Calw8W :: new (self , 14) }
#[doc = "Bit 15 - Increase frequency of RTC by 488.5 ppm"]
#[inline (always)] pub fn calp (& mut self) -> CalpW < '_ , CalrSpec > { CalpW :: new (self , 15) } }
#[doc = "calibration register\n\nYou can [`read`](crate::Reg::read) this register and get [`calr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`calr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CalrSpec ; impl crate :: RegisterSpec for CalrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`calr::R`](R) reader structure"] impl crate :: Readable for CalrSpec { }
#[doc = "`write(|w| ..)` method takes [`calr::W`](W) writer structure"] impl crate :: Writable for CalrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CALR to value 0"] impl crate :: Resettable for CalrSpec { } }
#[doc = "TAMPCR (rw) register accessor: tamper configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`tampcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tampcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tampcr`] module"]
#[doc (alias = "TAMPCR")] pub type Tampcr = crate :: Reg < tampcr :: TampcrSpec > ;
#[doc = "tamper configuration register"] pub mod tampcr {
#[doc = "Register `TAMPCR` reader"] pub type R = crate :: R < TampcrSpec > ;
#[doc = "Register `TAMPCR` writer"] pub type W = crate :: W < TampcrSpec > ;
#[doc = "Field `TAMP1E` reader - Tamper 1 detection enable"] pub type Tamp1eR = crate :: BitReader ;
#[doc = "Field `TAMP1E` writer - Tamper 1 detection enable"] pub type Tamp1eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TAMP1TRG` reader - Active level for tamper 1"] pub type Tamp1trgR = crate :: BitReader ;
#[doc = "Field `TAMP1TRG` writer - Active level for tamper 1"] pub type Tamp1trgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TAMPIE` reader - Tamper interrupt enable"] pub type TampieR = crate :: BitReader ;
#[doc = "Field `TAMPIE` writer - Tamper interrupt enable"] pub type TampieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TAMP2E` reader - Tamper 2 detection enable"] pub type Tamp2eR = crate :: BitReader ;
#[doc = "Field `TAMP2E` writer - Tamper 2 detection enable"] pub type Tamp2eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TAMP2TRG` reader - Active level for tamper 2"] pub type Tamp2trgR = crate :: BitReader ;
#[doc = "Field `TAMP2TRG` writer - Active level for tamper 2"] pub type Tamp2trgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TAMP3E` reader - Tamper 3 detection enable"] pub type Tamp3eR = crate :: BitReader ;
#[doc = "Field `TAMP3E` writer - Tamper 3 detection enable"] pub type Tamp3eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TAMP3TRG` reader - Active level for tamper 3"] pub type Tamp3trgR = crate :: BitReader ;
#[doc = "Field `TAMP3TRG` writer - Active level for tamper 3"] pub type Tamp3trgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TAMPTS` reader - Activate timestamp on tamper detection event"] pub type TamptsR = crate :: BitReader ;
#[doc = "Field `TAMPTS` writer - Activate timestamp on tamper detection event"] pub type TamptsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TAMPFREQ` reader - Tamper sampling frequency"] pub type TampfreqR = crate :: FieldReader ;
#[doc = "Field `TAMPFREQ` writer - Tamper sampling frequency"] pub type TampfreqW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `TAMPFLT` reader - Tamper filter count"] pub type TampfltR = crate :: FieldReader ;
#[doc = "Field `TAMPFLT` writer - Tamper filter count"] pub type TampfltW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `TAMPPRCH` reader - Tamper precharge duration"] pub type TampprchR = crate :: FieldReader ;
#[doc = "Field `TAMPPRCH` writer - Tamper precharge duration"] pub type TampprchW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `TAMPPUDIS` reader - TAMPER pull-up disable"] pub type TamppudisR = crate :: BitReader ;
#[doc = "Field `TAMPPUDIS` writer - TAMPER pull-up disable"] pub type TamppudisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TAMP1IE` reader - Tamper 1 interrupt enable"] pub type Tamp1ieR = crate :: BitReader ;
#[doc = "Field `TAMP1IE` writer - Tamper 1 interrupt enable"] pub type Tamp1ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TAMP1NOERASE` reader - Tamper 1 no erase"] pub type Tamp1noeraseR = crate :: BitReader ;
#[doc = "Field `TAMP1NOERASE` writer - Tamper 1 no erase"] pub type Tamp1noeraseW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TAMP1MF` reader - Tamper 1 mask flag"] pub type Tamp1mfR = crate :: BitReader ;
#[doc = "Field `TAMP1MF` writer - Tamper 1 mask flag"] pub type Tamp1mfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TAMP2IE` reader - Tamper 2 interrupt enable"] pub type Tamp2ieR = crate :: BitReader ;
#[doc = "Field `TAMP2IE` writer - Tamper 2 interrupt enable"] pub type Tamp2ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TAMP2NOERASE` reader - Tamper 2 no erase"] pub type Tamp2noeraseR = crate :: BitReader ;
#[doc = "Field `TAMP2NOERASE` writer - Tamper 2 no erase"] pub type Tamp2noeraseW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TAMP2MF` reader - Tamper 2 mask flag"] pub type Tamp2mfR = crate :: BitReader ;
#[doc = "Field `TAMP2MF` writer - Tamper 2 mask flag"] pub type Tamp2mfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TAMP3IE` reader - Tamper 3 interrupt enable"] pub type Tamp3ieR = crate :: BitReader ;
#[doc = "Field `TAMP3IE` writer - Tamper 3 interrupt enable"] pub type Tamp3ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TAMP3NOERASE` reader - Tamper 3 no erase"] pub type Tamp3noeraseR = crate :: BitReader ;
#[doc = "Field `TAMP3NOERASE` writer - Tamper 3 no erase"] pub type Tamp3noeraseW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TAMP3MF` reader - Tamper 3 mask flag"] pub type Tamp3mfR = crate :: BitReader ;
#[doc = "Field `TAMP3MF` writer - Tamper 3 mask flag"] pub type Tamp3mfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Tamper 1 detection enable"]
#[inline (always)] pub fn tamp1e (& self) -> Tamp1eR { Tamp1eR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Active level for tamper 1"]
#[inline (always)] pub fn tamp1trg (& self) -> Tamp1trgR { Tamp1trgR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Tamper interrupt enable"]
#[inline (always)] pub fn tampie (& self) -> TampieR { TampieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Tamper 2 detection enable"]
#[inline (always)] pub fn tamp2e (& self) -> Tamp2eR { Tamp2eR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Active level for tamper 2"]
#[inline (always)] pub fn tamp2trg (& self) -> Tamp2trgR { Tamp2trgR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Tamper 3 detection enable"]
#[inline (always)] pub fn tamp3e (& self) -> Tamp3eR { Tamp3eR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Active level for tamper 3"]
#[inline (always)] pub fn tamp3trg (& self) -> Tamp3trgR { Tamp3trgR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Activate timestamp on tamper detection event"]
#[inline (always)] pub fn tampts (& self) -> TamptsR { TamptsR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:10 - Tamper sampling frequency"]
#[inline (always)] pub fn tampfreq (& self) -> TampfreqR { TampfreqR :: new (((self . bits >> 8) & 7) as u8) }
#[doc = "Bits 11:12 - Tamper filter count"]
#[inline (always)] pub fn tampflt (& self) -> TampfltR { TampfltR :: new (((self . bits >> 11) & 3) as u8) }
#[doc = "Bits 13:14 - Tamper precharge duration"]
#[inline (always)] pub fn tampprch (& self) -> TampprchR { TampprchR :: new (((self . bits >> 13) & 3) as u8) }
#[doc = "Bit 15 - TAMPER pull-up disable"]
#[inline (always)] pub fn tamppudis (& self) -> TamppudisR { TamppudisR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Tamper 1 interrupt enable"]
#[inline (always)] pub fn tamp1ie (& self) -> Tamp1ieR { Tamp1ieR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Tamper 1 no erase"]
#[inline (always)] pub fn tamp1noerase (& self) -> Tamp1noeraseR { Tamp1noeraseR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Tamper 1 mask flag"]
#[inline (always)] pub fn tamp1mf (& self) -> Tamp1mfR { Tamp1mfR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Tamper 2 interrupt enable"]
#[inline (always)] pub fn tamp2ie (& self) -> Tamp2ieR { Tamp2ieR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Tamper 2 no erase"]
#[inline (always)] pub fn tamp2noerase (& self) -> Tamp2noeraseR { Tamp2noeraseR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Tamper 2 mask flag"]
#[inline (always)] pub fn tamp2mf (& self) -> Tamp2mfR { Tamp2mfR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Tamper 3 interrupt enable"]
#[inline (always)] pub fn tamp3ie (& self) -> Tamp3ieR { Tamp3ieR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Tamper 3 no erase"]
#[inline (always)] pub fn tamp3noerase (& self) -> Tamp3noeraseR { Tamp3noeraseR :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Tamper 3 mask flag"]
#[inline (always)] pub fn tamp3mf (& self) -> Tamp3mfR { Tamp3mfR :: new (((self . bits >> 24) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Tamper 1 detection enable"]
#[inline (always)] pub fn tamp1e (& mut self) -> Tamp1eW < '_ , TampcrSpec > { Tamp1eW :: new (self , 0) }
#[doc = "Bit 1 - Active level for tamper 1"]
#[inline (always)] pub fn tamp1trg (& mut self) -> Tamp1trgW < '_ , TampcrSpec > { Tamp1trgW :: new (self , 1) }
#[doc = "Bit 2 - Tamper interrupt enable"]
#[inline (always)] pub fn tampie (& mut self) -> TampieW < '_ , TampcrSpec > { TampieW :: new (self , 2) }
#[doc = "Bit 3 - Tamper 2 detection enable"]
#[inline (always)] pub fn tamp2e (& mut self) -> Tamp2eW < '_ , TampcrSpec > { Tamp2eW :: new (self , 3) }
#[doc = "Bit 4 - Active level for tamper 2"]
#[inline (always)] pub fn tamp2trg (& mut self) -> Tamp2trgW < '_ , TampcrSpec > { Tamp2trgW :: new (self , 4) }
#[doc = "Bit 5 - Tamper 3 detection enable"]
#[inline (always)] pub fn tamp3e (& mut self) -> Tamp3eW < '_ , TampcrSpec > { Tamp3eW :: new (self , 5) }
#[doc = "Bit 6 - Active level for tamper 3"]
#[inline (always)] pub fn tamp3trg (& mut self) -> Tamp3trgW < '_ , TampcrSpec > { Tamp3trgW :: new (self , 6) }
#[doc = "Bit 7 - Activate timestamp on tamper detection event"]
#[inline (always)] pub fn tampts (& mut self) -> TamptsW < '_ , TampcrSpec > { TamptsW :: new (self , 7) }
#[doc = "Bits 8:10 - Tamper sampling frequency"]
#[inline (always)] pub fn tampfreq (& mut self) -> TampfreqW < '_ , TampcrSpec > { TampfreqW :: new (self , 8) }
#[doc = "Bits 11:12 - Tamper filter count"]
#[inline (always)] pub fn tampflt (& mut self) -> TampfltW < '_ , TampcrSpec > { TampfltW :: new (self , 11) }
#[doc = "Bits 13:14 - Tamper precharge duration"]
#[inline (always)] pub fn tampprch (& mut self) -> TampprchW < '_ , TampcrSpec > { TampprchW :: new (self , 13) }
#[doc = "Bit 15 - TAMPER pull-up disable"]
#[inline (always)] pub fn tamppudis (& mut self) -> TamppudisW < '_ , TampcrSpec > { TamppudisW :: new (self , 15) }
#[doc = "Bit 16 - Tamper 1 interrupt enable"]
#[inline (always)] pub fn tamp1ie (& mut self) -> Tamp1ieW < '_ , TampcrSpec > { Tamp1ieW :: new (self , 16) }
#[doc = "Bit 17 - Tamper 1 no erase"]
#[inline (always)] pub fn tamp1noerase (& mut self) -> Tamp1noeraseW < '_ , TampcrSpec > { Tamp1noeraseW :: new (self , 17) }
#[doc = "Bit 18 - Tamper 1 mask flag"]
#[inline (always)] pub fn tamp1mf (& mut self) -> Tamp1mfW < '_ , TampcrSpec > { Tamp1mfW :: new (self , 18) }
#[doc = "Bit 19 - Tamper 2 interrupt enable"]
#[inline (always)] pub fn tamp2ie (& mut self) -> Tamp2ieW < '_ , TampcrSpec > { Tamp2ieW :: new (self , 19) }
#[doc = "Bit 20 - Tamper 2 no erase"]
#[inline (always)] pub fn tamp2noerase (& mut self) -> Tamp2noeraseW < '_ , TampcrSpec > { Tamp2noeraseW :: new (self , 20) }
#[doc = "Bit 21 - Tamper 2 mask flag"]
#[inline (always)] pub fn tamp2mf (& mut self) -> Tamp2mfW < '_ , TampcrSpec > { Tamp2mfW :: new (self , 21) }
#[doc = "Bit 22 - Tamper 3 interrupt enable"]
#[inline (always)] pub fn tamp3ie (& mut self) -> Tamp3ieW < '_ , TampcrSpec > { Tamp3ieW :: new (self , 22) }
#[doc = "Bit 23 - Tamper 3 no erase"]
#[inline (always)] pub fn tamp3noerase (& mut self) -> Tamp3noeraseW < '_ , TampcrSpec > { Tamp3noeraseW :: new (self , 23) }
#[doc = "Bit 24 - Tamper 3 mask flag"]
#[inline (always)] pub fn tamp3mf (& mut self) -> Tamp3mfW < '_ , TampcrSpec > { Tamp3mfW :: new (self , 24) } }
#[doc = "tamper configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`tampcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tampcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TampcrSpec ; impl crate :: RegisterSpec for TampcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`tampcr::R`](R) reader structure"] impl crate :: Readable for TampcrSpec { }
#[doc = "`write(|w| ..)` method takes [`tampcr::W`](W) writer structure"] impl crate :: Writable for TampcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets TAMPCR to value 0"] impl crate :: Resettable for TampcrSpec { } }
#[doc = "ALRMASSR (rw) register accessor: alarm A sub second register\n\nYou can [`read`](crate::Reg::read) this register and get [`alrmassr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`alrmassr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@alrmassr`] module"]
#[doc (alias = "ALRMASSR")] pub type Alrmassr = crate :: Reg < alrmassr :: AlrmassrSpec > ;
#[doc = "alarm A sub second register"] pub mod alrmassr {
#[doc = "Register `ALRMASSR` reader"] pub type R = crate :: R < AlrmassrSpec > ;
#[doc = "Register `ALRMASSR` writer"] pub type W = crate :: W < AlrmassrSpec > ;
#[doc = "Field `SS` reader - Sub seconds value"] pub type SsR = crate :: FieldReader < u16 > ;
#[doc = "Field `SS` writer - Sub seconds value"] pub type SsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 15 , u16 > ;
#[doc = "Field `MASKSS` reader - Mask the most-significant bits starting at this bit"] pub type MaskssR = crate :: FieldReader ;
#[doc = "Field `MASKSS` writer - Mask the most-significant bits starting at this bit"] pub type MaskssW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:14 - Sub seconds value"]
#[inline (always)] pub fn ss (& self) -> SsR { SsR :: new ((self . bits & 0x7fff) as u16) }
#[doc = "Bits 24:27 - Mask the most-significant bits starting at this bit"]
#[inline (always)] pub fn maskss (& self) -> MaskssR { MaskssR :: new (((self . bits >> 24) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:14 - Sub seconds value"]
#[inline (always)] pub fn ss (& mut self) -> SsW < '_ , AlrmassrSpec > { SsW :: new (self , 0) }
#[doc = "Bits 24:27 - Mask the most-significant bits starting at this bit"]
#[inline (always)] pub fn maskss (& mut self) -> MaskssW < '_ , AlrmassrSpec > { MaskssW :: new (self , 24) } }
#[doc = "alarm A sub second register\n\nYou can [`read`](crate::Reg::read) this register and get [`alrmassr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`alrmassr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AlrmassrSpec ; impl crate :: RegisterSpec for AlrmassrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`alrmassr::R`](R) reader structure"] impl crate :: Readable for AlrmassrSpec { }
#[doc = "`write(|w| ..)` method takes [`alrmassr::W`](W) writer structure"] impl crate :: Writable for AlrmassrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ALRMASSR to value 0"] impl crate :: Resettable for AlrmassrSpec { } }
#[doc = "ALRMBSSR (rw) register accessor: alarm B sub second register\n\nYou can [`read`](crate::Reg::read) this register and get [`alrmbssr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`alrmbssr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@alrmbssr`] module"]
#[doc (alias = "ALRMBSSR")] pub type Alrmbssr = crate :: Reg < alrmbssr :: AlrmbssrSpec > ;
#[doc = "alarm B sub second register"] pub mod alrmbssr {
#[doc = "Register `ALRMBSSR` reader"] pub type R = crate :: R < AlrmbssrSpec > ;
#[doc = "Register `ALRMBSSR` writer"] pub type W = crate :: W < AlrmbssrSpec > ;
#[doc = "Field `SS` reader - Sub seconds value"] pub type SsR = crate :: FieldReader < u16 > ;
#[doc = "Field `SS` writer - Sub seconds value"] pub type SsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 15 , u16 > ;
#[doc = "Field `MASKSS` reader - Mask the most-significant bits starting at this bit"] pub type MaskssR = crate :: FieldReader ;
#[doc = "Field `MASKSS` writer - Mask the most-significant bits starting at this bit"] pub type MaskssW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:14 - Sub seconds value"]
#[inline (always)] pub fn ss (& self) -> SsR { SsR :: new ((self . bits & 0x7fff) as u16) }
#[doc = "Bits 24:27 - Mask the most-significant bits starting at this bit"]
#[inline (always)] pub fn maskss (& self) -> MaskssR { MaskssR :: new (((self . bits >> 24) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:14 - Sub seconds value"]
#[inline (always)] pub fn ss (& mut self) -> SsW < '_ , AlrmbssrSpec > { SsW :: new (self , 0) }
#[doc = "Bits 24:27 - Mask the most-significant bits starting at this bit"]
#[inline (always)] pub fn maskss (& mut self) -> MaskssW < '_ , AlrmbssrSpec > { MaskssW :: new (self , 24) } }
#[doc = "alarm B sub second register\n\nYou can [`read`](crate::Reg::read) this register and get [`alrmbssr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`alrmbssr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AlrmbssrSpec ; impl crate :: RegisterSpec for AlrmbssrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`alrmbssr::R`](R) reader structure"] impl crate :: Readable for AlrmbssrSpec { }
#[doc = "`write(|w| ..)` method takes [`alrmbssr::W`](W) writer structure"] impl crate :: Writable for AlrmbssrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ALRMBSSR to value 0"] impl crate :: Resettable for AlrmbssrSpec { } }
#[doc = "OR (rw) register accessor: option register\n\nYou can [`read`](crate::Reg::read) this register and get [`or::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`or::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@or`] module"]
#[doc (alias = "OR")] pub type Or = crate :: Reg < or :: OrSpec > ;
#[doc = "option register"] pub mod or {
#[doc = "Register `OR` reader"] pub type R = crate :: R < OrSpec > ;
#[doc = "Register `OR` writer"] pub type W = crate :: W < OrSpec > ;
#[doc = "Field `RTC_ALARM_TYPE` reader - RTC_ALARM on PC13 output type"] pub type RtcAlarmTypeR = crate :: BitReader ;
#[doc = "Field `RTC_ALARM_TYPE` writer - RTC_ALARM on PC13 output type"] pub type RtcAlarmTypeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RTC_OUT_RMP` reader - RTC_OUT remap"] pub type RtcOutRmpR = crate :: BitReader ;
#[doc = "Field `RTC_OUT_RMP` writer - RTC_OUT remap"] pub type RtcOutRmpW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RTC_ALARM on PC13 output type"]
#[inline (always)] pub fn rtc_alarm_type (& self) -> RtcAlarmTypeR { RtcAlarmTypeR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RTC_OUT remap"]
#[inline (always)] pub fn rtc_out_rmp (& self) -> RtcOutRmpR { RtcOutRmpR :: new (((self . bits >> 1) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RTC_ALARM on PC13 output type"]
#[inline (always)] pub fn rtc_alarm_type (& mut self) -> RtcAlarmTypeW < '_ , OrSpec > { RtcAlarmTypeW :: new (self , 0) }
#[doc = "Bit 1 - RTC_OUT remap"]
#[inline (always)] pub fn rtc_out_rmp (& mut self) -> RtcOutRmpW < '_ , OrSpec > { RtcOutRmpW :: new (self , 1) } }
#[doc = "option register\n\nYou can [`read`](crate::Reg::read) this register and get [`or::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`or::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OrSpec ; impl crate :: RegisterSpec for OrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`or::R`](R) reader structure"] impl crate :: Readable for OrSpec { }
#[doc = "`write(|w| ..)` method takes [`or::W`](W) writer structure"] impl crate :: Writable for OrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OR to value 0"] impl crate :: Resettable for OrSpec { } }
#[doc = "BKP0R (rw) register accessor: backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp0r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp0r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bkp0r`] module"]
#[doc (alias = "BKP0R")] pub type Bkp0r = crate :: Reg < bkp0r :: Bkp0rSpec > ;
#[doc = "backup register"] pub mod bkp0r {
#[doc = "Register `BKP0R` reader"] pub type R = crate :: R < Bkp0rSpec > ;
#[doc = "Register `BKP0R` writer"] pub type W = crate :: W < Bkp0rSpec > ;
#[doc = "Field `BKP` reader - BKP"] pub type BkpR = crate :: FieldReader < u32 > ;
#[doc = "Field `BKP` writer - BKP"] pub type BkpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , Bkp0rSpec > { BkpW :: new (self , 0) } }
#[doc = "backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp0r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp0r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bkp0rSpec ; impl crate :: RegisterSpec for Bkp0rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bkp0r::R`](R) reader structure"] impl crate :: Readable for Bkp0rSpec { }
#[doc = "`write(|w| ..)` method takes [`bkp0r::W`](W) writer structure"] impl crate :: Writable for Bkp0rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BKP0R to value 0"] impl crate :: Resettable for Bkp0rSpec { } }
#[doc = "BKP1R (rw) register accessor: backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp1r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp1r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bkp1r`] module"]
#[doc (alias = "BKP1R")] pub type Bkp1r = crate :: Reg < bkp1r :: Bkp1rSpec > ;
#[doc = "backup register"] pub mod bkp1r {
#[doc = "Register `BKP1R` reader"] pub type R = crate :: R < Bkp1rSpec > ;
#[doc = "Register `BKP1R` writer"] pub type W = crate :: W < Bkp1rSpec > ;
#[doc = "Field `BKP` reader - BKP"] pub type BkpR = crate :: FieldReader < u32 > ;
#[doc = "Field `BKP` writer - BKP"] pub type BkpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , Bkp1rSpec > { BkpW :: new (self , 0) } }
#[doc = "backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp1r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp1r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bkp1rSpec ; impl crate :: RegisterSpec for Bkp1rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bkp1r::R`](R) reader structure"] impl crate :: Readable for Bkp1rSpec { }
#[doc = "`write(|w| ..)` method takes [`bkp1r::W`](W) writer structure"] impl crate :: Writable for Bkp1rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BKP1R to value 0"] impl crate :: Resettable for Bkp1rSpec { } }
#[doc = "BKP2R (rw) register accessor: backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp2r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp2r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bkp2r`] module"]
#[doc (alias = "BKP2R")] pub type Bkp2r = crate :: Reg < bkp2r :: Bkp2rSpec > ;
#[doc = "backup register"] pub mod bkp2r {
#[doc = "Register `BKP2R` reader"] pub type R = crate :: R < Bkp2rSpec > ;
#[doc = "Register `BKP2R` writer"] pub type W = crate :: W < Bkp2rSpec > ;
#[doc = "Field `BKP` reader - BKP"] pub type BkpR = crate :: FieldReader < u32 > ;
#[doc = "Field `BKP` writer - BKP"] pub type BkpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , Bkp2rSpec > { BkpW :: new (self , 0) } }
#[doc = "backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp2r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp2r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bkp2rSpec ; impl crate :: RegisterSpec for Bkp2rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bkp2r::R`](R) reader structure"] impl crate :: Readable for Bkp2rSpec { }
#[doc = "`write(|w| ..)` method takes [`bkp2r::W`](W) writer structure"] impl crate :: Writable for Bkp2rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BKP2R to value 0"] impl crate :: Resettable for Bkp2rSpec { } }
#[doc = "BKP3R (rw) register accessor: backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp3r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp3r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bkp3r`] module"]
#[doc (alias = "BKP3R")] pub type Bkp3r = crate :: Reg < bkp3r :: Bkp3rSpec > ;
#[doc = "backup register"] pub mod bkp3r {
#[doc = "Register `BKP3R` reader"] pub type R = crate :: R < Bkp3rSpec > ;
#[doc = "Register `BKP3R` writer"] pub type W = crate :: W < Bkp3rSpec > ;
#[doc = "Field `BKP` reader - BKP"] pub type BkpR = crate :: FieldReader < u32 > ;
#[doc = "Field `BKP` writer - BKP"] pub type BkpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , Bkp3rSpec > { BkpW :: new (self , 0) } }
#[doc = "backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp3r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp3r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bkp3rSpec ; impl crate :: RegisterSpec for Bkp3rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bkp3r::R`](R) reader structure"] impl crate :: Readable for Bkp3rSpec { }
#[doc = "`write(|w| ..)` method takes [`bkp3r::W`](W) writer structure"] impl crate :: Writable for Bkp3rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BKP3R to value 0"] impl crate :: Resettable for Bkp3rSpec { } }
#[doc = "BKP4R (rw) register accessor: backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp4r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp4r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bkp4r`] module"]
#[doc (alias = "BKP4R")] pub type Bkp4r = crate :: Reg < bkp4r :: Bkp4rSpec > ;
#[doc = "backup register"] pub mod bkp4r {
#[doc = "Register `BKP4R` reader"] pub type R = crate :: R < Bkp4rSpec > ;
#[doc = "Register `BKP4R` writer"] pub type W = crate :: W < Bkp4rSpec > ;
#[doc = "Field `BKP` reader - BKP"] pub type BkpR = crate :: FieldReader < u32 > ;
#[doc = "Field `BKP` writer - BKP"] pub type BkpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , Bkp4rSpec > { BkpW :: new (self , 0) } }
#[doc = "backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp4r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp4r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bkp4rSpec ; impl crate :: RegisterSpec for Bkp4rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bkp4r::R`](R) reader structure"] impl crate :: Readable for Bkp4rSpec { }
#[doc = "`write(|w| ..)` method takes [`bkp4r::W`](W) writer structure"] impl crate :: Writable for Bkp4rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BKP4R to value 0"] impl crate :: Resettable for Bkp4rSpec { } }
#[doc = "BKP5R (rw) register accessor: backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp5r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp5r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bkp5r`] module"]
#[doc (alias = "BKP5R")] pub type Bkp5r = crate :: Reg < bkp5r :: Bkp5rSpec > ;
#[doc = "backup register"] pub mod bkp5r {
#[doc = "Register `BKP5R` reader"] pub type R = crate :: R < Bkp5rSpec > ;
#[doc = "Register `BKP5R` writer"] pub type W = crate :: W < Bkp5rSpec > ;
#[doc = "Field `BKP` reader - BKP"] pub type BkpR = crate :: FieldReader < u32 > ;
#[doc = "Field `BKP` writer - BKP"] pub type BkpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , Bkp5rSpec > { BkpW :: new (self , 0) } }
#[doc = "backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp5r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp5r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bkp5rSpec ; impl crate :: RegisterSpec for Bkp5rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bkp5r::R`](R) reader structure"] impl crate :: Readable for Bkp5rSpec { }
#[doc = "`write(|w| ..)` method takes [`bkp5r::W`](W) writer structure"] impl crate :: Writable for Bkp5rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BKP5R to value 0"] impl crate :: Resettable for Bkp5rSpec { } }
#[doc = "BKP6R (rw) register accessor: backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp6r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp6r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bkp6r`] module"]
#[doc (alias = "BKP6R")] pub type Bkp6r = crate :: Reg < bkp6r :: Bkp6rSpec > ;
#[doc = "backup register"] pub mod bkp6r {
#[doc = "Register `BKP6R` reader"] pub type R = crate :: R < Bkp6rSpec > ;
#[doc = "Register `BKP6R` writer"] pub type W = crate :: W < Bkp6rSpec > ;
#[doc = "Field `BKP` reader - BKP"] pub type BkpR = crate :: FieldReader < u32 > ;
#[doc = "Field `BKP` writer - BKP"] pub type BkpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , Bkp6rSpec > { BkpW :: new (self , 0) } }
#[doc = "backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp6r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp6r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bkp6rSpec ; impl crate :: RegisterSpec for Bkp6rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bkp6r::R`](R) reader structure"] impl crate :: Readable for Bkp6rSpec { }
#[doc = "`write(|w| ..)` method takes [`bkp6r::W`](W) writer structure"] impl crate :: Writable for Bkp6rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BKP6R to value 0"] impl crate :: Resettable for Bkp6rSpec { } }
#[doc = "BKP7R (rw) register accessor: backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp7r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp7r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bkp7r`] module"]
#[doc (alias = "BKP7R")] pub type Bkp7r = crate :: Reg < bkp7r :: Bkp7rSpec > ;
#[doc = "backup register"] pub mod bkp7r {
#[doc = "Register `BKP7R` reader"] pub type R = crate :: R < Bkp7rSpec > ;
#[doc = "Register `BKP7R` writer"] pub type W = crate :: W < Bkp7rSpec > ;
#[doc = "Field `BKP` reader - BKP"] pub type BkpR = crate :: FieldReader < u32 > ;
#[doc = "Field `BKP` writer - BKP"] pub type BkpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , Bkp7rSpec > { BkpW :: new (self , 0) } }
#[doc = "backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp7r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp7r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bkp7rSpec ; impl crate :: RegisterSpec for Bkp7rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bkp7r::R`](R) reader structure"] impl crate :: Readable for Bkp7rSpec { }
#[doc = "`write(|w| ..)` method takes [`bkp7r::W`](W) writer structure"] impl crate :: Writable for Bkp7rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BKP7R to value 0"] impl crate :: Resettable for Bkp7rSpec { } }
#[doc = "BKP8R (rw) register accessor: backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp8r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp8r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bkp8r`] module"]
#[doc (alias = "BKP8R")] pub type Bkp8r = crate :: Reg < bkp8r :: Bkp8rSpec > ;
#[doc = "backup register"] pub mod bkp8r {
#[doc = "Register `BKP8R` reader"] pub type R = crate :: R < Bkp8rSpec > ;
#[doc = "Register `BKP8R` writer"] pub type W = crate :: W < Bkp8rSpec > ;
#[doc = "Field `BKP` reader - BKP"] pub type BkpR = crate :: FieldReader < u32 > ;
#[doc = "Field `BKP` writer - BKP"] pub type BkpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , Bkp8rSpec > { BkpW :: new (self , 0) } }
#[doc = "backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp8r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp8r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bkp8rSpec ; impl crate :: RegisterSpec for Bkp8rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bkp8r::R`](R) reader structure"] impl crate :: Readable for Bkp8rSpec { }
#[doc = "`write(|w| ..)` method takes [`bkp8r::W`](W) writer structure"] impl crate :: Writable for Bkp8rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BKP8R to value 0"] impl crate :: Resettable for Bkp8rSpec { } }
#[doc = "BKP9R (rw) register accessor: backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp9r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp9r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bkp9r`] module"]
#[doc (alias = "BKP9R")] pub type Bkp9r = crate :: Reg < bkp9r :: Bkp9rSpec > ;
#[doc = "backup register"] pub mod bkp9r {
#[doc = "Register `BKP9R` reader"] pub type R = crate :: R < Bkp9rSpec > ;
#[doc = "Register `BKP9R` writer"] pub type W = crate :: W < Bkp9rSpec > ;
#[doc = "Field `BKP` reader - BKP"] pub type BkpR = crate :: FieldReader < u32 > ;
#[doc = "Field `BKP` writer - BKP"] pub type BkpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , Bkp9rSpec > { BkpW :: new (self , 0) } }
#[doc = "backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp9r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp9r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bkp9rSpec ; impl crate :: RegisterSpec for Bkp9rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bkp9r::R`](R) reader structure"] impl crate :: Readable for Bkp9rSpec { }
#[doc = "`write(|w| ..)` method takes [`bkp9r::W`](W) writer structure"] impl crate :: Writable for Bkp9rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BKP9R to value 0"] impl crate :: Resettable for Bkp9rSpec { } }
#[doc = "BKP10R (rw) register accessor: backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp10r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp10r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bkp10r`] module"]
#[doc (alias = "BKP10R")] pub type Bkp10r = crate :: Reg < bkp10r :: Bkp10rSpec > ;
#[doc = "backup register"] pub mod bkp10r {
#[doc = "Register `BKP10R` reader"] pub type R = crate :: R < Bkp10rSpec > ;
#[doc = "Register `BKP10R` writer"] pub type W = crate :: W < Bkp10rSpec > ;
#[doc = "Field `BKP` reader - BKP"] pub type BkpR = crate :: FieldReader < u32 > ;
#[doc = "Field `BKP` writer - BKP"] pub type BkpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , Bkp10rSpec > { BkpW :: new (self , 0) } }
#[doc = "backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp10r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp10r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bkp10rSpec ; impl crate :: RegisterSpec for Bkp10rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bkp10r::R`](R) reader structure"] impl crate :: Readable for Bkp10rSpec { }
#[doc = "`write(|w| ..)` method takes [`bkp10r::W`](W) writer structure"] impl crate :: Writable for Bkp10rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BKP10R to value 0"] impl crate :: Resettable for Bkp10rSpec { } }
#[doc = "BKP11R (rw) register accessor: backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp11r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp11r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bkp11r`] module"]
#[doc (alias = "BKP11R")] pub type Bkp11r = crate :: Reg < bkp11r :: Bkp11rSpec > ;
#[doc = "backup register"] pub mod bkp11r {
#[doc = "Register `BKP11R` reader"] pub type R = crate :: R < Bkp11rSpec > ;
#[doc = "Register `BKP11R` writer"] pub type W = crate :: W < Bkp11rSpec > ;
#[doc = "Field `BKP` reader - BKP"] pub type BkpR = crate :: FieldReader < u32 > ;
#[doc = "Field `BKP` writer - BKP"] pub type BkpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , Bkp11rSpec > { BkpW :: new (self , 0) } }
#[doc = "backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp11r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp11r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bkp11rSpec ; impl crate :: RegisterSpec for Bkp11rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bkp11r::R`](R) reader structure"] impl crate :: Readable for Bkp11rSpec { }
#[doc = "`write(|w| ..)` method takes [`bkp11r::W`](W) writer structure"] impl crate :: Writable for Bkp11rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BKP11R to value 0"] impl crate :: Resettable for Bkp11rSpec { } }
#[doc = "BKP12R (rw) register accessor: backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp12r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp12r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bkp12r`] module"]
#[doc (alias = "BKP12R")] pub type Bkp12r = crate :: Reg < bkp12r :: Bkp12rSpec > ;
#[doc = "backup register"] pub mod bkp12r {
#[doc = "Register `BKP12R` reader"] pub type R = crate :: R < Bkp12rSpec > ;
#[doc = "Register `BKP12R` writer"] pub type W = crate :: W < Bkp12rSpec > ;
#[doc = "Field `BKP` reader - BKP"] pub type BkpR = crate :: FieldReader < u32 > ;
#[doc = "Field `BKP` writer - BKP"] pub type BkpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , Bkp12rSpec > { BkpW :: new (self , 0) } }
#[doc = "backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp12r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp12r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bkp12rSpec ; impl crate :: RegisterSpec for Bkp12rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bkp12r::R`](R) reader structure"] impl crate :: Readable for Bkp12rSpec { }
#[doc = "`write(|w| ..)` method takes [`bkp12r::W`](W) writer structure"] impl crate :: Writable for Bkp12rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BKP12R to value 0"] impl crate :: Resettable for Bkp12rSpec { } }
#[doc = "BKP13R (rw) register accessor: backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp13r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp13r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bkp13r`] module"]
#[doc (alias = "BKP13R")] pub type Bkp13r = crate :: Reg < bkp13r :: Bkp13rSpec > ;
#[doc = "backup register"] pub mod bkp13r {
#[doc = "Register `BKP13R` reader"] pub type R = crate :: R < Bkp13rSpec > ;
#[doc = "Register `BKP13R` writer"] pub type W = crate :: W < Bkp13rSpec > ;
#[doc = "Field `BKP` reader - BKP"] pub type BkpR = crate :: FieldReader < u32 > ;
#[doc = "Field `BKP` writer - BKP"] pub type BkpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , Bkp13rSpec > { BkpW :: new (self , 0) } }
#[doc = "backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp13r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp13r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bkp13rSpec ; impl crate :: RegisterSpec for Bkp13rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bkp13r::R`](R) reader structure"] impl crate :: Readable for Bkp13rSpec { }
#[doc = "`write(|w| ..)` method takes [`bkp13r::W`](W) writer structure"] impl crate :: Writable for Bkp13rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BKP13R to value 0"] impl crate :: Resettable for Bkp13rSpec { } }
#[doc = "BKP14R (rw) register accessor: backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp14r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp14r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bkp14r`] module"]
#[doc (alias = "BKP14R")] pub type Bkp14r = crate :: Reg < bkp14r :: Bkp14rSpec > ;
#[doc = "backup register"] pub mod bkp14r {
#[doc = "Register `BKP14R` reader"] pub type R = crate :: R < Bkp14rSpec > ;
#[doc = "Register `BKP14R` writer"] pub type W = crate :: W < Bkp14rSpec > ;
#[doc = "Field `BKP` reader - BKP"] pub type BkpR = crate :: FieldReader < u32 > ;
#[doc = "Field `BKP` writer - BKP"] pub type BkpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , Bkp14rSpec > { BkpW :: new (self , 0) } }
#[doc = "backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp14r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp14r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bkp14rSpec ; impl crate :: RegisterSpec for Bkp14rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bkp14r::R`](R) reader structure"] impl crate :: Readable for Bkp14rSpec { }
#[doc = "`write(|w| ..)` method takes [`bkp14r::W`](W) writer structure"] impl crate :: Writable for Bkp14rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BKP14R to value 0"] impl crate :: Resettable for Bkp14rSpec { } }
#[doc = "BKP15R (rw) register accessor: backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp15r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp15r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bkp15r`] module"]
#[doc (alias = "BKP15R")] pub type Bkp15r = crate :: Reg < bkp15r :: Bkp15rSpec > ;
#[doc = "backup register"] pub mod bkp15r {
#[doc = "Register `BKP15R` reader"] pub type R = crate :: R < Bkp15rSpec > ;
#[doc = "Register `BKP15R` writer"] pub type W = crate :: W < Bkp15rSpec > ;
#[doc = "Field `BKP` reader - BKP"] pub type BkpR = crate :: FieldReader < u32 > ;
#[doc = "Field `BKP` writer - BKP"] pub type BkpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , Bkp15rSpec > { BkpW :: new (self , 0) } }
#[doc = "backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp15r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp15r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bkp15rSpec ; impl crate :: RegisterSpec for Bkp15rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bkp15r::R`](R) reader structure"] impl crate :: Readable for Bkp15rSpec { }
#[doc = "`write(|w| ..)` method takes [`bkp15r::W`](W) writer structure"] impl crate :: Writable for Bkp15rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BKP15R to value 0"] impl crate :: Resettable for Bkp15rSpec { } }
#[doc = "BKP16R (rw) register accessor: backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp16r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp16r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bkp16r`] module"]
#[doc (alias = "BKP16R")] pub type Bkp16r = crate :: Reg < bkp16r :: Bkp16rSpec > ;
#[doc = "backup register"] pub mod bkp16r {
#[doc = "Register `BKP16R` reader"] pub type R = crate :: R < Bkp16rSpec > ;
#[doc = "Register `BKP16R` writer"] pub type W = crate :: W < Bkp16rSpec > ;
#[doc = "Field `BKP` reader - BKP"] pub type BkpR = crate :: FieldReader < u32 > ;
#[doc = "Field `BKP` writer - BKP"] pub type BkpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , Bkp16rSpec > { BkpW :: new (self , 0) } }
#[doc = "backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp16r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp16r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bkp16rSpec ; impl crate :: RegisterSpec for Bkp16rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bkp16r::R`](R) reader structure"] impl crate :: Readable for Bkp16rSpec { }
#[doc = "`write(|w| ..)` method takes [`bkp16r::W`](W) writer structure"] impl crate :: Writable for Bkp16rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BKP16R to value 0"] impl crate :: Resettable for Bkp16rSpec { } }
#[doc = "BKP17R (rw) register accessor: backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp17r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp17r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bkp17r`] module"]
#[doc (alias = "BKP17R")] pub type Bkp17r = crate :: Reg < bkp17r :: Bkp17rSpec > ;
#[doc = "backup register"] pub mod bkp17r {
#[doc = "Register `BKP17R` reader"] pub type R = crate :: R < Bkp17rSpec > ;
#[doc = "Register `BKP17R` writer"] pub type W = crate :: W < Bkp17rSpec > ;
#[doc = "Field `BKP` reader - BKP"] pub type BkpR = crate :: FieldReader < u32 > ;
#[doc = "Field `BKP` writer - BKP"] pub type BkpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , Bkp17rSpec > { BkpW :: new (self , 0) } }
#[doc = "backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp17r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp17r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bkp17rSpec ; impl crate :: RegisterSpec for Bkp17rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bkp17r::R`](R) reader structure"] impl crate :: Readable for Bkp17rSpec { }
#[doc = "`write(|w| ..)` method takes [`bkp17r::W`](W) writer structure"] impl crate :: Writable for Bkp17rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BKP17R to value 0"] impl crate :: Resettable for Bkp17rSpec { } }
#[doc = "BKP18R (rw) register accessor: backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp18r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp18r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bkp18r`] module"]
#[doc (alias = "BKP18R")] pub type Bkp18r = crate :: Reg < bkp18r :: Bkp18rSpec > ;
#[doc = "backup register"] pub mod bkp18r {
#[doc = "Register `BKP18R` reader"] pub type R = crate :: R < Bkp18rSpec > ;
#[doc = "Register `BKP18R` writer"] pub type W = crate :: W < Bkp18rSpec > ;
#[doc = "Field `BKP` reader - BKP"] pub type BkpR = crate :: FieldReader < u32 > ;
#[doc = "Field `BKP` writer - BKP"] pub type BkpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , Bkp18rSpec > { BkpW :: new (self , 0) } }
#[doc = "backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp18r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp18r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bkp18rSpec ; impl crate :: RegisterSpec for Bkp18rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bkp18r::R`](R) reader structure"] impl crate :: Readable for Bkp18rSpec { }
#[doc = "`write(|w| ..)` method takes [`bkp18r::W`](W) writer structure"] impl crate :: Writable for Bkp18rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BKP18R to value 0"] impl crate :: Resettable for Bkp18rSpec { } }
#[doc = "BKP19R (rw) register accessor: backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp19r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp19r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bkp19r`] module"]
#[doc (alias = "BKP19R")] pub type Bkp19r = crate :: Reg < bkp19r :: Bkp19rSpec > ;
#[doc = "backup register"] pub mod bkp19r {
#[doc = "Register `BKP19R` reader"] pub type R = crate :: R < Bkp19rSpec > ;
#[doc = "Register `BKP19R` writer"] pub type W = crate :: W < Bkp19rSpec > ;
#[doc = "Field `BKP` reader - BKP"] pub type BkpR = crate :: FieldReader < u32 > ;
#[doc = "Field `BKP` writer - BKP"] pub type BkpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - BKP"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , Bkp19rSpec > { BkpW :: new (self , 0) } }
#[doc = "backup register\n\nYou can [`read`](crate::Reg::read) this register and get [`bkp19r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bkp19r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bkp19rSpec ; impl crate :: RegisterSpec for Bkp19rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bkp19r::R`](R) reader structure"] impl crate :: Readable for Bkp19rSpec { }
#[doc = "`write(|w| ..)` method takes [`bkp19r::W`](W) writer structure"] impl crate :: Writable for Bkp19rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BKP19R to value 0"] impl crate :: Resettable for Bkp19rSpec { } } }
#[doc = "Debug support"] pub type Dbgmcu = crate :: Periph < dbgmcu :: RegisterBlock , 0xe004_2000 > ; impl core :: fmt :: Debug for Dbgmcu { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dbgmcu") . finish () } }
#[doc = "Debug support"] pub mod dbgmcu {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { idcode : Idcode , cr : Cr , _reserved2 : [u8 ; 0x34] , apb1fzr1 : Apb1fzr1 , c2ap_b1fzr1 : C2apB1fzr1 , apb1fzr2 : Apb1fzr2 , _reserved_5_c2apb : [u8 ; 0x04] , apb2fzr : Apb2fzr , } impl RegisterBlock {
#[doc = "0x00 - MCU Device ID Code Register"]
#[inline (always)] pub const fn idcode (& self) -> & Idcode { & self . idcode }
#[doc = "0x04 - Debug MCU Configuration Register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x3c - APB1 Low Freeze Register CPU1"]
#[inline (always)] pub const fn apb1fzr1 (& self) -> & Apb1fzr1 { & self . apb1fzr1 }
#[doc = "0x40 - APB1 Low Freeze Register CPU2"]
#[inline (always)] pub const fn c2ap_b1fzr1 (& self) -> & C2apB1fzr1 { & self . c2ap_b1fzr1 }
#[doc = "0x44 - APB1 High Freeze Register CPU1"]
#[inline (always)] pub const fn apb1fzr2 (& self) -> & Apb1fzr2 { & self . apb1fzr2 }
#[doc = "0x48 - APB2 Freeze Register CPU2"]
#[inline (always)] pub const fn c2apb2fzr (& self) -> & C2apb2fzr { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (72) . cast () } }
#[doc = "0x48 - APB1 High Freeze Register CPU2"]
#[inline (always)] pub const fn c2apb1fzr2 (& self) -> & C2apb1fzr2 { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (72) . cast () } }
#[doc = "0x4c - APB2 Freeze Register CPU1"]
#[inline (always)] pub const fn apb2fzr (& self) -> & Apb2fzr { & self . apb2fzr } }
#[doc = "IDCODE (r) register accessor: MCU Device ID Code Register\n\nYou can [`read`](crate::Reg::read) this register and get [`idcode::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@idcode`] module"]
#[doc (alias = "IDCODE")] pub type Idcode = crate :: Reg < idcode :: IdcodeSpec > ;
#[doc = "MCU Device ID Code Register"] pub mod idcode {
#[doc = "Register `IDCODE` reader"] pub type R = crate :: R < IdcodeSpec > ;
#[doc = "Field `DEV_ID` reader - Device Identifier"] pub type DevIdR = crate :: FieldReader < u16 > ;
#[doc = "Field `REV_ID` reader - Revision Identifier"] pub type RevIdR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:11 - Device Identifier"]
#[inline (always)] pub fn dev_id (& self) -> DevIdR { DevIdR :: new ((self . bits & 0x0fff) as u16) }
#[doc = "Bits 16:31 - Revision Identifier"]
#[inline (always)] pub fn rev_id (& self) -> RevIdR { RevIdR :: new (((self . bits >> 16) & 0xffff) as u16) } }
#[doc = "MCU Device ID Code Register\n\nYou can [`read`](crate::Reg::read) this register and get [`idcode::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IdcodeSpec ; impl crate :: RegisterSpec for IdcodeSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`idcode::R`](R) reader structure"] impl crate :: Readable for IdcodeSpec { }
#[doc = "`reset()` method sets IDCODE to value 0"] impl crate :: Resettable for IdcodeSpec { } }
#[doc = "CR (rw) register accessor: Debug MCU Configuration Register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "Debug MCU Configuration Register"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `DBG_SLEEP` reader - Debug Sleep Mode"] pub type DbgSleepR = crate :: BitReader ;
#[doc = "Field `DBG_SLEEP` writer - Debug Sleep Mode"] pub type DbgSleepW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_STOP` reader - Debug Stop Mode"] pub type DbgStopR = crate :: BitReader ;
#[doc = "Field `DBG_STOP` writer - Debug Stop Mode"] pub type DbgStopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_STANDBY` reader - Debug Standby Mode"] pub type DbgStandbyR = crate :: BitReader ;
#[doc = "Field `DBG_STANDBY` writer - Debug Standby Mode"] pub type DbgStandbyW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TRACE_IOEN` reader - Trace port and clock enable"] pub type TraceIoenR = crate :: BitReader ;
#[doc = "Field `TRACE_IOEN` writer - Trace port and clock enable"] pub type TraceIoenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TRGOEN` reader - External trigger output enable"] pub type TrgoenR = crate :: BitReader ;
#[doc = "Field `TRGOEN` writer - External trigger output enable"] pub type TrgoenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Debug Sleep Mode"]
#[inline (always)] pub fn dbg_sleep (& self) -> DbgSleepR { DbgSleepR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Debug Stop Mode"]
#[inline (always)] pub fn dbg_stop (& self) -> DbgStopR { DbgStopR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Debug Standby Mode"]
#[inline (always)] pub fn dbg_standby (& self) -> DbgStandbyR { DbgStandbyR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 5 - Trace port and clock enable"]
#[inline (always)] pub fn trace_ioen (& self) -> TraceIoenR { TraceIoenR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 28 - External trigger output enable"]
#[inline (always)] pub fn trgoen (& self) -> TrgoenR { TrgoenR :: new (((self . bits >> 28) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Debug Sleep Mode"]
#[inline (always)] pub fn dbg_sleep (& mut self) -> DbgSleepW < '_ , CrSpec > { DbgSleepW :: new (self , 0) }
#[doc = "Bit 1 - Debug Stop Mode"]
#[inline (always)] pub fn dbg_stop (& mut self) -> DbgStopW < '_ , CrSpec > { DbgStopW :: new (self , 1) }
#[doc = "Bit 2 - Debug Standby Mode"]
#[inline (always)] pub fn dbg_standby (& mut self) -> DbgStandbyW < '_ , CrSpec > { DbgStandbyW :: new (self , 2) }
#[doc = "Bit 5 - Trace port and clock enable"]
#[inline (always)] pub fn trace_ioen (& mut self) -> TraceIoenW < '_ , CrSpec > { TraceIoenW :: new (self , 5) }
#[doc = "Bit 28 - External trigger output enable"]
#[inline (always)] pub fn trgoen (& mut self) -> TrgoenW < '_ , CrSpec > { TrgoenW :: new (self , 28) } }
#[doc = "Debug MCU Configuration Register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { } }
#[doc = "APB1FZR1 (rw) register accessor: APB1 Low Freeze Register CPU1\n\nYou can [`read`](crate::Reg::read) this register and get [`apb1fzr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb1fzr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@apb1fzr1`] module"]
#[doc (alias = "APB1FZR1")] pub type Apb1fzr1 = crate :: Reg < apb1fzr1 :: Apb1fzr1Spec > ;
#[doc = "APB1 Low Freeze Register CPU1"] pub mod apb1fzr1 {
#[doc = "Register `APB1FZR1` reader"] pub type R = crate :: R < Apb1fzr1Spec > ;
#[doc = "Register `APB1FZR1` writer"] pub type W = crate :: W < Apb1fzr1Spec > ;
#[doc = "Field `DBG_TIMER2_STOP` reader - Debug Timer 2 stopped when Core is halted"] pub type DbgTimer2StopR = crate :: BitReader ;
#[doc = "Field `DBG_TIMER2_STOP` writer - Debug Timer 2 stopped when Core is halted"] pub type DbgTimer2StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_RTC_STOP` reader - RTC counter stopped when core is halted"] pub type DbgRtcStopR = crate :: BitReader ;
#[doc = "Field `DBG_RTC_STOP` writer - RTC counter stopped when core is halted"] pub type DbgRtcStopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_WWDG_STOP` reader - WWDG counter stopped when core is halted"] pub type DbgWwdgStopR = crate :: BitReader ;
#[doc = "Field `DBG_WWDG_STOP` writer - WWDG counter stopped when core is halted"] pub type DbgWwdgStopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_IWDG_STOP` reader - IWDG counter stopped when core is halted"] pub type DbgIwdgStopR = crate :: BitReader ;
#[doc = "Field `DBG_IWDG_STOP` writer - IWDG counter stopped when core is halted"] pub type DbgIwdgStopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_I2C1_STOP` reader - Debug I2C1 SMBUS timeout stopped when Core is halted"] pub type DbgI2c1StopR = crate :: BitReader ;
#[doc = "Field `DBG_I2C1_STOP` writer - Debug I2C1 SMBUS timeout stopped when Core is halted"] pub type DbgI2c1StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_I2C3_STOP` reader - Debug I2C3 SMBUS timeout stopped when core is halted"] pub type DbgI2c3StopR = crate :: BitReader ;
#[doc = "Field `DBG_I2C3_STOP` writer - Debug I2C3 SMBUS timeout stopped when core is halted"] pub type DbgI2c3StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_LPTIM1_STOP` reader - Debug LPTIM1 stopped when Core is halted"] pub type DbgLptim1StopR = crate :: BitReader ;
#[doc = "Field `DBG_LPTIM1_STOP` writer - Debug LPTIM1 stopped when Core is halted"] pub type DbgLptim1StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Debug Timer 2 stopped when Core is halted"]
#[inline (always)] pub fn dbg_timer2_stop (& self) -> DbgTimer2StopR { DbgTimer2StopR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 10 - RTC counter stopped when core is halted"]
#[inline (always)] pub fn dbg_rtc_stop (& self) -> DbgRtcStopR { DbgRtcStopR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - WWDG counter stopped when core is halted"]
#[inline (always)] pub fn dbg_wwdg_stop (& self) -> DbgWwdgStopR { DbgWwdgStopR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - IWDG counter stopped when core is halted"]
#[inline (always)] pub fn dbg_iwdg_stop (& self) -> DbgIwdgStopR { DbgIwdgStopR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 21 - Debug I2C1 SMBUS timeout stopped when Core is halted"]
#[inline (always)] pub fn dbg_i2c1_stop (& self) -> DbgI2c1StopR { DbgI2c1StopR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 23 - Debug I2C3 SMBUS timeout stopped when core is halted"]
#[inline (always)] pub fn dbg_i2c3_stop (& self) -> DbgI2c3StopR { DbgI2c3StopR :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 31 - Debug LPTIM1 stopped when Core is halted"]
#[inline (always)] pub fn dbg_lptim1_stop (& self) -> DbgLptim1StopR { DbgLptim1StopR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Debug Timer 2 stopped when Core is halted"]
#[inline (always)] pub fn dbg_timer2_stop (& mut self) -> DbgTimer2StopW < '_ , Apb1fzr1Spec > { DbgTimer2StopW :: new (self , 0) }
#[doc = "Bit 10 - RTC counter stopped when core is halted"]
#[inline (always)] pub fn dbg_rtc_stop (& mut self) -> DbgRtcStopW < '_ , Apb1fzr1Spec > { DbgRtcStopW :: new (self , 10) }
#[doc = "Bit 11 - WWDG counter stopped when core is halted"]
#[inline (always)] pub fn dbg_wwdg_stop (& mut self) -> DbgWwdgStopW < '_ , Apb1fzr1Spec > { DbgWwdgStopW :: new (self , 11) }
#[doc = "Bit 12 - IWDG counter stopped when core is halted"]
#[inline (always)] pub fn dbg_iwdg_stop (& mut self) -> DbgIwdgStopW < '_ , Apb1fzr1Spec > { DbgIwdgStopW :: new (self , 12) }
#[doc = "Bit 21 - Debug I2C1 SMBUS timeout stopped when Core is halted"]
#[inline (always)] pub fn dbg_i2c1_stop (& mut self) -> DbgI2c1StopW < '_ , Apb1fzr1Spec > { DbgI2c1StopW :: new (self , 21) }
#[doc = "Bit 23 - Debug I2C3 SMBUS timeout stopped when core is halted"]
#[inline (always)] pub fn dbg_i2c3_stop (& mut self) -> DbgI2c3StopW < '_ , Apb1fzr1Spec > { DbgI2c3StopW :: new (self , 23) }
#[doc = "Bit 31 - Debug LPTIM1 stopped when Core is halted"]
#[inline (always)] pub fn dbg_lptim1_stop (& mut self) -> DbgLptim1StopW < '_ , Apb1fzr1Spec > { DbgLptim1StopW :: new (self , 31) } }
#[doc = "APB1 Low Freeze Register CPU1\n\nYou can [`read`](crate::Reg::read) this register and get [`apb1fzr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb1fzr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Apb1fzr1Spec ; impl crate :: RegisterSpec for Apb1fzr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`apb1fzr1::R`](R) reader structure"] impl crate :: Readable for Apb1fzr1Spec { }
#[doc = "`write(|w| ..)` method takes [`apb1fzr1::W`](W) writer structure"] impl crate :: Writable for Apb1fzr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets APB1FZR1 to value 0"] impl crate :: Resettable for Apb1fzr1Spec { } }
#[doc = "C2AP_B1FZR1 (rw) register accessor: APB1 Low Freeze Register CPU2\n\nYou can [`read`](crate::Reg::read) this register and get [`c2ap_b1fzr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2ap_b1fzr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2ap_b1fzr1`] module"]
#[doc (alias = "C2AP_B1FZR1")] pub type C2apB1fzr1 = crate :: Reg < c2ap_b1fzr1 :: C2apB1fzr1Spec > ;
#[doc = "APB1 Low Freeze Register CPU2"] pub mod c2ap_b1fzr1 {
#[doc = "Register `C2AP_B1FZR1` reader"] pub type R = crate :: R < C2apB1fzr1Spec > ;
#[doc = "Register `C2AP_B1FZR1` writer"] pub type W = crate :: W < C2apB1fzr1Spec > ;
#[doc = "Field `DBG_LPTIM2_STOP` reader - LPTIM2 counter stopped when core is halted"] pub type DbgLptim2StopR = crate :: BitReader ;
#[doc = "Field `DBG_LPTIM2_STOP` writer - LPTIM2 counter stopped when core is halted"] pub type DbgLptim2StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_RTC_STOP` reader - RTC counter stopped when core is halted"] pub type DbgRtcStopR = crate :: BitReader ;
#[doc = "Field `DBG_RTC_STOP` writer - RTC counter stopped when core is halted"] pub type DbgRtcStopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_IWDG_STOP` reader - IWDG stopped when core is halted"] pub type DbgIwdgStopR = crate :: BitReader ;
#[doc = "Field `DBG_IWDG_STOP` writer - IWDG stopped when core is halted"] pub type DbgIwdgStopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_I2C1_STOP` reader - I2C1 SMBUS timeout stopped when core is halted"] pub type DbgI2c1StopR = crate :: BitReader ;
#[doc = "Field `DBG_I2C1_STOP` writer - I2C1 SMBUS timeout stopped when core is halted"] pub type DbgI2c1StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_I2C3_STOP` reader - I2C3 SMBUS timeout stopped when core is halted"] pub type DbgI2c3StopR = crate :: BitReader ;
#[doc = "Field `DBG_I2C3_STOP` writer - I2C3 SMBUS timeout stopped when core is halted"] pub type DbgI2c3StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_LPTIM1_STOP` reader - LPTIM1 counter stopped when core is halted"] pub type DbgLptim1StopR = crate :: BitReader ;
#[doc = "Field `DBG_LPTIM1_STOP` writer - LPTIM1 counter stopped when core is halted"] pub type DbgLptim1StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - LPTIM2 counter stopped when core is halted"]
#[inline (always)] pub fn dbg_lptim2_stop (& self) -> DbgLptim2StopR { DbgLptim2StopR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 10 - RTC counter stopped when core is halted"]
#[inline (always)] pub fn dbg_rtc_stop (& self) -> DbgRtcStopR { DbgRtcStopR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 12 - IWDG stopped when core is halted"]
#[inline (always)] pub fn dbg_iwdg_stop (& self) -> DbgIwdgStopR { DbgIwdgStopR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 21 - I2C1 SMBUS timeout stopped when core is halted"]
#[inline (always)] pub fn dbg_i2c1_stop (& self) -> DbgI2c1StopR { DbgI2c1StopR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 23 - I2C3 SMBUS timeout stopped when core is halted"]
#[inline (always)] pub fn dbg_i2c3_stop (& self) -> DbgI2c3StopR { DbgI2c3StopR :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 31 - LPTIM1 counter stopped when core is halted"]
#[inline (always)] pub fn dbg_lptim1_stop (& self) -> DbgLptim1StopR { DbgLptim1StopR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - LPTIM2 counter stopped when core is halted"]
#[inline (always)] pub fn dbg_lptim2_stop (& mut self) -> DbgLptim2StopW < '_ , C2apB1fzr1Spec > { DbgLptim2StopW :: new (self , 0) }
#[doc = "Bit 10 - RTC counter stopped when core is halted"]
#[inline (always)] pub fn dbg_rtc_stop (& mut self) -> DbgRtcStopW < '_ , C2apB1fzr1Spec > { DbgRtcStopW :: new (self , 10) }
#[doc = "Bit 12 - IWDG stopped when core is halted"]
#[inline (always)] pub fn dbg_iwdg_stop (& mut self) -> DbgIwdgStopW < '_ , C2apB1fzr1Spec > { DbgIwdgStopW :: new (self , 12) }
#[doc = "Bit 21 - I2C1 SMBUS timeout stopped when core is halted"]
#[inline (always)] pub fn dbg_i2c1_stop (& mut self) -> DbgI2c1StopW < '_ , C2apB1fzr1Spec > { DbgI2c1StopW :: new (self , 21) }
#[doc = "Bit 23 - I2C3 SMBUS timeout stopped when core is halted"]
#[inline (always)] pub fn dbg_i2c3_stop (& mut self) -> DbgI2c3StopW < '_ , C2apB1fzr1Spec > { DbgI2c3StopW :: new (self , 23) }
#[doc = "Bit 31 - LPTIM1 counter stopped when core is halted"]
#[inline (always)] pub fn dbg_lptim1_stop (& mut self) -> DbgLptim1StopW < '_ , C2apB1fzr1Spec > { DbgLptim1StopW :: new (self , 31) } }
#[doc = "APB1 Low Freeze Register CPU2\n\nYou can [`read`](crate::Reg::read) this register and get [`c2ap_b1fzr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2ap_b1fzr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2apB1fzr1Spec ; impl crate :: RegisterSpec for C2apB1fzr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2ap_b1fzr1::R`](R) reader structure"] impl crate :: Readable for C2apB1fzr1Spec { }
#[doc = "`write(|w| ..)` method takes [`c2ap_b1fzr1::W`](W) writer structure"] impl crate :: Writable for C2apB1fzr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2AP_B1FZR1 to value 0"] impl crate :: Resettable for C2apB1fzr1Spec { } }
#[doc = "APB1FZR2 (rw) register accessor: APB1 High Freeze Register CPU1\n\nYou can [`read`](crate::Reg::read) this register and get [`apb1fzr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb1fzr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@apb1fzr2`] module"]
#[doc (alias = "APB1FZR2")] pub type Apb1fzr2 = crate :: Reg < apb1fzr2 :: Apb1fzr2Spec > ;
#[doc = "APB1 High Freeze Register CPU1"] pub mod apb1fzr2 {
#[doc = "Register `APB1FZR2` reader"] pub type R = crate :: R < Apb1fzr2Spec > ;
#[doc = "Register `APB1FZR2` writer"] pub type W = crate :: W < Apb1fzr2Spec > ;
#[doc = "Field `DBG_LPTIM2_STOP` reader - LPTIM2 counter stopped when core is halted"] pub type DbgLptim2StopR = crate :: BitReader ;
#[doc = "Field `DBG_LPTIM2_STOP` writer - LPTIM2 counter stopped when core is halted"] pub type DbgLptim2StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 5 - LPTIM2 counter stopped when core is halted"]
#[inline (always)] pub fn dbg_lptim2_stop (& self) -> DbgLptim2StopR { DbgLptim2StopR :: new (((self . bits >> 5) & 1) != 0) } } impl W {
#[doc = "Bit 5 - LPTIM2 counter stopped when core is halted"]
#[inline (always)] pub fn dbg_lptim2_stop (& mut self) -> DbgLptim2StopW < '_ , Apb1fzr2Spec > { DbgLptim2StopW :: new (self , 5) } }
#[doc = "APB1 High Freeze Register CPU1\n\nYou can [`read`](crate::Reg::read) this register and get [`apb1fzr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb1fzr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Apb1fzr2Spec ; impl crate :: RegisterSpec for Apb1fzr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`apb1fzr2::R`](R) reader structure"] impl crate :: Readable for Apb1fzr2Spec { }
#[doc = "`write(|w| ..)` method takes [`apb1fzr2::W`](W) writer structure"] impl crate :: Writable for Apb1fzr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets APB1FZR2 to value 0"] impl crate :: Resettable for Apb1fzr2Spec { } }
#[doc = "C2APB1FZR2 (rw) register accessor: APB1 High Freeze Register CPU2\n\nYou can [`read`](crate::Reg::read) this register and get [`c2apb1fzr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2apb1fzr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2apb1fzr2`] module"]
#[doc (alias = "C2APB1FZR2")] pub type C2apb1fzr2 = crate :: Reg < c2apb1fzr2 :: C2apb1fzr2Spec > ;
#[doc = "APB1 High Freeze Register CPU2"] pub mod c2apb1fzr2 {
#[doc = "Register `C2APB1FZR2` reader"] pub type R = crate :: R < C2apb1fzr2Spec > ;
#[doc = "Register `C2APB1FZR2` writer"] pub type W = crate :: W < C2apb1fzr2Spec > ;
#[doc = "Field `DBG_LPTIM2_STOP` reader - LPTIM2 counter stopped when core is halted"] pub type DbgLptim2StopR = crate :: BitReader ;
#[doc = "Field `DBG_LPTIM2_STOP` writer - LPTIM2 counter stopped when core is halted"] pub type DbgLptim2StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 5 - LPTIM2 counter stopped when core is halted"]
#[inline (always)] pub fn dbg_lptim2_stop (& self) -> DbgLptim2StopR { DbgLptim2StopR :: new (((self . bits >> 5) & 1) != 0) } } impl W {
#[doc = "Bit 5 - LPTIM2 counter stopped when core is halted"]
#[inline (always)] pub fn dbg_lptim2_stop (& mut self) -> DbgLptim2StopW < '_ , C2apb1fzr2Spec > { DbgLptim2StopW :: new (self , 5) } }
#[doc = "APB1 High Freeze Register CPU2\n\nYou can [`read`](crate::Reg::read) this register and get [`c2apb1fzr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2apb1fzr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2apb1fzr2Spec ; impl crate :: RegisterSpec for C2apb1fzr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2apb1fzr2::R`](R) reader structure"] impl crate :: Readable for C2apb1fzr2Spec { }
#[doc = "`write(|w| ..)` method takes [`c2apb1fzr2::W`](W) writer structure"] impl crate :: Writable for C2apb1fzr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2APB1FZR2 to value 0"] impl crate :: Resettable for C2apb1fzr2Spec { } }
#[doc = "APB2FZR (rw) register accessor: APB2 Freeze Register CPU1\n\nYou can [`read`](crate::Reg::read) this register and get [`apb2fzr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb2fzr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@apb2fzr`] module"]
#[doc (alias = "APB2FZR")] pub type Apb2fzr = crate :: Reg < apb2fzr :: Apb2fzrSpec > ;
#[doc = "APB2 Freeze Register CPU1"] pub mod apb2fzr {
#[doc = "Register `APB2FZR` reader"] pub type R = crate :: R < Apb2fzrSpec > ;
#[doc = "Register `APB2FZR` writer"] pub type W = crate :: W < Apb2fzrSpec > ;
#[doc = "Field `DBG_TIM1_STOP` reader - TIM1 counter stopped when core is halted"] pub type DbgTim1StopR = crate :: BitReader ;
#[doc = "Field `DBG_TIM1_STOP` writer - TIM1 counter stopped when core is halted"] pub type DbgTim1StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_TIM16_STOP` reader - TIM16 counter stopped when core is halted"] pub type DbgTim16StopR = crate :: BitReader ;
#[doc = "Field `DBG_TIM16_STOP` writer - TIM16 counter stopped when core is halted"] pub type DbgTim16StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_TIM17_STOP` reader - TIM17 counter stopped when core is halted"] pub type DbgTim17StopR = crate :: BitReader ;
#[doc = "Field `DBG_TIM17_STOP` writer - TIM17 counter stopped when core is halted"] pub type DbgTim17StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 11 - TIM1 counter stopped when core is halted"]
#[inline (always)] pub fn dbg_tim1_stop (& self) -> DbgTim1StopR { DbgTim1StopR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 17 - TIM16 counter stopped when core is halted"]
#[inline (always)] pub fn dbg_tim16_stop (& self) -> DbgTim16StopR { DbgTim16StopR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - TIM17 counter stopped when core is halted"]
#[inline (always)] pub fn dbg_tim17_stop (& self) -> DbgTim17StopR { DbgTim17StopR :: new (((self . bits >> 18) & 1) != 0) } } impl W {
#[doc = "Bit 11 - TIM1 counter stopped when core is halted"]
#[inline (always)] pub fn dbg_tim1_stop (& mut self) -> DbgTim1StopW < '_ , Apb2fzrSpec > { DbgTim1StopW :: new (self , 11) }
#[doc = "Bit 17 - TIM16 counter stopped when core is halted"]
#[inline (always)] pub fn dbg_tim16_stop (& mut self) -> DbgTim16StopW < '_ , Apb2fzrSpec > { DbgTim16StopW :: new (self , 17) }
#[doc = "Bit 18 - TIM17 counter stopped when core is halted"]
#[inline (always)] pub fn dbg_tim17_stop (& mut self) -> DbgTim17StopW < '_ , Apb2fzrSpec > { DbgTim17StopW :: new (self , 18) } }
#[doc = "APB2 Freeze Register CPU1\n\nYou can [`read`](crate::Reg::read) this register and get [`apb2fzr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb2fzr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Apb2fzrSpec ; impl crate :: RegisterSpec for Apb2fzrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`apb2fzr::R`](R) reader structure"] impl crate :: Readable for Apb2fzrSpec { }
#[doc = "`write(|w| ..)` method takes [`apb2fzr::W`](W) writer structure"] impl crate :: Writable for Apb2fzrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets APB2FZR to value 0"] impl crate :: Resettable for Apb2fzrSpec { } }
#[doc = "C2APB2FZR (rw) register accessor: APB2 Freeze Register CPU2\n\nYou can [`read`](crate::Reg::read) this register and get [`c2apb2fzr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2apb2fzr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2apb2fzr`] module"]
#[doc (alias = "C2APB2FZR")] pub type C2apb2fzr = crate :: Reg < c2apb2fzr :: C2apb2fzrSpec > ;
#[doc = "APB2 Freeze Register CPU2"] pub mod c2apb2fzr {
#[doc = "Register `C2APB2FZR` reader"] pub type R = crate :: R < C2apb2fzrSpec > ;
#[doc = "Register `C2APB2FZR` writer"] pub type W = crate :: W < C2apb2fzrSpec > ;
#[doc = "Field `DBG_TIM1_STOP` reader - TIM1 counter stopped when core is halted"] pub type DbgTim1StopR = crate :: BitReader ;
#[doc = "Field `DBG_TIM1_STOP` writer - TIM1 counter stopped when core is halted"] pub type DbgTim1StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_TIM16_STOP` reader - TIM16 counter stopped when core is halted"] pub type DbgTim16StopR = crate :: BitReader ;
#[doc = "Field `DBG_TIM16_STOP` writer - TIM16 counter stopped when core is halted"] pub type DbgTim16StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_TIM17_STOP` reader - TIM17 counter stopped when core is halted"] pub type DbgTim17StopR = crate :: BitReader ;
#[doc = "Field `DBG_TIM17_STOP` writer - TIM17 counter stopped when core is halted"] pub type DbgTim17StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 11 - TIM1 counter stopped when core is halted"]
#[inline (always)] pub fn dbg_tim1_stop (& self) -> DbgTim1StopR { DbgTim1StopR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 17 - TIM16 counter stopped when core is halted"]
#[inline (always)] pub fn dbg_tim16_stop (& self) -> DbgTim16StopR { DbgTim16StopR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - TIM17 counter stopped when core is halted"]
#[inline (always)] pub fn dbg_tim17_stop (& self) -> DbgTim17StopR { DbgTim17StopR :: new (((self . bits >> 18) & 1) != 0) } } impl W {
#[doc = "Bit 11 - TIM1 counter stopped when core is halted"]
#[inline (always)] pub fn dbg_tim1_stop (& mut self) -> DbgTim1StopW < '_ , C2apb2fzrSpec > { DbgTim1StopW :: new (self , 11) }
#[doc = "Bit 17 - TIM16 counter stopped when core is halted"]
#[inline (always)] pub fn dbg_tim16_stop (& mut self) -> DbgTim16StopW < '_ , C2apb2fzrSpec > { DbgTim16StopW :: new (self , 17) }
#[doc = "Bit 18 - TIM17 counter stopped when core is halted"]
#[inline (always)] pub fn dbg_tim17_stop (& mut self) -> DbgTim17StopW < '_ , C2apb2fzrSpec > { DbgTim17StopW :: new (self , 18) } }
#[doc = "APB2 Freeze Register CPU2\n\nYou can [`read`](crate::Reg::read) this register and get [`c2apb2fzr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2apb2fzr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2apb2fzrSpec ; impl crate :: RegisterSpec for C2apb2fzrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2apb2fzr::R`](R) reader structure"] impl crate :: Readable for C2apb2fzrSpec { }
#[doc = "`write(|w| ..)` method takes [`c2apb2fzr::W`](W) writer structure"] impl crate :: Writable for C2apb2fzrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2APB2FZR to value 0"] impl crate :: Resettable for C2apb2fzrSpec { } } }
#[doc = "PKA"] pub type Pka = crate :: Periph < pka :: RegisterBlock , 0x5800_2000 > ; impl core :: fmt :: Debug for Pka { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Pka") . finish () } }
#[doc = "PKA"] pub mod pka {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr : Cr , sr : Sr , clrfr : Clrfr , _reserved3 : [u8 ; 0x1fe8] , verr : Verr , ipidr : Ipidr , sidr : Sidr , } impl RegisterBlock {
#[doc = "0x00 - Control register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x04 - PKA status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x08 - PKA clear flag register"]
#[inline (always)] pub const fn clrfr (& self) -> & Clrfr { & self . clrfr }
#[doc = "0x1ff4 - PKA version register"]
#[inline (always)] pub const fn verr (& self) -> & Verr { & self . verr }
#[doc = "0x1ff8 - PKA identification register"]
#[inline (always)] pub const fn ipidr (& self) -> & Ipidr { & self . ipidr }
#[doc = "0x1ffc - PKA size ID register"]
#[inline (always)] pub const fn sidr (& self) -> & Sidr { & self . sidr } }
#[doc = "CR (rw) register accessor: Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "Control register"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `EN` reader - Peripheral Enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Peripheral Enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `START` reader - Start the operation"] pub type StartR = crate :: BitReader ;
#[doc = "Field `START` writer - Start the operation"] pub type StartW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SECLVL` reader - Security Enable"] pub type SeclvlR = crate :: BitReader ;
#[doc = "Field `SECLVL` writer - Security Enable"] pub type SeclvlW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MODE` reader - PKA Operation Mode"] pub type ModeR = crate :: FieldReader ;
#[doc = "Field `MODE` writer - PKA Operation Mode"] pub type ModeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 > ;
#[doc = "Field `PROCENDIE` reader - End of operation interrupt enable"] pub type ProcendieR = crate :: BitReader ;
#[doc = "Field `PROCENDIE` writer - End of operation interrupt enable"] pub type ProcendieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RAMERRIE` reader - RAM error interrupt enable"] pub type RamerrieR = crate :: BitReader ;
#[doc = "Field `RAMERRIE` writer - RAM error interrupt enable"] pub type RamerrieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADDRERRIE` reader - Address error interrupt enable"] pub type AddrerrieR = crate :: BitReader ;
#[doc = "Field `ADDRERRIE` writer - Address error interrupt enable"] pub type AddrerrieW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Peripheral Enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Start the operation"]
#[inline (always)] pub fn start (& self) -> StartR { StartR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Security Enable"]
#[inline (always)] pub fn seclvl (& self) -> SeclvlR { SeclvlR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 8:13 - PKA Operation Mode"]
#[inline (always)] pub fn mode (& self) -> ModeR { ModeR :: new (((self . bits >> 8) & 0x3f) as u8) }
#[doc = "Bit 17 - End of operation interrupt enable"]
#[inline (always)] pub fn procendie (& self) -> ProcendieR { ProcendieR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 19 - RAM error interrupt enable"]
#[inline (always)] pub fn ramerrie (& self) -> RamerrieR { RamerrieR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Address error interrupt enable"]
#[inline (always)] pub fn addrerrie (& self) -> AddrerrieR { AddrerrieR :: new (((self . bits >> 20) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Peripheral Enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , CrSpec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Start the operation"]
#[inline (always)] pub fn start (& mut self) -> StartW < '_ , CrSpec > { StartW :: new (self , 1) }
#[doc = "Bit 2 - Security Enable"]
#[inline (always)] pub fn seclvl (& mut self) -> SeclvlW < '_ , CrSpec > { SeclvlW :: new (self , 2) }
#[doc = "Bits 8:13 - PKA Operation Mode"]
#[inline (always)] pub fn mode (& mut self) -> ModeW < '_ , CrSpec > { ModeW :: new (self , 8) }
#[doc = "Bit 17 - End of operation interrupt enable"]
#[inline (always)] pub fn procendie (& mut self) -> ProcendieW < '_ , CrSpec > { ProcendieW :: new (self , 17) }
#[doc = "Bit 19 - RAM error interrupt enable"]
#[inline (always)] pub fn ramerrie (& mut self) -> RamerrieW < '_ , CrSpec > { RamerrieW :: new (self , 19) }
#[doc = "Bit 20 - Address error interrupt enable"]
#[inline (always)] pub fn addrerrie (& mut self) -> AddrerrieW < '_ , CrSpec > { AddrerrieW :: new (self , 20) } }
#[doc = "Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { } }
#[doc = "SR (r) register accessor: PKA status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "PKA status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Field `BUSY` reader - PKA Operation in progress"] pub type BusyR = crate :: BitReader ;
#[doc = "Field `PROCENDF` reader - PKA End of Operation flag"] pub type ProcendfR = crate :: BitReader ;
#[doc = "Field `RAMERRF` reader - RAM error flag"] pub type RamerrfR = crate :: BitReader ;
#[doc = "Field `ADDRERRF` reader - Address error flag"] pub type AddrerrfR = crate :: BitReader ; impl R {
#[doc = "Bit 16 - PKA Operation in progress"]
#[inline (always)] pub fn busy (& self) -> BusyR { BusyR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - PKA End of Operation flag"]
#[inline (always)] pub fn procendf (& self) -> ProcendfR { ProcendfR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 19 - RAM error flag"]
#[inline (always)] pub fn ramerrf (& self) -> RamerrfR { RamerrfR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Address error flag"]
#[inline (always)] pub fn addrerrf (& self) -> AddrerrfR { AddrerrfR :: new (((self . bits >> 20) & 1) != 0) } }
#[doc = "PKA status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "CLRFR (rw) register accessor: PKA clear flag register\n\nYou can [`read`](crate::Reg::read) this register and get [`clrfr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clrfr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clrfr`] module"]
#[doc (alias = "CLRFR")] pub type Clrfr = crate :: Reg < clrfr :: ClrfrSpec > ;
#[doc = "PKA clear flag register"] pub mod clrfr {
#[doc = "Register `CLRFR` reader"] pub type R = crate :: R < ClrfrSpec > ;
#[doc = "Register `CLRFR` writer"] pub type W = crate :: W < ClrfrSpec > ;
#[doc = "Field `PROCENDFC` reader - Clear PKA End of Operation flag"] pub type ProcendfcR = crate :: BitReader ;
#[doc = "Field `PROCENDFC` writer - Clear PKA End of Operation flag"] pub type ProcendfcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RAMERRFC` reader - Clear RAM error flag"] pub type RamerrfcR = crate :: BitReader ;
#[doc = "Field `RAMERRFC` writer - Clear RAM error flag"] pub type RamerrfcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADDRERRFC` reader - Clear Address error flag"] pub type AddrerrfcR = crate :: BitReader ;
#[doc = "Field `ADDRERRFC` writer - Clear Address error flag"] pub type AddrerrfcW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 17 - Clear PKA End of Operation flag"]
#[inline (always)] pub fn procendfc (& self) -> ProcendfcR { ProcendfcR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 19 - Clear RAM error flag"]
#[inline (always)] pub fn ramerrfc (& self) -> RamerrfcR { RamerrfcR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Clear Address error flag"]
#[inline (always)] pub fn addrerrfc (& self) -> AddrerrfcR { AddrerrfcR :: new (((self . bits >> 20) & 1) != 0) } } impl W {
#[doc = "Bit 17 - Clear PKA End of Operation flag"]
#[inline (always)] pub fn procendfc (& mut self) -> ProcendfcW < '_ , ClrfrSpec > { ProcendfcW :: new (self , 17) }
#[doc = "Bit 19 - Clear RAM error flag"]
#[inline (always)] pub fn ramerrfc (& mut self) -> RamerrfcW < '_ , ClrfrSpec > { RamerrfcW :: new (self , 19) }
#[doc = "Bit 20 - Clear Address error flag"]
#[inline (always)] pub fn addrerrfc (& mut self) -> AddrerrfcW < '_ , ClrfrSpec > { AddrerrfcW :: new (self , 20) } }
#[doc = "PKA clear flag register\n\nYou can [`read`](crate::Reg::read) this register and get [`clrfr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clrfr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ClrfrSpec ; impl crate :: RegisterSpec for ClrfrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`clrfr::R`](R) reader structure"] impl crate :: Readable for ClrfrSpec { }
#[doc = "`write(|w| ..)` method takes [`clrfr::W`](W) writer structure"] impl crate :: Writable for ClrfrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CLRFR to value 0"] impl crate :: Resettable for ClrfrSpec { } }
#[doc = "VERR (r) register accessor: PKA version register\n\nYou can [`read`](crate::Reg::read) this register and get [`verr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@verr`] module"]
#[doc (alias = "VERR")] pub type Verr = crate :: Reg < verr :: VerrSpec > ;
#[doc = "PKA version register"] pub mod verr {
#[doc = "Register `VERR` reader"] pub type R = crate :: R < VerrSpec > ;
#[doc = "Field `MINREV` reader - Minor revision"] pub type MinrevR = crate :: FieldReader ;
#[doc = "Field `MAJREV` reader - Major revision"] pub type MajrevR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:3 - Minor revision"]
#[inline (always)] pub fn minrev (& self) -> MinrevR { MinrevR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - Major revision"]
#[inline (always)] pub fn majrev (& self) -> MajrevR { MajrevR :: new (((self . bits >> 4) & 0x0f) as u8) } }
#[doc = "PKA version register\n\nYou can [`read`](crate::Reg::read) this register and get [`verr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct VerrSpec ; impl crate :: RegisterSpec for VerrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`verr::R`](R) reader structure"] impl crate :: Readable for VerrSpec { }
#[doc = "`reset()` method sets VERR to value 0x10"] impl crate :: Resettable for VerrSpec { const RESET_VALUE : u32 = 0x10 ; } }
#[doc = "IPIDR (r) register accessor: PKA identification register\n\nYou can [`read`](crate::Reg::read) this register and get [`ipidr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ipidr`] module"]
#[doc (alias = "IPIDR")] pub type Ipidr = crate :: Reg < ipidr :: IpidrSpec > ;
#[doc = "PKA identification register"] pub mod ipidr {
#[doc = "Register `IPIDR` reader"] pub type R = crate :: R < IpidrSpec > ;
#[doc = "Field `ID` reader - Identification Code"] pub type IdR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Identification Code"]
#[inline (always)] pub fn id (& self) -> IdR { IdR :: new (self . bits) } }
#[doc = "PKA identification register\n\nYou can [`read`](crate::Reg::read) this register and get [`ipidr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IpidrSpec ; impl crate :: RegisterSpec for IpidrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ipidr::R`](R) reader structure"] impl crate :: Readable for IpidrSpec { }
#[doc = "`reset()` method sets IPIDR to value 0x0017_0061"] impl crate :: Resettable for IpidrSpec { const RESET_VALUE : u32 = 0x0017_0061 ; } }
#[doc = "SIDR (r) register accessor: PKA size ID register\n\nYou can [`read`](crate::Reg::read) this register and get [`sidr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sidr`] module"]
#[doc (alias = "SIDR")] pub type Sidr = crate :: Reg < sidr :: SidrSpec > ;
#[doc = "PKA size ID register"] pub mod sidr {
#[doc = "Register `SIDR` reader"] pub type R = crate :: R < SidrSpec > ;
#[doc = "Field `SID` reader - Side Identification Code"] pub type SidR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Side Identification Code"]
#[inline (always)] pub fn sid (& self) -> SidR { SidR :: new (self . bits) } }
#[doc = "PKA size ID register\n\nYou can [`read`](crate::Reg::read) this register and get [`sidr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SidrSpec ; impl crate :: RegisterSpec for SidrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sidr::R`](R) reader structure"] impl crate :: Readable for SidrSpec { }
#[doc = "`reset()` method sets SIDR to value 0xa3c5_dd08"] impl crate :: Resettable for SidrSpec { const RESET_VALUE : u32 = 0xa3c5_dd08 ; } } }
#[doc = "IPCC"] pub type Ipcc = crate :: Periph < ipcc :: RegisterBlock , 0x5800_0c00 > ; impl core :: fmt :: Debug for Ipcc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ipcc") . finish () } }
#[doc = "IPCC"] pub mod ipcc {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { c1cr : C1cr , c1mr : C1mr , c1scr : C1scr , c1to2sr : C1to2sr , c2cr : C2cr , c2mr : C2mr , c2scr : C2scr , c2toc1sr : C2toc1sr , _reserved8 : [u8 ; 0x03d0] , hwcfgr : Hwcfgr , verr : Verr , ipidr : Ipidr , sidr : Sidr , } impl RegisterBlock {
#[doc = "0x00 - Control register CPU1"]
#[inline (always)] pub const fn c1cr (& self) -> & C1cr { & self . c1cr }
#[doc = "0x04 - Mask register CPU1"]
#[inline (always)] pub const fn c1mr (& self) -> & C1mr { & self . c1mr }
#[doc = "0x08 - Status Set or Clear register CPU1"]
#[inline (always)] pub const fn c1scr (& self) -> & C1scr { & self . c1scr }
#[doc = "0x0c - CPU1 to CPU2 status register"]
#[inline (always)] pub const fn c1to2sr (& self) -> & C1to2sr { & self . c1to2sr }
#[doc = "0x10 - Control register CPU2"]
#[inline (always)] pub const fn c2cr (& self) -> & C2cr { & self . c2cr }
#[doc = "0x14 - Mask register CPU2"]
#[inline (always)] pub const fn c2mr (& self) -> & C2mr { & self . c2mr }
#[doc = "0x18 - Status Set or Clear register CPU2"]
#[inline (always)] pub const fn c2scr (& self) -> & C2scr { & self . c2scr }
#[doc = "0x1c - CPU2 to CPU1 status register"]
#[inline (always)] pub const fn c2toc1sr (& self) -> & C2toc1sr { & self . c2toc1sr }
#[doc = "0x3f0 - IPCC Hardware configuration register"]
#[inline (always)] pub const fn hwcfgr (& self) -> & Hwcfgr { & self . hwcfgr }
#[doc = "0x3f4 - IPCC version register"]
#[inline (always)] pub const fn verr (& self) -> & Verr { & self . verr }
#[doc = "0x3f8 - IPCC indentification register"]
#[inline (always)] pub const fn ipidr (& self) -> & Ipidr { & self . ipidr }
#[doc = "0x3fc - IPCC size indentification register"]
#[inline (always)] pub const fn sidr (& self) -> & Sidr { & self . sidr } }
#[doc = "C1CR (rw) register accessor: Control register CPU1\n\nYou can [`read`](crate::Reg::read) this register and get [`c1cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c1cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c1cr`] module"]
#[doc (alias = "C1CR")] pub type C1cr = crate :: Reg < c1cr :: C1crSpec > ;
#[doc = "Control register CPU1"] pub mod c1cr {
#[doc = "Register `C1CR` reader"] pub type R = crate :: R < C1crSpec > ;
#[doc = "Register `C1CR` writer"] pub type W = crate :: W < C1crSpec > ;
#[doc = "Field `RXOIE` reader - processor 1 Receive channel occupied interrupt enable"] pub type RxoieR = crate :: BitReader ;
#[doc = "Field `RXOIE` writer - processor 1 Receive channel occupied interrupt enable"] pub type RxoieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXFIE` reader - processor 1 Transmit channel free interrupt enable"] pub type TxfieR = crate :: BitReader ;
#[doc = "Field `TXFIE` writer - processor 1 Transmit channel free interrupt enable"] pub type TxfieW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - processor 1 Receive channel occupied interrupt enable"]
#[inline (always)] pub fn rxoie (& self) -> RxoieR { RxoieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 16 - processor 1 Transmit channel free interrupt enable"]
#[inline (always)] pub fn txfie (& self) -> TxfieR { TxfieR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bit 0 - processor 1 Receive channel occupied interrupt enable"]
#[inline (always)] pub fn rxoie (& mut self) -> RxoieW < '_ , C1crSpec > { RxoieW :: new (self , 0) }
#[doc = "Bit 16 - processor 1 Transmit channel free interrupt enable"]
#[inline (always)] pub fn txfie (& mut self) -> TxfieW < '_ , C1crSpec > { TxfieW :: new (self , 16) } }
#[doc = "Control register CPU1\n\nYou can [`read`](crate::Reg::read) this register and get [`c1cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c1cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C1crSpec ; impl crate :: RegisterSpec for C1crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c1cr::R`](R) reader structure"] impl crate :: Readable for C1crSpec { }
#[doc = "`write(|w| ..)` method takes [`c1cr::W`](W) writer structure"] impl crate :: Writable for C1crSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C1CR to value 0"] impl crate :: Resettable for C1crSpec { } }
#[doc = "C1MR (rw) register accessor: Mask register CPU1\n\nYou can [`read`](crate::Reg::read) this register and get [`c1mr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c1mr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c1mr`] module"]
#[doc (alias = "C1MR")] pub type C1mr = crate :: Reg < c1mr :: C1mrSpec > ;
#[doc = "Mask register CPU1"] pub mod c1mr {
#[doc = "Register `C1MR` reader"] pub type R = crate :: R < C1mrSpec > ;
#[doc = "Register `C1MR` writer"] pub type W = crate :: W < C1mrSpec > ;
#[doc = "Field `CH1OM` reader - processor 1 Receive channel 1 occupied interrupt enable"] pub type Ch1omR = crate :: BitReader ;
#[doc = "Field `CH1OM` writer - processor 1 Receive channel 1 occupied interrupt enable"] pub type Ch1omW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH2OM` reader - processor 1 Receive channel 2 occupied interrupt enable"] pub type Ch2omR = crate :: BitReader ;
#[doc = "Field `CH2OM` writer - processor 1 Receive channel 2 occupied interrupt enable"] pub type Ch2omW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH3OM` reader - processor 1 Receive channel 3 occupied interrupt enable"] pub type Ch3omR = crate :: BitReader ;
#[doc = "Field `CH3OM` writer - processor 1 Receive channel 3 occupied interrupt enable"] pub type Ch3omW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH4OM` reader - processor 1 Receive channel 4 occupied interrupt enable"] pub type Ch4omR = crate :: BitReader ;
#[doc = "Field `CH4OM` writer - processor 1 Receive channel 4 occupied interrupt enable"] pub type Ch4omW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH5OM` reader - processor 1 Receive channel 5 occupied interrupt enable"] pub type Ch5omR = crate :: BitReader ;
#[doc = "Field `CH5OM` writer - processor 1 Receive channel 5 occupied interrupt enable"] pub type Ch5omW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH6OM` reader - processor 1 Receive channel 6 occupied interrupt enable"] pub type Ch6omR = crate :: BitReader ;
#[doc = "Field `CH6OM` writer - processor 1 Receive channel 6 occupied interrupt enable"] pub type Ch6omW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH1FM` reader - processor 1 Transmit channel 1 free interrupt mask"] pub type Ch1fmR = crate :: BitReader ;
#[doc = "Field `CH1FM` writer - processor 1 Transmit channel 1 free interrupt mask"] pub type Ch1fmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH2FM` reader - processor 1 Transmit channel 2 free interrupt mask"] pub type Ch2fmR = crate :: BitReader ;
#[doc = "Field `CH2FM` writer - processor 1 Transmit channel 2 free interrupt mask"] pub type Ch2fmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH3FM` reader - processor 1 Transmit channel 3 free interrupt mask"] pub type Ch3fmR = crate :: BitReader ;
#[doc = "Field `CH3FM` writer - processor 1 Transmit channel 3 free interrupt mask"] pub type Ch3fmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH4FM` reader - processor 1 Transmit channel 4 free interrupt mask"] pub type Ch4fmR = crate :: BitReader ;
#[doc = "Field `CH4FM` writer - processor 1 Transmit channel 4 free interrupt mask"] pub type Ch4fmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH5FM` reader - processor 1 Transmit channel 5 free interrupt mask"] pub type Ch5fmR = crate :: BitReader ;
#[doc = "Field `CH5FM` writer - processor 1 Transmit channel 5 free interrupt mask"] pub type Ch5fmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH6FM` reader - processor 1 Transmit channel 6 free interrupt mask"] pub type Ch6fmR = crate :: BitReader ;
#[doc = "Field `CH6FM` writer - processor 1 Transmit channel 6 free interrupt mask"] pub type Ch6fmW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - processor 1 Receive channel 1 occupied interrupt enable"]
#[inline (always)] pub fn ch1om (& self) -> Ch1omR { Ch1omR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - processor 1 Receive channel 2 occupied interrupt enable"]
#[inline (always)] pub fn ch2om (& self) -> Ch2omR { Ch2omR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - processor 1 Receive channel 3 occupied interrupt enable"]
#[inline (always)] pub fn ch3om (& self) -> Ch3omR { Ch3omR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - processor 1 Receive channel 4 occupied interrupt enable"]
#[inline (always)] pub fn ch4om (& self) -> Ch4omR { Ch4omR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - processor 1 Receive channel 5 occupied interrupt enable"]
#[inline (always)] pub fn ch5om (& self) -> Ch5omR { Ch5omR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - processor 1 Receive channel 6 occupied interrupt enable"]
#[inline (always)] pub fn ch6om (& self) -> Ch6omR { Ch6omR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 16 - processor 1 Transmit channel 1 free interrupt mask"]
#[inline (always)] pub fn ch1fm (& self) -> Ch1fmR { Ch1fmR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - processor 1 Transmit channel 2 free interrupt mask"]
#[inline (always)] pub fn ch2fm (& self) -> Ch2fmR { Ch2fmR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - processor 1 Transmit channel 3 free interrupt mask"]
#[inline (always)] pub fn ch3fm (& self) -> Ch3fmR { Ch3fmR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - processor 1 Transmit channel 4 free interrupt mask"]
#[inline (always)] pub fn ch4fm (& self) -> Ch4fmR { Ch4fmR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - processor 1 Transmit channel 5 free interrupt mask"]
#[inline (always)] pub fn ch5fm (& self) -> Ch5fmR { Ch5fmR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - processor 1 Transmit channel 6 free interrupt mask"]
#[inline (always)] pub fn ch6fm (& self) -> Ch6fmR { Ch6fmR :: new (((self . bits >> 21) & 1) != 0) } } impl W {
#[doc = "Bit 0 - processor 1 Receive channel 1 occupied interrupt enable"]
#[inline (always)] pub fn ch1om (& mut self) -> Ch1omW < '_ , C1mrSpec > { Ch1omW :: new (self , 0) }
#[doc = "Bit 1 - processor 1 Receive channel 2 occupied interrupt enable"]
#[inline (always)] pub fn ch2om (& mut self) -> Ch2omW < '_ , C1mrSpec > { Ch2omW :: new (self , 1) }
#[doc = "Bit 2 - processor 1 Receive channel 3 occupied interrupt enable"]
#[inline (always)] pub fn ch3om (& mut self) -> Ch3omW < '_ , C1mrSpec > { Ch3omW :: new (self , 2) }
#[doc = "Bit 3 - processor 1 Receive channel 4 occupied interrupt enable"]
#[inline (always)] pub fn ch4om (& mut self) -> Ch4omW < '_ , C1mrSpec > { Ch4omW :: new (self , 3) }
#[doc = "Bit 4 - processor 1 Receive channel 5 occupied interrupt enable"]
#[inline (always)] pub fn ch5om (& mut self) -> Ch5omW < '_ , C1mrSpec > { Ch5omW :: new (self , 4) }
#[doc = "Bit 5 - processor 1 Receive channel 6 occupied interrupt enable"]
#[inline (always)] pub fn ch6om (& mut self) -> Ch6omW < '_ , C1mrSpec > { Ch6omW :: new (self , 5) }
#[doc = "Bit 16 - processor 1 Transmit channel 1 free interrupt mask"]
#[inline (always)] pub fn ch1fm (& mut self) -> Ch1fmW < '_ , C1mrSpec > { Ch1fmW :: new (self , 16) }
#[doc = "Bit 17 - processor 1 Transmit channel 2 free interrupt mask"]
#[inline (always)] pub fn ch2fm (& mut self) -> Ch2fmW < '_ , C1mrSpec > { Ch2fmW :: new (self , 17) }
#[doc = "Bit 18 - processor 1 Transmit channel 3 free interrupt mask"]
#[inline (always)] pub fn ch3fm (& mut self) -> Ch3fmW < '_ , C1mrSpec > { Ch3fmW :: new (self , 18) }
#[doc = "Bit 19 - processor 1 Transmit channel 4 free interrupt mask"]
#[inline (always)] pub fn ch4fm (& mut self) -> Ch4fmW < '_ , C1mrSpec > { Ch4fmW :: new (self , 19) }
#[doc = "Bit 20 - processor 1 Transmit channel 5 free interrupt mask"]
#[inline (always)] pub fn ch5fm (& mut self) -> Ch5fmW < '_ , C1mrSpec > { Ch5fmW :: new (self , 20) }
#[doc = "Bit 21 - processor 1 Transmit channel 6 free interrupt mask"]
#[inline (always)] pub fn ch6fm (& mut self) -> Ch6fmW < '_ , C1mrSpec > { Ch6fmW :: new (self , 21) } }
#[doc = "Mask register CPU1\n\nYou can [`read`](crate::Reg::read) this register and get [`c1mr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c1mr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C1mrSpec ; impl crate :: RegisterSpec for C1mrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c1mr::R`](R) reader structure"] impl crate :: Readable for C1mrSpec { }
#[doc = "`write(|w| ..)` method takes [`c1mr::W`](W) writer structure"] impl crate :: Writable for C1mrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C1MR to value 0xffff_ffff"] impl crate :: Resettable for C1mrSpec { const RESET_VALUE : u32 = 0xffff_ffff ; } }
#[doc = "C1SCR (w) register accessor: Status Set or Clear register CPU1\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c1scr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c1scr`] module"]
#[doc (alias = "C1SCR")] pub type C1scr = crate :: Reg < c1scr :: C1scrSpec > ;
#[doc = "Status Set or Clear register CPU1"] pub mod c1scr {
#[doc = "Register `C1SCR` writer"] pub type W = crate :: W < C1scrSpec > ;
#[doc = "Field `CH1C` writer - processor 1 Receive channel 1 status clear"] pub type Ch1cW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH2C` writer - processor 1 Receive channel 2 status clear"] pub type Ch2cW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH3C` writer - processor 1 Receive channel 3 status clear"] pub type Ch3cW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH4C` writer - processor 1 Receive channel 4 status clear"] pub type Ch4cW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH5C` writer - processor 1 Receive channel 5 status clear"] pub type Ch5cW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH6C` writer - processor 1 Receive channel 6 status clear"] pub type Ch6cW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH1S` writer - processor 1 Transmit channel 1 status set"] pub type Ch1sW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH2S` writer - processor 1 Transmit channel 2 status set"] pub type Ch2sW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH3S` writer - processor 1 Transmit channel 3 status set"] pub type Ch3sW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH4S` writer - processor 1 Transmit channel 4 status set"] pub type Ch4sW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH5S` writer - processor 1 Transmit channel 5 status set"] pub type Ch5sW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH6S` writer - processor 1 Transmit channel 6 status set"] pub type Ch6sW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - processor 1 Receive channel 1 status clear"]
#[inline (always)] pub fn ch1c (& mut self) -> Ch1cW < '_ , C1scrSpec > { Ch1cW :: new (self , 0) }
#[doc = "Bit 1 - processor 1 Receive channel 2 status clear"]
#[inline (always)] pub fn ch2c (& mut self) -> Ch2cW < '_ , C1scrSpec > { Ch2cW :: new (self , 1) }
#[doc = "Bit 2 - processor 1 Receive channel 3 status clear"]
#[inline (always)] pub fn ch3c (& mut self) -> Ch3cW < '_ , C1scrSpec > { Ch3cW :: new (self , 2) }
#[doc = "Bit 3 - processor 1 Receive channel 4 status clear"]
#[inline (always)] pub fn ch4c (& mut self) -> Ch4cW < '_ , C1scrSpec > { Ch4cW :: new (self , 3) }
#[doc = "Bit 4 - processor 1 Receive channel 5 status clear"]
#[inline (always)] pub fn ch5c (& mut self) -> Ch5cW < '_ , C1scrSpec > { Ch5cW :: new (self , 4) }
#[doc = "Bit 5 - processor 1 Receive channel 6 status clear"]
#[inline (always)] pub fn ch6c (& mut self) -> Ch6cW < '_ , C1scrSpec > { Ch6cW :: new (self , 5) }
#[doc = "Bit 16 - processor 1 Transmit channel 1 status set"]
#[inline (always)] pub fn ch1s (& mut self) -> Ch1sW < '_ , C1scrSpec > { Ch1sW :: new (self , 16) }
#[doc = "Bit 17 - processor 1 Transmit channel 2 status set"]
#[inline (always)] pub fn ch2s (& mut self) -> Ch2sW < '_ , C1scrSpec > { Ch2sW :: new (self , 17) }
#[doc = "Bit 18 - processor 1 Transmit channel 3 status set"]
#[inline (always)] pub fn ch3s (& mut self) -> Ch3sW < '_ , C1scrSpec > { Ch3sW :: new (self , 18) }
#[doc = "Bit 19 - processor 1 Transmit channel 4 status set"]
#[inline (always)] pub fn ch4s (& mut self) -> Ch4sW < '_ , C1scrSpec > { Ch4sW :: new (self , 19) }
#[doc = "Bit 20 - processor 1 Transmit channel 5 status set"]
#[inline (always)] pub fn ch5s (& mut self) -> Ch5sW < '_ , C1scrSpec > { Ch5sW :: new (self , 20) }
#[doc = "Bit 21 - processor 1 Transmit channel 6 status set"]
#[inline (always)] pub fn ch6s (& mut self) -> Ch6sW < '_ , C1scrSpec > { Ch6sW :: new (self , 21) } }
#[doc = "Status Set or Clear register CPU1\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c1scr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C1scrSpec ; impl crate :: RegisterSpec for C1scrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`c1scr::W`](W) writer structure"] impl crate :: Writable for C1scrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C1SCR to value 0"] impl crate :: Resettable for C1scrSpec { } }
#[doc = "C1TO2SR (r) register accessor: CPU1 to CPU2 status register\n\nYou can [`read`](crate::Reg::read) this register and get [`c1to2sr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c1to2sr`] module"]
#[doc (alias = "C1TO2SR")] pub type C1to2sr = crate :: Reg < c1to2sr :: C1to2srSpec > ;
#[doc = "CPU1 to CPU2 status register"] pub mod c1to2sr {
#[doc = "Register `C1TO2SR` reader"] pub type R = crate :: R < C1to2srSpec > ;
#[doc = "Field `CH1F` reader - processor 1 transmit to process 2 Receive channel 1 status flag"] pub type Ch1fR = crate :: BitReader ;
#[doc = "Field `CH2F` reader - processor 1 transmit to process 2 Receive channel 2 status flag"] pub type Ch2fR = crate :: BitReader ;
#[doc = "Field `CH3F` reader - processor 1 transmit to process 2 Receive channel 3 status flag"] pub type Ch3fR = crate :: BitReader ;
#[doc = "Field `CH4F` reader - processor 1 transmit to process 2 Receive channel 4 status flag"] pub type Ch4fR = crate :: BitReader ;
#[doc = "Field `CH5F` reader - processor 1 transmit to process 2 Receive channel 5 status flag"] pub type Ch5fR = crate :: BitReader ;
#[doc = "Field `CH6F` reader - processor 1 transmit to process 2 Receive channel 6 status flag"] pub type Ch6fR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - processor 1 transmit to process 2 Receive channel 1 status flag"]
#[inline (always)] pub fn ch1f (& self) -> Ch1fR { Ch1fR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - processor 1 transmit to process 2 Receive channel 2 status flag"]
#[inline (always)] pub fn ch2f (& self) -> Ch2fR { Ch2fR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - processor 1 transmit to process 2 Receive channel 3 status flag"]
#[inline (always)] pub fn ch3f (& self) -> Ch3fR { Ch3fR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - processor 1 transmit to process 2 Receive channel 4 status flag"]
#[inline (always)] pub fn ch4f (& self) -> Ch4fR { Ch4fR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - processor 1 transmit to process 2 Receive channel 5 status flag"]
#[inline (always)] pub fn ch5f (& self) -> Ch5fR { Ch5fR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - processor 1 transmit to process 2 Receive channel 6 status flag"]
#[inline (always)] pub fn ch6f (& self) -> Ch6fR { Ch6fR :: new (((self . bits >> 5) & 1) != 0) } }
#[doc = "CPU1 to CPU2 status register\n\nYou can [`read`](crate::Reg::read) this register and get [`c1to2sr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C1to2srSpec ; impl crate :: RegisterSpec for C1to2srSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c1to2sr::R`](R) reader structure"] impl crate :: Readable for C1to2srSpec { }
#[doc = "`reset()` method sets C1TO2SR to value 0"] impl crate :: Resettable for C1to2srSpec { } }
#[doc = "C2CR (rw) register accessor: Control register CPU2\n\nYou can [`read`](crate::Reg::read) this register and get [`c2cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2cr`] module"]
#[doc (alias = "C2CR")] pub type C2cr = crate :: Reg < c2cr :: C2crSpec > ;
#[doc = "Control register CPU2"] pub mod c2cr {
#[doc = "Register `C2CR` reader"] pub type R = crate :: R < C2crSpec > ;
#[doc = "Register `C2CR` writer"] pub type W = crate :: W < C2crSpec > ;
#[doc = "Field `RXOIE` reader - processor 2 Receive channel occupied interrupt enable"] pub type RxoieR = crate :: BitReader ;
#[doc = "Field `RXOIE` writer - processor 2 Receive channel occupied interrupt enable"] pub type RxoieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXFIE` reader - processor 2 Transmit channel free interrupt enable"] pub type TxfieR = crate :: BitReader ;
#[doc = "Field `TXFIE` writer - processor 2 Transmit channel free interrupt enable"] pub type TxfieW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - processor 2 Receive channel occupied interrupt enable"]
#[inline (always)] pub fn rxoie (& self) -> RxoieR { RxoieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 16 - processor 2 Transmit channel free interrupt enable"]
#[inline (always)] pub fn txfie (& self) -> TxfieR { TxfieR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bit 0 - processor 2 Receive channel occupied interrupt enable"]
#[inline (always)] pub fn rxoie (& mut self) -> RxoieW < '_ , C2crSpec > { RxoieW :: new (self , 0) }
#[doc = "Bit 16 - processor 2 Transmit channel free interrupt enable"]
#[inline (always)] pub fn txfie (& mut self) -> TxfieW < '_ , C2crSpec > { TxfieW :: new (self , 16) } }
#[doc = "Control register CPU2\n\nYou can [`read`](crate::Reg::read) this register and get [`c2cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2crSpec ; impl crate :: RegisterSpec for C2crSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2cr::R`](R) reader structure"] impl crate :: Readable for C2crSpec { }
#[doc = "`write(|w| ..)` method takes [`c2cr::W`](W) writer structure"] impl crate :: Writable for C2crSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2CR to value 0"] impl crate :: Resettable for C2crSpec { } }
#[doc = "C2MR (rw) register accessor: Mask register CPU2\n\nYou can [`read`](crate::Reg::read) this register and get [`c2mr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2mr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2mr`] module"]
#[doc (alias = "C2MR")] pub type C2mr = crate :: Reg < c2mr :: C2mrSpec > ;
#[doc = "Mask register CPU2"] pub mod c2mr {
#[doc = "Register `C2MR` reader"] pub type R = crate :: R < C2mrSpec > ;
#[doc = "Register `C2MR` writer"] pub type W = crate :: W < C2mrSpec > ;
#[doc = "Field `CH1OM` reader - processor 2 Receive channel 1 occupied interrupt enable"] pub type Ch1omR = crate :: BitReader ;
#[doc = "Field `CH1OM` writer - processor 2 Receive channel 1 occupied interrupt enable"] pub type Ch1omW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH2OM` reader - processor 2 Receive channel 2 occupied interrupt enable"] pub type Ch2omR = crate :: BitReader ;
#[doc = "Field `CH2OM` writer - processor 2 Receive channel 2 occupied interrupt enable"] pub type Ch2omW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH3OM` reader - processor 2 Receive channel 3 occupied interrupt enable"] pub type Ch3omR = crate :: BitReader ;
#[doc = "Field `CH3OM` writer - processor 2 Receive channel 3 occupied interrupt enable"] pub type Ch3omW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH4OM` reader - processor 2 Receive channel 4 occupied interrupt enable"] pub type Ch4omR = crate :: BitReader ;
#[doc = "Field `CH4OM` writer - processor 2 Receive channel 4 occupied interrupt enable"] pub type Ch4omW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH5OM` reader - processor 2 Receive channel 5 occupied interrupt enable"] pub type Ch5omR = crate :: BitReader ;
#[doc = "Field `CH5OM` writer - processor 2 Receive channel 5 occupied interrupt enable"] pub type Ch5omW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH6OM` reader - processor 2 Receive channel 6 occupied interrupt enable"] pub type Ch6omR = crate :: BitReader ;
#[doc = "Field `CH6OM` writer - processor 2 Receive channel 6 occupied interrupt enable"] pub type Ch6omW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH1FM` reader - processor 2 Transmit channel 1 free interrupt mask"] pub type Ch1fmR = crate :: BitReader ;
#[doc = "Field `CH1FM` writer - processor 2 Transmit channel 1 free interrupt mask"] pub type Ch1fmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH2FM` reader - processor 2 Transmit channel 2 free interrupt mask"] pub type Ch2fmR = crate :: BitReader ;
#[doc = "Field `CH2FM` writer - processor 2 Transmit channel 2 free interrupt mask"] pub type Ch2fmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH3FM` reader - processor 2 Transmit channel 3 free interrupt mask"] pub type Ch3fmR = crate :: BitReader ;
#[doc = "Field `CH3FM` writer - processor 2 Transmit channel 3 free interrupt mask"] pub type Ch3fmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH4FM` reader - processor 2 Transmit channel 4 free interrupt mask"] pub type Ch4fmR = crate :: BitReader ;
#[doc = "Field `CH4FM` writer - processor 2 Transmit channel 4 free interrupt mask"] pub type Ch4fmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH5FM` reader - processor 2 Transmit channel 5 free interrupt mask"] pub type Ch5fmR = crate :: BitReader ;
#[doc = "Field `CH5FM` writer - processor 2 Transmit channel 5 free interrupt mask"] pub type Ch5fmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH6FM` reader - processor 2 Transmit channel 6 free interrupt mask"] pub type Ch6fmR = crate :: BitReader ;
#[doc = "Field `CH6FM` writer - processor 2 Transmit channel 6 free interrupt mask"] pub type Ch6fmW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - processor 2 Receive channel 1 occupied interrupt enable"]
#[inline (always)] pub fn ch1om (& self) -> Ch1omR { Ch1omR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - processor 2 Receive channel 2 occupied interrupt enable"]
#[inline (always)] pub fn ch2om (& self) -> Ch2omR { Ch2omR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - processor 2 Receive channel 3 occupied interrupt enable"]
#[inline (always)] pub fn ch3om (& self) -> Ch3omR { Ch3omR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - processor 2 Receive channel 4 occupied interrupt enable"]
#[inline (always)] pub fn ch4om (& self) -> Ch4omR { Ch4omR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - processor 2 Receive channel 5 occupied interrupt enable"]
#[inline (always)] pub fn ch5om (& self) -> Ch5omR { Ch5omR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - processor 2 Receive channel 6 occupied interrupt enable"]
#[inline (always)] pub fn ch6om (& self) -> Ch6omR { Ch6omR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 16 - processor 2 Transmit channel 1 free interrupt mask"]
#[inline (always)] pub fn ch1fm (& self) -> Ch1fmR { Ch1fmR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - processor 2 Transmit channel 2 free interrupt mask"]
#[inline (always)] pub fn ch2fm (& self) -> Ch2fmR { Ch2fmR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - processor 2 Transmit channel 3 free interrupt mask"]
#[inline (always)] pub fn ch3fm (& self) -> Ch3fmR { Ch3fmR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - processor 2 Transmit channel 4 free interrupt mask"]
#[inline (always)] pub fn ch4fm (& self) -> Ch4fmR { Ch4fmR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - processor 2 Transmit channel 5 free interrupt mask"]
#[inline (always)] pub fn ch5fm (& self) -> Ch5fmR { Ch5fmR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - processor 2 Transmit channel 6 free interrupt mask"]
#[inline (always)] pub fn ch6fm (& self) -> Ch6fmR { Ch6fmR :: new (((self . bits >> 21) & 1) != 0) } } impl W {
#[doc = "Bit 0 - processor 2 Receive channel 1 occupied interrupt enable"]
#[inline (always)] pub fn ch1om (& mut self) -> Ch1omW < '_ , C2mrSpec > { Ch1omW :: new (self , 0) }
#[doc = "Bit 1 - processor 2 Receive channel 2 occupied interrupt enable"]
#[inline (always)] pub fn ch2om (& mut self) -> Ch2omW < '_ , C2mrSpec > { Ch2omW :: new (self , 1) }
#[doc = "Bit 2 - processor 2 Receive channel 3 occupied interrupt enable"]
#[inline (always)] pub fn ch3om (& mut self) -> Ch3omW < '_ , C2mrSpec > { Ch3omW :: new (self , 2) }
#[doc = "Bit 3 - processor 2 Receive channel 4 occupied interrupt enable"]
#[inline (always)] pub fn ch4om (& mut self) -> Ch4omW < '_ , C2mrSpec > { Ch4omW :: new (self , 3) }
#[doc = "Bit 4 - processor 2 Receive channel 5 occupied interrupt enable"]
#[inline (always)] pub fn ch5om (& mut self) -> Ch5omW < '_ , C2mrSpec > { Ch5omW :: new (self , 4) }
#[doc = "Bit 5 - processor 2 Receive channel 6 occupied interrupt enable"]
#[inline (always)] pub fn ch6om (& mut self) -> Ch6omW < '_ , C2mrSpec > { Ch6omW :: new (self , 5) }
#[doc = "Bit 16 - processor 2 Transmit channel 1 free interrupt mask"]
#[inline (always)] pub fn ch1fm (& mut self) -> Ch1fmW < '_ , C2mrSpec > { Ch1fmW :: new (self , 16) }
#[doc = "Bit 17 - processor 2 Transmit channel 2 free interrupt mask"]
#[inline (always)] pub fn ch2fm (& mut self) -> Ch2fmW < '_ , C2mrSpec > { Ch2fmW :: new (self , 17) }
#[doc = "Bit 18 - processor 2 Transmit channel 3 free interrupt mask"]
#[inline (always)] pub fn ch3fm (& mut self) -> Ch3fmW < '_ , C2mrSpec > { Ch3fmW :: new (self , 18) }
#[doc = "Bit 19 - processor 2 Transmit channel 4 free interrupt mask"]
#[inline (always)] pub fn ch4fm (& mut self) -> Ch4fmW < '_ , C2mrSpec > { Ch4fmW :: new (self , 19) }
#[doc = "Bit 20 - processor 2 Transmit channel 5 free interrupt mask"]
#[inline (always)] pub fn ch5fm (& mut self) -> Ch5fmW < '_ , C2mrSpec > { Ch5fmW :: new (self , 20) }
#[doc = "Bit 21 - processor 2 Transmit channel 6 free interrupt mask"]
#[inline (always)] pub fn ch6fm (& mut self) -> Ch6fmW < '_ , C2mrSpec > { Ch6fmW :: new (self , 21) } }
#[doc = "Mask register CPU2\n\nYou can [`read`](crate::Reg::read) this register and get [`c2mr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2mr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2mrSpec ; impl crate :: RegisterSpec for C2mrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2mr::R`](R) reader structure"] impl crate :: Readable for C2mrSpec { }
#[doc = "`write(|w| ..)` method takes [`c2mr::W`](W) writer structure"] impl crate :: Writable for C2mrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2MR to value 0xffff_ffff"] impl crate :: Resettable for C2mrSpec { const RESET_VALUE : u32 = 0xffff_ffff ; } }
#[doc = "C2SCR (w) register accessor: Status Set or Clear register CPU2\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2scr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2scr`] module"]
#[doc (alias = "C2SCR")] pub type C2scr = crate :: Reg < c2scr :: C2scrSpec > ;
#[doc = "Status Set or Clear register CPU2"] pub mod c2scr {
#[doc = "Register `C2SCR` writer"] pub type W = crate :: W < C2scrSpec > ;
#[doc = "Field `CH1C` writer - processor 2 Receive channel 1 status clear"] pub type Ch1cW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH2C` writer - processor 2 Receive channel 2 status clear"] pub type Ch2cW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH3C` writer - processor 2 Receive channel 3 status clear"] pub type Ch3cW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH4C` writer - processor 2 Receive channel 4 status clear"] pub type Ch4cW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH5C` writer - processor 2 Receive channel 5 status clear"] pub type Ch5cW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH6C` writer - processor 2 Receive channel 6 status clear"] pub type Ch6cW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH1S` writer - processor 2 Transmit channel 1 status set"] pub type Ch1sW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH2S` writer - processor 2 Transmit channel 2 status set"] pub type Ch2sW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH3S` writer - processor 2 Transmit channel 3 status set"] pub type Ch3sW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH4S` writer - processor 2 Transmit channel 4 status set"] pub type Ch4sW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH5S` writer - processor 2 Transmit channel 5 status set"] pub type Ch5sW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH6S` writer - processor 2 Transmit channel 6 status set"] pub type Ch6sW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - processor 2 Receive channel 1 status clear"]
#[inline (always)] pub fn ch1c (& mut self) -> Ch1cW < '_ , C2scrSpec > { Ch1cW :: new (self , 0) }
#[doc = "Bit 1 - processor 2 Receive channel 2 status clear"]
#[inline (always)] pub fn ch2c (& mut self) -> Ch2cW < '_ , C2scrSpec > { Ch2cW :: new (self , 1) }
#[doc = "Bit 2 - processor 2 Receive channel 3 status clear"]
#[inline (always)] pub fn ch3c (& mut self) -> Ch3cW < '_ , C2scrSpec > { Ch3cW :: new (self , 2) }
#[doc = "Bit 3 - processor 2 Receive channel 4 status clear"]
#[inline (always)] pub fn ch4c (& mut self) -> Ch4cW < '_ , C2scrSpec > { Ch4cW :: new (self , 3) }
#[doc = "Bit 4 - processor 2 Receive channel 5 status clear"]
#[inline (always)] pub fn ch5c (& mut self) -> Ch5cW < '_ , C2scrSpec > { Ch5cW :: new (self , 4) }
#[doc = "Bit 5 - processor 2 Receive channel 6 status clear"]
#[inline (always)] pub fn ch6c (& mut self) -> Ch6cW < '_ , C2scrSpec > { Ch6cW :: new (self , 5) }
#[doc = "Bit 16 - processor 2 Transmit channel 1 status set"]
#[inline (always)] pub fn ch1s (& mut self) -> Ch1sW < '_ , C2scrSpec > { Ch1sW :: new (self , 16) }
#[doc = "Bit 17 - processor 2 Transmit channel 2 status set"]
#[inline (always)] pub fn ch2s (& mut self) -> Ch2sW < '_ , C2scrSpec > { Ch2sW :: new (self , 17) }
#[doc = "Bit 18 - processor 2 Transmit channel 3 status set"]
#[inline (always)] pub fn ch3s (& mut self) -> Ch3sW < '_ , C2scrSpec > { Ch3sW :: new (self , 18) }
#[doc = "Bit 19 - processor 2 Transmit channel 4 status set"]
#[inline (always)] pub fn ch4s (& mut self) -> Ch4sW < '_ , C2scrSpec > { Ch4sW :: new (self , 19) }
#[doc = "Bit 20 - processor 2 Transmit channel 5 status set"]
#[inline (always)] pub fn ch5s (& mut self) -> Ch5sW < '_ , C2scrSpec > { Ch5sW :: new (self , 20) }
#[doc = "Bit 21 - processor 2 Transmit channel 6 status set"]
#[inline (always)] pub fn ch6s (& mut self) -> Ch6sW < '_ , C2scrSpec > { Ch6sW :: new (self , 21) } }
#[doc = "Status Set or Clear register CPU2\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2scr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2scrSpec ; impl crate :: RegisterSpec for C2scrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`c2scr::W`](W) writer structure"] impl crate :: Writable for C2scrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2SCR to value 0"] impl crate :: Resettable for C2scrSpec { } }
#[doc = "C2TOC1SR (r) register accessor: CPU2 to CPU1 status register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2toc1sr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2toc1sr`] module"]
#[doc (alias = "C2TOC1SR")] pub type C2toc1sr = crate :: Reg < c2toc1sr :: C2toc1srSpec > ;
#[doc = "CPU2 to CPU1 status register"] pub mod c2toc1sr {
#[doc = "Register `C2TOC1SR` reader"] pub type R = crate :: R < C2toc1srSpec > ;
#[doc = "Field `CH1F` reader - processor 2 transmit to process 1 Receive channel 1 status flag"] pub type Ch1fR = crate :: BitReader ;
#[doc = "Field `CH2F` reader - processor 2 transmit to process 1 Receive channel 2 status flag"] pub type Ch2fR = crate :: BitReader ;
#[doc = "Field `CH3F` reader - processor 2 transmit to process 1 Receive channel 3 status flag"] pub type Ch3fR = crate :: BitReader ;
#[doc = "Field `CH4F` reader - processor 2 transmit to process 1 Receive channel 4 status flag"] pub type Ch4fR = crate :: BitReader ;
#[doc = "Field `CH5F` reader - processor 2 transmit to process 1 Receive channel 5 status flag"] pub type Ch5fR = crate :: BitReader ;
#[doc = "Field `CH6F` reader - processor 2 transmit to process 1 Receive channel 6 status flag"] pub type Ch6fR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - processor 2 transmit to process 1 Receive channel 1 status flag"]
#[inline (always)] pub fn ch1f (& self) -> Ch1fR { Ch1fR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - processor 2 transmit to process 1 Receive channel 2 status flag"]
#[inline (always)] pub fn ch2f (& self) -> Ch2fR { Ch2fR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - processor 2 transmit to process 1 Receive channel 3 status flag"]
#[inline (always)] pub fn ch3f (& self) -> Ch3fR { Ch3fR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - processor 2 transmit to process 1 Receive channel 4 status flag"]
#[inline (always)] pub fn ch4f (& self) -> Ch4fR { Ch4fR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - processor 2 transmit to process 1 Receive channel 5 status flag"]
#[inline (always)] pub fn ch5f (& self) -> Ch5fR { Ch5fR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - processor 2 transmit to process 1 Receive channel 6 status flag"]
#[inline (always)] pub fn ch6f (& self) -> Ch6fR { Ch6fR :: new (((self . bits >> 5) & 1) != 0) } }
#[doc = "CPU2 to CPU1 status register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2toc1sr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2toc1srSpec ; impl crate :: RegisterSpec for C2toc1srSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2toc1sr::R`](R) reader structure"] impl crate :: Readable for C2toc1srSpec { }
#[doc = "`reset()` method sets C2TOC1SR to value 0"] impl crate :: Resettable for C2toc1srSpec { } }
#[doc = "HWCFGR (r) register accessor: IPCC Hardware configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`hwcfgr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hwcfgr`] module"]
#[doc (alias = "HWCFGR")] pub type Hwcfgr = crate :: Reg < hwcfgr :: HwcfgrSpec > ;
#[doc = "IPCC Hardware configuration register"] pub mod hwcfgr {
#[doc = "Register `HWCFGR` reader"] pub type R = crate :: R < HwcfgrSpec > ;
#[doc = "Field `CHANNELS` reader - Number of channels per CPU supported by the IP, range 1 to 16"] pub type ChannelsR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - Number of channels per CPU supported by the IP, range 1 to 16"]
#[inline (always)] pub fn channels (& self) -> ChannelsR { ChannelsR :: new ((self . bits & 0xff) as u8) } }
#[doc = "IPCC Hardware configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`hwcfgr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct HwcfgrSpec ; impl crate :: RegisterSpec for HwcfgrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`hwcfgr::R`](R) reader structure"] impl crate :: Readable for HwcfgrSpec { }
#[doc = "`reset()` method sets HWCFGR to value 0x06"] impl crate :: Resettable for HwcfgrSpec { const RESET_VALUE : u32 = 0x06 ; } }
#[doc = "VERR (r) register accessor: IPCC version register\n\nYou can [`read`](crate::Reg::read) this register and get [`verr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@verr`] module"]
#[doc (alias = "VERR")] pub type Verr = crate :: Reg < verr :: VerrSpec > ;
#[doc = "IPCC version register"] pub mod verr {
#[doc = "Register `VERR` reader"] pub type R = crate :: R < VerrSpec > ;
#[doc = "Field `MINREV` reader - Minor Revision"] pub type MinrevR = crate :: FieldReader ;
#[doc = "Field `MAJREV` reader - Major Revision"] pub type MajrevR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:3 - Minor Revision"]
#[inline (always)] pub fn minrev (& self) -> MinrevR { MinrevR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - Major Revision"]
#[inline (always)] pub fn majrev (& self) -> MajrevR { MajrevR :: new (((self . bits >> 4) & 0x0f) as u8) } }
#[doc = "IPCC version register\n\nYou can [`read`](crate::Reg::read) this register and get [`verr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct VerrSpec ; impl crate :: RegisterSpec for VerrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`verr::R`](R) reader structure"] impl crate :: Readable for VerrSpec { }
#[doc = "`reset()` method sets VERR to value 0x10"] impl crate :: Resettable for VerrSpec { const RESET_VALUE : u32 = 0x10 ; } }
#[doc = "IPIDR (r) register accessor: IPCC indentification register\n\nYou can [`read`](crate::Reg::read) this register and get [`ipidr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ipidr`] module"]
#[doc (alias = "IPIDR")] pub type Ipidr = crate :: Reg < ipidr :: IpidrSpec > ;
#[doc = "IPCC indentification register"] pub mod ipidr {
#[doc = "Register `IPIDR` reader"] pub type R = crate :: R < IpidrSpec > ;
#[doc = "Field `IPID` reader - Identification Code"] pub type IpidR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Identification Code"]
#[inline (always)] pub fn ipid (& self) -> IpidR { IpidR :: new (self . bits) } }
#[doc = "IPCC indentification register\n\nYou can [`read`](crate::Reg::read) this register and get [`ipidr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IpidrSpec ; impl crate :: RegisterSpec for IpidrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ipidr::R`](R) reader structure"] impl crate :: Readable for IpidrSpec { }
#[doc = "`reset()` method sets IPIDR to value 0x0010_0071"] impl crate :: Resettable for IpidrSpec { const RESET_VALUE : u32 = 0x0010_0071 ; } }
#[doc = "SIDR (r) register accessor: IPCC size indentification register\n\nYou can [`read`](crate::Reg::read) this register and get [`sidr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sidr`] module"]
#[doc (alias = "SIDR")] pub type Sidr = crate :: Reg < sidr :: SidrSpec > ;
#[doc = "IPCC size indentification register"] pub mod sidr {
#[doc = "Register `SIDR` reader"] pub type R = crate :: R < SidrSpec > ;
#[doc = "Field `SID` reader - Size Identification Code"] pub type SidR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Size Identification Code"]
#[inline (always)] pub fn sid (& self) -> SidR { SidR :: new (self . bits) } }
#[doc = "IPCC size indentification register\n\nYou can [`read`](crate::Reg::read) this register and get [`sidr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SidrSpec ; impl crate :: RegisterSpec for SidrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sidr::R`](R) reader structure"] impl crate :: Readable for SidrSpec { }
#[doc = "`reset()` method sets SIDR to value 0xa3c5_dd01"] impl crate :: Resettable for SidrSpec { const RESET_VALUE : u32 = 0xa3c5_dd01 ; } } }
#[doc = "External interrupt/event controller"] pub type Exti = crate :: Periph < exti :: RegisterBlock , 0x5800_0800 > ; impl core :: fmt :: Debug for Exti { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Exti") . finish () } }
#[doc = "External interrupt/event controller"] pub mod exti {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { rtsr1 : Rtsr1 , ftsr1 : Ftsr1 , swier1 : Swier1 , pr1 : Pr1 , _reserved4 : [u8 ; 0x10] , rtsr2 : Rtsr2 , ftsr2 : Ftsr2 , swier2 : Swier2 , pr2 : Pr2 , _reserved8 : [u8 ; 0x50] , c1imr1 : C1imr1 , c1emr1 : C1emr1 , _reserved10 : [u8 ; 0x08] , c1imr2 : C1imr2 , c1emr2 : C1emr2 , _reserved12 : [u8 ; 0x28] , c2imr1 : C2imr1 , c2emr1 : C2emr1 , _reserved14 : [u8 ; 0x08] , c2imr2 : C2imr2 , c2emr2 : C2emr2 , _reserved16 : [u8 ; 0x0300] , hwcfgr7 : Hwcfgr7 , hwcfgr6 : Hwcfgr6 , hwcfgr5 : Hwcfgr5 , hwcfgr4 : Hwcfgr4 , hwcfgr3 : Hwcfgr3 , hwcfgr2 : Hwcfgr2 , hwcfgr1 : Hwcfgr1 , verr : Verr , ipidr : Ipidr , sidr : Sidr , } impl RegisterBlock {
#[doc = "0x00 - rising trigger selection register"]
#[inline (always)] pub const fn rtsr1 (& self) -> & Rtsr1 { & self . rtsr1 }
#[doc = "0x04 - falling trigger selection register"]
#[inline (always)] pub const fn ftsr1 (& self) -> & Ftsr1 { & self . ftsr1 }
#[doc = "0x08 - software interrupt event register"]
#[inline (always)] pub const fn swier1 (& self) -> & Swier1 { & self . swier1 }
#[doc = "0x0c - EXTI pending register"]
#[inline (always)] pub const fn pr1 (& self) -> & Pr1 { & self . pr1 }
#[doc = "0x20 - rising trigger selection register"]
#[inline (always)] pub const fn rtsr2 (& self) -> & Rtsr2 { & self . rtsr2 }
#[doc = "0x24 - falling trigger selection register"]
#[inline (always)] pub const fn ftsr2 (& self) -> & Ftsr2 { & self . ftsr2 }
#[doc = "0x28 - software interrupt event register"]
#[inline (always)] pub const fn swier2 (& self) -> & Swier2 { & self . swier2 }
#[doc = "0x2c - pending register"]
#[inline (always)] pub const fn pr2 (& self) -> & Pr2 { & self . pr2 }
#[doc = "0x80 - CPUm wakeup with interrupt mask register"]
#[inline (always)] pub const fn c1imr1 (& self) -> & C1imr1 { & self . c1imr1 }
#[doc = "0x84 - CPUm wakeup with event mask register"]
#[inline (always)] pub const fn c1emr1 (& self) -> & C1emr1 { & self . c1emr1 }
#[doc = "0x90 - CPUm wakeup with interrupt mask register"]
#[inline (always)] pub const fn c1imr2 (& self) -> & C1imr2 { & self . c1imr2 }
#[doc = "0x94 - CPUm wakeup with event mask register"]
#[inline (always)] pub const fn c1emr2 (& self) -> & C1emr2 { & self . c1emr2 }
#[doc = "0xc0 - CPUm wakeup with interrupt mask register"]
#[inline (always)] pub const fn c2imr1 (& self) -> & C2imr1 { & self . c2imr1 }
#[doc = "0xc4 - CPUm wakeup with event mask register"]
#[inline (always)] pub const fn c2emr1 (& self) -> & C2emr1 { & self . c2emr1 }
#[doc = "0xd0 - CPUm wakeup with interrupt mask register"]
#[inline (always)] pub const fn c2imr2 (& self) -> & C2imr2 { & self . c2imr2 }
#[doc = "0xd4 - CPUm wakeup with event mask register"]
#[inline (always)] pub const fn c2emr2 (& self) -> & C2emr2 { & self . c2emr2 }
#[doc = "0x3d8 - EXTI Hardware configuration registers"]
#[inline (always)] pub const fn hwcfgr7 (& self) -> & Hwcfgr7 { & self . hwcfgr7 }
#[doc = "0x3dc - Hardware configuration registers"]
#[inline (always)] pub const fn hwcfgr6 (& self) -> & Hwcfgr6 { & self . hwcfgr6 }
#[doc = "0x3e0 - Hardware configuration registers"]
#[inline (always)] pub const fn hwcfgr5 (& self) -> & Hwcfgr5 { & self . hwcfgr5 }
#[doc = "0x3e4 - Hardware configuration registers"]
#[inline (always)] pub const fn hwcfgr4 (& self) -> & Hwcfgr4 { & self . hwcfgr4 }
#[doc = "0x3e8 - Hardware configuration registers"]
#[inline (always)] pub const fn hwcfgr3 (& self) -> & Hwcfgr3 { & self . hwcfgr3 }
#[doc = "0x3ec - Hardware configuration registers"]
#[inline (always)] pub const fn hwcfgr2 (& self) -> & Hwcfgr2 { & self . hwcfgr2 }
#[doc = "0x3f0 - Hardware configuration register 1"]
#[inline (always)] pub const fn hwcfgr1 (& self) -> & Hwcfgr1 { & self . hwcfgr1 }
#[doc = "0x3f4 - EXTI IP Version register"]
#[inline (always)] pub const fn verr (& self) -> & Verr { & self . verr }
#[doc = "0x3f8 - Identification register"]
#[inline (always)] pub const fn ipidr (& self) -> & Ipidr { & self . ipidr }
#[doc = "0x3fc - Size ID register"]
#[inline (always)] pub const fn sidr (& self) -> & Sidr { & self . sidr } }
#[doc = "RTSR1 (rw) register accessor: rising trigger selection register\n\nYou can [`read`](crate::Reg::read) this register and get [`rtsr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtsr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rtsr1`] module"]
#[doc (alias = "RTSR1")] pub type Rtsr1 = crate :: Reg < rtsr1 :: Rtsr1Spec > ;
#[doc = "rising trigger selection register"] pub mod rtsr1 {
#[doc = "Register `RTSR1` reader"] pub type R = crate :: R < Rtsr1Spec > ;
#[doc = "Register `RTSR1` writer"] pub type W = crate :: W < Rtsr1Spec > ;
#[doc = "Field `RT` reader - Rising trigger event configuration bit of Configurable Event input"] pub type RtR = crate :: FieldReader < u32 > ;
#[doc = "Field `RT` writer - Rising trigger event configuration bit of Configurable Event input"] pub type RtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 22 , u32 > ;
#[doc = "Field `RT_31` reader - Rising trigger event configuration bit of Configurable Event input"] pub type Rt31R = crate :: BitReader ;
#[doc = "Field `RT_31` writer - Rising trigger event configuration bit of Configurable Event input"] pub type Rt31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:21 - Rising trigger event configuration bit of Configurable Event input"]
#[inline (always)] pub fn rt (& self) -> RtR { RtR :: new (self . bits & 0x003f_ffff) }
#[doc = "Bit 31 - Rising trigger event configuration bit of Configurable Event input"]
#[inline (always)] pub fn rt_31 (& self) -> Rt31R { Rt31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:21 - Rising trigger event configuration bit of Configurable Event input"]
#[inline (always)] pub fn rt (& mut self) -> RtW < '_ , Rtsr1Spec > { RtW :: new (self , 0) }
#[doc = "Bit 31 - Rising trigger event configuration bit of Configurable Event input"]
#[inline (always)] pub fn rt_31 (& mut self) -> Rt31W < '_ , Rtsr1Spec > { Rt31W :: new (self , 31) } }
#[doc = "rising trigger selection register\n\nYou can [`read`](crate::Reg::read) this register and get [`rtsr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtsr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rtsr1Spec ; impl crate :: RegisterSpec for Rtsr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rtsr1::R`](R) reader structure"] impl crate :: Readable for Rtsr1Spec { }
#[doc = "`write(|w| ..)` method takes [`rtsr1::W`](W) writer structure"] impl crate :: Writable for Rtsr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RTSR1 to value 0"] impl crate :: Resettable for Rtsr1Spec { } }
#[doc = "FTSR1 (rw) register accessor: falling trigger selection register\n\nYou can [`read`](crate::Reg::read) this register and get [`ftsr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ftsr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ftsr1`] module"]
#[doc (alias = "FTSR1")] pub type Ftsr1 = crate :: Reg < ftsr1 :: Ftsr1Spec > ;
#[doc = "falling trigger selection register"] pub mod ftsr1 {
#[doc = "Register `FTSR1` reader"] pub type R = crate :: R < Ftsr1Spec > ;
#[doc = "Register `FTSR1` writer"] pub type W = crate :: W < Ftsr1Spec > ;
#[doc = "Field `FT` reader - Falling trigger event configuration bit of Configurable Event input"] pub type FtR = crate :: FieldReader < u32 > ;
#[doc = "Field `FT` writer - Falling trigger event configuration bit of Configurable Event input"] pub type FtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 22 , u32 > ;
#[doc = "Field `FT_31` reader - Falling trigger event configuration bit of Configurable Event input"] pub type Ft31R = crate :: BitReader ;
#[doc = "Field `FT_31` writer - Falling trigger event configuration bit of Configurable Event input"] pub type Ft31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:21 - Falling trigger event configuration bit of Configurable Event input"]
#[inline (always)] pub fn ft (& self) -> FtR { FtR :: new (self . bits & 0x003f_ffff) }
#[doc = "Bit 31 - Falling trigger event configuration bit of Configurable Event input"]
#[inline (always)] pub fn ft_31 (& self) -> Ft31R { Ft31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:21 - Falling trigger event configuration bit of Configurable Event input"]
#[inline (always)] pub fn ft (& mut self) -> FtW < '_ , Ftsr1Spec > { FtW :: new (self , 0) }
#[doc = "Bit 31 - Falling trigger event configuration bit of Configurable Event input"]
#[inline (always)] pub fn ft_31 (& mut self) -> Ft31W < '_ , Ftsr1Spec > { Ft31W :: new (self , 31) } }
#[doc = "falling trigger selection register\n\nYou can [`read`](crate::Reg::read) this register and get [`ftsr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ftsr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ftsr1Spec ; impl crate :: RegisterSpec for Ftsr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ftsr1::R`](R) reader structure"] impl crate :: Readable for Ftsr1Spec { }
#[doc = "`write(|w| ..)` method takes [`ftsr1::W`](W) writer structure"] impl crate :: Writable for Ftsr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FTSR1 to value 0"] impl crate :: Resettable for Ftsr1Spec { } }
#[doc = "SWIER1 (rw) register accessor: software interrupt event register\n\nYou can [`read`](crate::Reg::read) this register and get [`swier1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`swier1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@swier1`] module"]
#[doc (alias = "SWIER1")] pub type Swier1 = crate :: Reg < swier1 :: Swier1Spec > ;
#[doc = "software interrupt event register"] pub mod swier1 {
#[doc = "Register `SWIER1` reader"] pub type R = crate :: R < Swier1Spec > ;
#[doc = "Register `SWIER1` writer"] pub type W = crate :: W < Swier1Spec > ;
#[doc = "Field `SWI` reader - Software interrupt on event"] pub type SwiR = crate :: FieldReader < u32 > ;
#[doc = "Field `SWI` writer - Software interrupt on event"] pub type SwiW < 'a , REG > = crate :: FieldWriter < 'a , REG , 22 , u32 > ;
#[doc = "Field `SWI_31` reader - Software interrupt on event"] pub type Swi31R = crate :: BitReader ;
#[doc = "Field `SWI_31` writer - Software interrupt on event"] pub type Swi31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:21 - Software interrupt on event"]
#[inline (always)] pub fn swi (& self) -> SwiR { SwiR :: new (self . bits & 0x003f_ffff) }
#[doc = "Bit 31 - Software interrupt on event"]
#[inline (always)] pub fn swi_31 (& self) -> Swi31R { Swi31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:21 - Software interrupt on event"]
#[inline (always)] pub fn swi (& mut self) -> SwiW < '_ , Swier1Spec > { SwiW :: new (self , 0) }
#[doc = "Bit 31 - Software interrupt on event"]
#[inline (always)] pub fn swi_31 (& mut self) -> Swi31W < '_ , Swier1Spec > { Swi31W :: new (self , 31) } }
#[doc = "software interrupt event register\n\nYou can [`read`](crate::Reg::read) this register and get [`swier1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`swier1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Swier1Spec ; impl crate :: RegisterSpec for Swier1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`swier1::R`](R) reader structure"] impl crate :: Readable for Swier1Spec { }
#[doc = "`write(|w| ..)` method takes [`swier1::W`](W) writer structure"] impl crate :: Writable for Swier1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SWIER1 to value 0"] impl crate :: Resettable for Swier1Spec { } }
#[doc = "PR1 (rw) register accessor: EXTI pending register\n\nYou can [`read`](crate::Reg::read) this register and get [`pr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pr1`] module"]
#[doc (alias = "PR1")] pub type Pr1 = crate :: Reg < pr1 :: Pr1Spec > ;
#[doc = "EXTI pending register"] pub mod pr1 {
#[doc = "Register `PR1` reader"] pub type R = crate :: R < Pr1Spec > ;
#[doc = "Register `PR1` writer"] pub type W = crate :: W < Pr1Spec > ;
#[doc = "Field `PIF` reader - Configurable event inputs Pending bit"] pub type PifR = crate :: FieldReader < u32 > ;
#[doc = "Field `PIF` writer - Configurable event inputs Pending bit"] pub type PifW < 'a , REG > = crate :: FieldWriter < 'a , REG , 22 , u32 > ;
#[doc = "Field `PIF_31` reader - Configurable event inputs Pending bit"] pub type Pif31R = crate :: BitReader ;
#[doc = "Field `PIF_31` writer - Configurable event inputs Pending bit"] pub type Pif31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:21 - Configurable event inputs Pending bit"]
#[inline (always)] pub fn pif (& self) -> PifR { PifR :: new (self . bits & 0x003f_ffff) }
#[doc = "Bit 31 - Configurable event inputs Pending bit"]
#[inline (always)] pub fn pif_31 (& self) -> Pif31R { Pif31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:21 - Configurable event inputs Pending bit"]
#[inline (always)] pub fn pif (& mut self) -> PifW < '_ , Pr1Spec > { PifW :: new (self , 0) }
#[doc = "Bit 31 - Configurable event inputs Pending bit"]
#[inline (always)] pub fn pif_31 (& mut self) -> Pif31W < '_ , Pr1Spec > { Pif31W :: new (self , 31) } }
#[doc = "EXTI pending register\n\nYou can [`read`](crate::Reg::read) this register and get [`pr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Pr1Spec ; impl crate :: RegisterSpec for Pr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pr1::R`](R) reader structure"] impl crate :: Readable for Pr1Spec { }
#[doc = "`write(|w| ..)` method takes [`pr1::W`](W) writer structure"] impl crate :: Writable for Pr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PR1 to value 0"] impl crate :: Resettable for Pr1Spec { } }
#[doc = "RTSR2 (rw) register accessor: rising trigger selection register\n\nYou can [`read`](crate::Reg::read) this register and get [`rtsr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtsr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rtsr2`] module"]
#[doc (alias = "RTSR2")] pub type Rtsr2 = crate :: Reg < rtsr2 :: Rtsr2Spec > ;
#[doc = "rising trigger selection register"] pub mod rtsr2 {
#[doc = "Register `RTSR2` reader"] pub type R = crate :: R < Rtsr2Spec > ;
#[doc = "Register `RTSR2` writer"] pub type W = crate :: W < Rtsr2Spec > ;
#[doc = "Field `RT33` reader - Rising trigger event configuration bit of Configurable Event input"] pub type Rt33R = crate :: BitReader ;
#[doc = "Field `RT33` writer - Rising trigger event configuration bit of Configurable Event input"] pub type Rt33W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RT40_41` reader - Rising trigger event configuration bit of Configurable Event input"] pub type Rt40_41R = crate :: FieldReader ;
#[doc = "Field `RT40_41` writer - Rising trigger event configuration bit of Configurable Event input"] pub type Rt40_41W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bit 1 - Rising trigger event configuration bit of Configurable Event input"]
#[inline (always)] pub fn rt33 (& self) -> Rt33R { Rt33R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bits 8:9 - Rising trigger event configuration bit of Configurable Event input"]
#[inline (always)] pub fn rt40_41 (& self) -> Rt40_41R { Rt40_41R :: new (((self . bits >> 8) & 3) as u8) } } impl W {
#[doc = "Bit 1 - Rising trigger event configuration bit of Configurable Event input"]
#[inline (always)] pub fn rt33 (& mut self) -> Rt33W < '_ , Rtsr2Spec > { Rt33W :: new (self , 1) }
#[doc = "Bits 8:9 - Rising trigger event configuration bit of Configurable Event input"]
#[inline (always)] pub fn rt40_41 (& mut self) -> Rt40_41W < '_ , Rtsr2Spec > { Rt40_41W :: new (self , 8) } }
#[doc = "rising trigger selection register\n\nYou can [`read`](crate::Reg::read) this register and get [`rtsr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtsr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Rtsr2Spec ; impl crate :: RegisterSpec for Rtsr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rtsr2::R`](R) reader structure"] impl crate :: Readable for Rtsr2Spec { }
#[doc = "`write(|w| ..)` method takes [`rtsr2::W`](W) writer structure"] impl crate :: Writable for Rtsr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RTSR2 to value 0"] impl crate :: Resettable for Rtsr2Spec { } }
#[doc = "FTSR2 (rw) register accessor: falling trigger selection register\n\nYou can [`read`](crate::Reg::read) this register and get [`ftsr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ftsr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ftsr2`] module"]
#[doc (alias = "FTSR2")] pub type Ftsr2 = crate :: Reg < ftsr2 :: Ftsr2Spec > ;
#[doc = "falling trigger selection register"] pub mod ftsr2 {
#[doc = "Register `FTSR2` reader"] pub type R = crate :: R < Ftsr2Spec > ;
#[doc = "Register `FTSR2` writer"] pub type W = crate :: W < Ftsr2Spec > ;
#[doc = "Field `FT33` reader - Falling trigger event configuration bit of Configurable Event input"] pub type Ft33R = crate :: BitReader ;
#[doc = "Field `FT33` writer - Falling trigger event configuration bit of Configurable Event input"] pub type Ft33W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FT40_41` reader - Falling trigger event configuration bit of Configurable Event input"] pub type Ft40_41R = crate :: FieldReader ;
#[doc = "Field `FT40_41` writer - Falling trigger event configuration bit of Configurable Event input"] pub type Ft40_41W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bit 1 - Falling trigger event configuration bit of Configurable Event input"]
#[inline (always)] pub fn ft33 (& self) -> Ft33R { Ft33R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bits 8:9 - Falling trigger event configuration bit of Configurable Event input"]
#[inline (always)] pub fn ft40_41 (& self) -> Ft40_41R { Ft40_41R :: new (((self . bits >> 8) & 3) as u8) } } impl W {
#[doc = "Bit 1 - Falling trigger event configuration bit of Configurable Event input"]
#[inline (always)] pub fn ft33 (& mut self) -> Ft33W < '_ , Ftsr2Spec > { Ft33W :: new (self , 1) }
#[doc = "Bits 8:9 - Falling trigger event configuration bit of Configurable Event input"]
#[inline (always)] pub fn ft40_41 (& mut self) -> Ft40_41W < '_ , Ftsr2Spec > { Ft40_41W :: new (self , 8) } }
#[doc = "falling trigger selection register\n\nYou can [`read`](crate::Reg::read) this register and get [`ftsr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ftsr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ftsr2Spec ; impl crate :: RegisterSpec for Ftsr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ftsr2::R`](R) reader structure"] impl crate :: Readable for Ftsr2Spec { }
#[doc = "`write(|w| ..)` method takes [`ftsr2::W`](W) writer structure"] impl crate :: Writable for Ftsr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FTSR2 to value 0"] impl crate :: Resettable for Ftsr2Spec { } }
#[doc = "SWIER2 (rw) register accessor: software interrupt event register\n\nYou can [`read`](crate::Reg::read) this register and get [`swier2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`swier2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@swier2`] module"]
#[doc (alias = "SWIER2")] pub type Swier2 = crate :: Reg < swier2 :: Swier2Spec > ;
#[doc = "software interrupt event register"] pub mod swier2 {
#[doc = "Register `SWIER2` reader"] pub type R = crate :: R < Swier2Spec > ;
#[doc = "Register `SWIER2` writer"] pub type W = crate :: W < Swier2Spec > ;
#[doc = "Field `SWI33` reader - Software interrupt on event"] pub type Swi33R = crate :: BitReader ;
#[doc = "Field `SWI33` writer - Software interrupt on event"] pub type Swi33W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWI40_41` reader - Software interrupt on event"] pub type Swi40_41R = crate :: FieldReader ;
#[doc = "Field `SWI40_41` writer - Software interrupt on event"] pub type Swi40_41W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bit 1 - Software interrupt on event"]
#[inline (always)] pub fn swi33 (& self) -> Swi33R { Swi33R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bits 8:9 - Software interrupt on event"]
#[inline (always)] pub fn swi40_41 (& self) -> Swi40_41R { Swi40_41R :: new (((self . bits >> 8) & 3) as u8) } } impl W {
#[doc = "Bit 1 - Software interrupt on event"]
#[inline (always)] pub fn swi33 (& mut self) -> Swi33W < '_ , Swier2Spec > { Swi33W :: new (self , 1) }
#[doc = "Bits 8:9 - Software interrupt on event"]
#[inline (always)] pub fn swi40_41 (& mut self) -> Swi40_41W < '_ , Swier2Spec > { Swi40_41W :: new (self , 8) } }
#[doc = "software interrupt event register\n\nYou can [`read`](crate::Reg::read) this register and get [`swier2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`swier2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Swier2Spec ; impl crate :: RegisterSpec for Swier2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`swier2::R`](R) reader structure"] impl crate :: Readable for Swier2Spec { }
#[doc = "`write(|w| ..)` method takes [`swier2::W`](W) writer structure"] impl crate :: Writable for Swier2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SWIER2 to value 0"] impl crate :: Resettable for Swier2Spec { } }
#[doc = "PR2 (rw) register accessor: pending register\n\nYou can [`read`](crate::Reg::read) this register and get [`pr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pr2`] module"]
#[doc (alias = "PR2")] pub type Pr2 = crate :: Reg < pr2 :: Pr2Spec > ;
#[doc = "pending register"] pub mod pr2 {
#[doc = "Register `PR2` reader"] pub type R = crate :: R < Pr2Spec > ;
#[doc = "Register `PR2` writer"] pub type W = crate :: W < Pr2Spec > ;
#[doc = "Field `PIF33` reader - Configurable event inputs x+32 Pending bit."] pub type Pif33R = crate :: BitReader ;
#[doc = "Field `PIF33` writer - Configurable event inputs x+32 Pending bit."] pub type Pif33W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIF40_41` reader - Configurable event inputs x+32 Pending bit."] pub type Pif40_41R = crate :: FieldReader ;
#[doc = "Field `PIF40_41` writer - Configurable event inputs x+32 Pending bit."] pub type Pif40_41W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bit 1 - Configurable event inputs x+32 Pending bit."]
#[inline (always)] pub fn pif33 (& self) -> Pif33R { Pif33R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bits 8:9 - Configurable event inputs x+32 Pending bit."]
#[inline (always)] pub fn pif40_41 (& self) -> Pif40_41R { Pif40_41R :: new (((self . bits >> 8) & 3) as u8) } } impl W {
#[doc = "Bit 1 - Configurable event inputs x+32 Pending bit."]
#[inline (always)] pub fn pif33 (& mut self) -> Pif33W < '_ , Pr2Spec > { Pif33W :: new (self , 1) }
#[doc = "Bits 8:9 - Configurable event inputs x+32 Pending bit."]
#[inline (always)] pub fn pif40_41 (& mut self) -> Pif40_41W < '_ , Pr2Spec > { Pif40_41W :: new (self , 8) } }
#[doc = "pending register\n\nYou can [`read`](crate::Reg::read) this register and get [`pr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Pr2Spec ; impl crate :: RegisterSpec for Pr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pr2::R`](R) reader structure"] impl crate :: Readable for Pr2Spec { }
#[doc = "`write(|w| ..)` method takes [`pr2::W`](W) writer structure"] impl crate :: Writable for Pr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PR2 to value 0"] impl crate :: Resettable for Pr2Spec { } }
#[doc = "C1IMR1 (rw) register accessor: CPUm wakeup with interrupt mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`c1imr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c1imr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c1imr1`] module"]
#[doc (alias = "C1IMR1")] pub type C1imr1 = crate :: Reg < c1imr1 :: C1imr1Spec > ;
#[doc = "CPUm wakeup with interrupt mask register"] pub mod c1imr1 {
#[doc = "Register `C1IMR1` reader"] pub type R = crate :: R < C1imr1Spec > ;
#[doc = "Register `C1IMR1` writer"] pub type W = crate :: W < C1imr1Spec > ;
#[doc = "Field `IM` reader - CPU(m) wakeup with interrupt Mask on Event input"] pub type ImR = crate :: FieldReader < u32 > ;
#[doc = "Field `IM` writer - CPU(m) wakeup with interrupt Mask on Event input"] pub type ImW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - CPU(m) wakeup with interrupt Mask on Event input"]
#[inline (always)] pub fn im (& self) -> ImR { ImR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - CPU(m) wakeup with interrupt Mask on Event input"]
#[inline (always)] pub fn im (& mut self) -> ImW < '_ , C1imr1Spec > { ImW :: new (self , 0) } }
#[doc = "CPUm wakeup with interrupt mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`c1imr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c1imr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C1imr1Spec ; impl crate :: RegisterSpec for C1imr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c1imr1::R`](R) reader structure"] impl crate :: Readable for C1imr1Spec { }
#[doc = "`write(|w| ..)` method takes [`c1imr1::W`](W) writer structure"] impl crate :: Writable for C1imr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C1IMR1 to value 0x7fc0_0000"] impl crate :: Resettable for C1imr1Spec { const RESET_VALUE : u32 = 0x7fc0_0000 ; } }
#[doc = "C2IMR1 (rw) register accessor: CPUm wakeup with interrupt mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2imr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2imr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2imr1`] module"]
#[doc (alias = "C2IMR1")] pub type C2imr1 = crate :: Reg < c2imr1 :: C2imr1Spec > ;
#[doc = "CPUm wakeup with interrupt mask register"] pub mod c2imr1 {
#[doc = "Register `C2IMR1` reader"] pub type R = crate :: R < C2imr1Spec > ;
#[doc = "Register `C2IMR1` writer"] pub type W = crate :: W < C2imr1Spec > ;
#[doc = "Field `IM` reader - CPU(m) wakeup with interrupt Mask on Event input"] pub type ImR = crate :: FieldReader < u32 > ;
#[doc = "Field `IM` writer - CPU(m) wakeup with interrupt Mask on Event input"] pub type ImW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - CPU(m) wakeup with interrupt Mask on Event input"]
#[inline (always)] pub fn im (& self) -> ImR { ImR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - CPU(m) wakeup with interrupt Mask on Event input"]
#[inline (always)] pub fn im (& mut self) -> ImW < '_ , C2imr1Spec > { ImW :: new (self , 0) } }
#[doc = "CPUm wakeup with interrupt mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2imr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2imr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2imr1Spec ; impl crate :: RegisterSpec for C2imr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2imr1::R`](R) reader structure"] impl crate :: Readable for C2imr1Spec { }
#[doc = "`write(|w| ..)` method takes [`c2imr1::W`](W) writer structure"] impl crate :: Writable for C2imr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2IMR1 to value 0x7fc0_0000"] impl crate :: Resettable for C2imr1Spec { const RESET_VALUE : u32 = 0x7fc0_0000 ; } }
#[doc = "C1EMR1 (rw) register accessor: CPUm wakeup with event mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`c1emr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c1emr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c1emr1`] module"]
#[doc (alias = "C1EMR1")] pub type C1emr1 = crate :: Reg < c1emr1 :: C1emr1Spec > ;
#[doc = "CPUm wakeup with event mask register"] pub mod c1emr1 {
#[doc = "Register `C1EMR1` reader"] pub type R = crate :: R < C1emr1Spec > ;
#[doc = "Register `C1EMR1` writer"] pub type W = crate :: W < C1emr1Spec > ;
#[doc = "Field `EM0_15` reader - CPU(m) Wakeup with event generation Mask on Event input"] pub type Em0_15R = crate :: FieldReader < u16 > ;
#[doc = "Field `EM0_15` writer - CPU(m) Wakeup with event generation Mask on Event input"] pub type Em0_15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `EM17_21` reader - CPU(m) Wakeup with event generation Mask on Event input"] pub type Em17_21R = crate :: FieldReader ;
#[doc = "Field `EM17_21` writer - CPU(m) Wakeup with event generation Mask on Event input"] pub type Em17_21W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:15 - CPU(m) Wakeup with event generation Mask on Event input"]
#[inline (always)] pub fn em0_15 (& self) -> Em0_15R { Em0_15R :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bits 17:21 - CPU(m) Wakeup with event generation Mask on Event input"]
#[inline (always)] pub fn em17_21 (& self) -> Em17_21R { Em17_21R :: new (((self . bits >> 17) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:15 - CPU(m) Wakeup with event generation Mask on Event input"]
#[inline (always)] pub fn em0_15 (& mut self) -> Em0_15W < '_ , C1emr1Spec > { Em0_15W :: new (self , 0) }
#[doc = "Bits 17:21 - CPU(m) Wakeup with event generation Mask on Event input"]
#[inline (always)] pub fn em17_21 (& mut self) -> Em17_21W < '_ , C1emr1Spec > { Em17_21W :: new (self , 17) } }
#[doc = "CPUm wakeup with event mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`c1emr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c1emr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C1emr1Spec ; impl crate :: RegisterSpec for C1emr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c1emr1::R`](R) reader structure"] impl crate :: Readable for C1emr1Spec { }
#[doc = "`write(|w| ..)` method takes [`c1emr1::W`](W) writer structure"] impl crate :: Writable for C1emr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C1EMR1 to value 0"] impl crate :: Resettable for C1emr1Spec { } }
#[doc = "C2EMR1 (rw) register accessor: CPUm wakeup with event mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2emr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2emr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2emr1`] module"]
#[doc (alias = "C2EMR1")] pub type C2emr1 = crate :: Reg < c2emr1 :: C2emr1Spec > ;
#[doc = "CPUm wakeup with event mask register"] pub mod c2emr1 {
#[doc = "Register `C2EMR1` reader"] pub type R = crate :: R < C2emr1Spec > ;
#[doc = "Register `C2EMR1` writer"] pub type W = crate :: W < C2emr1Spec > ;
#[doc = "Field `EM0_15` reader - CPU(m) Wakeup with event generation Mask on Event input"] pub type Em0_15R = crate :: FieldReader < u16 > ;
#[doc = "Field `EM0_15` writer - CPU(m) Wakeup with event generation Mask on Event input"] pub type Em0_15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `EM17_21` reader - CPU(m) Wakeup with event generation Mask on Event input"] pub type Em17_21R = crate :: FieldReader ;
#[doc = "Field `EM17_21` writer - CPU(m) Wakeup with event generation Mask on Event input"] pub type Em17_21W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:15 - CPU(m) Wakeup with event generation Mask on Event input"]
#[inline (always)] pub fn em0_15 (& self) -> Em0_15R { Em0_15R :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bits 17:21 - CPU(m) Wakeup with event generation Mask on Event input"]
#[inline (always)] pub fn em17_21 (& self) -> Em17_21R { Em17_21R :: new (((self . bits >> 17) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:15 - CPU(m) Wakeup with event generation Mask on Event input"]
#[inline (always)] pub fn em0_15 (& mut self) -> Em0_15W < '_ , C2emr1Spec > { Em0_15W :: new (self , 0) }
#[doc = "Bits 17:21 - CPU(m) Wakeup with event generation Mask on Event input"]
#[inline (always)] pub fn em17_21 (& mut self) -> Em17_21W < '_ , C2emr1Spec > { Em17_21W :: new (self , 17) } }
#[doc = "CPUm wakeup with event mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2emr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2emr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2emr1Spec ; impl crate :: RegisterSpec for C2emr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2emr1::R`](R) reader structure"] impl crate :: Readable for C2emr1Spec { }
#[doc = "`write(|w| ..)` method takes [`c2emr1::W`](W) writer structure"] impl crate :: Writable for C2emr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2EMR1 to value 0"] impl crate :: Resettable for C2emr1Spec { } }
#[doc = "C1IMR2 (rw) register accessor: CPUm wakeup with interrupt mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`c1imr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c1imr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c1imr2`] module"]
#[doc (alias = "C1IMR2")] pub type C1imr2 = crate :: Reg < c1imr2 :: C1imr2Spec > ;
#[doc = "CPUm wakeup with interrupt mask register"] pub mod c1imr2 {
#[doc = "Register `C1IMR2` reader"] pub type R = crate :: R < C1imr2Spec > ;
#[doc = "Register `C1IMR2` writer"] pub type W = crate :: W < C1imr2Spec > ;
#[doc = "Field `IM` reader - CPUm Wakeup with interrupt Mask on Event input"] pub type ImR = crate :: FieldReader < u32 > ;
#[doc = "Field `IM` writer - CPUm Wakeup with interrupt Mask on Event input"] pub type ImW < 'a , REG > = crate :: FieldWriter < 'a , REG , 17 , u32 > ; impl R {
#[doc = "Bits 0:16 - CPUm Wakeup with interrupt Mask on Event input"]
#[inline (always)] pub fn im (& self) -> ImR { ImR :: new (self . bits & 0x0001_ffff) } } impl W {
#[doc = "Bits 0:16 - CPUm Wakeup with interrupt Mask on Event input"]
#[inline (always)] pub fn im (& mut self) -> ImW < '_ , C1imr2Spec > { ImW :: new (self , 0) } }
#[doc = "CPUm wakeup with interrupt mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`c1imr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c1imr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C1imr2Spec ; impl crate :: RegisterSpec for C1imr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c1imr2::R`](R) reader structure"] impl crate :: Readable for C1imr2Spec { }
#[doc = "`write(|w| ..)` method takes [`c1imr2::W`](W) writer structure"] impl crate :: Writable for C1imr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C1IMR2 to value 0x0001_fcfd"] impl crate :: Resettable for C1imr2Spec { const RESET_VALUE : u32 = 0x0001_fcfd ; } }
#[doc = "C2IMR2 (rw) register accessor: CPUm wakeup with interrupt mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2imr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2imr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2imr2`] module"]
#[doc (alias = "C2IMR2")] pub type C2imr2 = crate :: Reg < c2imr2 :: C2imr2Spec > ;
#[doc = "CPUm wakeup with interrupt mask register"] pub mod c2imr2 {
#[doc = "Register `C2IMR2` reader"] pub type R = crate :: R < C2imr2Spec > ;
#[doc = "Register `C2IMR2` writer"] pub type W = crate :: W < C2imr2Spec > ;
#[doc = "Field `IM` reader - CPUm Wakeup with interrupt Mask on Event input"] pub type ImR = crate :: FieldReader < u32 > ;
#[doc = "Field `IM` writer - CPUm Wakeup with interrupt Mask on Event input"] pub type ImW < 'a , REG > = crate :: FieldWriter < 'a , REG , 17 , u32 > ; impl R {
#[doc = "Bits 0:16 - CPUm Wakeup with interrupt Mask on Event input"]
#[inline (always)] pub fn im (& self) -> ImR { ImR :: new (self . bits & 0x0001_ffff) } } impl W {
#[doc = "Bits 0:16 - CPUm Wakeup with interrupt Mask on Event input"]
#[inline (always)] pub fn im (& mut self) -> ImW < '_ , C2imr2Spec > { ImW :: new (self , 0) } }
#[doc = "CPUm wakeup with interrupt mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2imr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2imr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2imr2Spec ; impl crate :: RegisterSpec for C2imr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2imr2::R`](R) reader structure"] impl crate :: Readable for C2imr2Spec { }
#[doc = "`write(|w| ..)` method takes [`c2imr2::W`](W) writer structure"] impl crate :: Writable for C2imr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2IMR2 to value 0x0001_fcfd"] impl crate :: Resettable for C2imr2Spec { const RESET_VALUE : u32 = 0x0001_fcfd ; } }
#[doc = "C1EMR2 (rw) register accessor: CPUm wakeup with event mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`c1emr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c1emr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c1emr2`] module"]
#[doc (alias = "C1EMR2")] pub type C1emr2 = crate :: Reg < c1emr2 :: C1emr2Spec > ;
#[doc = "CPUm wakeup with event mask register"] pub mod c1emr2 {
#[doc = "Register `C1EMR2` reader"] pub type R = crate :: R < C1emr2Spec > ;
#[doc = "Register `C1EMR2` writer"] pub type W = crate :: W < C1emr2Spec > ;
#[doc = "Field `EM` reader - CPU(m) Wakeup with event generation Mask on Event input"] pub type EmR = crate :: FieldReader ;
#[doc = "Field `EM` writer - CPU(m) Wakeup with event generation Mask on Event input"] pub type EmW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 8:9 - CPU(m) Wakeup with event generation Mask on Event input"]
#[inline (always)] pub fn em (& self) -> EmR { EmR :: new (((self . bits >> 8) & 3) as u8) } } impl W {
#[doc = "Bits 8:9 - CPU(m) Wakeup with event generation Mask on Event input"]
#[inline (always)] pub fn em (& mut self) -> EmW < '_ , C1emr2Spec > { EmW :: new (self , 8) } }
#[doc = "CPUm wakeup with event mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`c1emr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c1emr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C1emr2Spec ; impl crate :: RegisterSpec for C1emr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c1emr2::R`](R) reader structure"] impl crate :: Readable for C1emr2Spec { }
#[doc = "`write(|w| ..)` method takes [`c1emr2::W`](W) writer structure"] impl crate :: Writable for C1emr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C1EMR2 to value 0"] impl crate :: Resettable for C1emr2Spec { } }
#[doc = "C2EMR2 (rw) register accessor: CPUm wakeup with event mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2emr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2emr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@c2emr2`] module"]
#[doc (alias = "C2EMR2")] pub type C2emr2 = crate :: Reg < c2emr2 :: C2emr2Spec > ;
#[doc = "CPUm wakeup with event mask register"] pub mod c2emr2 {
#[doc = "Register `C2EMR2` reader"] pub type R = crate :: R < C2emr2Spec > ;
#[doc = "Register `C2EMR2` writer"] pub type W = crate :: W < C2emr2Spec > ;
#[doc = "Field `EM` reader - CPU(m) Wakeup with event generation Mask on Event input"] pub type EmR = crate :: FieldReader ;
#[doc = "Field `EM` writer - CPU(m) Wakeup with event generation Mask on Event input"] pub type EmW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 8:9 - CPU(m) Wakeup with event generation Mask on Event input"]
#[inline (always)] pub fn em (& self) -> EmR { EmR :: new (((self . bits >> 8) & 3) as u8) } } impl W {
#[doc = "Bits 8:9 - CPU(m) Wakeup with event generation Mask on Event input"]
#[inline (always)] pub fn em (& mut self) -> EmW < '_ , C2emr2Spec > { EmW :: new (self , 8) } }
#[doc = "CPUm wakeup with event mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`c2emr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c2emr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct C2emr2Spec ; impl crate :: RegisterSpec for C2emr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`c2emr2::R`](R) reader structure"] impl crate :: Readable for C2emr2Spec { }
#[doc = "`write(|w| ..)` method takes [`c2emr2::W`](W) writer structure"] impl crate :: Writable for C2emr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets C2EMR2 to value 0"] impl crate :: Resettable for C2emr2Spec { } }
#[doc = "HWCFGR5 (r) register accessor: Hardware configuration registers\n\nYou can [`read`](crate::Reg::read) this register and get [`hwcfgr5::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hwcfgr5`] module"]
#[doc (alias = "HWCFGR5")] pub type Hwcfgr5 = crate :: Reg < hwcfgr5 :: Hwcfgr5Spec > ;
#[doc = "Hardware configuration registers"] pub mod hwcfgr5 {
#[doc = "Register `HWCFGR5` reader"] pub type R = crate :: R < Hwcfgr5Spec > ;
#[doc = "Field `CPUEVENT` reader - HW configuration CPU event generation"] pub type CpueventR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - HW configuration CPU event generation"]
#[inline (always)] pub fn cpuevent (& self) -> CpueventR { CpueventR :: new (self . bits) } }
#[doc = "Hardware configuration registers\n\nYou can [`read`](crate::Reg::read) this register and get [`hwcfgr5::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Hwcfgr5Spec ; impl crate :: RegisterSpec for Hwcfgr5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`hwcfgr5::R`](R) reader structure"] impl crate :: Readable for Hwcfgr5Spec { }
#[doc = "`reset()` method sets HWCFGR5 to value 0x003e_ffff"] impl crate :: Resettable for Hwcfgr5Spec { const RESET_VALUE : u32 = 0x003e_ffff ; } }
#[doc = "HWCFGR6 (r) register accessor: Hardware configuration registers\n\nYou can [`read`](crate::Reg::read) this register and get [`hwcfgr6::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hwcfgr6`] module"]
#[doc (alias = "HWCFGR6")] pub type Hwcfgr6 = crate :: Reg < hwcfgr6 :: Hwcfgr6Spec > ;
#[doc = "Hardware configuration registers"] pub mod hwcfgr6 {
#[doc = "Register `HWCFGR6` reader"] pub type R = crate :: R < Hwcfgr6Spec > ;
#[doc = "Field `CPUEVENT` reader - HW configuration CPU event generation"] pub type CpueventR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - HW configuration CPU event generation"]
#[inline (always)] pub fn cpuevent (& self) -> CpueventR { CpueventR :: new (self . bits) } }
#[doc = "Hardware configuration registers\n\nYou can [`read`](crate::Reg::read) this register and get [`hwcfgr6::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Hwcfgr6Spec ; impl crate :: RegisterSpec for Hwcfgr6Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`hwcfgr6::R`](R) reader structure"] impl crate :: Readable for Hwcfgr6Spec { }
#[doc = "`reset()` method sets HWCFGR6 to value 0x0300"] impl crate :: Resettable for Hwcfgr6Spec { const RESET_VALUE : u32 = 0x0300 ; } }
#[doc = "HWCFGR7 (r) register accessor: EXTI Hardware configuration registers\n\nYou can [`read`](crate::Reg::read) this register and get [`hwcfgr7::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hwcfgr7`] module"]
#[doc (alias = "HWCFGR7")] pub type Hwcfgr7 = crate :: Reg < hwcfgr7 :: Hwcfgr7Spec > ;
#[doc = "EXTI Hardware configuration registers"] pub mod hwcfgr7 {
#[doc = "Register `HWCFGR7` reader"] pub type R = crate :: R < Hwcfgr7Spec > ;
#[doc = "Field `CPUEVENT` reader - HW configuration CPU event generation"] pub type CpueventR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - HW configuration CPU event generation"]
#[inline (always)] pub fn cpuevent (& self) -> CpueventR { CpueventR :: new (self . bits) } }
#[doc = "EXTI Hardware configuration registers\n\nYou can [`read`](crate::Reg::read) this register and get [`hwcfgr7::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Hwcfgr7Spec ; impl crate :: RegisterSpec for Hwcfgr7Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`hwcfgr7::R`](R) reader structure"] impl crate :: Readable for Hwcfgr7Spec { }
#[doc = "`reset()` method sets HWCFGR7 to value 0"] impl crate :: Resettable for Hwcfgr7Spec { } }
#[doc = "HWCFGR2 (r) register accessor: Hardware configuration registers\n\nYou can [`read`](crate::Reg::read) this register and get [`hwcfgr2::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hwcfgr2`] module"]
#[doc (alias = "HWCFGR2")] pub type Hwcfgr2 = crate :: Reg < hwcfgr2 :: Hwcfgr2Spec > ;
#[doc = "Hardware configuration registers"] pub mod hwcfgr2 {
#[doc = "Register `HWCFGR2` reader"] pub type R = crate :: R < Hwcfgr2Spec > ;
#[doc = "Field `EVENT_TRG` reader - HW configuration event trigger type"] pub type EventTrgR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - HW configuration event trigger type"]
#[inline (always)] pub fn event_trg (& self) -> EventTrgR { EventTrgR :: new (self . bits) } }
#[doc = "Hardware configuration registers\n\nYou can [`read`](crate::Reg::read) this register and get [`hwcfgr2::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Hwcfgr2Spec ; impl crate :: RegisterSpec for Hwcfgr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`hwcfgr2::R`](R) reader structure"] impl crate :: Readable for Hwcfgr2Spec { }
#[doc = "`reset()` method sets HWCFGR2 to value 0x803f_ffff"] impl crate :: Resettable for Hwcfgr2Spec { const RESET_VALUE : u32 = 0x803f_ffff ; } }
#[doc = "HWCFGR3 (r) register accessor: Hardware configuration registers\n\nYou can [`read`](crate::Reg::read) this register and get [`hwcfgr3::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hwcfgr3`] module"]
#[doc (alias = "HWCFGR3")] pub type Hwcfgr3 = crate :: Reg < hwcfgr3 :: Hwcfgr3Spec > ;
#[doc = "Hardware configuration registers"] pub mod hwcfgr3 {
#[doc = "Register `HWCFGR3` reader"] pub type R = crate :: R < Hwcfgr3Spec > ;
#[doc = "Field `EVENT_TRG` reader - HW configuration event trigger type"] pub type EventTrgR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - HW configuration event trigger type"]
#[inline (always)] pub fn event_trg (& self) -> EventTrgR { EventTrgR :: new (self . bits) } }
#[doc = "Hardware configuration registers\n\nYou can [`read`](crate::Reg::read) this register and get [`hwcfgr3::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Hwcfgr3Spec ; impl crate :: RegisterSpec for Hwcfgr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`hwcfgr3::R`](R) reader structure"] impl crate :: Readable for Hwcfgr3Spec { }
#[doc = "`reset()` method sets HWCFGR3 to value 0x0302"] impl crate :: Resettable for Hwcfgr3Spec { const RESET_VALUE : u32 = 0x0302 ; } }
#[doc = "HWCFGR4 (r) register accessor: Hardware configuration registers\n\nYou can [`read`](crate::Reg::read) this register and get [`hwcfgr4::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hwcfgr4`] module"]
#[doc (alias = "HWCFGR4")] pub type Hwcfgr4 = crate :: Reg < hwcfgr4 :: Hwcfgr4Spec > ;
#[doc = "Hardware configuration registers"] pub mod hwcfgr4 {
#[doc = "Register `HWCFGR4` reader"] pub type R = crate :: R < Hwcfgr4Spec > ;
#[doc = "Field `EVENT_TRG` reader - HW configuration event trigger type"] pub type EventTrgR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - HW configuration event trigger type"]
#[inline (always)] pub fn event_trg (& self) -> EventTrgR { EventTrgR :: new (self . bits) } }
#[doc = "Hardware configuration registers\n\nYou can [`read`](crate::Reg::read) this register and get [`hwcfgr4::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Hwcfgr4Spec ; impl crate :: RegisterSpec for Hwcfgr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`hwcfgr4::R`](R) reader structure"] impl crate :: Readable for Hwcfgr4Spec { }
#[doc = "`reset()` method sets HWCFGR4 to value 0"] impl crate :: Resettable for Hwcfgr4Spec { } }
#[doc = "HWCFGR1 (r) register accessor: Hardware configuration register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`hwcfgr1::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hwcfgr1`] module"]
#[doc (alias = "HWCFGR1")] pub type Hwcfgr1 = crate :: Reg < hwcfgr1 :: Hwcfgr1Spec > ;
#[doc = "Hardware configuration register 1"] pub mod hwcfgr1 {
#[doc = "Register `HWCFGR1` reader"] pub type R = crate :: R < Hwcfgr1Spec > ;
#[doc = "Field `NBEVENTS` reader - HW configuration number of event"] pub type NbeventsR = crate :: FieldReader ;
#[doc = "Field `NBCPUS` reader - HW configuration number of CPUs"] pub type NbcpusR = crate :: FieldReader ;
#[doc = "Field `CPUEVTEN` reader - HW configuration of CPU(m) event output enable"] pub type CpuevtenR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - HW configuration number of event"]
#[inline (always)] pub fn nbevents (& self) -> NbeventsR { NbeventsR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:11 - HW configuration number of CPUs"]
#[inline (always)] pub fn nbcpus (& self) -> NbcpusR { NbcpusR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:15 - HW configuration of CPU(m) event output enable"]
#[inline (always)] pub fn cpuevten (& self) -> CpuevtenR { CpuevtenR :: new (((self . bits >> 12) & 0x0f) as u8) } }
#[doc = "Hardware configuration register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`hwcfgr1::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Hwcfgr1Spec ; impl crate :: RegisterSpec for Hwcfgr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`hwcfgr1::R`](R) reader structure"] impl crate :: Readable for Hwcfgr1Spec { }
#[doc = "`reset()` method sets HWCFGR1 to value 0x3130"] impl crate :: Resettable for Hwcfgr1Spec { const RESET_VALUE : u32 = 0x3130 ; } }
#[doc = "VERR (r) register accessor: EXTI IP Version register\n\nYou can [`read`](crate::Reg::read) this register and get [`verr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@verr`] module"]
#[doc (alias = "VERR")] pub type Verr = crate :: Reg < verr :: VerrSpec > ;
#[doc = "EXTI IP Version register"] pub mod verr {
#[doc = "Register `VERR` reader"] pub type R = crate :: R < VerrSpec > ;
#[doc = "Field `MINREV` reader - Minor Revision number"] pub type MinrevR = crate :: FieldReader ;
#[doc = "Field `MAJREV` reader - Major Revision number"] pub type MajrevR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:3 - Minor Revision number"]
#[inline (always)] pub fn minrev (& self) -> MinrevR { MinrevR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - Major Revision number"]
#[inline (always)] pub fn majrev (& self) -> MajrevR { MajrevR :: new (((self . bits >> 4) & 0x0f) as u8) } }
#[doc = "EXTI IP Version register\n\nYou can [`read`](crate::Reg::read) this register and get [`verr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct VerrSpec ; impl crate :: RegisterSpec for VerrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`verr::R`](R) reader structure"] impl crate :: Readable for VerrSpec { }
#[doc = "`reset()` method sets VERR to value 0x20"] impl crate :: Resettable for VerrSpec { const RESET_VALUE : u32 = 0x20 ; } }
#[doc = "IPIDR (r) register accessor: Identification register\n\nYou can [`read`](crate::Reg::read) this register and get [`ipidr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ipidr`] module"]
#[doc (alias = "IPIDR")] pub type Ipidr = crate :: Reg < ipidr :: IpidrSpec > ;
#[doc = "Identification register"] pub mod ipidr {
#[doc = "Register `IPIDR` reader"] pub type R = crate :: R < IpidrSpec > ;
#[doc = "Field `IPID` reader - IP Identification"] pub type IpidR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - IP Identification"]
#[inline (always)] pub fn ipid (& self) -> IpidR { IpidR :: new (self . bits) } }
#[doc = "Identification register\n\nYou can [`read`](crate::Reg::read) this register and get [`ipidr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IpidrSpec ; impl crate :: RegisterSpec for IpidrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ipidr::R`](R) reader structure"] impl crate :: Readable for IpidrSpec { }
#[doc = "`reset()` method sets IPIDR to value 0x000e_0001"] impl crate :: Resettable for IpidrSpec { const RESET_VALUE : u32 = 0x000e_0001 ; } }
#[doc = "SIDR (r) register accessor: Size ID register\n\nYou can [`read`](crate::Reg::read) this register and get [`sidr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sidr`] module"]
#[doc (alias = "SIDR")] pub type Sidr = crate :: Reg < sidr :: SidrSpec > ;
#[doc = "Size ID register"] pub mod sidr {
#[doc = "Register `SIDR` reader"] pub type R = crate :: R < SidrSpec > ;
#[doc = "Field `SID` reader - Size Identification"] pub type SidR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Size Identification"]
#[inline (always)] pub fn sid (& self) -> SidR { SidR :: new (self . bits) } }
#[doc = "Size ID register\n\nYou can [`read`](crate::Reg::read) this register and get [`sidr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SidrSpec ; impl crate :: RegisterSpec for SidrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sidr::R`](R) reader structure"] impl crate :: Readable for SidrSpec { }
#[doc = "`reset()` method sets SIDR to value 0xa3c5_dd01"] impl crate :: Resettable for SidrSpec { const RESET_VALUE : u32 = 0xa3c5_dd01 ; } } }
#[doc = "Clock recovery system"] pub type Crs = crate :: Periph < crs :: RegisterBlock , 0x4000_6000 > ; impl core :: fmt :: Debug for Crs { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Crs") . finish () } }
#[doc = "Clock recovery system"] pub mod crs {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr : Cr , cfgr : Cfgr , isr : Isr , icr : Icr , } impl RegisterBlock {
#[doc = "0x00 - CRS control register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x04 - CRS configuration register"]
#[inline (always)] pub const fn cfgr (& self) -> & Cfgr { & self . cfgr }
#[doc = "0x08 - CRS interrupt and status register"]
#[inline (always)] pub const fn isr (& self) -> & Isr { & self . isr }
#[doc = "0x0c - CRS interrupt flag clear register"]
#[inline (always)] pub const fn icr (& self) -> & Icr { & self . icr } }
#[doc = "CR (rw) register accessor: CRS control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "CRS control register"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `SYNCOKIE` reader - SYNC event OK interrupt enable"] pub type SyncokieR = crate :: BitReader ;
#[doc = "Field `SYNCOKIE` writer - SYNC event OK interrupt enable"] pub type SyncokieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SYNCWARNIE` reader - SYNC warning interrupt enable"] pub type SyncwarnieR = crate :: BitReader ;
#[doc = "Field `SYNCWARNIE` writer - SYNC warning interrupt enable"] pub type SyncwarnieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ERRIE` reader - Synchronization or trimming error interrupt enable"] pub type ErrieR = crate :: BitReader ;
#[doc = "Field `ERRIE` writer - Synchronization or trimming error interrupt enable"] pub type ErrieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ESYNCIE` reader - Expected SYNC interrupt enable"] pub type EsyncieR = crate :: BitReader ;
#[doc = "Field `ESYNCIE` writer - Expected SYNC interrupt enable"] pub type EsyncieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CEN` reader - Frequency error counter enable"] pub type CenR = crate :: BitReader ;
#[doc = "Field `CEN` writer - Frequency error counter enable"] pub type CenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AUTOTRIMEN` reader - Automatic trimming enable"] pub type AutotrimenR = crate :: BitReader ;
#[doc = "Field `AUTOTRIMEN` writer - Automatic trimming enable"] pub type AutotrimenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWSYNC` reader - Automatic trimming enable"] pub type SwsyncR = crate :: BitReader ;
#[doc = "Field `SWSYNC` writer - Automatic trimming enable"] pub type SwsyncW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TRIM` reader - HSI48 oscillator smooth trimming"] pub type TrimR = crate :: FieldReader ;
#[doc = "Field `TRIM` writer - HSI48 oscillator smooth trimming"] pub type TrimW < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 > ; impl R {
#[doc = "Bit 0 - SYNC event OK interrupt enable"]
#[inline (always)] pub fn syncokie (& self) -> SyncokieR { SyncokieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - SYNC warning interrupt enable"]
#[inline (always)] pub fn syncwarnie (& self) -> SyncwarnieR { SyncwarnieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Synchronization or trimming error interrupt enable"]
#[inline (always)] pub fn errie (& self) -> ErrieR { ErrieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Expected SYNC interrupt enable"]
#[inline (always)] pub fn esyncie (& self) -> EsyncieR { EsyncieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 5 - Frequency error counter enable"]
#[inline (always)] pub fn cen (& self) -> CenR { CenR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Automatic trimming enable"]
#[inline (always)] pub fn autotrimen (& self) -> AutotrimenR { AutotrimenR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Automatic trimming enable"]
#[inline (always)] pub fn swsync (& self) -> SwsyncR { SwsyncR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:13 - HSI48 oscillator smooth trimming"]
#[inline (always)] pub fn trim (& self) -> TrimR { TrimR :: new (((self . bits >> 8) & 0x3f) as u8) } } impl W {
#[doc = "Bit 0 - SYNC event OK interrupt enable"]
#[inline (always)] pub fn syncokie (& mut self) -> SyncokieW < '_ , CrSpec > { SyncokieW :: new (self , 0) }
#[doc = "Bit 1 - SYNC warning interrupt enable"]
#[inline (always)] pub fn syncwarnie (& mut self) -> SyncwarnieW < '_ , CrSpec > { SyncwarnieW :: new (self , 1) }
#[doc = "Bit 2 - Synchronization or trimming error interrupt enable"]
#[inline (always)] pub fn errie (& mut self) -> ErrieW < '_ , CrSpec > { ErrieW :: new (self , 2) }
#[doc = "Bit 3 - Expected SYNC interrupt enable"]
#[inline (always)] pub fn esyncie (& mut self) -> EsyncieW < '_ , CrSpec > { EsyncieW :: new (self , 3) }
#[doc = "Bit 5 - Frequency error counter enable"]
#[inline (always)] pub fn cen (& mut self) -> CenW < '_ , CrSpec > { CenW :: new (self , 5) }
#[doc = "Bit 6 - Automatic trimming enable"]
#[inline (always)] pub fn autotrimen (& mut self) -> AutotrimenW < '_ , CrSpec > { AutotrimenW :: new (self , 6) }
#[doc = "Bit 7 - Automatic trimming enable"]
#[inline (always)] pub fn swsync (& mut self) -> SwsyncW < '_ , CrSpec > { SwsyncW :: new (self , 7) }
#[doc = "Bits 8:13 - HSI48 oscillator smooth trimming"]
#[inline (always)] pub fn trim (& mut self) -> TrimW < '_ , CrSpec > { TrimW :: new (self , 8) } }
#[doc = "CRS control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0x2000"] impl crate :: Resettable for CrSpec { const RESET_VALUE : u32 = 0x2000 ; } }
#[doc = "CFGR (rw) register accessor: CRS configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfgr`] module"]
#[doc (alias = "CFGR")] pub type Cfgr = crate :: Reg < cfgr :: CfgrSpec > ;
#[doc = "CRS configuration register"] pub mod cfgr {
#[doc = "Register `CFGR` reader"] pub type R = crate :: R < CfgrSpec > ;
#[doc = "Register `CFGR` writer"] pub type W = crate :: W < CfgrSpec > ;
#[doc = "Field `RELOAD` reader - Counter reload value"] pub type ReloadR = crate :: FieldReader < u16 > ;
#[doc = "Field `RELOAD` writer - Counter reload value"] pub type ReloadW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `FELIM` reader - Frequency error limit"] pub type FelimR = crate :: FieldReader ;
#[doc = "Field `FELIM` writer - Frequency error limit"] pub type FelimW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `SYNCDIV` reader - SYNCDIV"] pub type SyncdivR = crate :: FieldReader ;
#[doc = "Field `SYNCDIV` writer - SYNCDIV"] pub type SyncdivW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SYNCSRC` reader - SYNC signal source selection"] pub type SyncsrcR = crate :: FieldReader ;
#[doc = "Field `SYNCSRC` writer - SYNC signal source selection"] pub type SyncsrcW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SYNCPOL` reader - SYNC polarity selection"] pub type SyncpolR = crate :: BitReader ;
#[doc = "Field `SYNCPOL` writer - SYNC polarity selection"] pub type SyncpolW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:15 - Counter reload value"]
#[inline (always)] pub fn reload (& self) -> ReloadR { ReloadR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bits 16:23 - Frequency error limit"]
#[inline (always)] pub fn felim (& self) -> FelimR { FelimR :: new (((self . bits >> 16) & 0xff) as u8) }
#[doc = "Bits 24:26 - SYNCDIV"]
#[inline (always)] pub fn syncdiv (& self) -> SyncdivR { SyncdivR :: new (((self . bits >> 24) & 7) as u8) }
#[doc = "Bits 28:29 - SYNC signal source selection"]
#[inline (always)] pub fn syncsrc (& self) -> SyncsrcR { SyncsrcR :: new (((self . bits >> 28) & 3) as u8) }
#[doc = "Bit 31 - SYNC polarity selection"]
#[inline (always)] pub fn syncpol (& self) -> SyncpolR { SyncpolR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:15 - Counter reload value"]
#[inline (always)] pub fn reload (& mut self) -> ReloadW < '_ , CfgrSpec > { ReloadW :: new (self , 0) }
#[doc = "Bits 16:23 - Frequency error limit"]
#[inline (always)] pub fn felim (& mut self) -> FelimW < '_ , CfgrSpec > { FelimW :: new (self , 16) }
#[doc = "Bits 24:26 - SYNCDIV"]
#[inline (always)] pub fn syncdiv (& mut self) -> SyncdivW < '_ , CfgrSpec > { SyncdivW :: new (self , 24) }
#[doc = "Bits 28:29 - SYNC signal source selection"]
#[inline (always)] pub fn syncsrc (& mut self) -> SyncsrcW < '_ , CfgrSpec > { SyncsrcW :: new (self , 28) }
#[doc = "Bit 31 - SYNC polarity selection"]
#[inline (always)] pub fn syncpol (& mut self) -> SyncpolW < '_ , CfgrSpec > { SyncpolW :: new (self , 31) } }
#[doc = "CRS configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CfgrSpec ; impl crate :: RegisterSpec for CfgrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cfgr::R`](R) reader structure"] impl crate :: Readable for CfgrSpec { }
#[doc = "`write(|w| ..)` method takes [`cfgr::W`](W) writer structure"] impl crate :: Writable for CfgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CFGR to value 0x2022_bb7f"] impl crate :: Resettable for CfgrSpec { const RESET_VALUE : u32 = 0x2022_bb7f ; } }
#[doc = "ISR (r) register accessor: CRS interrupt and status register\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@isr`] module"]
#[doc (alias = "ISR")] pub type Isr = crate :: Reg < isr :: IsrSpec > ;
#[doc = "CRS interrupt and status register"] pub mod isr {
#[doc = "Register `ISR` reader"] pub type R = crate :: R < IsrSpec > ;
#[doc = "Field `SYNCOKF` reader - SYNC event OK flag"] pub type SyncokfR = crate :: BitReader ;
#[doc = "Field `SYNCWARNF` reader - SYNC warning flag"] pub type SyncwarnfR = crate :: BitReader ;
#[doc = "Field `ERRF` reader - Error flag"] pub type ErrfR = crate :: BitReader ;
#[doc = "Field `ESYNCF` reader - Expected SYNC flag"] pub type EsyncfR = crate :: BitReader ;
#[doc = "Field `SYNCERR` reader - SYNC error"] pub type SyncerrR = crate :: BitReader ;
#[doc = "Field `SYNCMISS` reader - SYNC missed"] pub type SyncmissR = crate :: BitReader ;
#[doc = "Field `TRIMOVF` reader - Trimming overflow or underflow"] pub type TrimovfR = crate :: BitReader ;
#[doc = "Field `FEDIR` reader - Frequency error direction"] pub type FedirR = crate :: BitReader ;
#[doc = "Field `FECAP` reader - Frequency error capture"] pub type FecapR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bit 0 - SYNC event OK flag"]
#[inline (always)] pub fn syncokf (& self) -> SyncokfR { SyncokfR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - SYNC warning flag"]
#[inline (always)] pub fn syncwarnf (& self) -> SyncwarnfR { SyncwarnfR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Error flag"]
#[inline (always)] pub fn errf (& self) -> ErrfR { ErrfR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Expected SYNC flag"]
#[inline (always)] pub fn esyncf (& self) -> EsyncfR { EsyncfR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 8 - SYNC error"]
#[inline (always)] pub fn syncerr (& self) -> SyncerrR { SyncerrR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - SYNC missed"]
#[inline (always)] pub fn syncmiss (& self) -> SyncmissR { SyncmissR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Trimming overflow or underflow"]
#[inline (always)] pub fn trimovf (& self) -> TrimovfR { TrimovfR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 15 - Frequency error direction"]
#[inline (always)] pub fn fedir (& self) -> FedirR { FedirR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bits 16:31 - Frequency error capture"]
#[inline (always)] pub fn fecap (& self) -> FecapR { FecapR :: new (((self . bits >> 16) & 0xffff) as u16) } }
#[doc = "CRS interrupt and status register\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IsrSpec ; impl crate :: RegisterSpec for IsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`isr::R`](R) reader structure"] impl crate :: Readable for IsrSpec { }
#[doc = "`reset()` method sets ISR to value 0"] impl crate :: Resettable for IsrSpec { } }
#[doc = "ICR (rw) register accessor: CRS interrupt flag clear register\n\nYou can [`read`](crate::Reg::read) this register and get [`icr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@icr`] module"]
#[doc (alias = "ICR")] pub type Icr = crate :: Reg < icr :: IcrSpec > ;
#[doc = "CRS interrupt flag clear register"] pub mod icr {
#[doc = "Register `ICR` reader"] pub type R = crate :: R < IcrSpec > ;
#[doc = "Register `ICR` writer"] pub type W = crate :: W < IcrSpec > ;
#[doc = "Field `SYNCOKC` reader - SYNC event OK clear flag"] pub type SyncokcR = crate :: BitReader ;
#[doc = "Field `SYNCOKC` writer - SYNC event OK clear flag"] pub type SyncokcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SYNCWARNC` reader - warning clear flag"] pub type SyncwarncR = crate :: BitReader ;
#[doc = "Field `SYNCWARNC` writer - warning clear flag"] pub type SyncwarncW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ERRC` reader - Error clear flag"] pub type ErrcR = crate :: BitReader ;
#[doc = "Field `ERRC` writer - Error clear flag"] pub type ErrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ESYNCC` reader - Expected SYNC clear flag"] pub type EsynccR = crate :: BitReader ;
#[doc = "Field `ESYNCC` writer - Expected SYNC clear flag"] pub type EsynccW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - SYNC event OK clear flag"]
#[inline (always)] pub fn syncokc (& self) -> SyncokcR { SyncokcR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - warning clear flag"]
#[inline (always)] pub fn syncwarnc (& self) -> SyncwarncR { SyncwarncR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Error clear flag"]
#[inline (always)] pub fn errc (& self) -> ErrcR { ErrcR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Expected SYNC clear flag"]
#[inline (always)] pub fn esyncc (& self) -> EsynccR { EsynccR :: new (((self . bits >> 3) & 1) != 0) } } impl W {
#[doc = "Bit 0 - SYNC event OK clear flag"]
#[inline (always)] pub fn syncokc (& mut self) -> SyncokcW < '_ , IcrSpec > { SyncokcW :: new (self , 0) }
#[doc = "Bit 1 - warning clear flag"]
#[inline (always)] pub fn syncwarnc (& mut self) -> SyncwarncW < '_ , IcrSpec > { SyncwarncW :: new (self , 1) }
#[doc = "Bit 2 - Error clear flag"]
#[inline (always)] pub fn errc (& mut self) -> ErrcW < '_ , IcrSpec > { ErrcW :: new (self , 2) }
#[doc = "Bit 3 - Expected SYNC clear flag"]
#[inline (always)] pub fn esyncc (& mut self) -> EsynccW < '_ , IcrSpec > { EsynccW :: new (self , 3) } }
#[doc = "CRS interrupt flag clear register\n\nYou can [`read`](crate::Reg::read) this register and get [`icr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IcrSpec ; impl crate :: RegisterSpec for IcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`icr::R`](R) reader structure"] impl crate :: Readable for IcrSpec { }
#[doc = "`write(|w| ..)` method takes [`icr::W`](W) writer structure"] impl crate :: Writable for IcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ICR to value 0"] impl crate :: Resettable for IcrSpec { } } }
#[doc = "Universal serial bus full-speed device interface"] pub type Usb = crate :: Periph < usb :: RegisterBlock , 0x4000_6800 > ; impl core :: fmt :: Debug for Usb { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Usb") . finish () } }
#[doc = "Universal serial bus full-speed device interface"] pub mod usb {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ep0r : Ep0r , _reserved1 : [u8 ; 0x02] , ep1r : Ep1r , _reserved2 : [u8 ; 0x02] , ep2r : Ep2r , _reserved3 : [u8 ; 0x02] , ep3r : Ep3r , _reserved4 : [u8 ; 0x02] , ep4r : Ep4r , _reserved5 : [u8 ; 0x02] , ep5r : Ep5r , _reserved6 : [u8 ; 0x02] , ep6r : Ep6r , _reserved7 : [u8 ; 0x02] , ep7r : Ep7r , _reserved8 : [u8 ; 0x22] , cntr : Cntr , _reserved9 : [u8 ; 0x02] , istr : Istr , _reserved10 : [u8 ; 0x02] , fnr : Fnr , _reserved11 : [u8 ; 0x02] , daddr : Daddr , _reserved12 : [u8 ; 0x02] , btable : Btable , count0_tx : Count0Tx , _reserved_14_lpmcsr : [u8 ; 0x02] , count0_rx : Count0Rx , bcdr : Bcdr , count1_tx : Count1Tx , addr1_rx : Addr1Rx , count1_rx : Count1Rx , _reserved20 : [u8 ; 0x02] , count2_tx : Count2Tx , addr2_rx : Addr2Rx , count2_rx : Count2Rx , _reserved23 : [u8 ; 0x02] , count3_tx : Count3Tx , addr3_rx : Addr3Rx , count3_rx : Count3Rx , _reserved26 : [u8 ; 0x02] , count4_tx : Count4Tx , addr4_rx : Addr4Rx , count4_rx : Count4Rx , _reserved29 : [u8 ; 0x02] , count5_tx : Count5Tx , addr5_rx : Addr5Rx , count5_rx : Count5Rx , _reserved32 : [u8 ; 0x02] , count6_tx : Count6Tx , addr6_rx : Addr6Rx , count6_rx : Count6Rx , _reserved35 : [u8 ; 0x02] , count7_tx : Count7Tx , addr7_rx : Addr7Rx , count7_rx : Count7Rx , } impl RegisterBlock {
#[doc = "0x00 - endpoint 0 register"]
#[inline (always)] pub const fn ep0r (& self) -> & Ep0r { & self . ep0r }
#[doc = "0x04 - endpoint 1 register"]
#[inline (always)] pub const fn ep1r (& self) -> & Ep1r { & self . ep1r }
#[doc = "0x08 - endpoint 2 register"]
#[inline (always)] pub const fn ep2r (& self) -> & Ep2r { & self . ep2r }
#[doc = "0x0c - endpoint 3 register"]
#[inline (always)] pub const fn ep3r (& self) -> & Ep3r { & self . ep3r }
#[doc = "0x10 - endpoint 4 register"]
#[inline (always)] pub const fn ep4r (& self) -> & Ep4r { & self . ep4r }
#[doc = "0x14 - endpoint 5 register"]
#[inline (always)] pub const fn ep5r (& self) -> & Ep5r { & self . ep5r }
#[doc = "0x18 - endpoint 6 register"]
#[inline (always)] pub const fn ep6r (& self) -> & Ep6r { & self . ep6r }
#[doc = "0x1c - endpoint 7 register"]
#[inline (always)] pub const fn ep7r (& self) -> & Ep7r { & self . ep7r }
#[doc = "0x40 - control register"]
#[inline (always)] pub const fn cntr (& self) -> & Cntr { & self . cntr }
#[doc = "0x44 - interrupt status register"]
#[inline (always)] pub const fn istr (& self) -> & Istr { & self . istr }
#[doc = "0x48 - frame number register"]
#[inline (always)] pub const fn fnr (& self) -> & Fnr { & self . fnr }
#[doc = "0x4c - device address"]
#[inline (always)] pub const fn daddr (& self) -> & Daddr { & self . daddr }
#[doc = "0x50 - Buffer table address"]
#[inline (always)] pub const fn btable (& self) -> & Btable { & self . btable }
#[doc = "0x52 - Transmission byte count 0"]
#[inline (always)] pub const fn count0_tx (& self) -> & Count0Tx { & self . count0_tx }
#[doc = "0x54 - control and status register"]
#[inline (always)] pub const fn lpmcsr (& self) -> & Lpmcsr { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (84) . cast () } }
#[doc = "0x54 - Reception buffer address 0"]
#[inline (always)] pub const fn addr0_rx (& self) -> & Addr0Rx { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (84) . cast () } }
#[doc = "0x56 - Reception byte count 0"]
#[inline (always)] pub const fn count0_rx (& self) -> & Count0Rx { & self . count0_rx }
#[doc = "0x58 - Battery charging detector("]
#[inline (always)] pub const fn bcdr (& self) -> & Bcdr { & self . bcdr }
#[doc = "0x5a - Transmission byte count 0"]
#[inline (always)] pub const fn count1_tx (& self) -> & Count1Tx { & self . count1_tx }
#[doc = "0x5c - Reception buffer address 0"]
#[inline (always)] pub const fn addr1_rx (& self) -> & Addr1Rx { & self . addr1_rx }
#[doc = "0x5e - Reception byte count 0"]
#[inline (always)] pub const fn count1_rx (& self) -> & Count1Rx { & self . count1_rx }
#[doc = "0x62 - Transmission byte count 0"]
#[inline (always)] pub const fn count2_tx (& self) -> & Count2Tx { & self . count2_tx }
#[doc = "0x64 - Reception buffer address 0"]
#[inline (always)] pub const fn addr2_rx (& self) -> & Addr2Rx { & self . addr2_rx }
#[doc = "0x66 - Reception byte count 0"]
#[inline (always)] pub const fn count2_rx (& self) -> & Count2Rx { & self . count2_rx }
#[doc = "0x6a - Transmission byte count 0"]
#[inline (always)] pub const fn count3_tx (& self) -> & Count3Tx { & self . count3_tx }
#[doc = "0x6c - Reception buffer address 0"]
#[inline (always)] pub const fn addr3_rx (& self) -> & Addr3Rx { & self . addr3_rx }
#[doc = "0x6e - Reception byte count 0"]
#[inline (always)] pub const fn count3_rx (& self) -> & Count3Rx { & self . count3_rx }
#[doc = "0x72 - Transmission byte count 0"]
#[inline (always)] pub const fn count4_tx (& self) -> & Count4Tx { & self . count4_tx }
#[doc = "0x74 - Reception buffer address 0"]
#[inline (always)] pub const fn addr4_rx (& self) -> & Addr4Rx { & self . addr4_rx }
#[doc = "0x76 - Reception byte count 0"]
#[inline (always)] pub const fn count4_rx (& self) -> & Count4Rx { & self . count4_rx }
#[doc = "0x7a - Transmission byte count 0"]
#[inline (always)] pub const fn count5_tx (& self) -> & Count5Tx { & self . count5_tx }
#[doc = "0x7c - Reception buffer address 0"]
#[inline (always)] pub const fn addr5_rx (& self) -> & Addr5Rx { & self . addr5_rx }
#[doc = "0x7e - Reception byte count 0"]
#[inline (always)] pub const fn count5_rx (& self) -> & Count5Rx { & self . count5_rx }
#[doc = "0x82 - Transmission byte count 0"]
#[inline (always)] pub const fn count6_tx (& self) -> & Count6Tx { & self . count6_tx }
#[doc = "0x84 - Reception buffer address 0"]
#[inline (always)] pub const fn addr6_rx (& self) -> & Addr6Rx { & self . addr6_rx }
#[doc = "0x86 - Reception byte count 0"]
#[inline (always)] pub const fn count6_rx (& self) -> & Count6Rx { & self . count6_rx }
#[doc = "0x8a - Transmission byte count 0"]
#[inline (always)] pub const fn count7_tx (& self) -> & Count7Tx { & self . count7_tx }
#[doc = "0x8c - Reception buffer address 0"]
#[inline (always)] pub const fn addr7_rx (& self) -> & Addr7Rx { & self . addr7_rx }
#[doc = "0x8e - Reception byte count 0"]
#[inline (always)] pub const fn count7_rx (& self) -> & Count7Rx { & self . count7_rx } }
#[doc = "EP0R (rw) register accessor: endpoint 0 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep0r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep0r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ep0r`] module"]
#[doc (alias = "EP0R")] pub type Ep0r = crate :: Reg < ep0r :: Ep0rSpec > ;
#[doc = "endpoint 0 register"] pub mod ep0r {
#[doc = "Register `EP0R` reader"] pub type R = crate :: R < Ep0rSpec > ;
#[doc = "Register `EP0R` writer"] pub type W = crate :: W < Ep0rSpec > ;
#[doc = "Field `EA` reader - Endpoint address"] pub type EaR = crate :: FieldReader ;
#[doc = "Field `EA` writer - Endpoint address"] pub type EaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `STAT_TX` reader - Status bits, for transmission transfers"] pub type StatTxR = crate :: FieldReader ;
#[doc = "Field `STAT_TX` writer - Status bits, for transmission transfers"] pub type StatTxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_TX` reader - Data Toggle, for transmission transfers"] pub type DtogTxR = crate :: BitReader ;
#[doc = "Field `DTOG_TX` writer - Data Toggle, for transmission transfers"] pub type DtogTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_TX` reader - Correct Transfer for transmission"] pub type CtrTxR = crate :: BitReader ;
#[doc = "Field `CTR_TX` writer - Correct Transfer for transmission"] pub type CtrTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_KIND` reader - Endpoint kind"] pub type EpKindR = crate :: BitReader ;
#[doc = "Field `EP_KIND` writer - Endpoint kind"] pub type EpKindW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_TYPE` reader - Endpoint type"] pub type EpTypeR = crate :: FieldReader ;
#[doc = "Field `EP_TYPE` writer - Endpoint type"] pub type EpTypeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SETUP` reader - Setup transaction completed"] pub type SetupR = crate :: BitReader ;
#[doc = "Field `SETUP` writer - Setup transaction completed"] pub type SetupW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STAT_RX` reader - Status bits, for reception transfers"] pub type StatRxR = crate :: FieldReader ;
#[doc = "Field `STAT_RX` writer - Status bits, for reception transfers"] pub type StatRxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_RX` reader - Data Toggle, for reception transfers"] pub type DtogRxR = crate :: BitReader ;
#[doc = "Field `DTOG_RX` writer - Data Toggle, for reception transfers"] pub type DtogRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_RX` reader - Correct transfer for reception"] pub type CtrRxR = crate :: BitReader ;
#[doc = "Field `CTR_RX` writer - Correct transfer for reception"] pub type CtrRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& self) -> EaR { EaR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& self) -> StatTxR { StatTxR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& self) -> DtogTxR { DtogTxR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& self) -> CtrTxR { CtrTxR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& self) -> EpKindR { EpKindR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& self) -> EpTypeR { EpTypeR :: new (((self . bits >> 9) & 3) as u8) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& self) -> SetupR { SetupR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& self) -> StatRxR { StatRxR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& self) -> DtogRxR { DtogRxR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& self) -> CtrRxR { CtrRxR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& mut self) -> EaW < '_ , Ep0rSpec > { EaW :: new (self , 0) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& mut self) -> StatTxW < '_ , Ep0rSpec > { StatTxW :: new (self , 4) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& mut self) -> DtogTxW < '_ , Ep0rSpec > { DtogTxW :: new (self , 6) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& mut self) -> CtrTxW < '_ , Ep0rSpec > { CtrTxW :: new (self , 7) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& mut self) -> EpKindW < '_ , Ep0rSpec > { EpKindW :: new (self , 8) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& mut self) -> EpTypeW < '_ , Ep0rSpec > { EpTypeW :: new (self , 9) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& mut self) -> SetupW < '_ , Ep0rSpec > { SetupW :: new (self , 11) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& mut self) -> StatRxW < '_ , Ep0rSpec > { StatRxW :: new (self , 12) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& mut self) -> DtogRxW < '_ , Ep0rSpec > { DtogRxW :: new (self , 14) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& mut self) -> CtrRxW < '_ , Ep0rSpec > { CtrRxW :: new (self , 15) } }
#[doc = "endpoint 0 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep0r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep0r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ep0rSpec ; impl crate :: RegisterSpec for Ep0rSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`ep0r::R`](R) reader structure"] impl crate :: Readable for Ep0rSpec { }
#[doc = "`write(|w| ..)` method takes [`ep0r::W`](W) writer structure"] impl crate :: Writable for Ep0rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EP0R to value 0"] impl crate :: Resettable for Ep0rSpec { } }
#[doc = "EP1R (rw) register accessor: endpoint 1 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep1r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep1r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ep1r`] module"]
#[doc (alias = "EP1R")] pub type Ep1r = crate :: Reg < ep1r :: Ep1rSpec > ;
#[doc = "endpoint 1 register"] pub mod ep1r {
#[doc = "Register `EP1R` reader"] pub type R = crate :: R < Ep1rSpec > ;
#[doc = "Register `EP1R` writer"] pub type W = crate :: W < Ep1rSpec > ;
#[doc = "Field `EA` reader - Endpoint address"] pub type EaR = crate :: FieldReader ;
#[doc = "Field `EA` writer - Endpoint address"] pub type EaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `STAT_TX` reader - Status bits, for transmission transfers"] pub type StatTxR = crate :: FieldReader ;
#[doc = "Field `STAT_TX` writer - Status bits, for transmission transfers"] pub type StatTxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_TX` reader - Data Toggle, for transmission transfers"] pub type DtogTxR = crate :: BitReader ;
#[doc = "Field `DTOG_TX` writer - Data Toggle, for transmission transfers"] pub type DtogTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_TX` reader - Correct Transfer for transmission"] pub type CtrTxR = crate :: BitReader ;
#[doc = "Field `CTR_TX` writer - Correct Transfer for transmission"] pub type CtrTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_KIND` reader - Endpoint kind"] pub type EpKindR = crate :: BitReader ;
#[doc = "Field `EP_KIND` writer - Endpoint kind"] pub type EpKindW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_TYPE` reader - Endpoint type"] pub type EpTypeR = crate :: FieldReader ;
#[doc = "Field `EP_TYPE` writer - Endpoint type"] pub type EpTypeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SETUP` reader - Setup transaction completed"] pub type SetupR = crate :: BitReader ;
#[doc = "Field `SETUP` writer - Setup transaction completed"] pub type SetupW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STAT_RX` reader - Status bits, for reception transfers"] pub type StatRxR = crate :: FieldReader ;
#[doc = "Field `STAT_RX` writer - Status bits, for reception transfers"] pub type StatRxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_RX` reader - Data Toggle, for reception transfers"] pub type DtogRxR = crate :: BitReader ;
#[doc = "Field `DTOG_RX` writer - Data Toggle, for reception transfers"] pub type DtogRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_RX` reader - Correct transfer for reception"] pub type CtrRxR = crate :: BitReader ;
#[doc = "Field `CTR_RX` writer - Correct transfer for reception"] pub type CtrRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& self) -> EaR { EaR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& self) -> StatTxR { StatTxR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& self) -> DtogTxR { DtogTxR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& self) -> CtrTxR { CtrTxR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& self) -> EpKindR { EpKindR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& self) -> EpTypeR { EpTypeR :: new (((self . bits >> 9) & 3) as u8) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& self) -> SetupR { SetupR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& self) -> StatRxR { StatRxR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& self) -> DtogRxR { DtogRxR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& self) -> CtrRxR { CtrRxR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& mut self) -> EaW < '_ , Ep1rSpec > { EaW :: new (self , 0) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& mut self) -> StatTxW < '_ , Ep1rSpec > { StatTxW :: new (self , 4) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& mut self) -> DtogTxW < '_ , Ep1rSpec > { DtogTxW :: new (self , 6) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& mut self) -> CtrTxW < '_ , Ep1rSpec > { CtrTxW :: new (self , 7) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& mut self) -> EpKindW < '_ , Ep1rSpec > { EpKindW :: new (self , 8) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& mut self) -> EpTypeW < '_ , Ep1rSpec > { EpTypeW :: new (self , 9) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& mut self) -> SetupW < '_ , Ep1rSpec > { SetupW :: new (self , 11) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& mut self) -> StatRxW < '_ , Ep1rSpec > { StatRxW :: new (self , 12) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& mut self) -> DtogRxW < '_ , Ep1rSpec > { DtogRxW :: new (self , 14) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& mut self) -> CtrRxW < '_ , Ep1rSpec > { CtrRxW :: new (self , 15) } }
#[doc = "endpoint 1 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep1r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep1r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ep1rSpec ; impl crate :: RegisterSpec for Ep1rSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`ep1r::R`](R) reader structure"] impl crate :: Readable for Ep1rSpec { }
#[doc = "`write(|w| ..)` method takes [`ep1r::W`](W) writer structure"] impl crate :: Writable for Ep1rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EP1R to value 0"] impl crate :: Resettable for Ep1rSpec { } }
#[doc = "EP2R (rw) register accessor: endpoint 2 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep2r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep2r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ep2r`] module"]
#[doc (alias = "EP2R")] pub type Ep2r = crate :: Reg < ep2r :: Ep2rSpec > ;
#[doc = "endpoint 2 register"] pub mod ep2r {
#[doc = "Register `EP2R` reader"] pub type R = crate :: R < Ep2rSpec > ;
#[doc = "Register `EP2R` writer"] pub type W = crate :: W < Ep2rSpec > ;
#[doc = "Field `EA` reader - Endpoint address"] pub type EaR = crate :: FieldReader ;
#[doc = "Field `EA` writer - Endpoint address"] pub type EaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `STAT_TX` reader - Status bits, for transmission transfers"] pub type StatTxR = crate :: FieldReader ;
#[doc = "Field `STAT_TX` writer - Status bits, for transmission transfers"] pub type StatTxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_TX` reader - Data Toggle, for transmission transfers"] pub type DtogTxR = crate :: BitReader ;
#[doc = "Field `DTOG_TX` writer - Data Toggle, for transmission transfers"] pub type DtogTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_TX` reader - Correct Transfer for transmission"] pub type CtrTxR = crate :: BitReader ;
#[doc = "Field `CTR_TX` writer - Correct Transfer for transmission"] pub type CtrTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_KIND` reader - Endpoint kind"] pub type EpKindR = crate :: BitReader ;
#[doc = "Field `EP_KIND` writer - Endpoint kind"] pub type EpKindW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_TYPE` reader - Endpoint type"] pub type EpTypeR = crate :: FieldReader ;
#[doc = "Field `EP_TYPE` writer - Endpoint type"] pub type EpTypeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SETUP` reader - Setup transaction completed"] pub type SetupR = crate :: BitReader ;
#[doc = "Field `SETUP` writer - Setup transaction completed"] pub type SetupW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STAT_RX` reader - Status bits, for reception transfers"] pub type StatRxR = crate :: FieldReader ;
#[doc = "Field `STAT_RX` writer - Status bits, for reception transfers"] pub type StatRxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_RX` reader - Data Toggle, for reception transfers"] pub type DtogRxR = crate :: BitReader ;
#[doc = "Field `DTOG_RX` writer - Data Toggle, for reception transfers"] pub type DtogRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_RX` reader - Correct transfer for reception"] pub type CtrRxR = crate :: BitReader ;
#[doc = "Field `CTR_RX` writer - Correct transfer for reception"] pub type CtrRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& self) -> EaR { EaR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& self) -> StatTxR { StatTxR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& self) -> DtogTxR { DtogTxR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& self) -> CtrTxR { CtrTxR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& self) -> EpKindR { EpKindR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& self) -> EpTypeR { EpTypeR :: new (((self . bits >> 9) & 3) as u8) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& self) -> SetupR { SetupR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& self) -> StatRxR { StatRxR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& self) -> DtogRxR { DtogRxR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& self) -> CtrRxR { CtrRxR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& mut self) -> EaW < '_ , Ep2rSpec > { EaW :: new (self , 0) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& mut self) -> StatTxW < '_ , Ep2rSpec > { StatTxW :: new (self , 4) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& mut self) -> DtogTxW < '_ , Ep2rSpec > { DtogTxW :: new (self , 6) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& mut self) -> CtrTxW < '_ , Ep2rSpec > { CtrTxW :: new (self , 7) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& mut self) -> EpKindW < '_ , Ep2rSpec > { EpKindW :: new (self , 8) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& mut self) -> EpTypeW < '_ , Ep2rSpec > { EpTypeW :: new (self , 9) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& mut self) -> SetupW < '_ , Ep2rSpec > { SetupW :: new (self , 11) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& mut self) -> StatRxW < '_ , Ep2rSpec > { StatRxW :: new (self , 12) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& mut self) -> DtogRxW < '_ , Ep2rSpec > { DtogRxW :: new (self , 14) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& mut self) -> CtrRxW < '_ , Ep2rSpec > { CtrRxW :: new (self , 15) } }
#[doc = "endpoint 2 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep2r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep2r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ep2rSpec ; impl crate :: RegisterSpec for Ep2rSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`ep2r::R`](R) reader structure"] impl crate :: Readable for Ep2rSpec { }
#[doc = "`write(|w| ..)` method takes [`ep2r::W`](W) writer structure"] impl crate :: Writable for Ep2rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EP2R to value 0"] impl crate :: Resettable for Ep2rSpec { } }
#[doc = "EP3R (rw) register accessor: endpoint 3 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep3r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep3r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ep3r`] module"]
#[doc (alias = "EP3R")] pub type Ep3r = crate :: Reg < ep3r :: Ep3rSpec > ;
#[doc = "endpoint 3 register"] pub mod ep3r {
#[doc = "Register `EP3R` reader"] pub type R = crate :: R < Ep3rSpec > ;
#[doc = "Register `EP3R` writer"] pub type W = crate :: W < Ep3rSpec > ;
#[doc = "Field `EA` reader - Endpoint address"] pub type EaR = crate :: FieldReader ;
#[doc = "Field `EA` writer - Endpoint address"] pub type EaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `STAT_TX` reader - Status bits, for transmission transfers"] pub type StatTxR = crate :: FieldReader ;
#[doc = "Field `STAT_TX` writer - Status bits, for transmission transfers"] pub type StatTxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_TX` reader - Data Toggle, for transmission transfers"] pub type DtogTxR = crate :: BitReader ;
#[doc = "Field `DTOG_TX` writer - Data Toggle, for transmission transfers"] pub type DtogTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_TX` reader - Correct Transfer for transmission"] pub type CtrTxR = crate :: BitReader ;
#[doc = "Field `CTR_TX` writer - Correct Transfer for transmission"] pub type CtrTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_KIND` reader - Endpoint kind"] pub type EpKindR = crate :: BitReader ;
#[doc = "Field `EP_KIND` writer - Endpoint kind"] pub type EpKindW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_TYPE` reader - Endpoint type"] pub type EpTypeR = crate :: FieldReader ;
#[doc = "Field `EP_TYPE` writer - Endpoint type"] pub type EpTypeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SETUP` reader - Setup transaction completed"] pub type SetupR = crate :: BitReader ;
#[doc = "Field `SETUP` writer - Setup transaction completed"] pub type SetupW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STAT_RX` reader - Status bits, for reception transfers"] pub type StatRxR = crate :: FieldReader ;
#[doc = "Field `STAT_RX` writer - Status bits, for reception transfers"] pub type StatRxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_RX` reader - Data Toggle, for reception transfers"] pub type DtogRxR = crate :: BitReader ;
#[doc = "Field `DTOG_RX` writer - Data Toggle, for reception transfers"] pub type DtogRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_RX` reader - Correct transfer for reception"] pub type CtrRxR = crate :: BitReader ;
#[doc = "Field `CTR_RX` writer - Correct transfer for reception"] pub type CtrRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& self) -> EaR { EaR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& self) -> StatTxR { StatTxR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& self) -> DtogTxR { DtogTxR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& self) -> CtrTxR { CtrTxR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& self) -> EpKindR { EpKindR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& self) -> EpTypeR { EpTypeR :: new (((self . bits >> 9) & 3) as u8) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& self) -> SetupR { SetupR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& self) -> StatRxR { StatRxR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& self) -> DtogRxR { DtogRxR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& self) -> CtrRxR { CtrRxR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& mut self) -> EaW < '_ , Ep3rSpec > { EaW :: new (self , 0) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& mut self) -> StatTxW < '_ , Ep3rSpec > { StatTxW :: new (self , 4) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& mut self) -> DtogTxW < '_ , Ep3rSpec > { DtogTxW :: new (self , 6) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& mut self) -> CtrTxW < '_ , Ep3rSpec > { CtrTxW :: new (self , 7) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& mut self) -> EpKindW < '_ , Ep3rSpec > { EpKindW :: new (self , 8) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& mut self) -> EpTypeW < '_ , Ep3rSpec > { EpTypeW :: new (self , 9) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& mut self) -> SetupW < '_ , Ep3rSpec > { SetupW :: new (self , 11) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& mut self) -> StatRxW < '_ , Ep3rSpec > { StatRxW :: new (self , 12) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& mut self) -> DtogRxW < '_ , Ep3rSpec > { DtogRxW :: new (self , 14) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& mut self) -> CtrRxW < '_ , Ep3rSpec > { CtrRxW :: new (self , 15) } }
#[doc = "endpoint 3 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep3r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep3r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ep3rSpec ; impl crate :: RegisterSpec for Ep3rSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`ep3r::R`](R) reader structure"] impl crate :: Readable for Ep3rSpec { }
#[doc = "`write(|w| ..)` method takes [`ep3r::W`](W) writer structure"] impl crate :: Writable for Ep3rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EP3R to value 0"] impl crate :: Resettable for Ep3rSpec { } }
#[doc = "EP4R (rw) register accessor: endpoint 4 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep4r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep4r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ep4r`] module"]
#[doc (alias = "EP4R")] pub type Ep4r = crate :: Reg < ep4r :: Ep4rSpec > ;
#[doc = "endpoint 4 register"] pub mod ep4r {
#[doc = "Register `EP4R` reader"] pub type R = crate :: R < Ep4rSpec > ;
#[doc = "Register `EP4R` writer"] pub type W = crate :: W < Ep4rSpec > ;
#[doc = "Field `EA` reader - Endpoint address"] pub type EaR = crate :: FieldReader ;
#[doc = "Field `EA` writer - Endpoint address"] pub type EaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `STAT_TX` reader - Status bits, for transmission transfers"] pub type StatTxR = crate :: FieldReader ;
#[doc = "Field `STAT_TX` writer - Status bits, for transmission transfers"] pub type StatTxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_TX` reader - Data Toggle, for transmission transfers"] pub type DtogTxR = crate :: BitReader ;
#[doc = "Field `DTOG_TX` writer - Data Toggle, for transmission transfers"] pub type DtogTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_TX` reader - Correct Transfer for transmission"] pub type CtrTxR = crate :: BitReader ;
#[doc = "Field `CTR_TX` writer - Correct Transfer for transmission"] pub type CtrTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_KIND` reader - Endpoint kind"] pub type EpKindR = crate :: BitReader ;
#[doc = "Field `EP_KIND` writer - Endpoint kind"] pub type EpKindW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_TYPE` reader - Endpoint type"] pub type EpTypeR = crate :: FieldReader ;
#[doc = "Field `EP_TYPE` writer - Endpoint type"] pub type EpTypeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SETUP` reader - Setup transaction completed"] pub type SetupR = crate :: BitReader ;
#[doc = "Field `SETUP` writer - Setup transaction completed"] pub type SetupW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STAT_RX` reader - Status bits, for reception transfers"] pub type StatRxR = crate :: FieldReader ;
#[doc = "Field `STAT_RX` writer - Status bits, for reception transfers"] pub type StatRxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_RX` reader - Data Toggle, for reception transfers"] pub type DtogRxR = crate :: BitReader ;
#[doc = "Field `DTOG_RX` writer - Data Toggle, for reception transfers"] pub type DtogRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_RX` reader - Correct transfer for reception"] pub type CtrRxR = crate :: BitReader ;
#[doc = "Field `CTR_RX` writer - Correct transfer for reception"] pub type CtrRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& self) -> EaR { EaR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& self) -> StatTxR { StatTxR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& self) -> DtogTxR { DtogTxR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& self) -> CtrTxR { CtrTxR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& self) -> EpKindR { EpKindR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& self) -> EpTypeR { EpTypeR :: new (((self . bits >> 9) & 3) as u8) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& self) -> SetupR { SetupR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& self) -> StatRxR { StatRxR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& self) -> DtogRxR { DtogRxR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& self) -> CtrRxR { CtrRxR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& mut self) -> EaW < '_ , Ep4rSpec > { EaW :: new (self , 0) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& mut self) -> StatTxW < '_ , Ep4rSpec > { StatTxW :: new (self , 4) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& mut self) -> DtogTxW < '_ , Ep4rSpec > { DtogTxW :: new (self , 6) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& mut self) -> CtrTxW < '_ , Ep4rSpec > { CtrTxW :: new (self , 7) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& mut self) -> EpKindW < '_ , Ep4rSpec > { EpKindW :: new (self , 8) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& mut self) -> EpTypeW < '_ , Ep4rSpec > { EpTypeW :: new (self , 9) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& mut self) -> SetupW < '_ , Ep4rSpec > { SetupW :: new (self , 11) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& mut self) -> StatRxW < '_ , Ep4rSpec > { StatRxW :: new (self , 12) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& mut self) -> DtogRxW < '_ , Ep4rSpec > { DtogRxW :: new (self , 14) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& mut self) -> CtrRxW < '_ , Ep4rSpec > { CtrRxW :: new (self , 15) } }
#[doc = "endpoint 4 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep4r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep4r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ep4rSpec ; impl crate :: RegisterSpec for Ep4rSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`ep4r::R`](R) reader structure"] impl crate :: Readable for Ep4rSpec { }
#[doc = "`write(|w| ..)` method takes [`ep4r::W`](W) writer structure"] impl crate :: Writable for Ep4rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EP4R to value 0"] impl crate :: Resettable for Ep4rSpec { } }
#[doc = "EP5R (rw) register accessor: endpoint 5 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep5r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep5r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ep5r`] module"]
#[doc (alias = "EP5R")] pub type Ep5r = crate :: Reg < ep5r :: Ep5rSpec > ;
#[doc = "endpoint 5 register"] pub mod ep5r {
#[doc = "Register `EP5R` reader"] pub type R = crate :: R < Ep5rSpec > ;
#[doc = "Register `EP5R` writer"] pub type W = crate :: W < Ep5rSpec > ;
#[doc = "Field `EA` reader - Endpoint address"] pub type EaR = crate :: FieldReader ;
#[doc = "Field `EA` writer - Endpoint address"] pub type EaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `STAT_TX` reader - Status bits, for transmission transfers"] pub type StatTxR = crate :: FieldReader ;
#[doc = "Field `STAT_TX` writer - Status bits, for transmission transfers"] pub type StatTxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_TX` reader - Data Toggle, for transmission transfers"] pub type DtogTxR = crate :: BitReader ;
#[doc = "Field `DTOG_TX` writer - Data Toggle, for transmission transfers"] pub type DtogTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_TX` reader - Correct Transfer for transmission"] pub type CtrTxR = crate :: BitReader ;
#[doc = "Field `CTR_TX` writer - Correct Transfer for transmission"] pub type CtrTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_KIND` reader - Endpoint kind"] pub type EpKindR = crate :: BitReader ;
#[doc = "Field `EP_KIND` writer - Endpoint kind"] pub type EpKindW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_TYPE` reader - Endpoint type"] pub type EpTypeR = crate :: FieldReader ;
#[doc = "Field `EP_TYPE` writer - Endpoint type"] pub type EpTypeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SETUP` reader - Setup transaction completed"] pub type SetupR = crate :: BitReader ;
#[doc = "Field `SETUP` writer - Setup transaction completed"] pub type SetupW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STAT_RX` reader - Status bits, for reception transfers"] pub type StatRxR = crate :: FieldReader ;
#[doc = "Field `STAT_RX` writer - Status bits, for reception transfers"] pub type StatRxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_RX` reader - Data Toggle, for reception transfers"] pub type DtogRxR = crate :: BitReader ;
#[doc = "Field `DTOG_RX` writer - Data Toggle, for reception transfers"] pub type DtogRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_RX` reader - Correct transfer for reception"] pub type CtrRxR = crate :: BitReader ;
#[doc = "Field `CTR_RX` writer - Correct transfer for reception"] pub type CtrRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& self) -> EaR { EaR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& self) -> StatTxR { StatTxR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& self) -> DtogTxR { DtogTxR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& self) -> CtrTxR { CtrTxR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& self) -> EpKindR { EpKindR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& self) -> EpTypeR { EpTypeR :: new (((self . bits >> 9) & 3) as u8) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& self) -> SetupR { SetupR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& self) -> StatRxR { StatRxR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& self) -> DtogRxR { DtogRxR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& self) -> CtrRxR { CtrRxR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& mut self) -> EaW < '_ , Ep5rSpec > { EaW :: new (self , 0) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& mut self) -> StatTxW < '_ , Ep5rSpec > { StatTxW :: new (self , 4) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& mut self) -> DtogTxW < '_ , Ep5rSpec > { DtogTxW :: new (self , 6) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& mut self) -> CtrTxW < '_ , Ep5rSpec > { CtrTxW :: new (self , 7) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& mut self) -> EpKindW < '_ , Ep5rSpec > { EpKindW :: new (self , 8) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& mut self) -> EpTypeW < '_ , Ep5rSpec > { EpTypeW :: new (self , 9) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& mut self) -> SetupW < '_ , Ep5rSpec > { SetupW :: new (self , 11) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& mut self) -> StatRxW < '_ , Ep5rSpec > { StatRxW :: new (self , 12) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& mut self) -> DtogRxW < '_ , Ep5rSpec > { DtogRxW :: new (self , 14) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& mut self) -> CtrRxW < '_ , Ep5rSpec > { CtrRxW :: new (self , 15) } }
#[doc = "endpoint 5 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep5r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep5r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ep5rSpec ; impl crate :: RegisterSpec for Ep5rSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`ep5r::R`](R) reader structure"] impl crate :: Readable for Ep5rSpec { }
#[doc = "`write(|w| ..)` method takes [`ep5r::W`](W) writer structure"] impl crate :: Writable for Ep5rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EP5R to value 0"] impl crate :: Resettable for Ep5rSpec { } }
#[doc = "EP6R (rw) register accessor: endpoint 6 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep6r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep6r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ep6r`] module"]
#[doc (alias = "EP6R")] pub type Ep6r = crate :: Reg < ep6r :: Ep6rSpec > ;
#[doc = "endpoint 6 register"] pub mod ep6r {
#[doc = "Register `EP6R` reader"] pub type R = crate :: R < Ep6rSpec > ;
#[doc = "Register `EP6R` writer"] pub type W = crate :: W < Ep6rSpec > ;
#[doc = "Field `EA` reader - Endpoint address"] pub type EaR = crate :: FieldReader ;
#[doc = "Field `EA` writer - Endpoint address"] pub type EaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `STAT_TX` reader - Status bits, for transmission transfers"] pub type StatTxR = crate :: FieldReader ;
#[doc = "Field `STAT_TX` writer - Status bits, for transmission transfers"] pub type StatTxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_TX` reader - Data Toggle, for transmission transfers"] pub type DtogTxR = crate :: BitReader ;
#[doc = "Field `DTOG_TX` writer - Data Toggle, for transmission transfers"] pub type DtogTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_TX` reader - Correct Transfer for transmission"] pub type CtrTxR = crate :: BitReader ;
#[doc = "Field `CTR_TX` writer - Correct Transfer for transmission"] pub type CtrTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_KIND` reader - Endpoint kind"] pub type EpKindR = crate :: BitReader ;
#[doc = "Field `EP_KIND` writer - Endpoint kind"] pub type EpKindW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_TYPE` reader - Endpoint type"] pub type EpTypeR = crate :: FieldReader ;
#[doc = "Field `EP_TYPE` writer - Endpoint type"] pub type EpTypeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SETUP` reader - Setup transaction completed"] pub type SetupR = crate :: BitReader ;
#[doc = "Field `SETUP` writer - Setup transaction completed"] pub type SetupW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STAT_RX` reader - Status bits, for reception transfers"] pub type StatRxR = crate :: FieldReader ;
#[doc = "Field `STAT_RX` writer - Status bits, for reception transfers"] pub type StatRxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_RX` reader - Data Toggle, for reception transfers"] pub type DtogRxR = crate :: BitReader ;
#[doc = "Field `DTOG_RX` writer - Data Toggle, for reception transfers"] pub type DtogRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_RX` reader - Correct transfer for reception"] pub type CtrRxR = crate :: BitReader ;
#[doc = "Field `CTR_RX` writer - Correct transfer for reception"] pub type CtrRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& self) -> EaR { EaR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& self) -> StatTxR { StatTxR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& self) -> DtogTxR { DtogTxR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& self) -> CtrTxR { CtrTxR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& self) -> EpKindR { EpKindR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& self) -> EpTypeR { EpTypeR :: new (((self . bits >> 9) & 3) as u8) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& self) -> SetupR { SetupR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& self) -> StatRxR { StatRxR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& self) -> DtogRxR { DtogRxR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& self) -> CtrRxR { CtrRxR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& mut self) -> EaW < '_ , Ep6rSpec > { EaW :: new (self , 0) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& mut self) -> StatTxW < '_ , Ep6rSpec > { StatTxW :: new (self , 4) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& mut self) -> DtogTxW < '_ , Ep6rSpec > { DtogTxW :: new (self , 6) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& mut self) -> CtrTxW < '_ , Ep6rSpec > { CtrTxW :: new (self , 7) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& mut self) -> EpKindW < '_ , Ep6rSpec > { EpKindW :: new (self , 8) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& mut self) -> EpTypeW < '_ , Ep6rSpec > { EpTypeW :: new (self , 9) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& mut self) -> SetupW < '_ , Ep6rSpec > { SetupW :: new (self , 11) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& mut self) -> StatRxW < '_ , Ep6rSpec > { StatRxW :: new (self , 12) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& mut self) -> DtogRxW < '_ , Ep6rSpec > { DtogRxW :: new (self , 14) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& mut self) -> CtrRxW < '_ , Ep6rSpec > { CtrRxW :: new (self , 15) } }
#[doc = "endpoint 6 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep6r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep6r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ep6rSpec ; impl crate :: RegisterSpec for Ep6rSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`ep6r::R`](R) reader structure"] impl crate :: Readable for Ep6rSpec { }
#[doc = "`write(|w| ..)` method takes [`ep6r::W`](W) writer structure"] impl crate :: Writable for Ep6rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EP6R to value 0"] impl crate :: Resettable for Ep6rSpec { } }
#[doc = "EP7R (rw) register accessor: endpoint 7 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep7r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep7r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ep7r`] module"]
#[doc (alias = "EP7R")] pub type Ep7r = crate :: Reg < ep7r :: Ep7rSpec > ;
#[doc = "endpoint 7 register"] pub mod ep7r {
#[doc = "Register `EP7R` reader"] pub type R = crate :: R < Ep7rSpec > ;
#[doc = "Register `EP7R` writer"] pub type W = crate :: W < Ep7rSpec > ;
#[doc = "Field `EA` reader - Endpoint address"] pub type EaR = crate :: FieldReader ;
#[doc = "Field `EA` writer - Endpoint address"] pub type EaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `STAT_TX` reader - Status bits, for transmission transfers"] pub type StatTxR = crate :: FieldReader ;
#[doc = "Field `STAT_TX` writer - Status bits, for transmission transfers"] pub type StatTxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_TX` reader - Data Toggle, for transmission transfers"] pub type DtogTxR = crate :: BitReader ;
#[doc = "Field `DTOG_TX` writer - Data Toggle, for transmission transfers"] pub type DtogTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_TX` reader - Correct Transfer for transmission"] pub type CtrTxR = crate :: BitReader ;
#[doc = "Field `CTR_TX` writer - Correct Transfer for transmission"] pub type CtrTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_KIND` reader - Endpoint kind"] pub type EpKindR = crate :: BitReader ;
#[doc = "Field `EP_KIND` writer - Endpoint kind"] pub type EpKindW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_TYPE` reader - Endpoint type"] pub type EpTypeR = crate :: FieldReader ;
#[doc = "Field `EP_TYPE` writer - Endpoint type"] pub type EpTypeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SETUP` reader - Setup transaction completed"] pub type SetupR = crate :: BitReader ;
#[doc = "Field `SETUP` writer - Setup transaction completed"] pub type SetupW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STAT_RX` reader - Status bits, for reception transfers"] pub type StatRxR = crate :: FieldReader ;
#[doc = "Field `STAT_RX` writer - Status bits, for reception transfers"] pub type StatRxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_RX` reader - Data Toggle, for reception transfers"] pub type DtogRxR = crate :: BitReader ;
#[doc = "Field `DTOG_RX` writer - Data Toggle, for reception transfers"] pub type DtogRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_RX` reader - Correct transfer for reception"] pub type CtrRxR = crate :: BitReader ;
#[doc = "Field `CTR_RX` writer - Correct transfer for reception"] pub type CtrRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& self) -> EaR { EaR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& self) -> StatTxR { StatTxR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& self) -> DtogTxR { DtogTxR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& self) -> CtrTxR { CtrTxR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& self) -> EpKindR { EpKindR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& self) -> EpTypeR { EpTypeR :: new (((self . bits >> 9) & 3) as u8) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& self) -> SetupR { SetupR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& self) -> StatRxR { StatRxR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& self) -> DtogRxR { DtogRxR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& self) -> CtrRxR { CtrRxR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& mut self) -> EaW < '_ , Ep7rSpec > { EaW :: new (self , 0) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& mut self) -> StatTxW < '_ , Ep7rSpec > { StatTxW :: new (self , 4) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& mut self) -> DtogTxW < '_ , Ep7rSpec > { DtogTxW :: new (self , 6) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& mut self) -> CtrTxW < '_ , Ep7rSpec > { CtrTxW :: new (self , 7) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& mut self) -> EpKindW < '_ , Ep7rSpec > { EpKindW :: new (self , 8) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& mut self) -> EpTypeW < '_ , Ep7rSpec > { EpTypeW :: new (self , 9) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& mut self) -> SetupW < '_ , Ep7rSpec > { SetupW :: new (self , 11) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& mut self) -> StatRxW < '_ , Ep7rSpec > { StatRxW :: new (self , 12) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& mut self) -> DtogRxW < '_ , Ep7rSpec > { DtogRxW :: new (self , 14) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& mut self) -> CtrRxW < '_ , Ep7rSpec > { CtrRxW :: new (self , 15) } }
#[doc = "endpoint 7 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep7r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep7r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ep7rSpec ; impl crate :: RegisterSpec for Ep7rSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`ep7r::R`](R) reader structure"] impl crate :: Readable for Ep7rSpec { }
#[doc = "`write(|w| ..)` method takes [`ep7r::W`](W) writer structure"] impl crate :: Writable for Ep7rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EP7R to value 0"] impl crate :: Resettable for Ep7rSpec { } }
#[doc = "CNTR (rw) register accessor: control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cntr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cntr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cntr`] module"]
#[doc (alias = "CNTR")] pub type Cntr = crate :: Reg < cntr :: CntrSpec > ;
#[doc = "control register"] pub mod cntr {
#[doc = "Register `CNTR` reader"] pub type R = crate :: R < CntrSpec > ;
#[doc = "Register `CNTR` writer"] pub type W = crate :: W < CntrSpec > ;
#[doc = "Field `FRES` reader - Force USB Reset"] pub type FresR = crate :: BitReader ;
#[doc = "Field `FRES` writer - Force USB Reset"] pub type FresW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PDWN` reader - Power down"] pub type PdwnR = crate :: BitReader ;
#[doc = "Field `PDWN` writer - Power down"] pub type PdwnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LPMODE` reader - Low-power mode"] pub type LpmodeR = crate :: BitReader ;
#[doc = "Field `LPMODE` writer - Low-power mode"] pub type LpmodeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FSUSP` reader - Force suspend"] pub type FsuspR = crate :: BitReader ;
#[doc = "Field `FSUSP` writer - Force suspend"] pub type FsuspW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RESUME` reader - Resume request"] pub type ResumeR = crate :: BitReader ;
#[doc = "Field `RESUME` writer - Resume request"] pub type ResumeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `L1RESUME` reader - LPM L1 Resume request"] pub type L1resumeR = crate :: BitReader ;
#[doc = "Field `L1RESUME` writer - LPM L1 Resume request"] pub type L1resumeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `L1REQM` reader - LPM L1 state request interrupt mask"] pub type L1reqmR = crate :: BitReader ;
#[doc = "Field `L1REQM` writer - LPM L1 state request interrupt mask"] pub type L1reqmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ESOFM` reader - Expected start of frame interrupt mask"] pub type EsofmR = crate :: BitReader ;
#[doc = "Field `ESOFM` writer - Expected start of frame interrupt mask"] pub type EsofmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SOFM` reader - Start of frame interrupt mask"] pub type SofmR = crate :: BitReader ;
#[doc = "Field `SOFM` writer - Start of frame interrupt mask"] pub type SofmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RESETM` reader - USB reset interrupt mask"] pub type ResetmR = crate :: BitReader ;
#[doc = "Field `RESETM` writer - USB reset interrupt mask"] pub type ResetmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SUSPM` reader - Suspend mode interrupt mask"] pub type SuspmR = crate :: BitReader ;
#[doc = "Field `SUSPM` writer - Suspend mode interrupt mask"] pub type SuspmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WKUPM` reader - Wakeup interrupt mask"] pub type WkupmR = crate :: BitReader ;
#[doc = "Field `WKUPM` writer - Wakeup interrupt mask"] pub type WkupmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ERRM` reader - Error interrupt mask"] pub type ErrmR = crate :: BitReader ;
#[doc = "Field `ERRM` writer - Error interrupt mask"] pub type ErrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PMAOVRM` reader - Packet memory area over / underrun interrupt mask"] pub type PmaovrmR = crate :: BitReader ;
#[doc = "Field `PMAOVRM` writer - Packet memory area over / underrun interrupt mask"] pub type PmaovrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTRM` reader - Correct transfer interrupt mask"] pub type CtrmR = crate :: BitReader ;
#[doc = "Field `CTRM` writer - Correct transfer interrupt mask"] pub type CtrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Force USB Reset"]
#[inline (always)] pub fn fres (& self) -> FresR { FresR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Power down"]
#[inline (always)] pub fn pdwn (& self) -> PdwnR { PdwnR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Low-power mode"]
#[inline (always)] pub fn lpmode (& self) -> LpmodeR { LpmodeR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Force suspend"]
#[inline (always)] pub fn fsusp (& self) -> FsuspR { FsuspR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Resume request"]
#[inline (always)] pub fn resume (& self) -> ResumeR { ResumeR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - LPM L1 Resume request"]
#[inline (always)] pub fn l1resume (& self) -> L1resumeR { L1resumeR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 7 - LPM L1 state request interrupt mask"]
#[inline (always)] pub fn l1reqm (& self) -> L1reqmR { L1reqmR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Expected start of frame interrupt mask"]
#[inline (always)] pub fn esofm (& self) -> EsofmR { EsofmR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Start of frame interrupt mask"]
#[inline (always)] pub fn sofm (& self) -> SofmR { SofmR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - USB reset interrupt mask"]
#[inline (always)] pub fn resetm (& self) -> ResetmR { ResetmR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Suspend mode interrupt mask"]
#[inline (always)] pub fn suspm (& self) -> SuspmR { SuspmR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Wakeup interrupt mask"]
#[inline (always)] pub fn wkupm (& self) -> WkupmR { WkupmR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Error interrupt mask"]
#[inline (always)] pub fn errm (& self) -> ErrmR { ErrmR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Packet memory area over / underrun interrupt mask"]
#[inline (always)] pub fn pmaovrm (& self) -> PmaovrmR { PmaovrmR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Correct transfer interrupt mask"]
#[inline (always)] pub fn ctrm (& self) -> CtrmR { CtrmR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Force USB Reset"]
#[inline (always)] pub fn fres (& mut self) -> FresW < '_ , CntrSpec > { FresW :: new (self , 0) }
#[doc = "Bit 1 - Power down"]
#[inline (always)] pub fn pdwn (& mut self) -> PdwnW < '_ , CntrSpec > { PdwnW :: new (self , 1) }
#[doc = "Bit 2 - Low-power mode"]
#[inline (always)] pub fn lpmode (& mut self) -> LpmodeW < '_ , CntrSpec > { LpmodeW :: new (self , 2) }
#[doc = "Bit 3 - Force suspend"]
#[inline (always)] pub fn fsusp (& mut self) -> FsuspW < '_ , CntrSpec > { FsuspW :: new (self , 3) }
#[doc = "Bit 4 - Resume request"]
#[inline (always)] pub fn resume (& mut self) -> ResumeW < '_ , CntrSpec > { ResumeW :: new (self , 4) }
#[doc = "Bit 5 - LPM L1 Resume request"]
#[inline (always)] pub fn l1resume (& mut self) -> L1resumeW < '_ , CntrSpec > { L1resumeW :: new (self , 5) }
#[doc = "Bit 7 - LPM L1 state request interrupt mask"]
#[inline (always)] pub fn l1reqm (& mut self) -> L1reqmW < '_ , CntrSpec > { L1reqmW :: new (self , 7) }
#[doc = "Bit 8 - Expected start of frame interrupt mask"]
#[inline (always)] pub fn esofm (& mut self) -> EsofmW < '_ , CntrSpec > { EsofmW :: new (self , 8) }
#[doc = "Bit 9 - Start of frame interrupt mask"]
#[inline (always)] pub fn sofm (& mut self) -> SofmW < '_ , CntrSpec > { SofmW :: new (self , 9) }
#[doc = "Bit 10 - USB reset interrupt mask"]
#[inline (always)] pub fn resetm (& mut self) -> ResetmW < '_ , CntrSpec > { ResetmW :: new (self , 10) }
#[doc = "Bit 11 - Suspend mode interrupt mask"]
#[inline (always)] pub fn suspm (& mut self) -> SuspmW < '_ , CntrSpec > { SuspmW :: new (self , 11) }
#[doc = "Bit 12 - Wakeup interrupt mask"]
#[inline (always)] pub fn wkupm (& mut self) -> WkupmW < '_ , CntrSpec > { WkupmW :: new (self , 12) }
#[doc = "Bit 13 - Error interrupt mask"]
#[inline (always)] pub fn errm (& mut self) -> ErrmW < '_ , CntrSpec > { ErrmW :: new (self , 13) }
#[doc = "Bit 14 - Packet memory area over / underrun interrupt mask"]
#[inline (always)] pub fn pmaovrm (& mut self) -> PmaovrmW < '_ , CntrSpec > { PmaovrmW :: new (self , 14) }
#[doc = "Bit 15 - Correct transfer interrupt mask"]
#[inline (always)] pub fn ctrm (& mut self) -> CtrmW < '_ , CntrSpec > { CtrmW :: new (self , 15) } }
#[doc = "control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cntr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cntr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CntrSpec ; impl crate :: RegisterSpec for CntrSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`cntr::R`](R) reader structure"] impl crate :: Readable for CntrSpec { }
#[doc = "`write(|w| ..)` method takes [`cntr::W`](W) writer structure"] impl crate :: Writable for CntrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNTR to value 0x03"] impl crate :: Resettable for CntrSpec { const RESET_VALUE : u16 = 0x03 ; } }
#[doc = "ISTR (rw) register accessor: interrupt status register\n\nYou can [`read`](crate::Reg::read) this register and get [`istr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`istr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@istr`] module"]
#[doc (alias = "ISTR")] pub type Istr = crate :: Reg < istr :: IstrSpec > ;
#[doc = "interrupt status register"] pub mod istr {
#[doc = "Register `ISTR` reader"] pub type R = crate :: R < IstrSpec > ;
#[doc = "Register `ISTR` writer"] pub type W = crate :: W < IstrSpec > ;
#[doc = "Field `EP_ID` reader - Endpoint Identifier"] pub type EpIdR = crate :: FieldReader ;
#[doc = "Field `DIR` reader - Direction of transaction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `L1REQ` reader - LPM L1 state request"] pub type L1reqR = crate :: BitReader ;
#[doc = "Field `L1REQ` writer - LPM L1 state request"] pub type L1reqW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ESOF` reader - Expected start frame"] pub type EsofR = crate :: BitReader ;
#[doc = "Field `ESOF` writer - Expected start frame"] pub type EsofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SOF` reader - start of frame"] pub type SofR = crate :: BitReader ;
#[doc = "Field `SOF` writer - start of frame"] pub type SofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RESET` reader - reset request"] pub type ResetR = crate :: BitReader ;
#[doc = "Field `RESET` writer - reset request"] pub type ResetW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SUSP` reader - Suspend mode request"] pub type SuspR = crate :: BitReader ;
#[doc = "Field `SUSP` writer - Suspend mode request"] pub type SuspW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WKUP` reader - Wakeup"] pub type WkupR = crate :: BitReader ;
#[doc = "Field `WKUP` writer - Wakeup"] pub type WkupW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ERR` reader - Error"] pub type ErrR = crate :: BitReader ;
#[doc = "Field `ERR` writer - Error"] pub type ErrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PMAOVR` reader - Packet memory area over / underrun"] pub type PmaovrR = crate :: BitReader ;
#[doc = "Field `PMAOVR` writer - Packet memory area over / underrun"] pub type PmaovrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR` reader - Correct transfer"] pub type CtrR = crate :: BitReader ; impl R {
#[doc = "Bits 0:3 - Endpoint Identifier"]
#[inline (always)] pub fn ep_id (& self) -> EpIdR { EpIdR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bit 4 - Direction of transaction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 7 - LPM L1 state request"]
#[inline (always)] pub fn l1req (& self) -> L1reqR { L1reqR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Expected start frame"]
#[inline (always)] pub fn esof (& self) -> EsofR { EsofR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - start of frame"]
#[inline (always)] pub fn sof (& self) -> SofR { SofR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - reset request"]
#[inline (always)] pub fn reset (& self) -> ResetR { ResetR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Suspend mode request"]
#[inline (always)] pub fn susp (& self) -> SuspR { SuspR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Wakeup"]
#[inline (always)] pub fn wkup (& self) -> WkupR { WkupR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Error"]
#[inline (always)] pub fn err (& self) -> ErrR { ErrR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Packet memory area over / underrun"]
#[inline (always)] pub fn pmaovr (& self) -> PmaovrR { PmaovrR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Correct transfer"]
#[inline (always)] pub fn ctr (& self) -> CtrR { CtrR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 7 - LPM L1 state request"]
#[inline (always)] pub fn l1req (& mut self) -> L1reqW < '_ , IstrSpec > { L1reqW :: new (self , 7) }
#[doc = "Bit 8 - Expected start frame"]
#[inline (always)] pub fn esof (& mut self) -> EsofW < '_ , IstrSpec > { EsofW :: new (self , 8) }
#[doc = "Bit 9 - start of frame"]
#[inline (always)] pub fn sof (& mut self) -> SofW < '_ , IstrSpec > { SofW :: new (self , 9) }
#[doc = "Bit 10 - reset request"]
#[inline (always)] pub fn reset (& mut self) -> ResetW < '_ , IstrSpec > { ResetW :: new (self , 10) }
#[doc = "Bit 11 - Suspend mode request"]
#[inline (always)] pub fn susp (& mut self) -> SuspW < '_ , IstrSpec > { SuspW :: new (self , 11) }
#[doc = "Bit 12 - Wakeup"]
#[inline (always)] pub fn wkup (& mut self) -> WkupW < '_ , IstrSpec > { WkupW :: new (self , 12) }
#[doc = "Bit 13 - Error"]
#[inline (always)] pub fn err (& mut self) -> ErrW < '_ , IstrSpec > { ErrW :: new (self , 13) }
#[doc = "Bit 14 - Packet memory area over / underrun"]
#[inline (always)] pub fn pmaovr (& mut self) -> PmaovrW < '_ , IstrSpec > { PmaovrW :: new (self , 14) } }
#[doc = "interrupt status register\n\nYou can [`read`](crate::Reg::read) this register and get [`istr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`istr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IstrSpec ; impl crate :: RegisterSpec for IstrSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`istr::R`](R) reader structure"] impl crate :: Readable for IstrSpec { }
#[doc = "`write(|w| ..)` method takes [`istr::W`](W) writer structure"] impl crate :: Writable for IstrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ISTR to value 0"] impl crate :: Resettable for IstrSpec { } }
#[doc = "FNR (r) register accessor: frame number register\n\nYou can [`read`](crate::Reg::read) this register and get [`fnr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fnr`] module"]
#[doc (alias = "FNR")] pub type Fnr = crate :: Reg < fnr :: FnrSpec > ;
#[doc = "frame number register"] pub mod fnr {
#[doc = "Register `FNR` reader"] pub type R = crate :: R < FnrSpec > ;
#[doc = "Field `FN` reader - Frame number"] pub type FnR = crate :: FieldReader < u16 > ;
#[doc = "Field `LSOF` reader - Lost SOF"] pub type LsofR = crate :: FieldReader ;
#[doc = "Field `LCK` reader - Locked"] pub type LckR = crate :: BitReader ;
#[doc = "Field `RXDM` reader - Receive data - line status"] pub type RxdmR = crate :: BitReader ;
#[doc = "Field `RXDP` reader - Receive data + line status"] pub type RxdpR = crate :: BitReader ; impl R {
#[doc = "Bits 0:10 - Frame number"]
#[inline (always)] pub fn fn_ (& self) -> FnR { FnR :: new (self . bits & 0x07ff) }
#[doc = "Bits 11:12 - Lost SOF"]
#[inline (always)] pub fn lsof (& self) -> LsofR { LsofR :: new (((self . bits >> 11) & 3) as u8) }
#[doc = "Bit 13 - Locked"]
#[inline (always)] pub fn lck (& self) -> LckR { LckR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Receive data - line status"]
#[inline (always)] pub fn rxdm (& self) -> RxdmR { RxdmR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Receive data + line status"]
#[inline (always)] pub fn rxdp (& self) -> RxdpR { RxdpR :: new (((self . bits >> 15) & 1) != 0) } }
#[doc = "frame number register\n\nYou can [`read`](crate::Reg::read) this register and get [`fnr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FnrSpec ; impl crate :: RegisterSpec for FnrSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`fnr::R`](R) reader structure"] impl crate :: Readable for FnrSpec { }
#[doc = "`reset()` method sets FNR to value 0"] impl crate :: Resettable for FnrSpec { } }
#[doc = "DADDR (rw) register accessor: device address\n\nYou can [`read`](crate::Reg::read) this register and get [`daddr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`daddr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@daddr`] module"]
#[doc (alias = "DADDR")] pub type Daddr = crate :: Reg < daddr :: DaddrSpec > ;
#[doc = "device address"] pub mod daddr {
#[doc = "Register `DADDR` reader"] pub type R = crate :: R < DaddrSpec > ;
#[doc = "Register `DADDR` writer"] pub type W = crate :: W < DaddrSpec > ;
#[doc = "Field `ADD` reader - Device address"] pub type AddR = crate :: FieldReader ;
#[doc = "Field `ADD` writer - Device address"] pub type AddW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `EF` reader - Enable function"] pub type EfR = crate :: BitReader ;
#[doc = "Field `EF` writer - Enable function"] pub type EfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:6 - Device address"]
#[inline (always)] pub fn add (& self) -> AddR { AddR :: new ((self . bits & 0x7f) as u8) }
#[doc = "Bit 7 - Enable function"]
#[inline (always)] pub fn ef (& self) -> EfR { EfR :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:6 - Device address"]
#[inline (always)] pub fn add (& mut self) -> AddW < '_ , DaddrSpec > { AddW :: new (self , 0) }
#[doc = "Bit 7 - Enable function"]
#[inline (always)] pub fn ef (& mut self) -> EfW < '_ , DaddrSpec > { EfW :: new (self , 7) } }
#[doc = "device address\n\nYou can [`read`](crate::Reg::read) this register and get [`daddr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`daddr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DaddrSpec ; impl crate :: RegisterSpec for DaddrSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`daddr::R`](R) reader structure"] impl crate :: Readable for DaddrSpec { }
#[doc = "`write(|w| ..)` method takes [`daddr::W`](W) writer structure"] impl crate :: Writable for DaddrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DADDR to value 0"] impl crate :: Resettable for DaddrSpec { } }
#[doc = "BTABLE (rw) register accessor: Buffer table address\n\nYou can [`read`](crate::Reg::read) this register and get [`btable::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`btable::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@btable`] module"]
#[doc (alias = "BTABLE")] pub type Btable = crate :: Reg < btable :: BtableSpec > ;
#[doc = "Buffer table address"] pub mod btable {
#[doc = "Register `BTABLE` reader"] pub type R = crate :: R < BtableSpec > ;
#[doc = "Register `BTABLE` writer"] pub type W = crate :: W < BtableSpec > ;
#[doc = "Field `BTABLE` reader - Buffer table"] pub type BtableR = crate :: FieldReader < u16 > ;
#[doc = "Field `BTABLE` writer - Buffer table"] pub type BtableW < 'a , REG > = crate :: FieldWriter < 'a , REG , 13 , u16 > ; impl R {
#[doc = "Bits 3:15 - Buffer table"]
#[inline (always)] pub fn btable (& self) -> BtableR { BtableR :: new ((self . bits >> 3) & 0x1fff) } } impl W {
#[doc = "Bits 3:15 - Buffer table"]
#[inline (always)] pub fn btable (& mut self) -> BtableW < '_ , BtableSpec > { BtableW :: new (self , 3) } }
#[doc = "Buffer table address\n\nYou can [`read`](crate::Reg::read) this register and get [`btable::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`btable::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BtableSpec ; impl crate :: RegisterSpec for BtableSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`btable::R`](R) reader structure"] impl crate :: Readable for BtableSpec { }
#[doc = "`write(|w| ..)` method takes [`btable::W`](W) writer structure"] impl crate :: Writable for BtableSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BTABLE to value 0"] impl crate :: Resettable for BtableSpec { } }
#[doc = "COUNT0_TX (rw) register accessor: Transmission byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count0_tx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count0_tx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@count0_tx`] module"]
#[doc (alias = "COUNT0_TX")] pub type Count0Tx = crate :: Reg < count0_tx :: Count0TxSpec > ;
#[doc = "Transmission byte count 0"] pub mod count0_tx {
#[doc = "Register `COUNT0_TX` reader"] pub type R = crate :: R < Count0TxSpec > ;
#[doc = "Register `COUNT0_TX` writer"] pub type W = crate :: W < Count0TxSpec > ;
#[doc = "Field `COUNT0_TX` reader - Transmission byte count"] pub type Count0TxR = crate :: FieldReader < u16 > ;
#[doc = "Field `COUNT0_TX` writer - Transmission byte count"] pub type Count0TxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ; impl R {
#[doc = "Bits 0:9 - Transmission byte count"]
#[inline (always)] pub fn count0_tx (& self) -> Count0TxR { Count0TxR :: new (self . bits & 0x03ff) } } impl W {
#[doc = "Bits 0:9 - Transmission byte count"]
#[inline (always)] pub fn count0_tx (& mut self) -> Count0TxW < '_ , Count0TxSpec > { Count0TxW :: new (self , 0) } }
#[doc = "Transmission byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count0_tx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count0_tx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Count0TxSpec ; impl crate :: RegisterSpec for Count0TxSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`count0_tx::R`](R) reader structure"] impl crate :: Readable for Count0TxSpec { }
#[doc = "`write(|w| ..)` method takes [`count0_tx::W`](W) writer structure"] impl crate :: Writable for Count0TxSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets COUNT0_TX to value 0"] impl crate :: Resettable for Count0TxSpec { } }
#[doc = "COUNT1_TX (rw) register accessor: Transmission byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count1_tx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count1_tx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@count1_tx`] module"]
#[doc (alias = "COUNT1_TX")] pub type Count1Tx = crate :: Reg < count1_tx :: Count1TxSpec > ;
#[doc = "Transmission byte count 0"] pub mod count1_tx {
#[doc = "Register `COUNT1_TX` reader"] pub type R = crate :: R < Count1TxSpec > ;
#[doc = "Register `COUNT1_TX` writer"] pub type W = crate :: W < Count1TxSpec > ;
#[doc = "Field `COUNT1_TX` reader - Transmission byte count"] pub type Count1TxR = crate :: FieldReader < u16 > ;
#[doc = "Field `COUNT1_TX` writer - Transmission byte count"] pub type Count1TxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ; impl R {
#[doc = "Bits 0:9 - Transmission byte count"]
#[inline (always)] pub fn count1_tx (& self) -> Count1TxR { Count1TxR :: new (self . bits & 0x03ff) } } impl W {
#[doc = "Bits 0:9 - Transmission byte count"]
#[inline (always)] pub fn count1_tx (& mut self) -> Count1TxW < '_ , Count1TxSpec > { Count1TxW :: new (self , 0) } }
#[doc = "Transmission byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count1_tx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count1_tx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Count1TxSpec ; impl crate :: RegisterSpec for Count1TxSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`count1_tx::R`](R) reader structure"] impl crate :: Readable for Count1TxSpec { }
#[doc = "`write(|w| ..)` method takes [`count1_tx::W`](W) writer structure"] impl crate :: Writable for Count1TxSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets COUNT1_TX to value 0"] impl crate :: Resettable for Count1TxSpec { } }
#[doc = "COUNT2_TX (rw) register accessor: Transmission byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count2_tx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count2_tx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@count2_tx`] module"]
#[doc (alias = "COUNT2_TX")] pub type Count2Tx = crate :: Reg < count2_tx :: Count2TxSpec > ;
#[doc = "Transmission byte count 0"] pub mod count2_tx {
#[doc = "Register `COUNT2_TX` reader"] pub type R = crate :: R < Count2TxSpec > ;
#[doc = "Register `COUNT2_TX` writer"] pub type W = crate :: W < Count2TxSpec > ;
#[doc = "Field `COUNT2_TX` reader - Transmission byte count"] pub type Count2TxR = crate :: FieldReader < u16 > ;
#[doc = "Field `COUNT2_TX` writer - Transmission byte count"] pub type Count2TxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ; impl R {
#[doc = "Bits 0:9 - Transmission byte count"]
#[inline (always)] pub fn count2_tx (& self) -> Count2TxR { Count2TxR :: new (self . bits & 0x03ff) } } impl W {
#[doc = "Bits 0:9 - Transmission byte count"]
#[inline (always)] pub fn count2_tx (& mut self) -> Count2TxW < '_ , Count2TxSpec > { Count2TxW :: new (self , 0) } }
#[doc = "Transmission byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count2_tx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count2_tx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Count2TxSpec ; impl crate :: RegisterSpec for Count2TxSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`count2_tx::R`](R) reader structure"] impl crate :: Readable for Count2TxSpec { }
#[doc = "`write(|w| ..)` method takes [`count2_tx::W`](W) writer structure"] impl crate :: Writable for Count2TxSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets COUNT2_TX to value 0"] impl crate :: Resettable for Count2TxSpec { } }
#[doc = "COUNT3_TX (rw) register accessor: Transmission byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count3_tx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count3_tx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@count3_tx`] module"]
#[doc (alias = "COUNT3_TX")] pub type Count3Tx = crate :: Reg < count3_tx :: Count3TxSpec > ;
#[doc = "Transmission byte count 0"] pub mod count3_tx {
#[doc = "Register `COUNT3_TX` reader"] pub type R = crate :: R < Count3TxSpec > ;
#[doc = "Register `COUNT3_TX` writer"] pub type W = crate :: W < Count3TxSpec > ;
#[doc = "Field `COUNT3_TX` reader - Transmission byte count"] pub type Count3TxR = crate :: FieldReader < u16 > ;
#[doc = "Field `COUNT3_TX` writer - Transmission byte count"] pub type Count3TxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ; impl R {
#[doc = "Bits 0:9 - Transmission byte count"]
#[inline (always)] pub fn count3_tx (& self) -> Count3TxR { Count3TxR :: new (self . bits & 0x03ff) } } impl W {
#[doc = "Bits 0:9 - Transmission byte count"]
#[inline (always)] pub fn count3_tx (& mut self) -> Count3TxW < '_ , Count3TxSpec > { Count3TxW :: new (self , 0) } }
#[doc = "Transmission byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count3_tx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count3_tx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Count3TxSpec ; impl crate :: RegisterSpec for Count3TxSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`count3_tx::R`](R) reader structure"] impl crate :: Readable for Count3TxSpec { }
#[doc = "`write(|w| ..)` method takes [`count3_tx::W`](W) writer structure"] impl crate :: Writable for Count3TxSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets COUNT3_TX to value 0"] impl crate :: Resettable for Count3TxSpec { } }
#[doc = "COUNT4_TX (rw) register accessor: Transmission byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count4_tx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count4_tx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@count4_tx`] module"]
#[doc (alias = "COUNT4_TX")] pub type Count4Tx = crate :: Reg < count4_tx :: Count4TxSpec > ;
#[doc = "Transmission byte count 0"] pub mod count4_tx {
#[doc = "Register `COUNT4_TX` reader"] pub type R = crate :: R < Count4TxSpec > ;
#[doc = "Register `COUNT4_TX` writer"] pub type W = crate :: W < Count4TxSpec > ;
#[doc = "Field `COUNT4_TX` reader - Transmission byte count"] pub type Count4TxR = crate :: FieldReader < u16 > ;
#[doc = "Field `COUNT4_TX` writer - Transmission byte count"] pub type Count4TxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ; impl R {
#[doc = "Bits 0:9 - Transmission byte count"]
#[inline (always)] pub fn count4_tx (& self) -> Count4TxR { Count4TxR :: new (self . bits & 0x03ff) } } impl W {
#[doc = "Bits 0:9 - Transmission byte count"]
#[inline (always)] pub fn count4_tx (& mut self) -> Count4TxW < '_ , Count4TxSpec > { Count4TxW :: new (self , 0) } }
#[doc = "Transmission byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count4_tx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count4_tx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Count4TxSpec ; impl crate :: RegisterSpec for Count4TxSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`count4_tx::R`](R) reader structure"] impl crate :: Readable for Count4TxSpec { }
#[doc = "`write(|w| ..)` method takes [`count4_tx::W`](W) writer structure"] impl crate :: Writable for Count4TxSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets COUNT4_TX to value 0"] impl crate :: Resettable for Count4TxSpec { } }
#[doc = "COUNT5_TX (rw) register accessor: Transmission byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count5_tx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count5_tx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@count5_tx`] module"]
#[doc (alias = "COUNT5_TX")] pub type Count5Tx = crate :: Reg < count5_tx :: Count5TxSpec > ;
#[doc = "Transmission byte count 0"] pub mod count5_tx {
#[doc = "Register `COUNT5_TX` reader"] pub type R = crate :: R < Count5TxSpec > ;
#[doc = "Register `COUNT5_TX` writer"] pub type W = crate :: W < Count5TxSpec > ;
#[doc = "Field `COUNT5_TX` reader - Transmission byte count"] pub type Count5TxR = crate :: FieldReader < u16 > ;
#[doc = "Field `COUNT5_TX` writer - Transmission byte count"] pub type Count5TxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ; impl R {
#[doc = "Bits 0:9 - Transmission byte count"]
#[inline (always)] pub fn count5_tx (& self) -> Count5TxR { Count5TxR :: new (self . bits & 0x03ff) } } impl W {
#[doc = "Bits 0:9 - Transmission byte count"]
#[inline (always)] pub fn count5_tx (& mut self) -> Count5TxW < '_ , Count5TxSpec > { Count5TxW :: new (self , 0) } }
#[doc = "Transmission byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count5_tx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count5_tx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Count5TxSpec ; impl crate :: RegisterSpec for Count5TxSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`count5_tx::R`](R) reader structure"] impl crate :: Readable for Count5TxSpec { }
#[doc = "`write(|w| ..)` method takes [`count5_tx::W`](W) writer structure"] impl crate :: Writable for Count5TxSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets COUNT5_TX to value 0"] impl crate :: Resettable for Count5TxSpec { } }
#[doc = "COUNT6_TX (rw) register accessor: Transmission byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count6_tx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count6_tx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@count6_tx`] module"]
#[doc (alias = "COUNT6_TX")] pub type Count6Tx = crate :: Reg < count6_tx :: Count6TxSpec > ;
#[doc = "Transmission byte count 0"] pub mod count6_tx {
#[doc = "Register `COUNT6_TX` reader"] pub type R = crate :: R < Count6TxSpec > ;
#[doc = "Register `COUNT6_TX` writer"] pub type W = crate :: W < Count6TxSpec > ;
#[doc = "Field `COUNT6_TX` reader - Transmission byte count"] pub type Count6TxR = crate :: FieldReader < u16 > ;
#[doc = "Field `COUNT6_TX` writer - Transmission byte count"] pub type Count6TxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ; impl R {
#[doc = "Bits 0:9 - Transmission byte count"]
#[inline (always)] pub fn count6_tx (& self) -> Count6TxR { Count6TxR :: new (self . bits & 0x03ff) } } impl W {
#[doc = "Bits 0:9 - Transmission byte count"]
#[inline (always)] pub fn count6_tx (& mut self) -> Count6TxW < '_ , Count6TxSpec > { Count6TxW :: new (self , 0) } }
#[doc = "Transmission byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count6_tx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count6_tx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Count6TxSpec ; impl crate :: RegisterSpec for Count6TxSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`count6_tx::R`](R) reader structure"] impl crate :: Readable for Count6TxSpec { }
#[doc = "`write(|w| ..)` method takes [`count6_tx::W`](W) writer structure"] impl crate :: Writable for Count6TxSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets COUNT6_TX to value 0"] impl crate :: Resettable for Count6TxSpec { } }
#[doc = "COUNT7_TX (rw) register accessor: Transmission byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count7_tx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count7_tx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@count7_tx`] module"]
#[doc (alias = "COUNT7_TX")] pub type Count7Tx = crate :: Reg < count7_tx :: Count7TxSpec > ;
#[doc = "Transmission byte count 0"] pub mod count7_tx {
#[doc = "Register `COUNT7_TX` reader"] pub type R = crate :: R < Count7TxSpec > ;
#[doc = "Register `COUNT7_TX` writer"] pub type W = crate :: W < Count7TxSpec > ;
#[doc = "Field `COUNT7_TX` reader - Transmission byte count"] pub type Count7TxR = crate :: FieldReader < u16 > ;
#[doc = "Field `COUNT7_TX` writer - Transmission byte count"] pub type Count7TxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ; impl R {
#[doc = "Bits 0:9 - Transmission byte count"]
#[inline (always)] pub fn count7_tx (& self) -> Count7TxR { Count7TxR :: new (self . bits & 0x03ff) } } impl W {
#[doc = "Bits 0:9 - Transmission byte count"]
#[inline (always)] pub fn count7_tx (& mut self) -> Count7TxW < '_ , Count7TxSpec > { Count7TxW :: new (self , 0) } }
#[doc = "Transmission byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count7_tx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count7_tx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Count7TxSpec ; impl crate :: RegisterSpec for Count7TxSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`count7_tx::R`](R) reader structure"] impl crate :: Readable for Count7TxSpec { }
#[doc = "`write(|w| ..)` method takes [`count7_tx::W`](W) writer structure"] impl crate :: Writable for Count7TxSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets COUNT7_TX to value 0"] impl crate :: Resettable for Count7TxSpec { } }
#[doc = "ADDR0_RX (rw) register accessor: Reception buffer address 0\n\nYou can [`read`](crate::Reg::read) this register and get [`addr0_rx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`addr0_rx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@addr0_rx`] module"]
#[doc (alias = "ADDR0_RX")] pub type Addr0Rx = crate :: Reg < addr0_rx :: Addr0RxSpec > ;
#[doc = "Reception buffer address 0"] pub mod addr0_rx {
#[doc = "Register `ADDR0_RX` reader"] pub type R = crate :: R < Addr0RxSpec > ;
#[doc = "Register `ADDR0_RX` writer"] pub type W = crate :: W < Addr0RxSpec > ;
#[doc = "Field `ADDR0_RX` reader - Reception buffer address"] pub type Addr0RxR = crate :: FieldReader < u16 > ;
#[doc = "Field `ADDR0_RX` writer - Reception buffer address"] pub type Addr0RxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 15 , u16 > ; impl R {
#[doc = "Bits 1:15 - Reception buffer address"]
#[inline (always)] pub fn addr0_rx (& self) -> Addr0RxR { Addr0RxR :: new ((self . bits >> 1) & 0x7fff) } } impl W {
#[doc = "Bits 1:15 - Reception buffer address"]
#[inline (always)] pub fn addr0_rx (& mut self) -> Addr0RxW < '_ , Addr0RxSpec > { Addr0RxW :: new (self , 1) } }
#[doc = "Reception buffer address 0\n\nYou can [`read`](crate::Reg::read) this register and get [`addr0_rx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`addr0_rx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Addr0RxSpec ; impl crate :: RegisterSpec for Addr0RxSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`addr0_rx::R`](R) reader structure"] impl crate :: Readable for Addr0RxSpec { }
#[doc = "`write(|w| ..)` method takes [`addr0_rx::W`](W) writer structure"] impl crate :: Writable for Addr0RxSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ADDR0_RX to value 0"] impl crate :: Resettable for Addr0RxSpec { } }
#[doc = "ADDR1_RX (rw) register accessor: Reception buffer address 0\n\nYou can [`read`](crate::Reg::read) this register and get [`addr1_rx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`addr1_rx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@addr1_rx`] module"]
#[doc (alias = "ADDR1_RX")] pub type Addr1Rx = crate :: Reg < addr1_rx :: Addr1RxSpec > ;
#[doc = "Reception buffer address 0"] pub mod addr1_rx {
#[doc = "Register `ADDR1_RX` reader"] pub type R = crate :: R < Addr1RxSpec > ;
#[doc = "Register `ADDR1_RX` writer"] pub type W = crate :: W < Addr1RxSpec > ;
#[doc = "Field `ADDR1_RX` reader - Reception buffer address"] pub type Addr1RxR = crate :: FieldReader < u16 > ;
#[doc = "Field `ADDR1_RX` writer - Reception buffer address"] pub type Addr1RxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 15 , u16 > ; impl R {
#[doc = "Bits 1:15 - Reception buffer address"]
#[inline (always)] pub fn addr1_rx (& self) -> Addr1RxR { Addr1RxR :: new ((self . bits >> 1) & 0x7fff) } } impl W {
#[doc = "Bits 1:15 - Reception buffer address"]
#[inline (always)] pub fn addr1_rx (& mut self) -> Addr1RxW < '_ , Addr1RxSpec > { Addr1RxW :: new (self , 1) } }
#[doc = "Reception buffer address 0\n\nYou can [`read`](crate::Reg::read) this register and get [`addr1_rx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`addr1_rx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Addr1RxSpec ; impl crate :: RegisterSpec for Addr1RxSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`addr1_rx::R`](R) reader structure"] impl crate :: Readable for Addr1RxSpec { }
#[doc = "`write(|w| ..)` method takes [`addr1_rx::W`](W) writer structure"] impl crate :: Writable for Addr1RxSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ADDR1_RX to value 0"] impl crate :: Resettable for Addr1RxSpec { } }
#[doc = "ADDR2_RX (rw) register accessor: Reception buffer address 0\n\nYou can [`read`](crate::Reg::read) this register and get [`addr2_rx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`addr2_rx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@addr2_rx`] module"]
#[doc (alias = "ADDR2_RX")] pub type Addr2Rx = crate :: Reg < addr2_rx :: Addr2RxSpec > ;
#[doc = "Reception buffer address 0"] pub mod addr2_rx {
#[doc = "Register `ADDR2_RX` reader"] pub type R = crate :: R < Addr2RxSpec > ;
#[doc = "Register `ADDR2_RX` writer"] pub type W = crate :: W < Addr2RxSpec > ;
#[doc = "Field `ADDR2_RX` reader - Reception buffer address"] pub type Addr2RxR = crate :: FieldReader < u16 > ;
#[doc = "Field `ADDR2_RX` writer - Reception buffer address"] pub type Addr2RxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 15 , u16 > ; impl R {
#[doc = "Bits 1:15 - Reception buffer address"]
#[inline (always)] pub fn addr2_rx (& self) -> Addr2RxR { Addr2RxR :: new ((self . bits >> 1) & 0x7fff) } } impl W {
#[doc = "Bits 1:15 - Reception buffer address"]
#[inline (always)] pub fn addr2_rx (& mut self) -> Addr2RxW < '_ , Addr2RxSpec > { Addr2RxW :: new (self , 1) } }
#[doc = "Reception buffer address 0\n\nYou can [`read`](crate::Reg::read) this register and get [`addr2_rx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`addr2_rx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Addr2RxSpec ; impl crate :: RegisterSpec for Addr2RxSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`addr2_rx::R`](R) reader structure"] impl crate :: Readable for Addr2RxSpec { }
#[doc = "`write(|w| ..)` method takes [`addr2_rx::W`](W) writer structure"] impl crate :: Writable for Addr2RxSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ADDR2_RX to value 0"] impl crate :: Resettable for Addr2RxSpec { } }
#[doc = "ADDR3_RX (rw) register accessor: Reception buffer address 0\n\nYou can [`read`](crate::Reg::read) this register and get [`addr3_rx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`addr3_rx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@addr3_rx`] module"]
#[doc (alias = "ADDR3_RX")] pub type Addr3Rx = crate :: Reg < addr3_rx :: Addr3RxSpec > ;
#[doc = "Reception buffer address 0"] pub mod addr3_rx {
#[doc = "Register `ADDR3_RX` reader"] pub type R = crate :: R < Addr3RxSpec > ;
#[doc = "Register `ADDR3_RX` writer"] pub type W = crate :: W < Addr3RxSpec > ;
#[doc = "Field `ADDR3_RX` reader - Reception buffer address"] pub type Addr3RxR = crate :: FieldReader < u16 > ;
#[doc = "Field `ADDR3_RX` writer - Reception buffer address"] pub type Addr3RxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 15 , u16 > ; impl R {
#[doc = "Bits 1:15 - Reception buffer address"]
#[inline (always)] pub fn addr3_rx (& self) -> Addr3RxR { Addr3RxR :: new ((self . bits >> 1) & 0x7fff) } } impl W {
#[doc = "Bits 1:15 - Reception buffer address"]
#[inline (always)] pub fn addr3_rx (& mut self) -> Addr3RxW < '_ , Addr3RxSpec > { Addr3RxW :: new (self , 1) } }
#[doc = "Reception buffer address 0\n\nYou can [`read`](crate::Reg::read) this register and get [`addr3_rx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`addr3_rx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Addr3RxSpec ; impl crate :: RegisterSpec for Addr3RxSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`addr3_rx::R`](R) reader structure"] impl crate :: Readable for Addr3RxSpec { }
#[doc = "`write(|w| ..)` method takes [`addr3_rx::W`](W) writer structure"] impl crate :: Writable for Addr3RxSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ADDR3_RX to value 0"] impl crate :: Resettable for Addr3RxSpec { } }
#[doc = "ADDR4_RX (rw) register accessor: Reception buffer address 0\n\nYou can [`read`](crate::Reg::read) this register and get [`addr4_rx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`addr4_rx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@addr4_rx`] module"]
#[doc (alias = "ADDR4_RX")] pub type Addr4Rx = crate :: Reg < addr4_rx :: Addr4RxSpec > ;
#[doc = "Reception buffer address 0"] pub mod addr4_rx {
#[doc = "Register `ADDR4_RX` reader"] pub type R = crate :: R < Addr4RxSpec > ;
#[doc = "Register `ADDR4_RX` writer"] pub type W = crate :: W < Addr4RxSpec > ;
#[doc = "Field `ADDR4_RX` reader - Reception buffer address"] pub type Addr4RxR = crate :: FieldReader < u16 > ;
#[doc = "Field `ADDR4_RX` writer - Reception buffer address"] pub type Addr4RxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 15 , u16 > ; impl R {
#[doc = "Bits 1:15 - Reception buffer address"]
#[inline (always)] pub fn addr4_rx (& self) -> Addr4RxR { Addr4RxR :: new ((self . bits >> 1) & 0x7fff) } } impl W {
#[doc = "Bits 1:15 - Reception buffer address"]
#[inline (always)] pub fn addr4_rx (& mut self) -> Addr4RxW < '_ , Addr4RxSpec > { Addr4RxW :: new (self , 1) } }
#[doc = "Reception buffer address 0\n\nYou can [`read`](crate::Reg::read) this register and get [`addr4_rx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`addr4_rx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Addr4RxSpec ; impl crate :: RegisterSpec for Addr4RxSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`addr4_rx::R`](R) reader structure"] impl crate :: Readable for Addr4RxSpec { }
#[doc = "`write(|w| ..)` method takes [`addr4_rx::W`](W) writer structure"] impl crate :: Writable for Addr4RxSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ADDR4_RX to value 0"] impl crate :: Resettable for Addr4RxSpec { } }
#[doc = "ADDR5_RX (rw) register accessor: Reception buffer address 0\n\nYou can [`read`](crate::Reg::read) this register and get [`addr5_rx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`addr5_rx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@addr5_rx`] module"]
#[doc (alias = "ADDR5_RX")] pub type Addr5Rx = crate :: Reg < addr5_rx :: Addr5RxSpec > ;
#[doc = "Reception buffer address 0"] pub mod addr5_rx {
#[doc = "Register `ADDR5_RX` reader"] pub type R = crate :: R < Addr5RxSpec > ;
#[doc = "Register `ADDR5_RX` writer"] pub type W = crate :: W < Addr5RxSpec > ;
#[doc = "Field `ADDR5_RX` reader - Reception buffer address"] pub type Addr5RxR = crate :: FieldReader < u16 > ;
#[doc = "Field `ADDR5_RX` writer - Reception buffer address"] pub type Addr5RxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 15 , u16 > ; impl R {
#[doc = "Bits 1:15 - Reception buffer address"]
#[inline (always)] pub fn addr5_rx (& self) -> Addr5RxR { Addr5RxR :: new ((self . bits >> 1) & 0x7fff) } } impl W {
#[doc = "Bits 1:15 - Reception buffer address"]
#[inline (always)] pub fn addr5_rx (& mut self) -> Addr5RxW < '_ , Addr5RxSpec > { Addr5RxW :: new (self , 1) } }
#[doc = "Reception buffer address 0\n\nYou can [`read`](crate::Reg::read) this register and get [`addr5_rx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`addr5_rx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Addr5RxSpec ; impl crate :: RegisterSpec for Addr5RxSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`addr5_rx::R`](R) reader structure"] impl crate :: Readable for Addr5RxSpec { }
#[doc = "`write(|w| ..)` method takes [`addr5_rx::W`](W) writer structure"] impl crate :: Writable for Addr5RxSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ADDR5_RX to value 0"] impl crate :: Resettable for Addr5RxSpec { } }
#[doc = "ADDR6_RX (rw) register accessor: Reception buffer address 0\n\nYou can [`read`](crate::Reg::read) this register and get [`addr6_rx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`addr6_rx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@addr6_rx`] module"]
#[doc (alias = "ADDR6_RX")] pub type Addr6Rx = crate :: Reg < addr6_rx :: Addr6RxSpec > ;
#[doc = "Reception buffer address 0"] pub mod addr6_rx {
#[doc = "Register `ADDR6_RX` reader"] pub type R = crate :: R < Addr6RxSpec > ;
#[doc = "Register `ADDR6_RX` writer"] pub type W = crate :: W < Addr6RxSpec > ;
#[doc = "Field `ADDR6_RX` reader - Reception buffer address"] pub type Addr6RxR = crate :: FieldReader < u16 > ;
#[doc = "Field `ADDR6_RX` writer - Reception buffer address"] pub type Addr6RxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 15 , u16 > ; impl R {
#[doc = "Bits 1:15 - Reception buffer address"]
#[inline (always)] pub fn addr6_rx (& self) -> Addr6RxR { Addr6RxR :: new ((self . bits >> 1) & 0x7fff) } } impl W {
#[doc = "Bits 1:15 - Reception buffer address"]
#[inline (always)] pub fn addr6_rx (& mut self) -> Addr6RxW < '_ , Addr6RxSpec > { Addr6RxW :: new (self , 1) } }
#[doc = "Reception buffer address 0\n\nYou can [`read`](crate::Reg::read) this register and get [`addr6_rx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`addr6_rx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Addr6RxSpec ; impl crate :: RegisterSpec for Addr6RxSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`addr6_rx::R`](R) reader structure"] impl crate :: Readable for Addr6RxSpec { }
#[doc = "`write(|w| ..)` method takes [`addr6_rx::W`](W) writer structure"] impl crate :: Writable for Addr6RxSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ADDR6_RX to value 0"] impl crate :: Resettable for Addr6RxSpec { } }
#[doc = "ADDR7_RX (rw) register accessor: Reception buffer address 0\n\nYou can [`read`](crate::Reg::read) this register and get [`addr7_rx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`addr7_rx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@addr7_rx`] module"]
#[doc (alias = "ADDR7_RX")] pub type Addr7Rx = crate :: Reg < addr7_rx :: Addr7RxSpec > ;
#[doc = "Reception buffer address 0"] pub mod addr7_rx {
#[doc = "Register `ADDR7_RX` reader"] pub type R = crate :: R < Addr7RxSpec > ;
#[doc = "Register `ADDR7_RX` writer"] pub type W = crate :: W < Addr7RxSpec > ;
#[doc = "Field `ADDR7_RX` reader - Reception buffer address"] pub type Addr7RxR = crate :: FieldReader < u16 > ;
#[doc = "Field `ADDR7_RX` writer - Reception buffer address"] pub type Addr7RxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 15 , u16 > ; impl R {
#[doc = "Bits 1:15 - Reception buffer address"]
#[inline (always)] pub fn addr7_rx (& self) -> Addr7RxR { Addr7RxR :: new ((self . bits >> 1) & 0x7fff) } } impl W {
#[doc = "Bits 1:15 - Reception buffer address"]
#[inline (always)] pub fn addr7_rx (& mut self) -> Addr7RxW < '_ , Addr7RxSpec > { Addr7RxW :: new (self , 1) } }
#[doc = "Reception buffer address 0\n\nYou can [`read`](crate::Reg::read) this register and get [`addr7_rx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`addr7_rx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Addr7RxSpec ; impl crate :: RegisterSpec for Addr7RxSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`addr7_rx::R`](R) reader structure"] impl crate :: Readable for Addr7RxSpec { }
#[doc = "`write(|w| ..)` method takes [`addr7_rx::W`](W) writer structure"] impl crate :: Writable for Addr7RxSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ADDR7_RX to value 0"] impl crate :: Resettable for Addr7RxSpec { } }
#[doc = "COUNT0_RX (rw) register accessor: Reception byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count0_rx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count0_rx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@count0_rx`] module"]
#[doc (alias = "COUNT0_RX")] pub type Count0Rx = crate :: Reg < count0_rx :: Count0RxSpec > ;
#[doc = "Reception byte count 0"] pub mod count0_rx {
#[doc = "Register `COUNT0_RX` reader"] pub type R = crate :: R < Count0RxSpec > ;
#[doc = "Register `COUNT0_RX` writer"] pub type W = crate :: W < Count0RxSpec > ;
#[doc = "Field `COUNT0_RX` reader - Reception byte count"] pub type Count0RxR = crate :: FieldReader < u16 > ;
#[doc = "Field `NUM_BLOCK` reader - Number of blocks"] pub type NumBlockR = crate :: FieldReader ;
#[doc = "Field `NUM_BLOCK` writer - Number of blocks"] pub type NumBlockW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `BL_SIZE` reader - Block size"] pub type BlSizeR = crate :: BitReader ;
#[doc = "Field `BL_SIZE` writer - Block size"] pub type BlSizeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:9 - Reception byte count"]
#[inline (always)] pub fn count0_rx (& self) -> Count0RxR { Count0RxR :: new (self . bits & 0x03ff) }
#[doc = "Bits 10:14 - Number of blocks"]
#[inline (always)] pub fn num_block (& self) -> NumBlockR { NumBlockR :: new (((self . bits >> 10) & 0x1f) as u8) }
#[doc = "Bit 15 - Block size"]
#[inline (always)] pub fn bl_size (& self) -> BlSizeR { BlSizeR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 10:14 - Number of blocks"]
#[inline (always)] pub fn num_block (& mut self) -> NumBlockW < '_ , Count0RxSpec > { NumBlockW :: new (self , 10) }
#[doc = "Bit 15 - Block size"]
#[inline (always)] pub fn bl_size (& mut self) -> BlSizeW < '_ , Count0RxSpec > { BlSizeW :: new (self , 15) } }
#[doc = "Reception byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count0_rx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count0_rx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Count0RxSpec ; impl crate :: RegisterSpec for Count0RxSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`count0_rx::R`](R) reader structure"] impl crate :: Readable for Count0RxSpec { }
#[doc = "`write(|w| ..)` method takes [`count0_rx::W`](W) writer structure"] impl crate :: Writable for Count0RxSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets COUNT0_RX to value 0"] impl crate :: Resettable for Count0RxSpec { } }
#[doc = "COUNT1_RX (rw) register accessor: Reception byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count1_rx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count1_rx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@count1_rx`] module"]
#[doc (alias = "COUNT1_RX")] pub type Count1Rx = crate :: Reg < count1_rx :: Count1RxSpec > ;
#[doc = "Reception byte count 0"] pub mod count1_rx {
#[doc = "Register `COUNT1_RX` reader"] pub type R = crate :: R < Count1RxSpec > ;
#[doc = "Register `COUNT1_RX` writer"] pub type W = crate :: W < Count1RxSpec > ;
#[doc = "Field `COUNT1_RX` reader - Reception byte count"] pub type Count1RxR = crate :: FieldReader < u16 > ;
#[doc = "Field `NUM_BLOCK` reader - Number of blocks"] pub type NumBlockR = crate :: FieldReader ;
#[doc = "Field `NUM_BLOCK` writer - Number of blocks"] pub type NumBlockW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `BL_SIZE` reader - Block size"] pub type BlSizeR = crate :: BitReader ;
#[doc = "Field `BL_SIZE` writer - Block size"] pub type BlSizeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:9 - Reception byte count"]
#[inline (always)] pub fn count1_rx (& self) -> Count1RxR { Count1RxR :: new (self . bits & 0x03ff) }
#[doc = "Bits 10:14 - Number of blocks"]
#[inline (always)] pub fn num_block (& self) -> NumBlockR { NumBlockR :: new (((self . bits >> 10) & 0x1f) as u8) }
#[doc = "Bit 15 - Block size"]
#[inline (always)] pub fn bl_size (& self) -> BlSizeR { BlSizeR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 10:14 - Number of blocks"]
#[inline (always)] pub fn num_block (& mut self) -> NumBlockW < '_ , Count1RxSpec > { NumBlockW :: new (self , 10) }
#[doc = "Bit 15 - Block size"]
#[inline (always)] pub fn bl_size (& mut self) -> BlSizeW < '_ , Count1RxSpec > { BlSizeW :: new (self , 15) } }
#[doc = "Reception byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count1_rx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count1_rx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Count1RxSpec ; impl crate :: RegisterSpec for Count1RxSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`count1_rx::R`](R) reader structure"] impl crate :: Readable for Count1RxSpec { }
#[doc = "`write(|w| ..)` method takes [`count1_rx::W`](W) writer structure"] impl crate :: Writable for Count1RxSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets COUNT1_RX to value 0"] impl crate :: Resettable for Count1RxSpec { } }
#[doc = "COUNT2_RX (rw) register accessor: Reception byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count2_rx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count2_rx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@count2_rx`] module"]
#[doc (alias = "COUNT2_RX")] pub type Count2Rx = crate :: Reg < count2_rx :: Count2RxSpec > ;
#[doc = "Reception byte count 0"] pub mod count2_rx {
#[doc = "Register `COUNT2_RX` reader"] pub type R = crate :: R < Count2RxSpec > ;
#[doc = "Register `COUNT2_RX` writer"] pub type W = crate :: W < Count2RxSpec > ;
#[doc = "Field `COUNT2_RX` reader - Reception byte count"] pub type Count2RxR = crate :: FieldReader < u16 > ;
#[doc = "Field `NUM_BLOCK` reader - Number of blocks"] pub type NumBlockR = crate :: FieldReader ;
#[doc = "Field `NUM_BLOCK` writer - Number of blocks"] pub type NumBlockW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `BL_SIZE` reader - Block size"] pub type BlSizeR = crate :: BitReader ;
#[doc = "Field `BL_SIZE` writer - Block size"] pub type BlSizeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:9 - Reception byte count"]
#[inline (always)] pub fn count2_rx (& self) -> Count2RxR { Count2RxR :: new (self . bits & 0x03ff) }
#[doc = "Bits 10:14 - Number of blocks"]
#[inline (always)] pub fn num_block (& self) -> NumBlockR { NumBlockR :: new (((self . bits >> 10) & 0x1f) as u8) }
#[doc = "Bit 15 - Block size"]
#[inline (always)] pub fn bl_size (& self) -> BlSizeR { BlSizeR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 10:14 - Number of blocks"]
#[inline (always)] pub fn num_block (& mut self) -> NumBlockW < '_ , Count2RxSpec > { NumBlockW :: new (self , 10) }
#[doc = "Bit 15 - Block size"]
#[inline (always)] pub fn bl_size (& mut self) -> BlSizeW < '_ , Count2RxSpec > { BlSizeW :: new (self , 15) } }
#[doc = "Reception byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count2_rx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count2_rx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Count2RxSpec ; impl crate :: RegisterSpec for Count2RxSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`count2_rx::R`](R) reader structure"] impl crate :: Readable for Count2RxSpec { }
#[doc = "`write(|w| ..)` method takes [`count2_rx::W`](W) writer structure"] impl crate :: Writable for Count2RxSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets COUNT2_RX to value 0"] impl crate :: Resettable for Count2RxSpec { } }
#[doc = "COUNT3_RX (rw) register accessor: Reception byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count3_rx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count3_rx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@count3_rx`] module"]
#[doc (alias = "COUNT3_RX")] pub type Count3Rx = crate :: Reg < count3_rx :: Count3RxSpec > ;
#[doc = "Reception byte count 0"] pub mod count3_rx {
#[doc = "Register `COUNT3_RX` reader"] pub type R = crate :: R < Count3RxSpec > ;
#[doc = "Register `COUNT3_RX` writer"] pub type W = crate :: W < Count3RxSpec > ;
#[doc = "Field `COUNT3_RX` reader - Reception byte count"] pub type Count3RxR = crate :: FieldReader < u16 > ;
#[doc = "Field `NUM_BLOCK` reader - Number of blocks"] pub type NumBlockR = crate :: FieldReader ;
#[doc = "Field `NUM_BLOCK` writer - Number of blocks"] pub type NumBlockW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `BL_SIZE` reader - Block size"] pub type BlSizeR = crate :: BitReader ;
#[doc = "Field `BL_SIZE` writer - Block size"] pub type BlSizeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:9 - Reception byte count"]
#[inline (always)] pub fn count3_rx (& self) -> Count3RxR { Count3RxR :: new (self . bits & 0x03ff) }
#[doc = "Bits 10:14 - Number of blocks"]
#[inline (always)] pub fn num_block (& self) -> NumBlockR { NumBlockR :: new (((self . bits >> 10) & 0x1f) as u8) }
#[doc = "Bit 15 - Block size"]
#[inline (always)] pub fn bl_size (& self) -> BlSizeR { BlSizeR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 10:14 - Number of blocks"]
#[inline (always)] pub fn num_block (& mut self) -> NumBlockW < '_ , Count3RxSpec > { NumBlockW :: new (self , 10) }
#[doc = "Bit 15 - Block size"]
#[inline (always)] pub fn bl_size (& mut self) -> BlSizeW < '_ , Count3RxSpec > { BlSizeW :: new (self , 15) } }
#[doc = "Reception byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count3_rx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count3_rx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Count3RxSpec ; impl crate :: RegisterSpec for Count3RxSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`count3_rx::R`](R) reader structure"] impl crate :: Readable for Count3RxSpec { }
#[doc = "`write(|w| ..)` method takes [`count3_rx::W`](W) writer structure"] impl crate :: Writable for Count3RxSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets COUNT3_RX to value 0"] impl crate :: Resettable for Count3RxSpec { } }
#[doc = "COUNT4_RX (rw) register accessor: Reception byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count4_rx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count4_rx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@count4_rx`] module"]
#[doc (alias = "COUNT4_RX")] pub type Count4Rx = crate :: Reg < count4_rx :: Count4RxSpec > ;
#[doc = "Reception byte count 0"] pub mod count4_rx {
#[doc = "Register `COUNT4_RX` reader"] pub type R = crate :: R < Count4RxSpec > ;
#[doc = "Register `COUNT4_RX` writer"] pub type W = crate :: W < Count4RxSpec > ;
#[doc = "Field `COUNT4_RX` reader - Reception byte count"] pub type Count4RxR = crate :: FieldReader < u16 > ;
#[doc = "Field `NUM_BLOCK` reader - Number of blocks"] pub type NumBlockR = crate :: FieldReader ;
#[doc = "Field `NUM_BLOCK` writer - Number of blocks"] pub type NumBlockW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `BL_SIZE` reader - Block size"] pub type BlSizeR = crate :: BitReader ;
#[doc = "Field `BL_SIZE` writer - Block size"] pub type BlSizeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:9 - Reception byte count"]
#[inline (always)] pub fn count4_rx (& self) -> Count4RxR { Count4RxR :: new (self . bits & 0x03ff) }
#[doc = "Bits 10:14 - Number of blocks"]
#[inline (always)] pub fn num_block (& self) -> NumBlockR { NumBlockR :: new (((self . bits >> 10) & 0x1f) as u8) }
#[doc = "Bit 15 - Block size"]
#[inline (always)] pub fn bl_size (& self) -> BlSizeR { BlSizeR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 10:14 - Number of blocks"]
#[inline (always)] pub fn num_block (& mut self) -> NumBlockW < '_ , Count4RxSpec > { NumBlockW :: new (self , 10) }
#[doc = "Bit 15 - Block size"]
#[inline (always)] pub fn bl_size (& mut self) -> BlSizeW < '_ , Count4RxSpec > { BlSizeW :: new (self , 15) } }
#[doc = "Reception byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count4_rx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count4_rx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Count4RxSpec ; impl crate :: RegisterSpec for Count4RxSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`count4_rx::R`](R) reader structure"] impl crate :: Readable for Count4RxSpec { }
#[doc = "`write(|w| ..)` method takes [`count4_rx::W`](W) writer structure"] impl crate :: Writable for Count4RxSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets COUNT4_RX to value 0"] impl crate :: Resettable for Count4RxSpec { } }
#[doc = "COUNT5_RX (rw) register accessor: Reception byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count5_rx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count5_rx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@count5_rx`] module"]
#[doc (alias = "COUNT5_RX")] pub type Count5Rx = crate :: Reg < count5_rx :: Count5RxSpec > ;
#[doc = "Reception byte count 0"] pub mod count5_rx {
#[doc = "Register `COUNT5_RX` reader"] pub type R = crate :: R < Count5RxSpec > ;
#[doc = "Register `COUNT5_RX` writer"] pub type W = crate :: W < Count5RxSpec > ;
#[doc = "Field `COUNT5_RX` reader - Reception byte count"] pub type Count5RxR = crate :: FieldReader < u16 > ;
#[doc = "Field `NUM_BLOCK` reader - Number of blocks"] pub type NumBlockR = crate :: FieldReader ;
#[doc = "Field `NUM_BLOCK` writer - Number of blocks"] pub type NumBlockW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `BL_SIZE` reader - Block size"] pub type BlSizeR = crate :: BitReader ;
#[doc = "Field `BL_SIZE` writer - Block size"] pub type BlSizeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:9 - Reception byte count"]
#[inline (always)] pub fn count5_rx (& self) -> Count5RxR { Count5RxR :: new (self . bits & 0x03ff) }
#[doc = "Bits 10:14 - Number of blocks"]
#[inline (always)] pub fn num_block (& self) -> NumBlockR { NumBlockR :: new (((self . bits >> 10) & 0x1f) as u8) }
#[doc = "Bit 15 - Block size"]
#[inline (always)] pub fn bl_size (& self) -> BlSizeR { BlSizeR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 10:14 - Number of blocks"]
#[inline (always)] pub fn num_block (& mut self) -> NumBlockW < '_ , Count5RxSpec > { NumBlockW :: new (self , 10) }
#[doc = "Bit 15 - Block size"]
#[inline (always)] pub fn bl_size (& mut self) -> BlSizeW < '_ , Count5RxSpec > { BlSizeW :: new (self , 15) } }
#[doc = "Reception byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count5_rx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count5_rx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Count5RxSpec ; impl crate :: RegisterSpec for Count5RxSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`count5_rx::R`](R) reader structure"] impl crate :: Readable for Count5RxSpec { }
#[doc = "`write(|w| ..)` method takes [`count5_rx::W`](W) writer structure"] impl crate :: Writable for Count5RxSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets COUNT5_RX to value 0"] impl crate :: Resettable for Count5RxSpec { } }
#[doc = "COUNT6_RX (rw) register accessor: Reception byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count6_rx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count6_rx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@count6_rx`] module"]
#[doc (alias = "COUNT6_RX")] pub type Count6Rx = crate :: Reg < count6_rx :: Count6RxSpec > ;
#[doc = "Reception byte count 0"] pub mod count6_rx {
#[doc = "Register `COUNT6_RX` reader"] pub type R = crate :: R < Count6RxSpec > ;
#[doc = "Register `COUNT6_RX` writer"] pub type W = crate :: W < Count6RxSpec > ;
#[doc = "Field `COUNT6_RX` reader - Reception byte count"] pub type Count6RxR = crate :: FieldReader < u16 > ;
#[doc = "Field `NUM_BLOCK` reader - Number of blocks"] pub type NumBlockR = crate :: FieldReader ;
#[doc = "Field `NUM_BLOCK` writer - Number of blocks"] pub type NumBlockW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `BL_SIZE` reader - Block size"] pub type BlSizeR = crate :: BitReader ;
#[doc = "Field `BL_SIZE` writer - Block size"] pub type BlSizeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:9 - Reception byte count"]
#[inline (always)] pub fn count6_rx (& self) -> Count6RxR { Count6RxR :: new (self . bits & 0x03ff) }
#[doc = "Bits 10:14 - Number of blocks"]
#[inline (always)] pub fn num_block (& self) -> NumBlockR { NumBlockR :: new (((self . bits >> 10) & 0x1f) as u8) }
#[doc = "Bit 15 - Block size"]
#[inline (always)] pub fn bl_size (& self) -> BlSizeR { BlSizeR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 10:14 - Number of blocks"]
#[inline (always)] pub fn num_block (& mut self) -> NumBlockW < '_ , Count6RxSpec > { NumBlockW :: new (self , 10) }
#[doc = "Bit 15 - Block size"]
#[inline (always)] pub fn bl_size (& mut self) -> BlSizeW < '_ , Count6RxSpec > { BlSizeW :: new (self , 15) } }
#[doc = "Reception byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count6_rx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count6_rx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Count6RxSpec ; impl crate :: RegisterSpec for Count6RxSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`count6_rx::R`](R) reader structure"] impl crate :: Readable for Count6RxSpec { }
#[doc = "`write(|w| ..)` method takes [`count6_rx::W`](W) writer structure"] impl crate :: Writable for Count6RxSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets COUNT6_RX to value 0"] impl crate :: Resettable for Count6RxSpec { } }
#[doc = "COUNT7_RX (rw) register accessor: Reception byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count7_rx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count7_rx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@count7_rx`] module"]
#[doc (alias = "COUNT7_RX")] pub type Count7Rx = crate :: Reg < count7_rx :: Count7RxSpec > ;
#[doc = "Reception byte count 0"] pub mod count7_rx {
#[doc = "Register `COUNT7_RX` reader"] pub type R = crate :: R < Count7RxSpec > ;
#[doc = "Register `COUNT7_RX` writer"] pub type W = crate :: W < Count7RxSpec > ;
#[doc = "Field `COUNT7_RX` reader - Reception byte count"] pub type Count7RxR = crate :: FieldReader < u16 > ;
#[doc = "Field `NUM_BLOCK` reader - Number of blocks"] pub type NumBlockR = crate :: FieldReader ;
#[doc = "Field `NUM_BLOCK` writer - Number of blocks"] pub type NumBlockW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `BL_SIZE` reader - Block size"] pub type BlSizeR = crate :: BitReader ;
#[doc = "Field `BL_SIZE` writer - Block size"] pub type BlSizeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:9 - Reception byte count"]
#[inline (always)] pub fn count7_rx (& self) -> Count7RxR { Count7RxR :: new (self . bits & 0x03ff) }
#[doc = "Bits 10:14 - Number of blocks"]
#[inline (always)] pub fn num_block (& self) -> NumBlockR { NumBlockR :: new (((self . bits >> 10) & 0x1f) as u8) }
#[doc = "Bit 15 - Block size"]
#[inline (always)] pub fn bl_size (& self) -> BlSizeR { BlSizeR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 10:14 - Number of blocks"]
#[inline (always)] pub fn num_block (& mut self) -> NumBlockW < '_ , Count7RxSpec > { NumBlockW :: new (self , 10) }
#[doc = "Bit 15 - Block size"]
#[inline (always)] pub fn bl_size (& mut self) -> BlSizeW < '_ , Count7RxSpec > { BlSizeW :: new (self , 15) } }
#[doc = "Reception byte count 0\n\nYou can [`read`](crate::Reg::read) this register and get [`count7_rx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`count7_rx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Count7RxSpec ; impl crate :: RegisterSpec for Count7RxSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`count7_rx::R`](R) reader structure"] impl crate :: Readable for Count7RxSpec { }
#[doc = "`write(|w| ..)` method takes [`count7_rx::W`](W) writer structure"] impl crate :: Writable for Count7RxSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets COUNT7_RX to value 0"] impl crate :: Resettable for Count7RxSpec { } }
#[doc = "LPMCSR (rw) register accessor: control and status register\n\nYou can [`read`](crate::Reg::read) this register and get [`lpmcsr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lpmcsr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lpmcsr`] module"]
#[doc (alias = "LPMCSR")] pub type Lpmcsr = crate :: Reg < lpmcsr :: LpmcsrSpec > ;
#[doc = "control and status register"] pub mod lpmcsr {
#[doc = "Register `LPMCSR` reader"] pub type R = crate :: R < LpmcsrSpec > ;
#[doc = "Register `LPMCSR` writer"] pub type W = crate :: W < LpmcsrSpec > ;
#[doc = "Field `LPMEN` reader - LPM support enable"] pub type LpmenR = crate :: BitReader ;
#[doc = "Field `LPMEN` writer - LPM support enable"] pub type LpmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LPMACK` reader - LPM Token acknowledge enable"] pub type LpmackR = crate :: BitReader ;
#[doc = "Field `LPMACK` writer - LPM Token acknowledge enable"] pub type LpmackW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `REMWAKE` reader - RemoteWake value"] pub type RemwakeR = crate :: BitReader ;
#[doc = "Field `REMWAKE` writer - RemoteWake value"] pub type RemwakeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BESL` reader - BESL value"] pub type BeslR = crate :: FieldReader ; impl R {
#[doc = "Bit 0 - LPM support enable"]
#[inline (always)] pub fn lpmen (& self) -> LpmenR { LpmenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - LPM Token acknowledge enable"]
#[inline (always)] pub fn lpmack (& self) -> LpmackR { LpmackR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - RemoteWake value"]
#[inline (always)] pub fn remwake (& self) -> RemwakeR { RemwakeR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:7 - BESL value"]
#[inline (always)] pub fn besl (& self) -> BeslR { BeslR :: new (((self . bits >> 4) & 0x0f) as u8) } } impl W {
#[doc = "Bit 0 - LPM support enable"]
#[inline (always)] pub fn lpmen (& mut self) -> LpmenW < '_ , LpmcsrSpec > { LpmenW :: new (self , 0) }
#[doc = "Bit 1 - LPM Token acknowledge enable"]
#[inline (always)] pub fn lpmack (& mut self) -> LpmackW < '_ , LpmcsrSpec > { LpmackW :: new (self , 1) }
#[doc = "Bit 3 - RemoteWake value"]
#[inline (always)] pub fn remwake (& mut self) -> RemwakeW < '_ , LpmcsrSpec > { RemwakeW :: new (self , 3) } }
#[doc = "control and status register\n\nYou can [`read`](crate::Reg::read) this register and get [`lpmcsr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lpmcsr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct LpmcsrSpec ; impl crate :: RegisterSpec for LpmcsrSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`lpmcsr::R`](R) reader structure"] impl crate :: Readable for LpmcsrSpec { }
#[doc = "`write(|w| ..)` method takes [`lpmcsr::W`](W) writer structure"] impl crate :: Writable for LpmcsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets LPMCSR to value 0"] impl crate :: Resettable for LpmcsrSpec { } }
#[doc = "BCDR (rw) register accessor: Battery charging detector(\n\nYou can [`read`](crate::Reg::read) this register and get [`bcdr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bcdr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bcdr`] module"]
#[doc (alias = "BCDR")] pub type Bcdr = crate :: Reg < bcdr :: BcdrSpec > ;
#[doc = "Battery charging detector("] pub mod bcdr {
#[doc = "Register `BCDR` reader"] pub type R = crate :: R < BcdrSpec > ;
#[doc = "Register `BCDR` writer"] pub type W = crate :: W < BcdrSpec > ;
#[doc = "Field `BCDEN` reader - Battery charging detector (BCD) enable"] pub type BcdenR = crate :: BitReader ;
#[doc = "Field `BCDEN` writer - Battery charging detector (BCD) enable"] pub type BcdenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DCDEN` reader - Data contact detection (DCD) mode enable"] pub type DcdenR = crate :: BitReader ;
#[doc = "Field `DCDEN` writer - Data contact detection (DCD) mode enable"] pub type DcdenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PDEN` reader - Primary detection (PD) mode enable"] pub type PdenR = crate :: BitReader ;
#[doc = "Field `PDEN` writer - Primary detection (PD) mode enable"] pub type PdenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SDEN` reader - Secondary detection (SD) mode enable"] pub type SdenR = crate :: BitReader ;
#[doc = "Field `SDEN` writer - Secondary detection (SD) mode enable"] pub type SdenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DCDET` reader - Data contact detection (DCD) status"] pub type DcdetR = crate :: BitReader ;
#[doc = "Field `PDET` reader - Primary detection (PD) status"] pub type PdetR = crate :: BitReader ;
#[doc = "Field `SDET` reader - Secondary detection (SD) status"] pub type SdetR = crate :: BitReader ;
#[doc = "Field `PS2DET` reader - DM pull-up detection status"] pub type Ps2detR = crate :: BitReader ;
#[doc = "Field `DPPU` reader - DP pull-up control"] pub type DppuR = crate :: BitReader ;
#[doc = "Field `DPPU` writer - DP pull-up control"] pub type DppuW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Battery charging detector (BCD) enable"]
#[inline (always)] pub fn bcden (& self) -> BcdenR { BcdenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Data contact detection (DCD) mode enable"]
#[inline (always)] pub fn dcden (& self) -> DcdenR { DcdenR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Primary detection (PD) mode enable"]
#[inline (always)] pub fn pden (& self) -> PdenR { PdenR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Secondary detection (SD) mode enable"]
#[inline (always)] pub fn sden (& self) -> SdenR { SdenR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data contact detection (DCD) status"]
#[inline (always)] pub fn dcdet (& self) -> DcdetR { DcdetR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Primary detection (PD) status"]
#[inline (always)] pub fn pdet (& self) -> PdetR { PdetR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Secondary detection (SD) status"]
#[inline (always)] pub fn sdet (& self) -> SdetR { SdetR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - DM pull-up detection status"]
#[inline (always)] pub fn ps2det (& self) -> Ps2detR { Ps2detR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 15 - DP pull-up control"]
#[inline (always)] pub fn dppu (& self) -> DppuR { DppuR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Battery charging detector (BCD) enable"]
#[inline (always)] pub fn bcden (& mut self) -> BcdenW < '_ , BcdrSpec > { BcdenW :: new (self , 0) }
#[doc = "Bit 1 - Data contact detection (DCD) mode enable"]
#[inline (always)] pub fn dcden (& mut self) -> DcdenW < '_ , BcdrSpec > { DcdenW :: new (self , 1) }
#[doc = "Bit 2 - Primary detection (PD) mode enable"]
#[inline (always)] pub fn pden (& mut self) -> PdenW < '_ , BcdrSpec > { PdenW :: new (self , 2) }
#[doc = "Bit 3 - Secondary detection (SD) mode enable"]
#[inline (always)] pub fn sden (& mut self) -> SdenW < '_ , BcdrSpec > { SdenW :: new (self , 3) }
#[doc = "Bit 15 - DP pull-up control"]
#[inline (always)] pub fn dppu (& mut self) -> DppuW < '_ , BcdrSpec > { DppuW :: new (self , 15) } }
#[doc = "Battery charging detector(\n\nYou can [`read`](crate::Reg::read) this register and get [`bcdr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bcdr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BcdrSpec ; impl crate :: RegisterSpec for BcdrSpec { type Ux = u16 ; }
#[doc = "`read()` method returns [`bcdr::R`](R) reader structure"] impl crate :: Readable for BcdrSpec { }
#[doc = "`write(|w| ..)` method takes [`bcdr::W`](W) writer structure"] impl crate :: Writable for BcdrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BCDR to value 0"] impl crate :: Resettable for BcdrSpec { } } }
#[no_mangle] static mut DEVICE_PERIPHERALS : bool = false ;
#[doc = r" All the peripherals."]
#[allow (non_snake_case)] pub struct Peripherals {
#[doc = "DMA1"] pub dma1 : Dma1 ,
#[doc = "DMA2"] pub dma2 : Dma2 ,
#[doc = "DMAMUX1"] pub dmamux1 : Dmamux1 ,
#[doc = "CRC"] pub crc : Crc ,
#[doc = "LCD"] pub lcd : Lcd ,
#[doc = "TSC"] pub tsc : Tsc ,
#[doc = "IWDG"] pub iwdg : Iwdg ,
#[doc = "WWDG"] pub wwdg : Wwdg ,
#[doc = "I2C1"] pub i2c1 : I2c1 ,
#[doc = "I2C3"] pub i2c3 : I2c3 ,
#[doc = "Flash"] pub flash : Flash ,
#[doc = "QUADSPI"] pub quadspi : Quadspi ,
#[doc = "RCC"] pub rcc : Rcc ,
#[doc = "PWR"] pub pwr : Pwr ,
#[doc = "SYSCFG_VREFBUF"] pub syscfg_vrefbuf : SyscfgVrefbuf ,
#[doc = "COMP"] pub comp : Comp ,
#[doc = "RNG"] pub rng : Rng ,
#[doc = "AES1"] pub aes1 : Aes1 ,
#[doc = "AES2"] pub aes2 : Aes2 ,
#[doc = "HSEM"] pub hsem : Hsem ,
#[doc = "ADC"] pub adc : Adc ,
#[doc = "GPIOA"] pub gpioa : Gpioa ,
#[doc = "GPIOB"] pub gpiob : Gpiob ,
#[doc = "GPIOC"] pub gpioc : Gpioc ,
#[doc = "GPIOD"] pub gpiod : Gpiod ,
#[doc = "GPIOE"] pub gpioe : Gpioe ,
#[doc = "GPIOH"] pub gpioh : Gpioh ,
#[doc = "SAI1"] pub sai1 : Sai1 ,
#[doc = "TIM2"] pub tim2 : Tim2 ,
#[doc = "TIM16"] pub tim16 : Tim16 ,
#[doc = "TIM17"] pub tim17 : Tim17 ,
#[doc = "TIM1"] pub tim1 : Tim1 ,
#[doc = "LPTIM1"] pub lptim1 : Lptim1 ,
#[doc = "LPTIM2"] pub lptim2 : Lptim2 ,
#[doc = "USART1"] pub usart1 : Usart1 ,
#[doc = "LPUART1"] pub lpuart1 : Lpuart1 ,
#[doc = "SPI1"] pub spi1 : Spi1 ,
#[doc = "SPI2"] pub spi2 : Spi2 ,
#[doc = "RTC"] pub rtc : Rtc ,
#[doc = "DBGMCU"] pub dbgmcu : Dbgmcu ,
#[doc = "PKA"] pub pka : Pka ,
#[doc = "IPCC"] pub ipcc : Ipcc ,
#[doc = "EXTI"] pub exti : Exti ,
#[doc = "CRS"] pub crs : Crs ,
#[doc = "USB"] pub usb : Usb , } impl Peripherals {
#[doc = r" Returns all the peripherals *once*."]
#[cfg (feature = "critical-section")]
#[inline] pub fn take () -> Option < Self > { critical_section :: with (| _ | { if unsafe { DEVICE_PERIPHERALS } { return None } Some (unsafe { Peripherals :: steal () }) }) }
#[doc = r" Unchecked version of `Peripherals::take`."]
#[doc = r""]
#[doc = r" # Safety"]
#[doc = r""]
#[doc = r" Each of the returned peripherals must be used at most once."]
#[inline] pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { dma1 : Dma1 :: steal () , dma2 : Dma2 :: steal () , dmamux1 : Dmamux1 :: steal () , crc : Crc :: steal () , lcd : Lcd :: steal () , tsc : Tsc :: steal () , iwdg : Iwdg :: steal () , wwdg : Wwdg :: steal () , i2c1 : I2c1 :: steal () , i2c3 : I2c3 :: steal () , flash : Flash :: steal () , quadspi : Quadspi :: steal () , rcc : Rcc :: steal () , pwr : Pwr :: steal () , syscfg_vrefbuf : SyscfgVrefbuf :: steal () , comp : Comp :: steal () , rng : Rng :: steal () , aes1 : Aes1 :: steal () , aes2 : Aes2 :: steal () , hsem : Hsem :: steal () , adc : Adc :: steal () , gpioa : Gpioa :: steal () , gpiob : Gpiob :: steal () , gpioc : Gpioc :: steal () , gpiod : Gpiod :: steal () , gpioe : Gpioe :: steal () , gpioh : Gpioh :: steal () , sai1 : Sai1 :: steal () , tim2 : Tim2 :: steal () , tim16 : Tim16 :: steal () , tim17 : Tim17 :: steal () , tim1 : Tim1 :: steal () , lptim1 : Lptim1 :: steal () , lptim2 : Lptim2 :: steal () , usart1 : Usart1 :: steal () , lpuart1 : Lpuart1 :: steal () , spi1 : Spi1 :: steal () , spi2 : Spi2 :: steal () , rtc : Rtc :: steal () , dbgmcu : Dbgmcu :: steal () , pka : Pka :: steal () , ipcc : Ipcc :: steal () , exti : Exti :: steal () , crs : Crs :: steal () , usb : Usb :: steal () , } } }